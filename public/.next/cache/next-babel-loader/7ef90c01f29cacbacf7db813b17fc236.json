{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport var LineDecoration = /*#__PURE__*/function () {\n  function LineDecoration(startColumn, endColumn, className, type) {\n    _classCallCheck(this, LineDecoration);\n\n    this.startColumn = startColumn;\n    this.endColumn = endColumn;\n    this.className = className;\n    this.type = type;\n  }\n\n  _createClass(LineDecoration, null, [{\n    key: \"_equals\",\n    value: function _equals(a, b) {\n      return a.startColumn === b.startColumn && a.endColumn === b.endColumn && a.className === b.className && a.type === b.type;\n    }\n  }, {\n    key: \"equalsArr\",\n    value: function equalsArr(a, b) {\n      var aLen = a.length;\n      var bLen = b.length;\n\n      if (aLen !== bLen) {\n        return false;\n      }\n\n      for (var i = 0; i < aLen; i++) {\n        if (!LineDecoration._equals(a[i], b[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"extractWrapped\",\n    value: function extractWrapped(arr, startOffset, endOffset) {\n      if (arr.length === 0) {\n        return arr;\n      }\n\n      var startColumn = startOffset + 1;\n      var endColumn = endOffset + 1;\n      var lineLength = endOffset - startOffset;\n      var r = [];\n      var rLength = 0;\n\n      var _iterator = _createForOfIteratorHelper(arr),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dec = _step.value;\n\n          if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n            continue;\n          }\n\n          r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return r;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n      if (lineDecorations.length === 0) {\n        return [];\n      }\n\n      var result = [],\n          resultLen = 0;\n\n      for (var i = 0, len = lineDecorations.length; i < len; i++) {\n        var d = lineDecorations[i];\n        var range = d.range;\n\n        if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n          // Ignore decorations that sit outside this line\n          continue;\n        }\n\n        if (range.isEmpty() && (d.type === 0\n        /* Regular */\n        || d.type === 3\n        /* RegularAffectingLetterSpacing */\n        )) {\n          // Ignore empty range decorations\n          continue;\n        }\n\n        var startColumn = range.startLineNumber === lineNumber ? range.startColumn : minLineColumn;\n        var endColumn = range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn;\n        result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_typeCompare\",\n    value: function _typeCompare(a, b) {\n      var ORDER = [2, 0, 1, 3];\n      return ORDER[a] - ORDER[b];\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      if (a.startColumn === b.startColumn) {\n        if (a.endColumn === b.endColumn) {\n          var typeCmp = LineDecoration._typeCompare(a.type, b.type);\n\n          if (typeCmp === 0) {\n            if (a.className < b.className) {\n              return -1;\n            }\n\n            if (a.className > b.className) {\n              return 1;\n            }\n\n            return 0;\n          }\n\n          return typeCmp;\n        }\n\n        return a.endColumn - b.endColumn;\n      }\n\n      return a.startColumn - b.startColumn;\n    }\n  }]);\n\n  return LineDecoration;\n}();\nexport var DecorationSegment = function DecorationSegment(startOffset, endOffset, className, metadata) {\n  _classCallCheck(this, DecorationSegment);\n\n  this.startOffset = startOffset;\n  this.endOffset = endOffset;\n  this.className = className;\n  this.metadata = metadata;\n};\n\nvar Stack = /*#__PURE__*/function () {\n  function Stack() {\n    _classCallCheck(this, Stack);\n\n    this.stopOffsets = [];\n    this.classNames = [];\n    this.metadata = [];\n    this.count = 0;\n  }\n\n  _createClass(Stack, [{\n    key: \"consumeLowerThan\",\n    value: function consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n      while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n        var i = 0; // Take all equal stopping offsets\n\n        while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n          i++;\n        } // Basically we are consuming the first i + 1 elements of the stack\n\n\n        result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n        nextStartOffset = this.stopOffsets[i] + 1; // Consume them\n\n        this.stopOffsets.splice(0, i + 1);\n        this.classNames.splice(0, i + 1);\n        this.metadata.splice(0, i + 1);\n        this.count -= i + 1;\n      }\n\n      if (this.count > 0 && nextStartOffset < maxStopOffset) {\n        result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n        nextStartOffset = maxStopOffset;\n      }\n\n      return nextStartOffset;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(stopOffset, className, metadata) {\n      if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n        // Insert at the end\n        this.stopOffsets.push(stopOffset);\n        this.classNames.push(className);\n        this.metadata.push(metadata);\n      } else {\n        // Find the insertion position for `stopOffset`\n        for (var i = 0; i < this.count; i++) {\n          if (this.stopOffsets[i] >= stopOffset) {\n            this.stopOffsets.splice(i, 0, stopOffset);\n            this.classNames.splice(i, 0, className);\n            this.metadata.splice(i, 0, metadata);\n            break;\n          }\n        }\n      }\n\n      this.count++;\n      return;\n    }\n  }], [{\n    key: \"_metadata\",\n    value: function _metadata(metadata) {\n      var result = 0;\n\n      for (var i = 0, len = metadata.length; i < len; i++) {\n        result |= metadata[i];\n      }\n\n      return result;\n    }\n  }]);\n\n  return Stack;\n}();\n\nexport var LineDecorationsNormalizer = /*#__PURE__*/function () {\n  function LineDecorationsNormalizer() {\n    _classCallCheck(this, LineDecorationsNormalizer);\n  }\n\n  _createClass(LineDecorationsNormalizer, null, [{\n    key: \"normalize\",\n\n    /**\r\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n     */\n    value: function normalize(lineContent, lineDecorations) {\n      if (lineDecorations.length === 0) {\n        return [];\n      }\n\n      var result = [];\n      var stack = new Stack();\n      var nextStartOffset = 0;\n\n      for (var i = 0, len = lineDecorations.length; i < len; i++) {\n        var d = lineDecorations[i];\n        var startColumn = d.startColumn;\n        var endColumn = d.endColumn;\n        var className = d.className;\n        var metadata = d.type === 1\n        /* Before */\n        ? 2\n        /* PSEUDO_BEFORE */\n        : d.type === 2\n        /* After */\n        ? 4\n        /* PSEUDO_AFTER */\n        : 0; // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n\n        if (startColumn > 1) {\n          var charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n\n          if (strings.isHighSurrogate(charCodeBefore)) {\n            startColumn--;\n          }\n        }\n\n        if (endColumn > 1) {\n          var _charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n\n          if (strings.isHighSurrogate(_charCodeBefore)) {\n            endColumn--;\n          }\n        }\n\n        var currentStartOffset = startColumn - 1;\n        var currentEndOffset = endColumn - 2;\n        nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n\n        if (stack.count === 0) {\n          nextStartOffset = currentStartOffset;\n        }\n\n        stack.insert(currentEndOffset, className, metadata);\n      }\n\n      stack.consumeLowerThan(1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      , nextStartOffset, result);\n      return result;\n    }\n  }]);\n\n  return LineDecorationsNormalizer;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js"],"names":["strings","LineDecoration","startColumn","endColumn","className","type","a","b","aLen","length","bLen","i","_equals","arr","startOffset","endOffset","lineLength","r","rLength","dec","Math","max","min","lineDecorations","lineNumber","minLineColumn","maxLineColumn","result","resultLen","len","d","range","endLineNumber","startLineNumber","isEmpty","inlineClassName","ORDER","typeCmp","_typeCompare","DecorationSegment","metadata","Stack","stopOffsets","classNames","count","maxStopOffset","nextStartOffset","push","join","_metadata","splice","stopOffset","LineDecorationsNormalizer","lineContent","stack","charCodeBefore","charCodeAt","isHighSurrogate","currentStartOffset","currentEndOffset","consumeLowerThan","insert"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nexport class LineDecoration {\r\n    constructor(startColumn, endColumn, className, type) {\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.className = className;\r\n        this.type = type;\r\n    }\r\n    static _equals(a, b) {\r\n        return (a.startColumn === b.startColumn\r\n            && a.endColumn === b.endColumn\r\n            && a.className === b.className\r\n            && a.type === b.type);\r\n    }\r\n    static equalsArr(a, b) {\r\n        const aLen = a.length;\r\n        const bLen = b.length;\r\n        if (aLen !== bLen) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < aLen; i++) {\r\n            if (!LineDecoration._equals(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static extractWrapped(arr, startOffset, endOffset) {\r\n        if (arr.length === 0) {\r\n            return arr;\r\n        }\r\n        const startColumn = startOffset + 1;\r\n        const endColumn = endOffset + 1;\r\n        const lineLength = endOffset - startOffset;\r\n        const r = [];\r\n        let rLength = 0;\r\n        for (const dec of arr) {\r\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\r\n                continue;\r\n            }\r\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\r\n        }\r\n        return r;\r\n    }\r\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        let result = [], resultLen = 0;\r\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\r\n            const d = lineDecorations[i];\r\n            const range = d.range;\r\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\r\n                // Ignore decorations that sit outside this line\r\n                continue;\r\n            }\r\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\r\n                // Ignore empty range decorations\r\n                continue;\r\n            }\r\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\r\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\r\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\r\n        }\r\n        return result;\r\n    }\r\n    static _typeCompare(a, b) {\r\n        const ORDER = [2, 0, 1, 3];\r\n        return ORDER[a] - ORDER[b];\r\n    }\r\n    static compare(a, b) {\r\n        if (a.startColumn === b.startColumn) {\r\n            if (a.endColumn === b.endColumn) {\r\n                const typeCmp = LineDecoration._typeCompare(a.type, b.type);\r\n                if (typeCmp === 0) {\r\n                    if (a.className < b.className) {\r\n                        return -1;\r\n                    }\r\n                    if (a.className > b.className) {\r\n                        return 1;\r\n                    }\r\n                    return 0;\r\n                }\r\n                return typeCmp;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.startColumn - b.startColumn;\r\n    }\r\n}\r\nexport class DecorationSegment {\r\n    constructor(startOffset, endOffset, className, metadata) {\r\n        this.startOffset = startOffset;\r\n        this.endOffset = endOffset;\r\n        this.className = className;\r\n        this.metadata = metadata;\r\n    }\r\n}\r\nclass Stack {\r\n    constructor() {\r\n        this.stopOffsets = [];\r\n        this.classNames = [];\r\n        this.metadata = [];\r\n        this.count = 0;\r\n    }\r\n    static _metadata(metadata) {\r\n        let result = 0;\r\n        for (let i = 0, len = metadata.length; i < len; i++) {\r\n            result |= metadata[i];\r\n        }\r\n        return result;\r\n    }\r\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\r\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\r\n            let i = 0;\r\n            // Take all equal stopping offsets\r\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\r\n                i++;\r\n            }\r\n            // Basically we are consuming the first i + 1 elements of the stack\r\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\r\n            nextStartOffset = this.stopOffsets[i] + 1;\r\n            // Consume them\r\n            this.stopOffsets.splice(0, i + 1);\r\n            this.classNames.splice(0, i + 1);\r\n            this.metadata.splice(0, i + 1);\r\n            this.count -= (i + 1);\r\n        }\r\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\r\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\r\n            nextStartOffset = maxStopOffset;\r\n        }\r\n        return nextStartOffset;\r\n    }\r\n    insert(stopOffset, className, metadata) {\r\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\r\n            // Insert at the end\r\n            this.stopOffsets.push(stopOffset);\r\n            this.classNames.push(className);\r\n            this.metadata.push(metadata);\r\n        }\r\n        else {\r\n            // Find the insertion position for `stopOffset`\r\n            for (let i = 0; i < this.count; i++) {\r\n                if (this.stopOffsets[i] >= stopOffset) {\r\n                    this.stopOffsets.splice(i, 0, stopOffset);\r\n                    this.classNames.splice(i, 0, className);\r\n                    this.metadata.splice(i, 0, metadata);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this.count++;\r\n        return;\r\n    }\r\n}\r\nexport class LineDecorationsNormalizer {\r\n    /**\r\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\r\n     */\r\n    static normalize(lineContent, lineDecorations) {\r\n        if (lineDecorations.length === 0) {\r\n            return [];\r\n        }\r\n        let result = [];\r\n        const stack = new Stack();\r\n        let nextStartOffset = 0;\r\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\r\n            const d = lineDecorations[i];\r\n            let startColumn = d.startColumn;\r\n            let endColumn = d.endColumn;\r\n            const className = d.className;\r\n            const metadata = (d.type === 1 /* Before */\r\n                ? 2 /* PSEUDO_BEFORE */\r\n                : d.type === 2 /* After */\r\n                    ? 4 /* PSEUDO_AFTER */\r\n                    : 0);\r\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\r\n            if (startColumn > 1) {\r\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    startColumn--;\r\n                }\r\n            }\r\n            if (endColumn > 1) {\r\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\r\n                if (strings.isHighSurrogate(charCodeBefore)) {\r\n                    endColumn--;\r\n                }\r\n            }\r\n            const currentStartOffset = startColumn - 1;\r\n            const currentEndOffset = endColumn - 2;\r\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\r\n            if (stack.count === 0) {\r\n                nextStartOffset = currentStartOffset;\r\n            }\r\n            stack.insert(currentEndOffset, className, metadata);\r\n        }\r\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}