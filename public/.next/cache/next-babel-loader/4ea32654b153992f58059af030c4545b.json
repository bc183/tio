{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * **!Do not construct directly!**\r\n *\r\n * **!Only static methods because it gets serialized!**\r\n *\r\n * This represents the \"canonical\" version for an extension identifier. Extension ids\r\n * have to be case-insensitive (due to the marketplace), but we must ensure case\r\n * preservation because the extension API is already public at this time.\r\n *\r\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\r\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\r\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\r\n *\r\n * To make matters more complicated, an extension can optionally have an UUID. When two\r\n * extensions have the same UUID, they are considered equal even if their identifier is different.\r\n */\nexport var ExtensionIdentifier = /*#__PURE__*/function () {\n  function ExtensionIdentifier(value) {\n    _classCallCheck(this, ExtensionIdentifier);\n\n    this.value = value;\n    this._lower = value.toLowerCase();\n  }\n  /**\r\n   * Gives the value by which to index (for equality).\r\n   */\n\n\n  _createClass(ExtensionIdentifier, null, [{\n    key: \"toKey\",\n    value: function toKey(id) {\n      if (typeof id === 'string') {\n        return id.toLowerCase();\n      }\n\n      return id._lower;\n    }\n  }]);\n\n  return ExtensionIdentifier;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/platform/extensions/common/extensions.js"],"names":["ExtensionIdentifier","value","_lower","toLowerCase","id"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAaA,mBAAb;AACI,+BAAYC,KAAZ,EAAmB;AAAA;;AACf,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcD,KAAK,CAACE,WAAN,EAAd;AACH;AACD;AACJ;AACA;;;AAPA;AAAA;AAAA,0BAQiBC,EARjB,EAQqB;AACb,UAAI,OAAOA,EAAP,KAAc,QAAlB,EAA4B;AACxB,eAAOA,EAAE,CAACD,WAAH,EAAP;AACH;;AACD,aAAOC,EAAE,CAACF,MAAV;AACH;AAbL;;AAAA;AAAA","sourcesContent":["/**\r\n * **!Do not construct directly!**\r\n *\r\n * **!Only static methods because it gets serialized!**\r\n *\r\n * This represents the \"canonical\" version for an extension identifier. Extension ids\r\n * have to be case-insensitive (due to the marketplace), but we must ensure case\r\n * preservation because the extension API is already public at this time.\r\n *\r\n * For example, given an extension with the publisher `\"Hello\"` and the name `\"World\"`,\r\n * its canonical extension identifier is `\"Hello.World\"`. This extension could be\r\n * referenced in some other extension's dependencies using the string `\"hello.world\"`.\r\n *\r\n * To make matters more complicated, an extension can optionally have an UUID. When two\r\n * extensions have the same UUID, they are considered equal even if their identifier is different.\r\n */\r\nexport class ExtensionIdentifier {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this._lower = value.toLowerCase();\r\n    }\r\n    /**\r\n     * Gives the value by which to index (for equality).\r\n     */\r\n    static toKey(id) {\r\n        if (typeof id === 'string') {\r\n            return id.toLowerCase();\r\n        }\r\n        return id._lower;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}