{"ast":null,"code":"import _assertThisInitialized from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport './viewLines.css';\nimport * as platform from '../../../../base/common/platform.js';\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { Configuration } from '../../config/configuration.js';\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\n\nvar LastRenderedData = /*#__PURE__*/function () {\n  function LastRenderedData() {\n    _classCallCheck(this, LastRenderedData);\n\n    this._currentVisibleRange = new Range(1, 1, 1, 1);\n  }\n\n  _createClass(LastRenderedData, [{\n    key: \"getCurrentVisibleRange\",\n    value: function getCurrentVisibleRange() {\n      return this._currentVisibleRange;\n    }\n  }, {\n    key: \"setCurrentVisibleRange\",\n    value: function setCurrentVisibleRange(currentVisibleRange) {\n      this._currentVisibleRange = currentVisibleRange;\n    }\n  }]);\n\n  return LastRenderedData;\n}();\n\nvar HorizontalRevealRangeRequest = function HorizontalRevealRangeRequest(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\n  _classCallCheck(this, HorizontalRevealRangeRequest);\n\n  this.lineNumber = lineNumber;\n  this.startColumn = startColumn;\n  this.endColumn = endColumn;\n  this.startScrollTop = startScrollTop;\n  this.stopScrollTop = stopScrollTop;\n  this.scrollType = scrollType;\n  this.type = 'range';\n  this.minLineNumber = lineNumber;\n  this.maxLineNumber = lineNumber;\n};\n\nvar HorizontalRevealSelectionsRequest = function HorizontalRevealSelectionsRequest(selections, startScrollTop, stopScrollTop, scrollType) {\n  _classCallCheck(this, HorizontalRevealSelectionsRequest);\n\n  this.selections = selections;\n  this.startScrollTop = startScrollTop;\n  this.stopScrollTop = stopScrollTop;\n  this.scrollType = scrollType;\n  this.type = 'selections';\n  var minLineNumber = selections[0].startLineNumber;\n  var maxLineNumber = selections[0].endLineNumber;\n\n  for (var i = 1, len = selections.length; i < len; i++) {\n    var selection = selections[i];\n    minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\n    maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\n  }\n\n  this.minLineNumber = minLineNumber;\n  this.maxLineNumber = maxLineNumber;\n};\n\nexport var ViewLines = /*#__PURE__*/function (_ViewPart) {\n  _inherits(ViewLines, _ViewPart);\n\n  var _super = _createSuper(ViewLines);\n\n  function ViewLines(context, linesContent) {\n    var _this;\n\n    _classCallCheck(this, ViewLines);\n\n    _this = _super.call(this, context);\n    _this._linesContent = linesContent;\n    _this._textRangeRestingSpot = document.createElement('div');\n    _this._visibleLines = new VisibleLinesCollection(_assertThisInitialized(_this));\n    _this.domNode = _this._visibleLines.domNode;\n    var conf = _this._context.configuration;\n    var options = _this._context.configuration.options;\n    var fontInfo = options.get(38\n    /* fontInfo */\n    );\n    var wrappingInfo = options.get(125\n    /* wrappingInfo */\n    );\n    _this._lineHeight = options.get(53\n    /* lineHeight */\n    );\n    _this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    _this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n    _this._revealHorizontalRightPadding = options.get(84\n    /* revealHorizontalRightPadding */\n    );\n    _this._cursorSurroundingLines = options.get(22\n    /* cursorSurroundingLines */\n    );\n    _this._cursorSurroundingLinesStyle = options.get(23\n    /* cursorSurroundingLinesStyle */\n    );\n    _this._canUseLayerHinting = !options.get(25\n    /* disableLayerHinting */\n    );\n    _this._viewLineOptions = new ViewLineOptions(conf, _this._context.theme.type);\n    PartFingerprints.write(_this.domNode, 7\n    /* ViewLines */\n    );\n\n    _this.domNode.setClassName(\"view-lines \".concat(MOUSE_CURSOR_TEXT_CSS_CLASS_NAME));\n\n    Configuration.applyFontInfo(_this.domNode, fontInfo); // --- width & height\n\n    _this._maxLineWidth = 0;\n    _this._asyncUpdateLineWidths = new RunOnceScheduler(function () {\n      _this._updateLineWidthsSlow();\n    }, 200);\n    _this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(function () {\n      _this._checkMonospaceFontAssumptions();\n    }, 2000);\n    _this._lastRenderedData = new LastRenderedData();\n    _this._horizontalRevealRequest = null;\n    return _this;\n  }\n\n  _createClass(ViewLines, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._asyncUpdateLineWidths.dispose();\n\n      this._asyncCheckMonospaceFontAssumptions.dispose();\n\n      _get(_getPrototypeOf(ViewLines.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this.domNode;\n    } // ---- begin IVisibleLinesHost\n\n  }, {\n    key: \"createVisibleLine\",\n    value: function createVisibleLine() {\n      return new ViewLine(this._viewLineOptions);\n    } // ---- end IVisibleLinesHost\n    // ---- begin view event handlers\n\n  }, {\n    key: \"onConfigurationChanged\",\n    value: function onConfigurationChanged(e) {\n      this._visibleLines.onConfigurationChanged(e);\n\n      if (e.hasChanged(125\n      /* wrappingInfo */\n      )) {\n        this._maxLineWidth = 0;\n      }\n\n      var options = this._context.configuration.options;\n      var fontInfo = options.get(38\n      /* fontInfo */\n      );\n      var wrappingInfo = options.get(125\n      /* wrappingInfo */\n      );\n      this._lineHeight = options.get(53\n      /* lineHeight */\n      );\n      this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n      this._isViewportWrapping = wrappingInfo.isViewportWrapping;\n      this._revealHorizontalRightPadding = options.get(84\n      /* revealHorizontalRightPadding */\n      );\n      this._cursorSurroundingLines = options.get(22\n      /* cursorSurroundingLines */\n      );\n      this._cursorSurroundingLinesStyle = options.get(23\n      /* cursorSurroundingLinesStyle */\n      );\n      this._canUseLayerHinting = !options.get(25\n      /* disableLayerHinting */\n      );\n      Configuration.applyFontInfo(this.domNode, fontInfo);\n\n      this._onOptionsMaybeChanged();\n\n      if (e.hasChanged(124\n      /* layoutInfo */\n      )) {\n        this._maxLineWidth = 0;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_onOptionsMaybeChanged\",\n    value: function _onOptionsMaybeChanged() {\n      var conf = this._context.configuration;\n      var newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\n\n      if (!this._viewLineOptions.equals(newViewLineOptions)) {\n        this._viewLineOptions = newViewLineOptions;\n\n        var startLineNumber = this._visibleLines.getStartLineNumber();\n\n        var endLineNumber = this._visibleLines.getEndLineNumber();\n\n        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n          var line = this._visibleLines.getVisibleLine(lineNumber);\n\n          line.onOptionsChanged(this._viewLineOptions);\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onCursorStateChanged\",\n    value: function onCursorStateChanged(e) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      var r = false;\n\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged(e) {\n      if (true\n      /*e.inlineDecorationsChanged*/\n      ) {\n          var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n          var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n          for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n            this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\n          }\n        }\n\n      return true;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(e) {\n      var shouldRender = this._visibleLines.onFlushed(e);\n\n      this._maxLineWidth = 0;\n      return shouldRender;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(e) {\n      return this._visibleLines.onLinesChanged(e);\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      return this._visibleLines.onLinesDeleted(e);\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      return this._visibleLines.onLinesInserted(e);\n    }\n  }, {\n    key: \"onRevealRangeRequest\",\n    value: function onRevealRangeRequest(e) {\n      // Using the future viewport here in order to handle multiple\n      // incoming reveal range requests that might all desire to be animated\n      var desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\n\n      if (desiredScrollTop === -1) {\n        // marker to abort the reveal range request\n        return false;\n      } // validate the new desired scroll top\n\n\n      var newScrollPosition = this._context.viewLayout.validateScrollPosition({\n        scrollTop: desiredScrollTop\n      });\n\n      if (e.revealHorizontal) {\n        if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\n          // Two or more lines? => scroll to base (That's how you see most of the two lines)\n          newScrollPosition = {\n            scrollTop: newScrollPosition.scrollTop,\n            scrollLeft: 0\n          };\n        } else if (e.range) {\n          // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\n          this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n        } else if (e.selections && e.selections.length > 0) {\n          this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\n        }\n      } else {\n        this._horizontalRevealRequest = null;\n      }\n\n      var scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\n      var scrollType = scrollTopDelta <= this._lineHeight ? 1\n      /* Immediate */\n      : e.scrollType;\n\n      this._context.model.setScrollPosition(newScrollPosition, scrollType);\n\n      return true;\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged(e) {\n      if (this._horizontalRevealRequest && e.scrollLeftChanged) {\n        // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\n        this._horizontalRevealRequest = null;\n      }\n\n      if (this._horizontalRevealRequest && e.scrollTopChanged) {\n        var min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n        var max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\n\n        if (e.scrollTop < min || e.scrollTop > max) {\n          // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\n          this._horizontalRevealRequest = null;\n        }\n      }\n\n      this.domNode.setWidth(e.scrollWidth);\n      return this._visibleLines.onScrollChanged(e) || true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(e) {\n      return this._visibleLines.onTokensChanged(e);\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged(e) {\n      this._context.model.setMaxLineWidth(this._maxLineWidth);\n\n      return this._visibleLines.onZonesChanged(e);\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged(e) {\n      return this._onOptionsMaybeChanged();\n    } // ---- end view event handlers\n    // ----------- HELPERS FOR OTHERS\n\n  }, {\n    key: \"getPositionFromDOMInfo\",\n    value: function getPositionFromDOMInfo(spanNode, offset) {\n      var viewLineDomNode = this._getViewLineDomNode(spanNode);\n\n      if (viewLineDomNode === null) {\n        // Couldn't find view line node\n        return null;\n      }\n\n      var lineNumber = this._getLineNumberFor(viewLineDomNode);\n\n      if (lineNumber === -1) {\n        // Couldn't find view line node\n        return null;\n      }\n\n      if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\n        // lineNumber is outside range\n        return null;\n      }\n\n      if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\n        // Line is empty\n        return new Position(lineNumber, 1);\n      }\n\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        // Couldn't find line\n        return null;\n      }\n\n      var column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\n\n      var minColumn = this._context.model.getLineMinColumn(lineNumber);\n\n      if (column < minColumn) {\n        column = minColumn;\n      }\n\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"_getViewLineDomNode\",\n    value: function _getViewLineDomNode(node) {\n      while (node && node.nodeType === 1) {\n        if (node.className === ViewLine.CLASS_NAME) {\n          return node;\n        }\n\n        node = node.parentElement;\n      }\n\n      return null;\n    }\n    /**\r\n     * @returns the line number of this view line dom node.\r\n     */\n\n  }, {\n    key: \"_getLineNumberFor\",\n    value: function _getLineNumberFor(domNode) {\n      var startLineNumber = this._visibleLines.getStartLineNumber();\n\n      var endLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var line = this._visibleLines.getVisibleLine(lineNumber);\n\n        if (domNode === line.getDomNode()) {\n          return lineNumber;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(lineNumber) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n        // Couldn't find line\n        return -1;\n      }\n\n      return this._visibleLines.getVisibleLine(lineNumber).getWidth();\n    }\n  }, {\n    key: \"linesVisibleRangesForRange\",\n    value: function linesVisibleRangesForRange(_range, includeNewLines) {\n      if (this.shouldRender()) {\n        // Cannot read from the DOM because it is dirty\n        // i.e. the model & the dom are out of sync, so I'd be reading something stale\n        return null;\n      }\n\n      var originalEndLineNumber = _range.endLineNumber;\n      var range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\n\n      if (!range) {\n        return null;\n      }\n\n      var visibleRanges = [],\n          visibleRangesLen = 0;\n      var domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\n      var nextLineModelLineNumber = 0;\n\n      if (includeNewLines) {\n        nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\n      }\n\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\n          continue;\n        }\n\n        var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\n        var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\n\n        var visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\n\n        if (!visibleRangesForLine) {\n          continue;\n        }\n\n        if (includeNewLines && lineNumber < originalEndLineNumber) {\n          var currentLineModelLineNumber = nextLineModelLineNumber;\n          nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\n\n          if (currentLineModelLineNumber !== nextLineModelLineNumber) {\n            visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\n          }\n        }\n\n        visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\n      }\n\n      if (visibleRangesLen === 0) {\n        return null;\n      }\n\n      return visibleRanges;\n    }\n  }, {\n    key: \"_visibleRangesForLineRange\",\n    value: function _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\n      if (this.shouldRender()) {\n        // Cannot read from the DOM because it is dirty\n        // i.e. the model & the dom are out of sync, so I'd be reading something stale\n        return null;\n      }\n\n      if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\n        return null;\n      }\n\n      return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\n    }\n  }, {\n    key: \"visibleRangeForPosition\",\n    value: function visibleRangeForPosition(position) {\n      var visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\n\n      if (!visibleRanges) {\n        return null;\n      }\n\n      return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\n    } // --- implementation\n\n  }, {\n    key: \"updateLineWidths\",\n    value: function updateLineWidths() {\n      this._updateLineWidths(false);\n    }\n    /**\r\n     * Updates the max line width if it is fast to compute.\r\n     * Returns true if all lines were taken into account.\r\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n     */\n\n  }, {\n    key: \"_updateLineWidthsFast\",\n    value: function _updateLineWidthsFast() {\n      return this._updateLineWidths(true);\n    }\n  }, {\n    key: \"_updateLineWidthsSlow\",\n    value: function _updateLineWidthsSlow() {\n      this._updateLineWidths(false);\n    }\n  }, {\n    key: \"_updateLineWidths\",\n    value: function _updateLineWidths(fast) {\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      var localMaxLineWidth = 1;\n      var allWidthsComputed = true;\n\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n        if (fast && !visibleLine.getWidthIsFast()) {\n          // Cannot compute width in a fast way for this line\n          allWidthsComputed = false;\n          continue;\n        }\n\n        localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\n      }\n\n      if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\n        // we know the max line width for all the lines\n        this._maxLineWidth = 0;\n      }\n\n      this._ensureMaxLineWidth(localMaxLineWidth);\n\n      return allWidthsComputed;\n    }\n  }, {\n    key: \"_checkMonospaceFontAssumptions\",\n    value: function _checkMonospaceFontAssumptions() {\n      // Problems with monospace assumptions are more apparent for longer lines,\n      // as small rounding errors start to sum up, so we will select the longest\n      // line for a closer inspection\n      var longestLineNumber = -1;\n      var longestWidth = -1;\n\n      var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n      var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n      for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n        var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n        if (visibleLine.needsMonospaceFontCheck()) {\n          var lineWidth = visibleLine.getWidth();\n\n          if (lineWidth > longestWidth) {\n            longestWidth = lineWidth;\n            longestLineNumber = lineNumber;\n          }\n        }\n      }\n\n      if (longestLineNumber === -1) {\n        return;\n      }\n\n      if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\n        for (var _lineNumber = rendStartLineNumber; _lineNumber <= rendEndLineNumber; _lineNumber++) {\n          var _visibleLine = this._visibleLines.getVisibleLine(_lineNumber);\n\n          _visibleLine.onMonospaceAssumptionsInvalidated();\n        }\n      }\n    }\n  }, {\n    key: \"prepareRender\",\n    value: function prepareRender() {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"renderText\",\n    value: function renderText(viewportData) {\n      // (1) render lines - ensures lines are in the DOM\n      this._visibleLines.renderLines(viewportData);\n\n      this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\n\n      this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\n      this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000)); // (2) compute horizontal scroll position:\n      //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\n      //  - it might change `scrollWidth` and `scrollLeft`\n\n      if (this._horizontalRevealRequest) {\n        var horizontalRevealRequest = this._horizontalRevealRequest; // Check that we have the line that contains the horizontal range in the viewport\n\n        if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\n          this._horizontalRevealRequest = null; // allow `visibleRangesForRange2` to work\n\n          this.onDidRender(); // compute new scroll position\n\n          var newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\n\n          if (newScrollLeft) {\n            if (!this._isViewportWrapping) {\n              // ensure `scrollWidth` is large enough\n              this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\n            } // set `scrollLeft`\n\n\n            this._context.model.setScrollPosition({\n              scrollLeft: newScrollLeft.scrollLeft\n            }, horizontalRevealRequest.scrollType);\n          }\n        }\n      } // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\n\n\n      if (!this._updateLineWidthsFast()) {\n        // Computing the width of some lines would be slow => delay it\n        this._asyncUpdateLineWidths.schedule();\n      }\n\n      if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\n        var rendStartLineNumber = this._visibleLines.getStartLineNumber();\n\n        var rendEndLineNumber = this._visibleLines.getEndLineNumber();\n\n        for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\n          var visibleLine = this._visibleLines.getVisibleLine(lineNumber);\n\n          if (visibleLine.needsMonospaceFontCheck()) {\n            this._asyncCheckMonospaceFontAssumptions.schedule();\n\n            break;\n          }\n        }\n      } // (3) handle scrolling\n\n\n      this._linesContent.setLayerHinting(this._canUseLayerHinting);\n\n      this._linesContent.setContain('strict');\n\n      var adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\n\n      this._linesContent.setTop(-adjustedScrollTop);\n\n      this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\n    } // --- width\n\n  }, {\n    key: \"_ensureMaxLineWidth\",\n    value: function _ensureMaxLineWidth(lineWidth) {\n      var iLineWidth = Math.ceil(lineWidth);\n\n      if (this._maxLineWidth < iLineWidth) {\n        this._maxLineWidth = iLineWidth;\n\n        this._context.model.setMaxLineWidth(this._maxLineWidth);\n      }\n    }\n  }, {\n    key: \"_computeScrollTopToRevealRange\",\n    value: function _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\n      var viewportStartY = viewport.top;\n      var viewportHeight = viewport.height;\n      var viewportEndY = viewportStartY + viewportHeight;\n      var boxIsSingleRange;\n      var boxStartY;\n      var boxEndY; // Have a box that includes one extra line height (for the horizontal scrollbar)\n\n      if (selections && selections.length > 0) {\n        var _minLineNumber = selections[0].startLineNumber;\n        var _maxLineNumber = selections[0].endLineNumber;\n\n        for (var i = 1, len = selections.length; i < len; i++) {\n          var selection = selections[i];\n          _minLineNumber = Math.min(_minLineNumber, selection.startLineNumber);\n          _maxLineNumber = Math.max(_maxLineNumber, selection.endLineNumber);\n        }\n\n        boxIsSingleRange = false;\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(_minLineNumber);\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(_maxLineNumber) + this._lineHeight;\n      } else if (range) {\n        boxIsSingleRange = true;\n        boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\n        boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\n      } else {\n        return -1;\n      }\n\n      var shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\n\n      if (!shouldIgnoreScrollOff) {\n        var context = Math.min(viewportHeight / this._lineHeight / 2, this._cursorSurroundingLines);\n        boxStartY -= context * this._lineHeight;\n        boxEndY += Math.max(0, context - 1) * this._lineHeight;\n      }\n\n      if (verticalType === 0\n      /* Simple */\n      || verticalType === 4\n      /* Bottom */\n      ) {\n          // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\n          boxEndY += this._lineHeight;\n        }\n\n      var newScrollTop;\n\n      if (boxEndY - boxStartY > viewportHeight) {\n        // the box is larger than the viewport ... scroll to its top\n        if (!boxIsSingleRange) {\n          // do not reveal multiple cursors if there are more than fit the viewport\n          return -1;\n        }\n\n        newScrollTop = boxStartY;\n      } else if (verticalType === 5\n      /* NearTop */\n      || verticalType === 6\n      /* NearTopIfOutsideViewport */\n      ) {\n          if (verticalType === 6\n          /* NearTopIfOutsideViewport */\n          && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n            // Box is already in the viewport... do nothing\n            newScrollTop = viewportStartY;\n          } else {\n            // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\n            var desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2); // Try to scroll just above the box with the desired gap\n\n            var desiredScrollTop = boxStartY - desiredGapAbove; // But ensure that the box is not pushed out of viewport\n\n            var minScrollTop = boxEndY - viewportHeight;\n            newScrollTop = Math.max(minScrollTop, desiredScrollTop);\n          }\n        } else if (verticalType === 1\n      /* Center */\n      || verticalType === 2\n      /* CenterIfOutsideViewport */\n      ) {\n          if (verticalType === 2\n          /* CenterIfOutsideViewport */\n          && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\n            // Box is already in the viewport... do nothing\n            newScrollTop = viewportStartY;\n          } else {\n            // Box is outside the viewport... center it\n            var boxMiddleY = (boxStartY + boxEndY) / 2;\n            newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\n          }\n        } else {\n        newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3\n        /* Top */\n        , verticalType === 4\n        /* Bottom */\n        );\n      }\n\n      return newScrollTop;\n    }\n  }, {\n    key: \"_computeScrollLeftToReveal\",\n    value: function _computeScrollLeftToReveal(horizontalRevealRequest) {\n      var viewport = this._context.viewLayout.getCurrentViewport();\n\n      var viewportStartX = viewport.left;\n      var viewportEndX = viewportStartX + viewport.width;\n      var boxStartX = 1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      ;\n      var boxEndX = 0;\n\n      if (horizontalRevealRequest.type === 'range') {\n        var visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\n\n        if (!visibleRanges) {\n          return null;\n        }\n\n        var _iterator = _createForOfIteratorHelper(visibleRanges.ranges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var visibleRange = _step.value;\n            boxStartX = Math.min(boxStartX, visibleRange.left);\n            boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(horizontalRevealRequest.selections),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var selection = _step2.value;\n\n            if (selection.startLineNumber !== selection.endLineNumber) {\n              return null;\n            }\n\n            var _visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\n\n            if (!_visibleRanges) {\n              return null;\n            }\n\n            var _iterator3 = _createForOfIteratorHelper(_visibleRanges.ranges),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _visibleRange = _step3.value;\n                boxStartX = Math.min(boxStartX, _visibleRange.left);\n                boxEndX = Math.max(boxEndX, _visibleRange.left + _visibleRange.width);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\n      boxEndX += this._revealHorizontalRightPadding;\n\n      if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\n        return null;\n      }\n\n      var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\n\n      return {\n        scrollLeft: newScrollLeft,\n        maxHorizontalOffset: boxEndX\n      };\n    }\n  }, {\n    key: \"_computeMinimumScrolling\",\n    value: function _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\n      viewportStart = viewportStart | 0;\n      viewportEnd = viewportEnd | 0;\n      boxStart = boxStart | 0;\n      boxEnd = boxEnd | 0;\n      revealAtStart = !!revealAtStart;\n      revealAtEnd = !!revealAtEnd;\n      var viewportLength = viewportEnd - viewportStart;\n      var boxLength = boxEnd - boxStart;\n\n      if (boxLength < viewportLength) {\n        // The box would fit in the viewport\n        if (revealAtStart) {\n          return boxStart;\n        }\n\n        if (revealAtEnd) {\n          return Math.max(0, boxEnd - viewportLength);\n        }\n\n        if (boxStart < viewportStart) {\n          // The box is above the viewport\n          return boxStart;\n        } else if (boxEnd > viewportEnd) {\n          // The box is below the viewport\n          return Math.max(0, boxEnd - viewportLength);\n        }\n      } else {\n        // The box would not fit in the viewport\n        // Reveal the beginning of the box\n        return boxStart;\n      }\n\n      return viewportStart;\n    }\n  }]);\n\n  return ViewLines;\n}(ViewPart);\n/**\r\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n */\n\nViewLines.HORIZONTAL_EXTRA_PX = 30;","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/viewLines.js"],"names":["platform","RunOnceScheduler","Configuration","VisibleLinesCollection","PartFingerprints","ViewPart","DomReadingContext","ViewLine","ViewLineOptions","Position","Range","LineVisibleRanges","HorizontalPosition","MOUSE_CURSOR_TEXT_CSS_CLASS_NAME","LastRenderedData","_currentVisibleRange","currentVisibleRange","HorizontalRevealRangeRequest","lineNumber","startColumn","endColumn","startScrollTop","stopScrollTop","scrollType","type","minLineNumber","maxLineNumber","HorizontalRevealSelectionsRequest","selections","startLineNumber","endLineNumber","i","len","length","selection","Math","min","max","ViewLines","context","linesContent","_linesContent","_textRangeRestingSpot","document","createElement","_visibleLines","domNode","conf","_context","configuration","options","fontInfo","get","wrappingInfo","_lineHeight","_typicalHalfwidthCharacterWidth","typicalHalfwidthCharacterWidth","_isViewportWrapping","isViewportWrapping","_revealHorizontalRightPadding","_cursorSurroundingLines","_cursorSurroundingLinesStyle","_canUseLayerHinting","_viewLineOptions","theme","write","setClassName","applyFontInfo","_maxLineWidth","_asyncUpdateLineWidths","_updateLineWidthsSlow","_asyncCheckMonospaceFontAssumptions","_checkMonospaceFontAssumptions","_lastRenderedData","_horizontalRevealRequest","dispose","e","onConfigurationChanged","hasChanged","_onOptionsMaybeChanged","newViewLineOptions","equals","getStartLineNumber","getEndLineNumber","line","getVisibleLine","onOptionsChanged","rendStartLineNumber","rendEndLineNumber","r","onSelectionChanged","onDecorationsChanged","shouldRender","onFlushed","onLinesChanged","onLinesDeleted","onLinesInserted","desiredScrollTop","_computeScrollTopToRevealRange","viewLayout","getFutureViewport","source","range","verticalType","newScrollPosition","validateScrollPosition","scrollTop","revealHorizontal","scrollLeft","getCurrentScrollTop","scrollTopDelta","abs","model","setScrollPosition","scrollLeftChanged","scrollTopChanged","setWidth","scrollWidth","onScrollChanged","onTokensChanged","setMaxLineWidth","onZonesChanged","spanNode","offset","viewLineDomNode","_getViewLineDomNode","_getLineNumberFor","getLineCount","getLineMaxColumn","column","getColumnOfNodeOffset","minColumn","getLineMinColumn","node","nodeType","className","CLASS_NAME","parentElement","getDomNode","getWidth","_range","includeNewLines","originalEndLineNumber","intersectRanges","getCurrentVisibleRange","visibleRanges","visibleRangesLen","domReadingContext","nextLineModelLineNumber","coordinatesConverter","convertViewPositionToModelPosition","visibleRangesForLine","getVisibleRangesForRange","currentLineModelLineNumber","ranges","width","outsideRenderedLine","position","_visibleRangesForLineRange","left","_updateLineWidths","fast","localMaxLineWidth","allWidthsComputed","visibleLine","getWidthIsFast","_ensureMaxLineWidth","longestLineNumber","longestWidth","needsMonospaceFontCheck","lineWidth","monospaceAssumptionsAreValid","onMonospaceAssumptionsInvalidated","Error","viewportData","renderLines","setCurrentVisibleRange","visibleRange","getScrollWidth","setHeight","getScrollHeight","horizontalRevealRequest","onDidRender","newScrollLeft","_computeScrollLeftToReveal","maxHorizontalOffset","_updateLineWidthsFast","schedule","isLinux","isScheduled","setLayerHinting","setContain","adjustedScrollTop","bigNumbersDelta","setTop","setLeft","getCurrentScrollLeft","iLineWidth","ceil","viewport","viewportStartY","top","viewportHeight","height","viewportEndY","boxIsSingleRange","boxStartY","boxEndY","getVerticalOffsetForLineNumber","shouldIgnoreScrollOff","newScrollTop","desiredGapAbove","minScrollTop","boxMiddleY","_computeMinimumScrolling","getCurrentViewport","viewportStartX","viewportEndX","boxStartX","boxEndX","HORIZONTAL_EXTRA_PX","viewportStart","viewportEnd","boxStart","boxEnd","revealAtStart","revealAtEnd","viewportLength","boxLength"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport './viewLines.css';\r\nimport * as platform from '../../../../base/common/platform.js';\r\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\r\nimport { Configuration } from '../../config/configuration.js';\r\nimport { VisibleLinesCollection } from '../../view/viewLayer.js';\r\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\r\nimport { DomReadingContext, ViewLine, ViewLineOptions } from './viewLine.js';\r\nimport { Position } from '../../../common/core/position.js';\r\nimport { Range } from '../../../common/core/range.js';\r\nimport { LineVisibleRanges, HorizontalPosition } from '../../../common/view/renderingContext.js';\r\nimport { MOUSE_CURSOR_TEXT_CSS_CLASS_NAME } from '../../../../base/browser/ui/mouseCursor/mouseCursor.js';\r\nclass LastRenderedData {\r\n    constructor() {\r\n        this._currentVisibleRange = new Range(1, 1, 1, 1);\r\n    }\r\n    getCurrentVisibleRange() {\r\n        return this._currentVisibleRange;\r\n    }\r\n    setCurrentVisibleRange(currentVisibleRange) {\r\n        this._currentVisibleRange = currentVisibleRange;\r\n    }\r\n}\r\nclass HorizontalRevealRangeRequest {\r\n    constructor(lineNumber, startColumn, endColumn, startScrollTop, stopScrollTop, scrollType) {\r\n        this.lineNumber = lineNumber;\r\n        this.startColumn = startColumn;\r\n        this.endColumn = endColumn;\r\n        this.startScrollTop = startScrollTop;\r\n        this.stopScrollTop = stopScrollTop;\r\n        this.scrollType = scrollType;\r\n        this.type = 'range';\r\n        this.minLineNumber = lineNumber;\r\n        this.maxLineNumber = lineNumber;\r\n    }\r\n}\r\nclass HorizontalRevealSelectionsRequest {\r\n    constructor(selections, startScrollTop, stopScrollTop, scrollType) {\r\n        this.selections = selections;\r\n        this.startScrollTop = startScrollTop;\r\n        this.stopScrollTop = stopScrollTop;\r\n        this.scrollType = scrollType;\r\n        this.type = 'selections';\r\n        let minLineNumber = selections[0].startLineNumber;\r\n        let maxLineNumber = selections[0].endLineNumber;\r\n        for (let i = 1, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\r\n            maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\r\n        }\r\n        this.minLineNumber = minLineNumber;\r\n        this.maxLineNumber = maxLineNumber;\r\n    }\r\n}\r\nexport class ViewLines extends ViewPart {\r\n    constructor(context, linesContent) {\r\n        super(context);\r\n        this._linesContent = linesContent;\r\n        this._textRangeRestingSpot = document.createElement('div');\r\n        this._visibleLines = new VisibleLinesCollection(this);\r\n        this.domNode = this._visibleLines.domNode;\r\n        const conf = this._context.configuration;\r\n        const options = this._context.configuration.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n        this._lineHeight = options.get(53 /* lineHeight */);\r\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\r\n        this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\r\n        this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\r\n        this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\r\n        this._viewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\r\n        PartFingerprints.write(this.domNode, 7 /* ViewLines */);\r\n        this.domNode.setClassName(`view-lines ${MOUSE_CURSOR_TEXT_CSS_CLASS_NAME}`);\r\n        Configuration.applyFontInfo(this.domNode, fontInfo);\r\n        // --- width & height\r\n        this._maxLineWidth = 0;\r\n        this._asyncUpdateLineWidths = new RunOnceScheduler(() => {\r\n            this._updateLineWidthsSlow();\r\n        }, 200);\r\n        this._asyncCheckMonospaceFontAssumptions = new RunOnceScheduler(() => {\r\n            this._checkMonospaceFontAssumptions();\r\n        }, 2000);\r\n        this._lastRenderedData = new LastRenderedData();\r\n        this._horizontalRevealRequest = null;\r\n    }\r\n    dispose() {\r\n        this._asyncUpdateLineWidths.dispose();\r\n        this._asyncCheckMonospaceFontAssumptions.dispose();\r\n        super.dispose();\r\n    }\r\n    getDomNode() {\r\n        return this.domNode;\r\n    }\r\n    // ---- begin IVisibleLinesHost\r\n    createVisibleLine() {\r\n        return new ViewLine(this._viewLineOptions);\r\n    }\r\n    // ---- end IVisibleLinesHost\r\n    // ---- begin view event handlers\r\n    onConfigurationChanged(e) {\r\n        this._visibleLines.onConfigurationChanged(e);\r\n        if (e.hasChanged(125 /* wrappingInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        const options = this._context.configuration.options;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const wrappingInfo = options.get(125 /* wrappingInfo */);\r\n        this._lineHeight = options.get(53 /* lineHeight */);\r\n        this._typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this._isViewportWrapping = wrappingInfo.isViewportWrapping;\r\n        this._revealHorizontalRightPadding = options.get(84 /* revealHorizontalRightPadding */);\r\n        this._cursorSurroundingLines = options.get(22 /* cursorSurroundingLines */);\r\n        this._cursorSurroundingLinesStyle = options.get(23 /* cursorSurroundingLinesStyle */);\r\n        this._canUseLayerHinting = !options.get(25 /* disableLayerHinting */);\r\n        Configuration.applyFontInfo(this.domNode, fontInfo);\r\n        this._onOptionsMaybeChanged();\r\n        if (e.hasChanged(124 /* layoutInfo */)) {\r\n            this._maxLineWidth = 0;\r\n        }\r\n        return true;\r\n    }\r\n    _onOptionsMaybeChanged() {\r\n        const conf = this._context.configuration;\r\n        const newViewLineOptions = new ViewLineOptions(conf, this._context.theme.type);\r\n        if (!this._viewLineOptions.equals(newViewLineOptions)) {\r\n            this._viewLineOptions = newViewLineOptions;\r\n            const startLineNumber = this._visibleLines.getStartLineNumber();\r\n            const endLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n                const line = this._visibleLines.getVisibleLine(lineNumber);\r\n                line.onOptionsChanged(this._viewLineOptions);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    onCursorStateChanged(e) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        let r = false;\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            r = this._visibleLines.getVisibleLine(lineNumber).onSelectionChanged() || r;\r\n        }\r\n        return r;\r\n    }\r\n    onDecorationsChanged(e) {\r\n        if (true /*e.inlineDecorationsChanged*/) {\r\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                this._visibleLines.getVisibleLine(lineNumber).onDecorationsChanged();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    onFlushed(e) {\r\n        const shouldRender = this._visibleLines.onFlushed(e);\r\n        this._maxLineWidth = 0;\r\n        return shouldRender;\r\n    }\r\n    onLinesChanged(e) {\r\n        return this._visibleLines.onLinesChanged(e);\r\n    }\r\n    onLinesDeleted(e) {\r\n        return this._visibleLines.onLinesDeleted(e);\r\n    }\r\n    onLinesInserted(e) {\r\n        return this._visibleLines.onLinesInserted(e);\r\n    }\r\n    onRevealRangeRequest(e) {\r\n        // Using the future viewport here in order to handle multiple\r\n        // incoming reveal range requests that might all desire to be animated\r\n        const desiredScrollTop = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.range, e.selections, e.verticalType);\r\n        if (desiredScrollTop === -1) {\r\n            // marker to abort the reveal range request\r\n            return false;\r\n        }\r\n        // validate the new desired scroll top\r\n        let newScrollPosition = this._context.viewLayout.validateScrollPosition({ scrollTop: desiredScrollTop });\r\n        if (e.revealHorizontal) {\r\n            if (e.range && e.range.startLineNumber !== e.range.endLineNumber) {\r\n                // Two or more lines? => scroll to base (That's how you see most of the two lines)\r\n                newScrollPosition = {\r\n                    scrollTop: newScrollPosition.scrollTop,\r\n                    scrollLeft: 0\r\n                };\r\n            }\r\n            else if (e.range) {\r\n                // We don't necessarily know the horizontal offset of this range since the line might not be in the view...\r\n                this._horizontalRevealRequest = new HorizontalRevealRangeRequest(e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\r\n            }\r\n            else if (e.selections && e.selections.length > 0) {\r\n                this._horizontalRevealRequest = new HorizontalRevealSelectionsRequest(e.selections, this._context.viewLayout.getCurrentScrollTop(), newScrollPosition.scrollTop, e.scrollType);\r\n            }\r\n        }\r\n        else {\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        const scrollTopDelta = Math.abs(this._context.viewLayout.getCurrentScrollTop() - newScrollPosition.scrollTop);\r\n        const scrollType = (scrollTopDelta <= this._lineHeight ? 1 /* Immediate */ : e.scrollType);\r\n        this._context.model.setScrollPosition(newScrollPosition, scrollType);\r\n        return true;\r\n    }\r\n    onScrollChanged(e) {\r\n        if (this._horizontalRevealRequest && e.scrollLeftChanged) {\r\n            // cancel any outstanding horizontal reveal request if someone else scrolls horizontally.\r\n            this._horizontalRevealRequest = null;\r\n        }\r\n        if (this._horizontalRevealRequest && e.scrollTopChanged) {\r\n            const min = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            const max = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);\r\n            if (e.scrollTop < min || e.scrollTop > max) {\r\n                // cancel any outstanding horizontal reveal request if someone else scrolls vertically.\r\n                this._horizontalRevealRequest = null;\r\n            }\r\n        }\r\n        this.domNode.setWidth(e.scrollWidth);\r\n        return this._visibleLines.onScrollChanged(e) || true;\r\n    }\r\n    onTokensChanged(e) {\r\n        return this._visibleLines.onTokensChanged(e);\r\n    }\r\n    onZonesChanged(e) {\r\n        this._context.model.setMaxLineWidth(this._maxLineWidth);\r\n        return this._visibleLines.onZonesChanged(e);\r\n    }\r\n    onThemeChanged(e) {\r\n        return this._onOptionsMaybeChanged();\r\n    }\r\n    // ---- end view event handlers\r\n    // ----------- HELPERS FOR OTHERS\r\n    getPositionFromDOMInfo(spanNode, offset) {\r\n        const viewLineDomNode = this._getViewLineDomNode(spanNode);\r\n        if (viewLineDomNode === null) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        const lineNumber = this._getLineNumberFor(viewLineDomNode);\r\n        if (lineNumber === -1) {\r\n            // Couldn't find view line node\r\n            return null;\r\n        }\r\n        if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {\r\n            // lineNumber is outside range\r\n            return null;\r\n        }\r\n        if (this._context.model.getLineMaxColumn(lineNumber) === 1) {\r\n            // Line is empty\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return null;\r\n        }\r\n        let column = this._visibleLines.getVisibleLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);\r\n        const minColumn = this._context.model.getLineMinColumn(lineNumber);\r\n        if (column < minColumn) {\r\n            column = minColumn;\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    _getViewLineDomNode(node) {\r\n        while (node && node.nodeType === 1) {\r\n            if (node.className === ViewLine.CLASS_NAME) {\r\n                return node;\r\n            }\r\n            node = node.parentElement;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @returns the line number of this view line dom node.\r\n     */\r\n    _getLineNumberFor(domNode) {\r\n        const startLineNumber = this._visibleLines.getStartLineNumber();\r\n        const endLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            const line = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (domNode === line.getDomNode()) {\r\n                return lineNumber;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    getLineWidth(lineNumber) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n            // Couldn't find line\r\n            return -1;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getWidth();\r\n    }\r\n    linesVisibleRangesForRange(_range, includeNewLines) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        const originalEndLineNumber = _range.endLineNumber;\r\n        const range = Range.intersectRanges(_range, this._lastRenderedData.getCurrentVisibleRange());\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        let visibleRanges = [], visibleRangesLen = 0;\r\n        const domReadingContext = new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);\r\n        let nextLineModelLineNumber = 0;\r\n        if (includeNewLines) {\r\n            nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(range.startLineNumber, 1)).lineNumber;\r\n        }\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\r\n            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {\r\n                continue;\r\n            }\r\n            const startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;\r\n            const endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);\r\n            const visibleRangesForLine = this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);\r\n            if (!visibleRangesForLine) {\r\n                continue;\r\n            }\r\n            if (includeNewLines && lineNumber < originalEndLineNumber) {\r\n                const currentLineModelLineNumber = nextLineModelLineNumber;\r\n                nextLineModelLineNumber = this._context.model.coordinatesConverter.convertViewPositionToModelPosition(new Position(lineNumber + 1, 1)).lineNumber;\r\n                if (currentLineModelLineNumber !== nextLineModelLineNumber) {\r\n                    visibleRangesForLine.ranges[visibleRangesForLine.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth;\r\n                }\r\n            }\r\n            visibleRanges[visibleRangesLen++] = new LineVisibleRanges(visibleRangesForLine.outsideRenderedLine, lineNumber, visibleRangesForLine.ranges);\r\n        }\r\n        if (visibleRangesLen === 0) {\r\n            return null;\r\n        }\r\n        return visibleRanges;\r\n    }\r\n    _visibleRangesForLineRange(lineNumber, startColumn, endColumn) {\r\n        if (this.shouldRender()) {\r\n            // Cannot read from the DOM because it is dirty\r\n            // i.e. the model & the dom are out of sync, so I'd be reading something stale\r\n            return null;\r\n        }\r\n        if (lineNumber < this._visibleLines.getStartLineNumber() || lineNumber > this._visibleLines.getEndLineNumber()) {\r\n            return null;\r\n        }\r\n        return this._visibleLines.getVisibleLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, new DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot));\r\n    }\r\n    visibleRangeForPosition(position) {\r\n        const visibleRanges = this._visibleRangesForLineRange(position.lineNumber, position.column, position.column);\r\n        if (!visibleRanges) {\r\n            return null;\r\n        }\r\n        return new HorizontalPosition(visibleRanges.outsideRenderedLine, visibleRanges.ranges[0].left);\r\n    }\r\n    // --- implementation\r\n    updateLineWidths() {\r\n        this._updateLineWidths(false);\r\n    }\r\n    /**\r\n     * Updates the max line width if it is fast to compute.\r\n     * Returns true if all lines were taken into account.\r\n     * Returns false if some lines need to be reevaluated (in a slow fashion).\r\n     */\r\n    _updateLineWidthsFast() {\r\n        return this._updateLineWidths(true);\r\n    }\r\n    _updateLineWidthsSlow() {\r\n        this._updateLineWidths(false);\r\n    }\r\n    _updateLineWidths(fast) {\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        let localMaxLineWidth = 1;\r\n        let allWidthsComputed = true;\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (fast && !visibleLine.getWidthIsFast()) {\r\n                // Cannot compute width in a fast way for this line\r\n                allWidthsComputed = false;\r\n                continue;\r\n            }\r\n            localMaxLineWidth = Math.max(localMaxLineWidth, visibleLine.getWidth());\r\n        }\r\n        if (allWidthsComputed && rendStartLineNumber === 1 && rendEndLineNumber === this._context.model.getLineCount()) {\r\n            // we know the max line width for all the lines\r\n            this._maxLineWidth = 0;\r\n        }\r\n        this._ensureMaxLineWidth(localMaxLineWidth);\r\n        return allWidthsComputed;\r\n    }\r\n    _checkMonospaceFontAssumptions() {\r\n        // Problems with monospace assumptions are more apparent for longer lines,\r\n        // as small rounding errors start to sum up, so we will select the longest\r\n        // line for a closer inspection\r\n        let longestLineNumber = -1;\r\n        let longestWidth = -1;\r\n        const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n        const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n        for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n            const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n            if (visibleLine.needsMonospaceFontCheck()) {\r\n                const lineWidth = visibleLine.getWidth();\r\n                if (lineWidth > longestWidth) {\r\n                    longestWidth = lineWidth;\r\n                    longestLineNumber = lineNumber;\r\n                }\r\n            }\r\n        }\r\n        if (longestLineNumber === -1) {\r\n            return;\r\n        }\r\n        if (!this._visibleLines.getVisibleLine(longestLineNumber).monospaceAssumptionsAreValid()) {\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n                visibleLine.onMonospaceAssumptionsInvalidated();\r\n            }\r\n        }\r\n    }\r\n    prepareRender() {\r\n        throw new Error('Not supported');\r\n    }\r\n    render() {\r\n        throw new Error('Not supported');\r\n    }\r\n    renderText(viewportData) {\r\n        // (1) render lines - ensures lines are in the DOM\r\n        this._visibleLines.renderLines(viewportData);\r\n        this._lastRenderedData.setCurrentVisibleRange(viewportData.visibleRange);\r\n        this.domNode.setWidth(this._context.viewLayout.getScrollWidth());\r\n        this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1000000));\r\n        // (2) compute horizontal scroll position:\r\n        //  - this must happen after the lines are in the DOM since it might need a line that rendered just now\r\n        //  - it might change `scrollWidth` and `scrollLeft`\r\n        if (this._horizontalRevealRequest) {\r\n            const horizontalRevealRequest = this._horizontalRevealRequest;\r\n            // Check that we have the line that contains the horizontal range in the viewport\r\n            if (viewportData.startLineNumber <= horizontalRevealRequest.minLineNumber && horizontalRevealRequest.maxLineNumber <= viewportData.endLineNumber) {\r\n                this._horizontalRevealRequest = null;\r\n                // allow `visibleRangesForRange2` to work\r\n                this.onDidRender();\r\n                // compute new scroll position\r\n                const newScrollLeft = this._computeScrollLeftToReveal(horizontalRevealRequest);\r\n                if (newScrollLeft) {\r\n                    if (!this._isViewportWrapping) {\r\n                        // ensure `scrollWidth` is large enough\r\n                        this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);\r\n                    }\r\n                    // set `scrollLeft`\r\n                    this._context.model.setScrollPosition({\r\n                        scrollLeft: newScrollLeft.scrollLeft\r\n                    }, horizontalRevealRequest.scrollType);\r\n                }\r\n            }\r\n        }\r\n        // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)\r\n        if (!this._updateLineWidthsFast()) {\r\n            // Computing the width of some lines would be slow => delay it\r\n            this._asyncUpdateLineWidths.schedule();\r\n        }\r\n        if (platform.isLinux && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {\r\n            const rendStartLineNumber = this._visibleLines.getStartLineNumber();\r\n            const rendEndLineNumber = this._visibleLines.getEndLineNumber();\r\n            for (let lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {\r\n                const visibleLine = this._visibleLines.getVisibleLine(lineNumber);\r\n                if (visibleLine.needsMonospaceFontCheck()) {\r\n                    this._asyncCheckMonospaceFontAssumptions.schedule();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // (3) handle scrolling\r\n        this._linesContent.setLayerHinting(this._canUseLayerHinting);\r\n        this._linesContent.setContain('strict');\r\n        const adjustedScrollTop = this._context.viewLayout.getCurrentScrollTop() - viewportData.bigNumbersDelta;\r\n        this._linesContent.setTop(-adjustedScrollTop);\r\n        this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());\r\n    }\r\n    // --- width\r\n    _ensureMaxLineWidth(lineWidth) {\r\n        const iLineWidth = Math.ceil(lineWidth);\r\n        if (this._maxLineWidth < iLineWidth) {\r\n            this._maxLineWidth = iLineWidth;\r\n            this._context.model.setMaxLineWidth(this._maxLineWidth);\r\n        }\r\n    }\r\n    _computeScrollTopToRevealRange(viewport, source, range, selections, verticalType) {\r\n        const viewportStartY = viewport.top;\r\n        const viewportHeight = viewport.height;\r\n        const viewportEndY = viewportStartY + viewportHeight;\r\n        let boxIsSingleRange;\r\n        let boxStartY;\r\n        let boxEndY;\r\n        // Have a box that includes one extra line height (for the horizontal scrollbar)\r\n        if (selections && selections.length > 0) {\r\n            let minLineNumber = selections[0].startLineNumber;\r\n            let maxLineNumber = selections[0].endLineNumber;\r\n            for (let i = 1, len = selections.length; i < len; i++) {\r\n                const selection = selections[i];\r\n                minLineNumber = Math.min(minLineNumber, selection.startLineNumber);\r\n                maxLineNumber = Math.max(maxLineNumber, selection.endLineNumber);\r\n            }\r\n            boxIsSingleRange = false;\r\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(minLineNumber);\r\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(maxLineNumber) + this._lineHeight;\r\n        }\r\n        else if (range) {\r\n            boxIsSingleRange = true;\r\n            boxStartY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.startLineNumber);\r\n            boxEndY = this._context.viewLayout.getVerticalOffsetForLineNumber(range.endLineNumber) + this._lineHeight;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n        const shouldIgnoreScrollOff = source === 'mouse' && this._cursorSurroundingLinesStyle === 'default';\r\n        if (!shouldIgnoreScrollOff) {\r\n            const context = Math.min((viewportHeight / this._lineHeight) / 2, this._cursorSurroundingLines);\r\n            boxStartY -= context * this._lineHeight;\r\n            boxEndY += Math.max(0, (context - 1)) * this._lineHeight;\r\n        }\r\n        if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {\r\n            // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom\r\n            boxEndY += this._lineHeight;\r\n        }\r\n        let newScrollTop;\r\n        if (boxEndY - boxStartY > viewportHeight) {\r\n            // the box is larger than the viewport ... scroll to its top\r\n            if (!boxIsSingleRange) {\r\n                // do not reveal multiple cursors if there are more than fit the viewport\r\n                return -1;\r\n            }\r\n            newScrollTop = boxStartY;\r\n        }\r\n        else if (verticalType === 5 /* NearTop */ || verticalType === 6 /* NearTopIfOutsideViewport */) {\r\n            if (verticalType === 6 /* NearTopIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\r\n                // Box is already in the viewport... do nothing\r\n                newScrollTop = viewportStartY;\r\n            }\r\n            else {\r\n                // We want a gap that is 20% of the viewport, but with a minimum of 5 lines\r\n                const desiredGapAbove = Math.max(5 * this._lineHeight, viewportHeight * 0.2);\r\n                // Try to scroll just above the box with the desired gap\r\n                const desiredScrollTop = boxStartY - desiredGapAbove;\r\n                // But ensure that the box is not pushed out of viewport\r\n                const minScrollTop = boxEndY - viewportHeight;\r\n                newScrollTop = Math.max(minScrollTop, desiredScrollTop);\r\n            }\r\n        }\r\n        else if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {\r\n            if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {\r\n                // Box is already in the viewport... do nothing\r\n                newScrollTop = viewportStartY;\r\n            }\r\n            else {\r\n                // Box is outside the viewport... center it\r\n                const boxMiddleY = (boxStartY + boxEndY) / 2;\r\n                newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);\r\n            }\r\n        }\r\n        else {\r\n            newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);\r\n        }\r\n        return newScrollTop;\r\n    }\r\n    _computeScrollLeftToReveal(horizontalRevealRequest) {\r\n        const viewport = this._context.viewLayout.getCurrentViewport();\r\n        const viewportStartX = viewport.left;\r\n        const viewportEndX = viewportStartX + viewport.width;\r\n        let boxStartX = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        let boxEndX = 0;\r\n        if (horizontalRevealRequest.type === 'range') {\r\n            const visibleRanges = this._visibleRangesForLineRange(horizontalRevealRequest.lineNumber, horizontalRevealRequest.startColumn, horizontalRevealRequest.endColumn);\r\n            if (!visibleRanges) {\r\n                return null;\r\n            }\r\n            for (const visibleRange of visibleRanges.ranges) {\r\n                boxStartX = Math.min(boxStartX, visibleRange.left);\r\n                boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\r\n            }\r\n        }\r\n        else {\r\n            for (const selection of horizontalRevealRequest.selections) {\r\n                if (selection.startLineNumber !== selection.endLineNumber) {\r\n                    return null;\r\n                }\r\n                const visibleRanges = this._visibleRangesForLineRange(selection.startLineNumber, selection.startColumn, selection.endColumn);\r\n                if (!visibleRanges) {\r\n                    return null;\r\n                }\r\n                for (const visibleRange of visibleRanges.ranges) {\r\n                    boxStartX = Math.min(boxStartX, visibleRange.left);\r\n                    boxEndX = Math.max(boxEndX, visibleRange.left + visibleRange.width);\r\n                }\r\n            }\r\n        }\r\n        boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);\r\n        boxEndX += this._revealHorizontalRightPadding;\r\n        if (horizontalRevealRequest.type === 'selections' && boxEndX - boxStartX > viewport.width) {\r\n            return null;\r\n        }\r\n        const newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);\r\n        return {\r\n            scrollLeft: newScrollLeft,\r\n            maxHorizontalOffset: boxEndX\r\n        };\r\n    }\r\n    _computeMinimumScrolling(viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {\r\n        viewportStart = viewportStart | 0;\r\n        viewportEnd = viewportEnd | 0;\r\n        boxStart = boxStart | 0;\r\n        boxEnd = boxEnd | 0;\r\n        revealAtStart = !!revealAtStart;\r\n        revealAtEnd = !!revealAtEnd;\r\n        const viewportLength = viewportEnd - viewportStart;\r\n        const boxLength = boxEnd - boxStart;\r\n        if (boxLength < viewportLength) {\r\n            // The box would fit in the viewport\r\n            if (revealAtStart) {\r\n                return boxStart;\r\n            }\r\n            if (revealAtEnd) {\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n            if (boxStart < viewportStart) {\r\n                // The box is above the viewport\r\n                return boxStart;\r\n            }\r\n            else if (boxEnd > viewportEnd) {\r\n                // The box is below the viewport\r\n                return Math.max(0, boxEnd - viewportLength);\r\n            }\r\n        }\r\n        else {\r\n            // The box would not fit in the viewport\r\n            // Reveal the beginning of the box\r\n            return boxStart;\r\n        }\r\n        return viewportStart;\r\n    }\r\n}\r\n/**\r\n * Adds this amount of pixels to the right of lines (no-one wants to type near the edge of the viewport)\r\n */\r\nViewLines.HORIZONTAL_EXTRA_PX = 30;\r\n"]},"metadata":{},"sourceType":"module"}