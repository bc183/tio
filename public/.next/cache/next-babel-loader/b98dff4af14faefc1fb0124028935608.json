{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\n\nvar LinePart = /*#__PURE__*/function () {\n  function LinePart(endIndex, type, metadata) {\n    _classCallCheck(this, LinePart);\n\n    this.endIndex = endIndex;\n    this.type = type;\n    this.metadata = metadata;\n  }\n\n  _createClass(LinePart, [{\n    key: \"isWhitespace\",\n    value: function isWhitespace() {\n      return this.metadata & 1\n      /* IS_WHITESPACE_MASK */\n      ? true : false;\n    }\n  }]);\n\n  return LinePart;\n}();\n\nexport var LineRange = /*#__PURE__*/function () {\n  function LineRange(startIndex, endIndex) {\n    _classCallCheck(this, LineRange);\n\n    this.startOffset = startIndex;\n    this.endOffset = endIndex;\n  }\n\n  _createClass(LineRange, [{\n    key: \"equals\",\n    value: function equals(otherLineRange) {\n      return this.startOffset === otherLineRange.startOffset && this.endOffset === otherLineRange.endOffset;\n    }\n  }]);\n\n  return LineRange;\n}();\nexport var RenderLineInput = /*#__PURE__*/function () {\n  function RenderLineInput(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n    _classCallCheck(this, RenderLineInput);\n\n    this.useMonospaceOptimizations = useMonospaceOptimizations;\n    this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n    this.lineContent = lineContent;\n    this.continuesWithWrappedLine = continuesWithWrappedLine;\n    this.isBasicASCII = isBasicASCII;\n    this.containsRTL = containsRTL;\n    this.fauxIndentLength = fauxIndentLength;\n    this.lineTokens = lineTokens;\n    this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n    this.tabSize = tabSize;\n    this.startVisibleColumn = startVisibleColumn;\n    this.spaceWidth = spaceWidth;\n    this.stopRenderingLineAfter = stopRenderingLineAfter;\n    this.renderWhitespace = renderWhitespace === 'all' ? 4\n    /* All */\n    : renderWhitespace === 'boundary' ? 1\n    /* Boundary */\n    : renderWhitespace === 'selection' ? 2\n    /* Selection */\n    : renderWhitespace === 'trailing' ? 3\n    /* Trailing */\n    : 0\n    /* None */\n    ;\n    this.renderControlCharacters = renderControlCharacters;\n    this.fontLigatures = fontLigatures;\n    this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort(function (a, b) {\n      return a.startOffset < b.startOffset ? -1 : 1;\n    });\n    var wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n    var middotDiff = Math.abs(middotWidth - spaceWidth);\n\n    if (wsmiddotDiff < middotDiff) {\n      this.renderSpaceWidth = wsmiddotWidth;\n      this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n    } else {\n      this.renderSpaceWidth = middotWidth;\n      this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n    }\n  }\n\n  _createClass(RenderLineInput, [{\n    key: \"sameSelection\",\n    value: function sameSelection(otherSelections) {\n      if (this.selectionsOnLine === null) {\n        return otherSelections === null;\n      }\n\n      if (otherSelections === null) {\n        return false;\n      }\n\n      if (otherSelections.length !== this.selectionsOnLine.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.selectionsOnLine.length; i++) {\n        if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.useMonospaceOptimizations === other.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow && this.lineContent === other.lineContent && this.continuesWithWrappedLine === other.continuesWithWrappedLine && this.isBasicASCII === other.isBasicASCII && this.containsRTL === other.containsRTL && this.fauxIndentLength === other.fauxIndentLength && this.tabSize === other.tabSize && this.startVisibleColumn === other.startVisibleColumn && this.spaceWidth === other.spaceWidth && this.renderSpaceWidth === other.renderSpaceWidth && this.renderSpaceCharCode === other.renderSpaceCharCode && this.stopRenderingLineAfter === other.stopRenderingLineAfter && this.renderWhitespace === other.renderWhitespace && this.renderControlCharacters === other.renderControlCharacters && this.fontLigatures === other.fontLigatures && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations) && this.lineTokens.equals(other.lineTokens) && this.sameSelection(other.selectionsOnLine);\n    }\n  }]);\n\n  return RenderLineInput;\n}();\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\n\nexport var CharacterMapping = /*#__PURE__*/function () {\n  function CharacterMapping(length, partCount) {\n    _classCallCheck(this, CharacterMapping);\n\n    this.length = length;\n    this._data = new Uint32Array(this.length);\n    this._absoluteOffsets = new Uint32Array(this.length);\n  }\n\n  _createClass(CharacterMapping, [{\n    key: \"setPartData\",\n    value: function setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\n      var partData = (partIndex << 16\n      /* PART_INDEX_OFFSET */\n      | charIndex << 0\n      /* CHAR_INDEX_OFFSET */\n      ) >>> 0;\n      this._data[charOffset] = partData;\n      this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\n    }\n  }, {\n    key: \"getAbsoluteOffsets\",\n    value: function getAbsoluteOffsets() {\n      return this._absoluteOffsets;\n    }\n  }, {\n    key: \"charOffsetToPartData\",\n    value: function charOffsetToPartData(charOffset) {\n      if (this.length === 0) {\n        return 0;\n      }\n\n      if (charOffset < 0) {\n        return this._data[0];\n      }\n\n      if (charOffset >= this.length) {\n        return this._data[this.length - 1];\n      }\n\n      return this._data[charOffset];\n    }\n  }, {\n    key: \"partDataToCharOffset\",\n    value: function partDataToCharOffset(partIndex, partLength, charIndex) {\n      if (this.length === 0) {\n        return 0;\n      }\n\n      var searchEntry = (partIndex << 16\n      /* PART_INDEX_OFFSET */\n      | charIndex << 0\n      /* CHAR_INDEX_OFFSET */\n      ) >>> 0;\n      var min = 0;\n      var max = this.length - 1;\n\n      while (min + 1 < max) {\n        var mid = min + max >>> 1;\n        var midEntry = this._data[mid];\n\n        if (midEntry === searchEntry) {\n          return mid;\n        } else if (midEntry > searchEntry) {\n          max = mid;\n        } else {\n          min = mid;\n        }\n      }\n\n      if (min === max) {\n        return min;\n      }\n\n      var minEntry = this._data[min];\n      var maxEntry = this._data[max];\n\n      if (minEntry === searchEntry) {\n        return min;\n      }\n\n      if (maxEntry === searchEntry) {\n        return max;\n      }\n\n      var minPartIndex = CharacterMapping.getPartIndex(minEntry);\n      var minCharIndex = CharacterMapping.getCharIndex(minEntry);\n      var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n      var maxCharIndex;\n\n      if (minPartIndex !== maxPartIndex) {\n        // sitting between parts\n        maxCharIndex = partLength;\n      } else {\n        maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n      }\n\n      var minEntryDistance = charIndex - minCharIndex;\n      var maxEntryDistance = maxCharIndex - charIndex;\n\n      if (minEntryDistance <= maxEntryDistance) {\n        return min;\n      }\n\n      return max;\n    }\n  }], [{\n    key: \"getPartIndex\",\n    value: function getPartIndex(partData) {\n      return (partData & 4294901760\n      /* PART_INDEX_MASK */\n      ) >>> 16\n      /* PART_INDEX_OFFSET */\n      ;\n    }\n  }, {\n    key: \"getCharIndex\",\n    value: function getCharIndex(partData) {\n      return (partData & 65535\n      /* CHAR_INDEX_MASK */\n      ) >>> 0\n      /* CHAR_INDEX_OFFSET */\n      ;\n    }\n  }]);\n\n  return CharacterMapping;\n}();\nexport var RenderLineOutput = function RenderLineOutput(characterMapping, containsRTL, containsForeignElements) {\n  _classCallCheck(this, RenderLineOutput);\n\n  this.characterMapping = characterMapping;\n  this.containsRTL = containsRTL;\n  this.containsForeignElements = containsForeignElements;\n};\nexport function renderViewLine(input, sb) {\n  if (input.lineContent.length === 0) {\n    var containsForeignElements = 0\n    /* None */\n    ;\n    var content = '<span><span></span></span>';\n\n    if (input.lineDecorations.length > 0) {\n      // This line is empty, but it contains inline decorations\n      var beforeClassNames = [];\n      var afterClassNames = [];\n\n      for (var i = 0, len = input.lineDecorations.length; i < len; i++) {\n        var lineDecoration = input.lineDecorations[i];\n\n        if (lineDecoration.type === 1\n        /* Before */\n        ) {\n            beforeClassNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 1\n            /* Before */\n            ;\n          }\n\n        if (lineDecoration.type === 2\n        /* After */\n        ) {\n            afterClassNames.push(input.lineDecorations[i].className);\n            containsForeignElements |= 2\n            /* After */\n            ;\n          }\n      }\n\n      if (containsForeignElements !== 0\n      /* None */\n      ) {\n          var beforeSpan = beforeClassNames.length > 0 ? \"<span class=\\\"\".concat(beforeClassNames.join(' '), \"\\\"></span>\") : \"\";\n          var afterSpan = afterClassNames.length > 0 ? \"<span class=\\\"\".concat(afterClassNames.join(' '), \"\\\"></span>\") : \"\";\n          content = \"<span>\".concat(beforeSpan).concat(afterSpan, \"</span>\");\n        }\n    }\n\n    sb.appendASCIIString(content);\n    return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\n  }\n\n  return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport var RenderLineOutput2 = function RenderLineOutput2(characterMapping, html, containsRTL, containsForeignElements) {\n  _classCallCheck(this, RenderLineOutput2);\n\n  this.characterMapping = characterMapping;\n  this.html = html;\n  this.containsRTL = containsRTL;\n  this.containsForeignElements = containsForeignElements;\n};\nexport function renderViewLine2(input) {\n  var sb = createStringBuilder(10000);\n  var out = renderViewLine(input, sb);\n  return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\n\nvar ResolvedRenderLineInput = function ResolvedRenderLineInput(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n  _classCallCheck(this, ResolvedRenderLineInput);\n\n  this.fontIsMonospace = fontIsMonospace;\n  this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n  this.lineContent = lineContent;\n  this.len = len;\n  this.isOverflowing = isOverflowing;\n  this.parts = parts;\n  this.containsForeignElements = containsForeignElements;\n  this.fauxIndentLength = fauxIndentLength;\n  this.tabSize = tabSize;\n  this.startVisibleColumn = startVisibleColumn;\n  this.containsRTL = containsRTL;\n  this.spaceWidth = spaceWidth;\n  this.renderSpaceCharCode = renderSpaceCharCode;\n  this.renderWhitespace = renderWhitespace;\n  this.renderControlCharacters = renderControlCharacters; //\n};\n\nfunction resolveRenderLineInput(input) {\n  var lineContent = input.lineContent;\n  var isOverflowing;\n  var len;\n\n  if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n    isOverflowing = true;\n    len = input.stopRenderingLineAfter;\n  } else {\n    isOverflowing = false;\n    len = lineContent.length;\n  }\n\n  var tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n\n  if (input.renderWhitespace === 4\n  /* All */\n  || input.renderWhitespace === 1\n  /* Boundary */\n  || input.renderWhitespace === 2\n  /* Selection */\n  && !!input.selectionsOnLine || input.renderWhitespace === 3\n  /* Trailing */\n  ) {\n      tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n\n  var containsForeignElements = 0\n  /* None */\n  ;\n\n  if (input.lineDecorations.length > 0) {\n    for (var i = 0, _len = input.lineDecorations.length; i < _len; i++) {\n      var lineDecoration = input.lineDecorations[i];\n\n      if (lineDecoration.type === 3\n      /* RegularAffectingLetterSpacing */\n      ) {\n          // Pretend there are foreign elements... although not 100% accurate.\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 1\n      /* Before */\n      ) {\n          containsForeignElements |= 1\n          /* Before */\n          ;\n        } else if (lineDecoration.type === 2\n      /* After */\n      ) {\n          containsForeignElements |= 2\n          /* After */\n          ;\n        }\n    }\n\n    tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n  }\n\n  if (!input.containsRTL) {\n    // We can never split RTL text, as it ruins the rendering\n    tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n  }\n\n  return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\n\n\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n  var result = [],\n      resultLen = 0; // The faux indent part of the line should have no token type\n\n  if (fauxIndentLength > 0) {\n    result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n  }\n\n  for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n    var endIndex = tokens.getEndOffset(tokenIndex);\n\n    if (endIndex <= fauxIndentLength) {\n      // The faux indent part of the line should have no token type\n      continue;\n    }\n\n    var type = tokens.getClassName(tokenIndex);\n\n    if (endIndex >= len) {\n      result[resultLen++] = new LinePart(len, type, 0);\n      break;\n    }\n\n    result[resultLen++] = new LinePart(endIndex, type, 0);\n  }\n\n  return result;\n}\n/**\r\n * See https://github.com/microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\n\n\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n  var lastTokenEndIndex = 0;\n  var result = [],\n      resultLen = 0;\n\n  if (onlyAtSpaces) {\n    // Split only at spaces => we need to walk each character\n    for (var i = 0, len = tokens.length; i < len; i++) {\n      var token = tokens[i];\n      var tokenEndIndex = token.endIndex;\n\n      if (lastTokenEndIndex + 50\n      /* LongToken */\n      < tokenEndIndex) {\n        var tokenType = token.type;\n        var tokenMetadata = token.metadata;\n        var lastSpaceOffset = -1;\n        var currTokenStart = lastTokenEndIndex;\n\n        for (var j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n          if (lineContent.charCodeAt(j) === 32\n          /* Space */\n          ) {\n              lastSpaceOffset = j;\n            }\n\n          if (lastSpaceOffset !== -1 && j - currTokenStart >= 50\n          /* LongToken */\n          ) {\n              // Split at `lastSpaceOffset` + 1\n              result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n              currTokenStart = lastSpaceOffset + 1;\n              lastSpaceOffset = -1;\n            }\n        }\n\n        if (currTokenStart !== tokenEndIndex) {\n          result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n        }\n      } else {\n        result[resultLen++] = token;\n      }\n\n      lastTokenEndIndex = tokenEndIndex;\n    }\n  } else {\n    // Split anywhere => we don't need to walk each character\n    for (var _i = 0, _len2 = tokens.length; _i < _len2; _i++) {\n      var _token = tokens[_i];\n      var _tokenEndIndex = _token.endIndex;\n      var diff = _tokenEndIndex - lastTokenEndIndex;\n\n      if (diff > 50\n      /* LongToken */\n      ) {\n          var _tokenType = _token.type;\n          var _tokenMetadata = _token.metadata;\n          var piecesCount = Math.ceil(diff / 50\n          /* LongToken */\n          );\n\n          for (var _j = 1; _j < piecesCount; _j++) {\n            var pieceEndIndex = lastTokenEndIndex + _j * 50\n            /* LongToken */\n            ;\n            result[resultLen++] = new LinePart(pieceEndIndex, _tokenType, _tokenMetadata);\n          }\n\n          result[resultLen++] = new LinePart(_tokenEndIndex, _tokenType, _tokenMetadata);\n        } else {\n        result[resultLen++] = _token;\n      }\n\n      lastTokenEndIndex = _tokenEndIndex;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\n\n\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n  var continuesWithWrappedLine = input.continuesWithWrappedLine;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var useMonospaceOptimizations = input.useMonospaceOptimizations;\n  var selections = input.selectionsOnLine;\n  var onlyBoundary = input.renderWhitespace === 1\n  /* Boundary */\n  ;\n  var onlyTrailing = input.renderWhitespace === 3\n  /* Trailing */\n  ;\n  var generateLinePartForEachWhitespace = input.renderSpaceWidth !== input.spaceWidth;\n  var result = [],\n      resultLen = 0;\n  var tokenIndex = 0;\n  var tokenType = tokens[tokenIndex].type;\n  var tokenEndIndex = tokens[tokenIndex].endIndex;\n  var tokensLength = tokens.length;\n  var lineIsEmptyOrWhitespace = false;\n  var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n  var lastNonWhitespaceIndex;\n\n  if (firstNonWhitespaceIndex === -1) {\n    lineIsEmptyOrWhitespace = true;\n    firstNonWhitespaceIndex = len;\n    lastNonWhitespaceIndex = len;\n  } else {\n    lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n  }\n\n  var wasInWhitespace = false;\n  var currentSelectionIndex = 0;\n  var currentSelection = selections && selections[currentSelectionIndex];\n  var tmpIndent = startVisibleColumn % tabSize;\n\n  for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n    var chCode = lineContent.charCodeAt(charIndex);\n\n    if (currentSelection && charIndex >= currentSelection.endOffset) {\n      currentSelectionIndex++;\n      currentSelection = selections && selections[currentSelectionIndex];\n    }\n\n    var isInWhitespace = void 0;\n\n    if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n      // in leading or trailing whitespace\n      isInWhitespace = true;\n    } else if (chCode === 9\n    /* Tab */\n    ) {\n        // a tab character is rendered both in all and boundary cases\n        isInWhitespace = true;\n      } else if (chCode === 32\n    /* Space */\n    ) {\n        // hit a space character\n        if (onlyBoundary) {\n          // rendering only boundary whitespace\n          if (wasInWhitespace) {\n            isInWhitespace = true;\n          } else {\n            var nextChCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n            /* Null */\n            ;\n            isInWhitespace = nextChCode === 32\n            /* Space */\n            || nextChCode === 9\n            /* Tab */\n            ;\n          }\n        } else {\n          isInWhitespace = true;\n        }\n      } else {\n      isInWhitespace = false;\n    } // If rendering whitespace on selection, check that the charIndex falls within a selection\n\n\n    if (isInWhitespace && selections) {\n      isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n    } // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n\n\n    if (isInWhitespace && onlyTrailing) {\n      isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n    }\n\n    if (wasInWhitespace) {\n      // was in whitespace token\n      if (!isInWhitespace || !useMonospaceOptimizations && tmpIndent >= tabSize) {\n        // leaving whitespace token or entering a new indent\n        if (generateLinePartForEachWhitespace) {\n          var lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n\n          for (var i = lastEndIndex + 1; i <= charIndex; i++) {\n            result[resultLen++] = new LinePart(i, 'mtkw', 1\n            /* IS_WHITESPACE */\n            );\n          }\n        } else {\n          result[resultLen++] = new LinePart(charIndex, 'mtkw', 1\n          /* IS_WHITESPACE */\n          );\n        }\n\n        tmpIndent = tmpIndent % tabSize;\n      }\n    } else {\n      // was in regular token\n      if (charIndex === tokenEndIndex || isInWhitespace && charIndex > fauxIndentLength) {\n        result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n        tmpIndent = tmpIndent % tabSize;\n      }\n    }\n\n    if (chCode === 9\n    /* Tab */\n    ) {\n        tmpIndent = tabSize;\n      } else if (strings.isFullWidthCharacter(chCode)) {\n      tmpIndent += 2;\n    } else {\n      tmpIndent++;\n    }\n\n    wasInWhitespace = isInWhitespace;\n\n    while (charIndex === tokenEndIndex) {\n      tokenIndex++;\n\n      if (tokenIndex < tokensLength) {\n        tokenType = tokens[tokenIndex].type;\n        tokenEndIndex = tokens[tokenIndex].endIndex;\n      }\n    }\n  }\n\n  var generateWhitespace = false;\n\n  if (wasInWhitespace) {\n    // was in whitespace token\n    if (continuesWithWrappedLine && onlyBoundary) {\n      var lastCharCode = len > 0 ? lineContent.charCodeAt(len - 1) : 0\n      /* Null */\n      ;\n      var prevCharCode = len > 1 ? lineContent.charCodeAt(len - 2) : 0\n      /* Null */\n      ;\n      var isSingleTrailingSpace = lastCharCode === 32\n      /* Space */\n      && prevCharCode !== 32\n      /* Space */\n      && prevCharCode !== 9\n      /* Tab */\n      ;\n\n      if (!isSingleTrailingSpace) {\n        generateWhitespace = true;\n      }\n    } else {\n      generateWhitespace = true;\n    }\n  }\n\n  if (generateWhitespace) {\n    if (generateLinePartForEachWhitespace) {\n      var _lastEndIndex = resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength;\n\n      for (var _i2 = _lastEndIndex + 1; _i2 <= len; _i2++) {\n        result[resultLen++] = new LinePart(_i2, 'mtkw', 1\n        /* IS_WHITESPACE */\n        );\n      }\n    } else {\n      result[resultLen++] = new LinePart(len, 'mtkw', 1\n      /* IS_WHITESPACE */\n      );\n    }\n  } else {\n    result[resultLen++] = new LinePart(len, tokenType, 0);\n  }\n\n  return result;\n}\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\n\n\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n  _lineDecorations.sort(LineDecoration.compare);\n\n  var lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n  var lineDecorationsLen = lineDecorations.length;\n  var lineDecorationIndex = 0;\n  var result = [],\n      resultLen = 0,\n      lastResultEndIndex = 0;\n\n  for (var tokenIndex = 0, _len3 = tokens.length; tokenIndex < _len3; tokenIndex++) {\n    var token = tokens[tokenIndex];\n    var tokenEndIndex = token.endIndex;\n    var tokenType = token.type;\n    var tokenMetadata = token.metadata;\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n      var lineDecoration = lineDecorations[lineDecorationIndex];\n\n      if (lineDecoration.startOffset > lastResultEndIndex) {\n        lastResultEndIndex = lineDecoration.startOffset;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n      }\n\n      if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n        // This line decoration ends before this token ends\n        lastResultEndIndex = lineDecoration.endOffset + 1;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        lineDecorationIndex++;\n      } else {\n        // This line decoration continues on to the next token\n        lastResultEndIndex = tokenEndIndex;\n        result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n        break;\n      }\n    }\n\n    if (tokenEndIndex > lastResultEndIndex) {\n      lastResultEndIndex = tokenEndIndex;\n      result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n    }\n  }\n\n  var lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n\n  if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n    var classNames = [];\n    var metadata = 0;\n\n    while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n      classNames.push(lineDecorations[lineDecorationIndex].className);\n      metadata |= lineDecorations[lineDecorationIndex].metadata;\n      lineDecorationIndex++;\n    }\n\n    result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '), metadata);\n  }\n\n  return result;\n}\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\n\n\nfunction _renderLine(input, sb) {\n  var fontIsMonospace = input.fontIsMonospace;\n  var canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n  var containsForeignElements = input.containsForeignElements;\n  var lineContent = input.lineContent;\n  var len = input.len;\n  var isOverflowing = input.isOverflowing;\n  var parts = input.parts;\n  var fauxIndentLength = input.fauxIndentLength;\n  var tabSize = input.tabSize;\n  var startVisibleColumn = input.startVisibleColumn;\n  var containsRTL = input.containsRTL;\n  var spaceWidth = input.spaceWidth;\n  var renderSpaceCharCode = input.renderSpaceCharCode;\n  var renderWhitespace = input.renderWhitespace;\n  var renderControlCharacters = input.renderControlCharacters;\n  var characterMapping = new CharacterMapping(len + 1, parts.length);\n  var charIndex = 0;\n  var visibleColumn = startVisibleColumn;\n  var charOffsetInPart = 0;\n  var partDisplacement = 0;\n  var prevPartContentCnt = 0;\n  var partAbsoluteOffset = 0;\n\n  if (containsRTL) {\n    sb.appendASCIIString('<span dir=\"ltr\">');\n  } else {\n    sb.appendASCIIString('<span>');\n  }\n\n  for (var partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n    partAbsoluteOffset += prevPartContentCnt;\n    var part = parts[partIndex];\n    var partEndIndex = part.endIndex;\n    var partType = part.type;\n    var partRendersWhitespace = renderWhitespace !== 0\n    /* None */\n    && part.isWhitespace();\n    var partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw'\n    /*only whitespace*/\n    || !containsForeignElements);\n    var partIsEmptyAndHasPseudoAfter = charIndex === partEndIndex && part.metadata === 4\n    /* PSEUDO_AFTER */\n    ;\n    charOffsetInPart = 0;\n    sb.appendASCIIString('<span class=\"');\n    sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n    sb.appendASCII(34\n    /* DoubleQuote */\n    );\n\n    if (partRendersWhitespace) {\n      var partContentCnt = 0;\n      {\n        var _charIndex = charIndex;\n        var _visibleColumn = visibleColumn;\n\n        for (; _charIndex < partEndIndex; _charIndex++) {\n          var charCode = lineContent.charCodeAt(_charIndex);\n          var charWidth = (charCode === 9\n          /* Tab */\n          ? tabSize - _visibleColumn % tabSize : 1) | 0;\n          partContentCnt += charWidth;\n\n          if (_charIndex >= fauxIndentLength) {\n            _visibleColumn += charWidth;\n          }\n        }\n      }\n\n      if (partRendersWhitespaceWithWidth) {\n        sb.appendASCIIString(' style=\"width:');\n        sb.appendASCIIString(String(spaceWidth * partContentCnt));\n        sb.appendASCIIString('px\"');\n      }\n\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n\n        var _charCode = lineContent.charCodeAt(charIndex);\n\n        var _charWidth = void 0;\n\n        if (_charCode === 9\n        /* Tab */\n        ) {\n            _charWidth = tabSize - visibleColumn % tabSize | 0;\n\n            if (!canUseHalfwidthRightwardsArrow || _charWidth > 1) {\n              sb.write1(0x2192); // RIGHTWARDS ARROW\n            } else {\n              sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n            }\n\n            for (var space = 2; space <= _charWidth; space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n          } else {\n          // must be CharCode.Space\n          _charWidth = 1;\n          sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n        }\n\n        charOffsetInPart += _charWidth;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += _charWidth;\n        }\n      }\n\n      prevPartContentCnt = partContentCnt;\n    } else {\n      var _partContentCnt = 0;\n      sb.appendASCII(62\n      /* GreaterThan */\n      );\n\n      for (; charIndex < partEndIndex; charIndex++) {\n        characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n        partDisplacement = 0;\n\n        var _charCode2 = lineContent.charCodeAt(charIndex);\n\n        var producedCharacters = 1;\n        var _charWidth2 = 1;\n\n        switch (_charCode2) {\n          case 9\n          /* Tab */\n          :\n            producedCharacters = tabSize - visibleColumn % tabSize;\n            _charWidth2 = producedCharacters;\n\n            for (var _space = 1; _space <= producedCharacters; _space++) {\n              sb.write1(0xA0); // &nbsp;\n            }\n\n            break;\n\n          case 32\n          /* Space */\n          :\n            sb.write1(0xA0); // &nbsp;\n\n            break;\n\n          case 60\n          /* LessThan */\n          :\n            sb.appendASCIIString('&lt;');\n            break;\n\n          case 62\n          /* GreaterThan */\n          :\n            sb.appendASCIIString('&gt;');\n            break;\n\n          case 38\n          /* Ampersand */\n          :\n            sb.appendASCIIString('&amp;');\n            break;\n\n          case 0\n          /* Null */\n          :\n            sb.appendASCIIString('&#00;');\n            break;\n\n          case 65279\n          /* UTF8_BOM */\n          :\n          case 8232\n          /* LINE_SEPARATOR */\n          :\n          case 8233\n          /* PARAGRAPH_SEPARATOR */\n          :\n          case 133\n          /* NEXT_LINE */\n          :\n            sb.write1(0xFFFD);\n            break;\n\n          default:\n            if (strings.isFullWidthCharacter(_charCode2)) {\n              _charWidth2++;\n            }\n\n            if (renderControlCharacters && _charCode2 < 32) {\n              sb.write1(9216 + _charCode2);\n            } else {\n              sb.write1(_charCode2);\n            }\n\n        }\n\n        charOffsetInPart += producedCharacters;\n        _partContentCnt += producedCharacters;\n\n        if (charIndex >= fauxIndentLength) {\n          visibleColumn += _charWidth2;\n        }\n      }\n\n      prevPartContentCnt = _partContentCnt;\n    }\n\n    if (partIsEmptyAndHasPseudoAfter) {\n      partDisplacement++;\n    } else {\n      partDisplacement = 0;\n    }\n\n    sb.appendASCIIString('</span>');\n  } // When getting client rects for the last character, we will position the\n  // text range at the end of the span, insteaf of at the beginning of next span\n\n\n  characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n\n  if (isOverflowing) {\n    sb.appendASCIIString('<span>&hellip;</span>');\n  }\n\n  sb.appendASCIIString('</span>');\n  return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js"],"names":["strings","createStringBuilder","LineDecoration","LineDecorationsNormalizer","LinePart","endIndex","type","metadata","LineRange","startIndex","startOffset","endOffset","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","lineContent","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","lineTokens","lineDecorations","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","sort","compare","a","b","wsmiddotDiff","Math","abs","middotDiff","renderSpaceWidth","renderSpaceCharCode","otherSelections","length","i","equals","other","equalsArr","sameSelection","CharacterMapping","partCount","_data","Uint32Array","_absoluteOffsets","charOffset","partIndex","charIndex","partAbsoluteOffset","partData","partLength","searchEntry","min","max","mid","midEntry","minEntry","maxEntry","minPartIndex","getPartIndex","minCharIndex","getCharIndex","maxPartIndex","maxCharIndex","minEntryDistance","maxEntryDistance","RenderLineOutput","characterMapping","containsForeignElements","renderViewLine","input","sb","content","beforeClassNames","afterClassNames","len","lineDecoration","push","className","beforeSpan","join","afterSpan","appendASCIIString","_renderLine","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","out","build","ResolvedRenderLineInput","fontIsMonospace","isOverflowing","parts","tokens","transformAndRemoveOverflowing","_applyRenderWhitespace","_applyInlineDecorations","splitLargeTokens","result","resultLen","tokenIndex","tokensLen","getCount","getEndOffset","getClassName","onlyAtSpaces","lastTokenEndIndex","token","tokenEndIndex","tokenType","tokenMetadata","lastSpaceOffset","currTokenStart","j","charCodeAt","diff","piecesCount","ceil","pieceEndIndex","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","lastNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","lastEndIndex","isFullWidthCharacter","generateWhitespace","lastCharCode","prevCharCode","isSingleTrailingSpace","_lineDecorations","normalize","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","classNames","visibleColumn","charOffsetInPart","partDisplacement","prevPartContentCnt","part","partEndIndex","partType","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","appendASCII","partContentCnt","_charIndex","_visibleColumn","charCode","charWidth","String","setPartData","write1","space","producedCharacters"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,iCAAzB;AACA,SAASC,mBAAT,QAAoC,0BAApC;AACA,SAASC,cAAT,EAAyBC,yBAAzB,QAA0D,sBAA1D;;IACMC,Q;AACF,oBAAYC,QAAZ,EAAsBC,IAAtB,EAA4BC,QAA5B,EAAsC;AAAA;;AAClC,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACH;;;;mCACc;AACX,aAAQ,KAAKA,QAAL,GAAgB;AAAE;AAAlB,QAA6C,IAA7C,GAAoD,KAA5D;AACH;;;;;;AAEL,WAAaC,SAAb;AACI,qBAAYC,UAAZ,EAAwBJ,QAAxB,EAAkC;AAAA;;AAC9B,SAAKK,WAAL,GAAmBD,UAAnB;AACA,SAAKE,SAAL,GAAiBN,QAAjB;AACH;;AAJL;AAAA;AAAA,2BAKWO,cALX,EAK2B;AACnB,aAAO,KAAKF,WAAL,KAAqBE,cAAc,CAACF,WAApC,IACA,KAAKC,SAAL,KAAmBC,cAAc,CAACD,SADzC;AAEH;AARL;;AAAA;AAAA;AAUA,WAAaE,eAAb;AACI,2BAAYC,yBAAZ,EAAuCC,8BAAvC,EAAuEC,WAAvE,EAAoFC,wBAApF,EAA8GC,YAA9G,EAA4HC,WAA5H,EAAyIC,gBAAzI,EAA2JC,UAA3J,EAAuKC,eAAvK,EAAwLC,OAAxL,EAAiMC,kBAAjM,EAAqNC,UAArN,EAAiOC,WAAjO,EAA8OC,aAA9O,EAA6PC,sBAA7P,EAAqRC,gBAArR,EAAuSC,uBAAvS,EAAgUC,aAAhU,EAA+UC,gBAA/U,EAAiW;AAAA;;AAC7V,SAAKlB,yBAAL,GAAiCA,yBAAjC;AACA,SAAKC,8BAAL,GAAsCA,8BAAtC;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,wBAAL,GAAgCA,wBAAhC;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,eAAL,GAAuBA,eAAe,CAACW,IAAhB,CAAqB/B,cAAc,CAACgC,OAApC,CAAvB;AACA,SAAKX,OAAL,GAAeA,OAAf;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKG,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,gBAAL,GAAyBA,gBAAgB,KAAK,KAArB,GACnB;AAAE;AADiB,MAEnBA,gBAAgB,KAAK,UAArB,GACI;AAAE;AADN,MAEIA,gBAAgB,KAAK,WAArB,GACI;AAAE;AADN,MAEIA,gBAAgB,KAAK,UAArB,GACI;AAAE;AADN,MAEI;AAAE;AARpB;AASA,SAAKC,uBAAL,GAA+BA,uBAA/B;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,gBAAL,GAAwBA,gBAAgB,IAAIA,gBAAgB,CAACC,IAAjB,CAAsB,UAACE,CAAD,EAAIC,CAAJ;AAAA,aAAUD,CAAC,CAACzB,WAAF,GAAgB0B,CAAC,CAAC1B,WAAlB,GAAgC,CAAC,CAAjC,GAAqC,CAA/C;AAAA,KAAtB,CAA5C;AACA,QAAM2B,YAAY,GAAGC,IAAI,CAACC,GAAL,CAASZ,aAAa,GAAGF,UAAzB,CAArB;AACA,QAAMe,UAAU,GAAGF,IAAI,CAACC,GAAL,CAASb,WAAW,GAAGD,UAAvB,CAAnB;;AACA,QAAIY,YAAY,GAAGG,UAAnB,EAA+B;AAC3B,WAAKC,gBAAL,GAAwBd,aAAxB;AACA,WAAKe,mBAAL,GAA2B,MAA3B,CAF2B,CAEQ;AACtC,KAHD,MAIK;AACD,WAAKD,gBAAL,GAAwBf,WAAxB;AACA,WAAKgB,mBAAL,GAA2B,IAA3B,CAFC,CAEgC;AACpC;AACJ;;AArCL;AAAA;AAAA,kCAsCkBC,eAtClB,EAsCmC;AAC3B,UAAI,KAAKX,gBAAL,KAA0B,IAA9B,EAAoC;AAChC,eAAOW,eAAe,KAAK,IAA3B;AACH;;AACD,UAAIA,eAAe,KAAK,IAAxB,EAA8B;AAC1B,eAAO,KAAP;AACH;;AACD,UAAIA,eAAe,CAACC,MAAhB,KAA2B,KAAKZ,gBAAL,CAAsBY,MAArD,EAA6D;AACzD,eAAO,KAAP;AACH;;AACD,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKb,gBAAL,CAAsBY,MAA1C,EAAkDC,CAAC,EAAnD,EAAuD;AACnD,YAAI,CAAC,KAAKb,gBAAL,CAAsBa,CAAtB,EAAyBC,MAAzB,CAAgCH,eAAe,CAACE,CAAD,CAA/C,CAAL,EAA0D;AACtD,iBAAO,KAAP;AACH;AACJ;;AACD,aAAO,IAAP;AACH;AAtDL;AAAA;AAAA,2BAuDWE,KAvDX,EAuDkB;AACV,aAAQ,KAAKjC,yBAAL,KAAmCiC,KAAK,CAACjC,yBAAzC,IACD,KAAKC,8BAAL,KAAwCgC,KAAK,CAAChC,8BAD7C,IAED,KAAKC,WAAL,KAAqB+B,KAAK,CAAC/B,WAF1B,IAGD,KAAKC,wBAAL,KAAkC8B,KAAK,CAAC9B,wBAHvC,IAID,KAAKC,YAAL,KAAsB6B,KAAK,CAAC7B,YAJ3B,IAKD,KAAKC,WAAL,KAAqB4B,KAAK,CAAC5B,WAL1B,IAMD,KAAKC,gBAAL,KAA0B2B,KAAK,CAAC3B,gBAN/B,IAOD,KAAKG,OAAL,KAAiBwB,KAAK,CAACxB,OAPtB,IAQD,KAAKC,kBAAL,KAA4BuB,KAAK,CAACvB,kBARjC,IASD,KAAKC,UAAL,KAAoBsB,KAAK,CAACtB,UATzB,IAUD,KAAKgB,gBAAL,KAA0BM,KAAK,CAACN,gBAV/B,IAWD,KAAKC,mBAAL,KAA6BK,KAAK,CAACL,mBAXlC,IAYD,KAAKd,sBAAL,KAAgCmB,KAAK,CAACnB,sBAZrC,IAaD,KAAKC,gBAAL,KAA0BkB,KAAK,CAAClB,gBAb/B,IAcD,KAAKC,uBAAL,KAAiCiB,KAAK,CAACjB,uBAdtC,IAeD,KAAKC,aAAL,KAAuBgB,KAAK,CAAChB,aAf5B,IAgBD7B,cAAc,CAAC8C,SAAf,CAAyB,KAAK1B,eAA9B,EAA+CyB,KAAK,CAACzB,eAArD,CAhBC,IAiBD,KAAKD,UAAL,CAAgByB,MAAhB,CAAuBC,KAAK,CAAC1B,UAA7B,CAjBC,IAkBD,KAAK4B,aAAL,CAAmBF,KAAK,CAACf,gBAAzB,CAlBP;AAmBH;AA3EL;;AAAA;AAAA;AA6EA;AACA;AACA;;AACA,WAAakB,gBAAb;AACI,4BAAYN,MAAZ,EAAoBO,SAApB,EAA+B;AAAA;;AAC3B,SAAKP,MAAL,GAAcA,MAAd;AACA,SAAKQ,KAAL,GAAa,IAAIC,WAAJ,CAAgB,KAAKT,MAArB,CAAb;AACA,SAAKU,gBAAL,GAAwB,IAAID,WAAJ,CAAgB,KAAKT,MAArB,CAAxB;AACH;;AALL;AAAA;AAAA,gCAYgBW,UAZhB,EAY4BC,SAZ5B,EAYuCC,SAZvC,EAYkDC,kBAZlD,EAYsE;AAC9D,UAAIC,QAAQ,GAAG,CAAEH,SAAS,IAAI;AAAG;AAAjB,QACTC,SAAS,IAAI;AAAE;AADP,YACqC,CADpD;AAEA,WAAKL,KAAL,CAAWG,UAAX,IAAyBI,QAAzB;AACA,WAAKL,gBAAL,CAAsBC,UAAtB,IAAoCG,kBAAkB,GAAGD,SAAzD;AACH;AAjBL;AAAA;AAAA,yCAkByB;AACjB,aAAO,KAAKH,gBAAZ;AACH;AApBL;AAAA;AAAA,yCAqByBC,UArBzB,EAqBqC;AAC7B,UAAI,KAAKX,MAAL,KAAgB,CAApB,EAAuB;AACnB,eAAO,CAAP;AACH;;AACD,UAAIW,UAAU,GAAG,CAAjB,EAAoB;AAChB,eAAO,KAAKH,KAAL,CAAW,CAAX,CAAP;AACH;;AACD,UAAIG,UAAU,IAAI,KAAKX,MAAvB,EAA+B;AAC3B,eAAO,KAAKQ,KAAL,CAAW,KAAKR,MAAL,GAAc,CAAzB,CAAP;AACH;;AACD,aAAO,KAAKQ,KAAL,CAAWG,UAAX,CAAP;AACH;AAhCL;AAAA;AAAA,yCAiCyBC,SAjCzB,EAiCoCI,UAjCpC,EAiCgDH,SAjChD,EAiC2D;AACnD,UAAI,KAAKb,MAAL,KAAgB,CAApB,EAAuB;AACnB,eAAO,CAAP;AACH;;AACD,UAAIiB,WAAW,GAAG,CAAEL,SAAS,IAAI;AAAG;AAAjB,QACZC,SAAS,IAAI;AAAE;AADJ,YACkC,CADpD;AAEA,UAAIK,GAAG,GAAG,CAAV;AACA,UAAIC,GAAG,GAAG,KAAKnB,MAAL,GAAc,CAAxB;;AACA,aAAOkB,GAAG,GAAG,CAAN,GAAUC,GAAjB,EAAsB;AAClB,YAAIC,GAAG,GAAKF,GAAG,GAAGC,GAAP,KAAgB,CAA3B;AACA,YAAIE,QAAQ,GAAG,KAAKb,KAAL,CAAWY,GAAX,CAAf;;AACA,YAAIC,QAAQ,KAAKJ,WAAjB,EAA8B;AAC1B,iBAAOG,GAAP;AACH,SAFD,MAGK,IAAIC,QAAQ,GAAGJ,WAAf,EAA4B;AAC7BE,UAAAA,GAAG,GAAGC,GAAN;AACH,SAFI,MAGA;AACDF,UAAAA,GAAG,GAAGE,GAAN;AACH;AACJ;;AACD,UAAIF,GAAG,KAAKC,GAAZ,EAAiB;AACb,eAAOD,GAAP;AACH;;AACD,UAAII,QAAQ,GAAG,KAAKd,KAAL,CAAWU,GAAX,CAAf;AACA,UAAIK,QAAQ,GAAG,KAAKf,KAAL,CAAWW,GAAX,CAAf;;AACA,UAAIG,QAAQ,KAAKL,WAAjB,EAA8B;AAC1B,eAAOC,GAAP;AACH;;AACD,UAAIK,QAAQ,KAAKN,WAAjB,EAA8B;AAC1B,eAAOE,GAAP;AACH;;AACD,UAAIK,YAAY,GAAGlB,gBAAgB,CAACmB,YAAjB,CAA8BH,QAA9B,CAAnB;AACA,UAAII,YAAY,GAAGpB,gBAAgB,CAACqB,YAAjB,CAA8BL,QAA9B,CAAnB;AACA,UAAIM,YAAY,GAAGtB,gBAAgB,CAACmB,YAAjB,CAA8BF,QAA9B,CAAnB;AACA,UAAIM,YAAJ;;AACA,UAAIL,YAAY,KAAKI,YAArB,EAAmC;AAC/B;AACAC,QAAAA,YAAY,GAAGb,UAAf;AACH,OAHD,MAIK;AACDa,QAAAA,YAAY,GAAGvB,gBAAgB,CAACqB,YAAjB,CAA8BJ,QAA9B,CAAf;AACH;;AACD,UAAIO,gBAAgB,GAAGjB,SAAS,GAAGa,YAAnC;AACA,UAAIK,gBAAgB,GAAGF,YAAY,GAAGhB,SAAtC;;AACA,UAAIiB,gBAAgB,IAAIC,gBAAxB,EAA0C;AACtC,eAAOb,GAAP;AACH;;AACD,aAAOC,GAAP;AACH;AAlFL;AAAA;AAAA,iCAMwBJ,QANxB,EAMkC;AAC1B,aAAO,CAACA,QAAQ,GAAG;AAAW;AAAvB,YAAkD;AAAG;AAA5D;AACH;AARL;AAAA;AAAA,iCASwBA,QATxB,EASkC;AAC1B,aAAO,CAACA,QAAQ,GAAG;AAAM;AAAlB,YAA6C;AAAE;AAAtD;AACH;AAXL;;AAAA;AAAA;AAoFA,WAAaiB,gBAAb,GACI,0BAAYC,gBAAZ,EAA8B1D,WAA9B,EAA2C2D,uBAA3C,EAAoE;AAAA;;AAChE,OAAKD,gBAAL,GAAwBA,gBAAxB;AACA,OAAK1D,WAAL,GAAmBA,WAAnB;AACA,OAAK2D,uBAAL,GAA+BA,uBAA/B;AACH,CALL;AAOA,OAAO,SAASC,cAAT,CAAwBC,KAAxB,EAA+BC,EAA/B,EAAmC;AACtC,MAAID,KAAK,CAAChE,WAAN,CAAkB4B,MAAlB,KAA6B,CAAjC,EAAoC;AAChC,QAAIkC,uBAAuB,GAAG;AAAE;AAAhC;AACA,QAAII,OAAO,GAAG,4BAAd;;AACA,QAAIF,KAAK,CAAC1D,eAAN,CAAsBsB,MAAtB,GAA+B,CAAnC,EAAsC;AAClC;AACA,UAAMuC,gBAAgB,GAAG,EAAzB;AACA,UAAMC,eAAe,GAAG,EAAxB;;AACA,WAAK,IAAIvC,CAAC,GAAG,CAAR,EAAWwC,GAAG,GAAGL,KAAK,CAAC1D,eAAN,CAAsBsB,MAA5C,EAAoDC,CAAC,GAAGwC,GAAxD,EAA6DxC,CAAC,EAA9D,EAAkE;AAC9D,YAAMyC,cAAc,GAAGN,KAAK,CAAC1D,eAAN,CAAsBuB,CAAtB,CAAvB;;AACA,YAAIyC,cAAc,CAAChF,IAAf,KAAwB;AAAE;AAA9B,UAA4C;AACxC6E,YAAAA,gBAAgB,CAACI,IAAjB,CAAsBP,KAAK,CAAC1D,eAAN,CAAsBuB,CAAtB,EAAyB2C,SAA/C;AACAV,YAAAA,uBAAuB,IAAI;AAAE;AAA7B;AACH;;AACD,YAAIQ,cAAc,CAAChF,IAAf,KAAwB;AAAE;AAA9B,UAA2C;AACvC8E,YAAAA,eAAe,CAACG,IAAhB,CAAqBP,KAAK,CAAC1D,eAAN,CAAsBuB,CAAtB,EAAyB2C,SAA9C;AACAV,YAAAA,uBAAuB,IAAI;AAAE;AAA7B;AACH;AACJ;;AACD,UAAIA,uBAAuB,KAAK;AAAE;AAAlC,QAA8C;AAC1C,cAAMW,UAAU,GAAIN,gBAAgB,CAACvC,MAAjB,GAA0B,CAA1B,2BAA8CuC,gBAAgB,CAACO,IAAjB,CAAsB,GAAtB,CAA9C,oBAApB;AACA,cAAMC,SAAS,GAAIP,eAAe,CAACxC,MAAhB,GAAyB,CAAzB,2BAA6CwC,eAAe,CAACM,IAAhB,CAAqB,GAArB,CAA7C,oBAAnB;AACAR,UAAAA,OAAO,mBAAYO,UAAZ,SAAyBE,SAAzB,YAAP;AACH;AACJ;;AACDV,IAAAA,EAAE,CAACW,iBAAH,CAAqBV,OAArB;AACA,WAAO,IAAIN,gBAAJ,CAAqB,IAAI1B,gBAAJ,CAAqB,CAArB,EAAwB,CAAxB,CAArB,EAAiD,KAAjD,EAAwD4B,uBAAxD,CAAP;AACH;;AACD,SAAOe,WAAW,CAACC,sBAAsB,CAACd,KAAD,CAAvB,EAAgCC,EAAhC,CAAlB;AACH;AACD,WAAac,iBAAb,GACI,2BAAYlB,gBAAZ,EAA8BmB,IAA9B,EAAoC7E,WAApC,EAAiD2D,uBAAjD,EAA0E;AAAA;;AACtE,OAAKD,gBAAL,GAAwBA,gBAAxB;AACA,OAAKmB,IAAL,GAAYA,IAAZ;AACA,OAAK7E,WAAL,GAAmBA,WAAnB;AACA,OAAK2D,uBAAL,GAA+BA,uBAA/B;AACH,CANL;AAQA,OAAO,SAASmB,eAAT,CAAyBjB,KAAzB,EAAgC;AACnC,MAAIC,EAAE,GAAGhF,mBAAmB,CAAC,KAAD,CAA5B;AACA,MAAIiG,GAAG,GAAGnB,cAAc,CAACC,KAAD,EAAQC,EAAR,CAAxB;AACA,SAAO,IAAIc,iBAAJ,CAAsBG,GAAG,CAACrB,gBAA1B,EAA4CI,EAAE,CAACkB,KAAH,EAA5C,EAAwDD,GAAG,CAAC/E,WAA5D,EAAyE+E,GAAG,CAACpB,uBAA7E,CAAP;AACH;;IACKsB,uB,GACF,iCAAYC,eAAZ,EAA6BtF,8BAA7B,EAA6DC,WAA7D,EAA0EqE,GAA1E,EAA+EiB,aAA/E,EAA8FC,KAA9F,EAAqGzB,uBAArG,EAA8H1D,gBAA9H,EAAgJG,OAAhJ,EAAyJC,kBAAzJ,EAA6KL,WAA7K,EAA0LM,UAA1L,EAAsMiB,mBAAtM,EAA2Nb,gBAA3N,EAA6OC,uBAA7O,EAAsQ;AAAA;;AAClQ,OAAKuE,eAAL,GAAuBA,eAAvB;AACA,OAAKtF,8BAAL,GAAsCA,8BAAtC;AACA,OAAKC,WAAL,GAAmBA,WAAnB;AACA,OAAKqE,GAAL,GAAWA,GAAX;AACA,OAAKiB,aAAL,GAAqBA,aAArB;AACA,OAAKC,KAAL,GAAaA,KAAb;AACA,OAAKzB,uBAAL,GAA+BA,uBAA/B;AACA,OAAK1D,gBAAL,GAAwBA,gBAAxB;AACA,OAAKG,OAAL,GAAeA,OAAf;AACA,OAAKC,kBAAL,GAA0BA,kBAA1B;AACA,OAAKL,WAAL,GAAmBA,WAAnB;AACA,OAAKM,UAAL,GAAkBA,UAAlB;AACA,OAAKiB,mBAAL,GAA2BA,mBAA3B;AACA,OAAKb,gBAAL,GAAwBA,gBAAxB;AACA,OAAKC,uBAAL,GAA+BA,uBAA/B,CAfkQ,CAgBlQ;AACH,C;;AAEL,SAASgE,sBAAT,CAAgCd,KAAhC,EAAuC;AACnC,MAAMhE,WAAW,GAAGgE,KAAK,CAAChE,WAA1B;AACA,MAAIsF,aAAJ;AACA,MAAIjB,GAAJ;;AACA,MAAIL,KAAK,CAACpD,sBAAN,KAAiC,CAAC,CAAlC,IAAuCoD,KAAK,CAACpD,sBAAN,GAA+BZ,WAAW,CAAC4B,MAAtF,EAA8F;AAC1F0D,IAAAA,aAAa,GAAG,IAAhB;AACAjB,IAAAA,GAAG,GAAGL,KAAK,CAACpD,sBAAZ;AACH,GAHD,MAIK;AACD0E,IAAAA,aAAa,GAAG,KAAhB;AACAjB,IAAAA,GAAG,GAAGrE,WAAW,CAAC4B,MAAlB;AACH;;AACD,MAAI4D,MAAM,GAAGC,6BAA6B,CAACzB,KAAK,CAAC3D,UAAP,EAAmB2D,KAAK,CAAC5D,gBAAzB,EAA2CiE,GAA3C,CAA1C;;AACA,MAAIL,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAA7B,KACAmD,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAD7B,KAECmD,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAA7B,KAAgD,CAAC,CAACmD,KAAK,CAAChD,gBAFzD,IAGAgD,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAHjC,IAGiD;AAC7C2E,MAAAA,MAAM,GAAGE,sBAAsB,CAAC1B,KAAD,EAAQhE,WAAR,EAAqBqE,GAArB,EAA0BmB,MAA1B,CAA/B;AACH;;AACD,MAAI1B,uBAAuB,GAAG;AAAE;AAAhC;;AACA,MAAIE,KAAK,CAAC1D,eAAN,CAAsBsB,MAAtB,GAA+B,CAAnC,EAAsC;AAClC,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWwC,IAAG,GAAGL,KAAK,CAAC1D,eAAN,CAAsBsB,MAA5C,EAAoDC,CAAC,GAAGwC,IAAxD,EAA6DxC,CAAC,EAA9D,EAAkE;AAC9D,UAAMyC,cAAc,GAAGN,KAAK,CAAC1D,eAAN,CAAsBuB,CAAtB,CAAvB;;AACA,UAAIyC,cAAc,CAAChF,IAAf,KAAwB;AAAE;AAA9B,QAAmE;AAC/D;AACAwE,UAAAA,uBAAuB,IAAI;AAAE;AAA7B;AACH,SAHD,MAIK,IAAIQ,cAAc,CAAChF,IAAf,KAAwB;AAAE;AAA9B,QAA4C;AAC7CwE,UAAAA,uBAAuB,IAAI;AAAE;AAA7B;AACH,SAFI,MAGA,IAAIQ,cAAc,CAAChF,IAAf,KAAwB;AAAE;AAA9B,QAA2C;AAC5CwE,UAAAA,uBAAuB,IAAI;AAAE;AAA7B;AACH;AACJ;;AACD0B,IAAAA,MAAM,GAAGG,uBAAuB,CAAC3F,WAAD,EAAcqE,GAAd,EAAmBmB,MAAnB,EAA2BxB,KAAK,CAAC1D,eAAjC,CAAhC;AACH;;AACD,MAAI,CAAC0D,KAAK,CAAC7D,WAAX,EAAwB;AACpB;AACAqF,IAAAA,MAAM,GAAGI,gBAAgB,CAAC5F,WAAD,EAAcwF,MAAd,EAAsB,CAACxB,KAAK,CAAC9D,YAAP,IAAuB8D,KAAK,CAACjD,aAAnD,CAAzB;AACH;;AACD,SAAO,IAAIqE,uBAAJ,CAA4BpB,KAAK,CAAClE,yBAAlC,EAA6DkE,KAAK,CAACjE,8BAAnE,EAAmGC,WAAnG,EAAgHqE,GAAhH,EAAqHiB,aAArH,EAAoIE,MAApI,EAA4I1B,uBAA5I,EAAqKE,KAAK,CAAC5D,gBAA3K,EAA6L4D,KAAK,CAACzD,OAAnM,EAA4MyD,KAAK,CAACxD,kBAAlN,EAAsOwD,KAAK,CAAC7D,WAA5O,EAAyP6D,KAAK,CAACvD,UAA/P,EAA2QuD,KAAK,CAACtC,mBAAjR,EAAsSsC,KAAK,CAACnD,gBAA5S,EAA8TmD,KAAK,CAAClD,uBAApU,CAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAS2E,6BAAT,CAAuCD,MAAvC,EAA+CpF,gBAA/C,EAAiEiE,GAAjE,EAAsE;AAClE,MAAIwB,MAAM,GAAG,EAAb;AAAA,MAAiBC,SAAS,GAAG,CAA7B,CADkE,CAElE;;AACA,MAAI1F,gBAAgB,GAAG,CAAvB,EAA0B;AACtByF,IAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAagB,gBAAb,EAA+B,EAA/B,EAAmC,CAAnC,CAAtB;AACH;;AACD,OAAK,IAAI2F,UAAU,GAAG,CAAjB,EAAoBC,SAAS,GAAGR,MAAM,CAACS,QAAP,EAArC,EAAwDF,UAAU,GAAGC,SAArE,EAAgFD,UAAU,EAA1F,EAA8F;AAC1F,QAAM1G,QAAQ,GAAGmG,MAAM,CAACU,YAAP,CAAoBH,UAApB,CAAjB;;AACA,QAAI1G,QAAQ,IAAIe,gBAAhB,EAAkC;AAC9B;AACA;AACH;;AACD,QAAMd,IAAI,GAAGkG,MAAM,CAACW,YAAP,CAAoBJ,UAApB,CAAb;;AACA,QAAI1G,QAAQ,IAAIgF,GAAhB,EAAqB;AACjBwB,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaiF,GAAb,EAAkB/E,IAAlB,EAAwB,CAAxB,CAAtB;AACA;AACH;;AACDuG,IAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaC,QAAb,EAAuBC,IAAvB,EAA6B,CAA7B,CAAtB;AACH;;AACD,SAAOuG,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASD,gBAAT,CAA0B5F,WAA1B,EAAuCwF,MAAvC,EAA+CY,YAA/C,EAA6D;AACzD,MAAIC,iBAAiB,GAAG,CAAxB;AACA,MAAIR,MAAM,GAAG,EAAb;AAAA,MAAiBC,SAAS,GAAG,CAA7B;;AACA,MAAIM,YAAJ,EAAkB;AACd;AACA,SAAK,IAAIvE,CAAC,GAAG,CAAR,EAAWwC,GAAG,GAAGmB,MAAM,CAAC5D,MAA7B,EAAqCC,CAAC,GAAGwC,GAAzC,EAA8CxC,CAAC,EAA/C,EAAmD;AAC/C,UAAMyE,KAAK,GAAGd,MAAM,CAAC3D,CAAD,CAApB;AACA,UAAM0E,aAAa,GAAGD,KAAK,CAACjH,QAA5B;;AACA,UAAIgH,iBAAiB,GAAG;AAAG;AAAvB,QAAyCE,aAA7C,EAA4D;AACxD,YAAMC,SAAS,GAAGF,KAAK,CAAChH,IAAxB;AACA,YAAMmH,aAAa,GAAGH,KAAK,CAAC/G,QAA5B;AACA,YAAImH,eAAe,GAAG,CAAC,CAAvB;AACA,YAAIC,cAAc,GAAGN,iBAArB;;AACA,aAAK,IAAIO,CAAC,GAAGP,iBAAb,EAAgCO,CAAC,GAAGL,aAApC,EAAmDK,CAAC,EAApD,EAAwD;AACpD,cAAI5G,WAAW,CAAC6G,UAAZ,CAAuBD,CAAvB,MAA8B;AAAG;AAArC,YAAkD;AAC9CF,cAAAA,eAAe,GAAGE,CAAlB;AACH;;AACD,cAAIF,eAAe,KAAK,CAAC,CAArB,IAA0BE,CAAC,GAAGD,cAAJ,IAAsB;AAAG;AAAvD,YAAwE;AACpE;AACAd,cAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAasH,eAAe,GAAG,CAA/B,EAAkCF,SAAlC,EAA6CC,aAA7C,CAAtB;AACAE,cAAAA,cAAc,GAAGD,eAAe,GAAG,CAAnC;AACAA,cAAAA,eAAe,GAAG,CAAC,CAAnB;AACH;AACJ;;AACD,YAAIC,cAAc,KAAKJ,aAAvB,EAAsC;AAClCV,UAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAamH,aAAb,EAA4BC,SAA5B,EAAuCC,aAAvC,CAAtB;AACH;AACJ,OAnBD,MAoBK;AACDZ,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBQ,KAAtB;AACH;;AACDD,MAAAA,iBAAiB,GAAGE,aAApB;AACH;AACJ,GA9BD,MA+BK;AACD;AACA,SAAK,IAAI1E,EAAC,GAAG,CAAR,EAAWwC,KAAG,GAAGmB,MAAM,CAAC5D,MAA7B,EAAqCC,EAAC,GAAGwC,KAAzC,EAA8CxC,EAAC,EAA/C,EAAmD;AAC/C,UAAMyE,MAAK,GAAGd,MAAM,CAAC3D,EAAD,CAApB;AACA,UAAM0E,cAAa,GAAGD,MAAK,CAACjH,QAA5B;AACA,UAAIyH,IAAI,GAAIP,cAAa,GAAGF,iBAA5B;;AACA,UAAIS,IAAI,GAAG;AAAG;AAAd,QAA+B;AAC3B,cAAMN,UAAS,GAAGF,MAAK,CAAChH,IAAxB;AACA,cAAMmH,cAAa,GAAGH,MAAK,CAAC/G,QAA5B;AACA,cAAMwH,WAAW,GAAGzF,IAAI,CAAC0F,IAAL,CAAUF,IAAI,GAAG;AAAG;AAApB,WAApB;;AACA,eAAK,IAAIF,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGG,WAApB,EAAiCH,EAAC,EAAlC,EAAsC;AAClC,gBAAIK,aAAa,GAAGZ,iBAAiB,GAAIO,EAAC,GAAG;AAAG;AAAhD;AACAf,YAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAa6H,aAAb,EAA4BT,UAA5B,EAAuCC,cAAvC,CAAtB;AACH;;AACDZ,UAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAamH,cAAb,EAA4BC,UAA5B,EAAuCC,cAAvC,CAAtB;AACH,SATD,MAUK;AACDZ,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBQ,MAAtB;AACH;;AACDD,MAAAA,iBAAiB,GAAGE,cAApB;AACH;AACJ;;AACD,SAAOV,MAAP;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASH,sBAAT,CAAgC1B,KAAhC,EAAuChE,WAAvC,EAAoDqE,GAApD,EAAyDmB,MAAzD,EAAiE;AAC7D,MAAMvF,wBAAwB,GAAG+D,KAAK,CAAC/D,wBAAvC;AACA,MAAMG,gBAAgB,GAAG4D,KAAK,CAAC5D,gBAA/B;AACA,MAAMG,OAAO,GAAGyD,KAAK,CAACzD,OAAtB;AACA,MAAMC,kBAAkB,GAAGwD,KAAK,CAACxD,kBAAjC;AACA,MAAMV,yBAAyB,GAAGkE,KAAK,CAAClE,yBAAxC;AACA,MAAMoH,UAAU,GAAGlD,KAAK,CAAChD,gBAAzB;AACA,MAAMmG,YAAY,GAAInD,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAAnD;AACA,MAAMuG,YAAY,GAAIpD,KAAK,CAACnD,gBAAN,KAA2B;AAAE;AAAnD;AACA,MAAMwG,iCAAiC,GAAIrD,KAAK,CAACvC,gBAAN,KAA2BuC,KAAK,CAACvD,UAA5E;AACA,MAAIoF,MAAM,GAAG,EAAb;AAAA,MAAiBC,SAAS,GAAG,CAA7B;AACA,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIS,SAAS,GAAGhB,MAAM,CAACO,UAAD,CAAN,CAAmBzG,IAAnC;AACA,MAAIiH,aAAa,GAAGf,MAAM,CAACO,UAAD,CAAN,CAAmB1G,QAAvC;AACA,MAAMiI,YAAY,GAAG9B,MAAM,CAAC5D,MAA5B;AACA,MAAI2F,uBAAuB,GAAG,KAA9B;AACA,MAAIC,uBAAuB,GAAGxI,OAAO,CAACwI,uBAAR,CAAgCxH,WAAhC,CAA9B;AACA,MAAIyH,sBAAJ;;AACA,MAAID,uBAAuB,KAAK,CAAC,CAAjC,EAAoC;AAChCD,IAAAA,uBAAuB,GAAG,IAA1B;AACAC,IAAAA,uBAAuB,GAAGnD,GAA1B;AACAoD,IAAAA,sBAAsB,GAAGpD,GAAzB;AACH,GAJD,MAKK;AACDoD,IAAAA,sBAAsB,GAAGzI,OAAO,CAACyI,sBAAR,CAA+BzH,WAA/B,CAAzB;AACH;;AACD,MAAI0H,eAAe,GAAG,KAAtB;AACA,MAAIC,qBAAqB,GAAG,CAA5B;AACA,MAAIC,gBAAgB,GAAGV,UAAU,IAAIA,UAAU,CAACS,qBAAD,CAA/C;AACA,MAAIE,SAAS,GAAGrH,kBAAkB,GAAGD,OAArC;;AACA,OAAK,IAAIkC,SAAS,GAAGrC,gBAArB,EAAuCqC,SAAS,GAAG4B,GAAnD,EAAwD5B,SAAS,EAAjE,EAAqE;AACjE,QAAMqF,MAAM,GAAG9H,WAAW,CAAC6G,UAAZ,CAAuBpE,SAAvB,CAAf;;AACA,QAAImF,gBAAgB,IAAInF,SAAS,IAAImF,gBAAgB,CAACjI,SAAtD,EAAiE;AAC7DgI,MAAAA,qBAAqB;AACrBC,MAAAA,gBAAgB,GAAGV,UAAU,IAAIA,UAAU,CAACS,qBAAD,CAA3C;AACH;;AACD,QAAII,cAAc,SAAlB;;AACA,QAAItF,SAAS,GAAG+E,uBAAZ,IAAuC/E,SAAS,GAAGgF,sBAAvD,EAA+E;AAC3E;AACAM,MAAAA,cAAc,GAAG,IAAjB;AACH,KAHD,MAIK,IAAID,MAAM,KAAK;AAAE;AAAjB,MAA4B;AAC7B;AACAC,QAAAA,cAAc,GAAG,IAAjB;AACH,OAHI,MAIA,IAAID,MAAM,KAAK;AAAG;AAAlB,MAA+B;AAChC;AACA,YAAIX,YAAJ,EAAkB;AACd;AACA,cAAIO,eAAJ,EAAqB;AACjBK,YAAAA,cAAc,GAAG,IAAjB;AACH,WAFD,MAGK;AACD,gBAAMC,UAAU,GAAIvF,SAAS,GAAG,CAAZ,GAAgB4B,GAAhB,GAAsBrE,WAAW,CAAC6G,UAAZ,CAAuBpE,SAAS,GAAG,CAAnC,CAAtB,GAA8D;AAAE;AAApF;AACAsF,YAAAA,cAAc,GAAIC,UAAU,KAAK;AAAG;AAAlB,eAAiCA,UAAU,KAAK;AAAE;AAApE;AACH;AACJ,SATD,MAUK;AACDD,UAAAA,cAAc,GAAG,IAAjB;AACH;AACJ,OAfI,MAgBA;AACDA,MAAAA,cAAc,GAAG,KAAjB;AACH,KAjCgE,CAkCjE;;;AACA,QAAIA,cAAc,IAAIb,UAAtB,EAAkC;AAC9Ba,MAAAA,cAAc,GAAG,CAAC,CAACH,gBAAF,IAAsBA,gBAAgB,CAAClI,WAAjB,IAAgC+C,SAAtD,IAAmEmF,gBAAgB,CAACjI,SAAjB,GAA6B8C,SAAjH;AACH,KArCgE,CAsCjE;;;AACA,QAAIsF,cAAc,IAAIX,YAAtB,EAAoC;AAChCW,MAAAA,cAAc,GAAGR,uBAAuB,IAAI9E,SAAS,GAAGgF,sBAAxD;AACH;;AACD,QAAIC,eAAJ,EAAqB;AACjB;AACA,UAAI,CAACK,cAAD,IAAoB,CAACjI,yBAAD,IAA8B+H,SAAS,IAAItH,OAAnE,EAA6E;AACzE;AACA,YAAI8G,iCAAJ,EAAuC;AACnC,cAAMY,YAAY,GAAInC,SAAS,GAAG,CAAZ,GAAgBD,MAAM,CAACC,SAAS,GAAG,CAAb,CAAN,CAAsBzG,QAAtC,GAAiDe,gBAAvE;;AACA,eAAK,IAAIyB,CAAC,GAAGoG,YAAY,GAAG,CAA5B,EAA+BpG,CAAC,IAAIY,SAApC,EAA+CZ,CAAC,EAAhD,EAAoD;AAChDgE,YAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAayC,CAAb,EAAgB,MAAhB,EAAwB;AAAE;AAA1B,aAAtB;AACH;AACJ,SALD,MAMK;AACDgE,UAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaqD,SAAb,EAAwB,MAAxB,EAAgC;AAAE;AAAlC,WAAtB;AACH;;AACDoF,QAAAA,SAAS,GAAGA,SAAS,GAAGtH,OAAxB;AACH;AACJ,KAfD,MAgBK;AACD;AACA,UAAIkC,SAAS,KAAK8D,aAAd,IAAgCwB,cAAc,IAAItF,SAAS,GAAGrC,gBAAlE,EAAqF;AACjFyF,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaqD,SAAb,EAAwB+D,SAAxB,EAAmC,CAAnC,CAAtB;AACAqB,QAAAA,SAAS,GAAGA,SAAS,GAAGtH,OAAxB;AACH;AACJ;;AACD,QAAIuH,MAAM,KAAK;AAAE;AAAjB,MAA4B;AACxBD,QAAAA,SAAS,GAAGtH,OAAZ;AACH,OAFD,MAGK,IAAIvB,OAAO,CAACkJ,oBAAR,CAA6BJ,MAA7B,CAAJ,EAA0C;AAC3CD,MAAAA,SAAS,IAAI,CAAb;AACH,KAFI,MAGA;AACDA,MAAAA,SAAS;AACZ;;AACDH,IAAAA,eAAe,GAAGK,cAAlB;;AACA,WAAOtF,SAAS,KAAK8D,aAArB,EAAoC;AAChCR,MAAAA,UAAU;;AACV,UAAIA,UAAU,GAAGuB,YAAjB,EAA+B;AAC3Bd,QAAAA,SAAS,GAAGhB,MAAM,CAACO,UAAD,CAAN,CAAmBzG,IAA/B;AACAiH,QAAAA,aAAa,GAAGf,MAAM,CAACO,UAAD,CAAN,CAAmB1G,QAAnC;AACH;AACJ;AACJ;;AACD,MAAI8I,kBAAkB,GAAG,KAAzB;;AACA,MAAIT,eAAJ,EAAqB;AACjB;AACA,QAAIzH,wBAAwB,IAAIkH,YAAhC,EAA8C;AAC1C,UAAIiB,YAAY,GAAI/D,GAAG,GAAG,CAAN,GAAUrE,WAAW,CAAC6G,UAAZ,CAAuBxC,GAAG,GAAG,CAA7B,CAAV,GAA4C;AAAE;AAAlE;AACA,UAAIgE,YAAY,GAAIhE,GAAG,GAAG,CAAN,GAAUrE,WAAW,CAAC6G,UAAZ,CAAuBxC,GAAG,GAAG,CAA7B,CAAV,GAA4C;AAAE;AAAlE;AACA,UAAIiE,qBAAqB,GAAIF,YAAY,KAAK;AAAG;AAApB,SAAoCC,YAAY,KAAK;AAAG;AAApB,SAAmCA,YAAY,KAAK;AAAE;AAAvH;;AACA,UAAI,CAACC,qBAAL,EAA4B;AACxBH,QAAAA,kBAAkB,GAAG,IAArB;AACH;AACJ,KAPD,MAQK;AACDA,MAAAA,kBAAkB,GAAG,IAArB;AACH;AACJ;;AACD,MAAIA,kBAAJ,EAAwB;AACpB,QAAId,iCAAJ,EAAuC;AACnC,UAAMY,aAAY,GAAInC,SAAS,GAAG,CAAZ,GAAgBD,MAAM,CAACC,SAAS,GAAG,CAAb,CAAN,CAAsBzG,QAAtC,GAAiDe,gBAAvE;;AACA,WAAK,IAAIyB,GAAC,GAAGoG,aAAY,GAAG,CAA5B,EAA+BpG,GAAC,IAAIwC,GAApC,EAAyCxC,GAAC,EAA1C,EAA8C;AAC1CgE,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAayC,GAAb,EAAgB,MAAhB,EAAwB;AAAE;AAA1B,SAAtB;AACH;AACJ,KALD,MAMK;AACDgE,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaiF,GAAb,EAAkB,MAAlB,EAA0B;AAAE;AAA5B,OAAtB;AACH;AACJ,GAVD,MAWK;AACDwB,IAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAaiF,GAAb,EAAkBmC,SAAlB,EAA6B,CAA7B,CAAtB;AACH;;AACD,SAAOX,MAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAASF,uBAAT,CAAiC3F,WAAjC,EAA8CqE,GAA9C,EAAmDmB,MAAnD,EAA2D+C,gBAA3D,EAA6E;AACzEA,EAAAA,gBAAgB,CAACtH,IAAjB,CAAsB/B,cAAc,CAACgC,OAArC;;AACA,MAAMZ,eAAe,GAAGnB,yBAAyB,CAACqJ,SAA1B,CAAoCxI,WAApC,EAAiDuI,gBAAjD,CAAxB;AACA,MAAME,kBAAkB,GAAGnI,eAAe,CAACsB,MAA3C;AACA,MAAI8G,mBAAmB,GAAG,CAA1B;AACA,MAAI7C,MAAM,GAAG,EAAb;AAAA,MAAiBC,SAAS,GAAG,CAA7B;AAAA,MAAgC6C,kBAAkB,GAAG,CAArD;;AACA,OAAK,IAAI5C,UAAU,GAAG,CAAjB,EAAoB1B,KAAG,GAAGmB,MAAM,CAAC5D,MAAtC,EAA8CmE,UAAU,GAAG1B,KAA3D,EAAgE0B,UAAU,EAA1E,EAA8E;AAC1E,QAAMO,KAAK,GAAGd,MAAM,CAACO,UAAD,CAApB;AACA,QAAMQ,aAAa,GAAGD,KAAK,CAACjH,QAA5B;AACA,QAAMmH,SAAS,GAAGF,KAAK,CAAChH,IAAxB;AACA,QAAMmH,aAAa,GAAGH,KAAK,CAAC/G,QAA5B;;AACA,WAAOmJ,mBAAmB,GAAGD,kBAAtB,IAA4CnI,eAAe,CAACoI,mBAAD,CAAf,CAAqChJ,WAArC,GAAmD6G,aAAtG,EAAqH;AACjH,UAAMjC,cAAc,GAAGhE,eAAe,CAACoI,mBAAD,CAAtC;;AACA,UAAIpE,cAAc,CAAC5E,WAAf,GAA6BiJ,kBAAjC,EAAqD;AACjDA,QAAAA,kBAAkB,GAAGrE,cAAc,CAAC5E,WAApC;AACAmG,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAauJ,kBAAb,EAAiCnC,SAAjC,EAA4CC,aAA5C,CAAtB;AACH;;AACD,UAAInC,cAAc,CAAC3E,SAAf,GAA2B,CAA3B,IAAgC4G,aAApC,EAAmD;AAC/C;AACAoC,QAAAA,kBAAkB,GAAGrE,cAAc,CAAC3E,SAAf,GAA2B,CAAhD;AACAkG,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAauJ,kBAAb,EAAiCnC,SAAS,GAAG,GAAZ,GAAkBlC,cAAc,CAACE,SAAlE,EAA6EiC,aAAa,GAAGnC,cAAc,CAAC/E,QAA5G,CAAtB;AACAmJ,QAAAA,mBAAmB;AACtB,OALD,MAMK;AACD;AACAC,QAAAA,kBAAkB,GAAGpC,aAArB;AACAV,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAauJ,kBAAb,EAAiCnC,SAAS,GAAG,GAAZ,GAAkBlC,cAAc,CAACE,SAAlE,EAA6EiC,aAAa,GAAGnC,cAAc,CAAC/E,QAA5G,CAAtB;AACA;AACH;AACJ;;AACD,QAAIgH,aAAa,GAAGoC,kBAApB,EAAwC;AACpCA,MAAAA,kBAAkB,GAAGpC,aAArB;AACAV,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAauJ,kBAAb,EAAiCnC,SAAjC,EAA4CC,aAA5C,CAAtB;AACH;AACJ;;AACD,MAAMJ,iBAAiB,GAAGb,MAAM,CAACA,MAAM,CAAC5D,MAAP,GAAgB,CAAjB,CAAN,CAA0BvC,QAApD;;AACA,MAAIqJ,mBAAmB,GAAGD,kBAAtB,IAA4CnI,eAAe,CAACoI,mBAAD,CAAf,CAAqChJ,WAArC,KAAqD2G,iBAArG,EAAwH;AACpH,QAAIuC,UAAU,GAAG,EAAjB;AACA,QAAIrJ,QAAQ,GAAG,CAAf;;AACA,WAAOmJ,mBAAmB,GAAGD,kBAAtB,IAA4CnI,eAAe,CAACoI,mBAAD,CAAf,CAAqChJ,WAArC,KAAqD2G,iBAAxG,EAA2H;AACvHuC,MAAAA,UAAU,CAACrE,IAAX,CAAgBjE,eAAe,CAACoI,mBAAD,CAAf,CAAqClE,SAArD;AACAjF,MAAAA,QAAQ,IAAIe,eAAe,CAACoI,mBAAD,CAAf,CAAqCnJ,QAAjD;AACAmJ,MAAAA,mBAAmB;AACtB;;AACD7C,IAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsB,IAAI1G,QAAJ,CAAauJ,kBAAb,EAAiCC,UAAU,CAAClE,IAAX,CAAgB,GAAhB,CAAjC,EAAuDnF,QAAvD,CAAtB;AACH;;AACD,SAAOsG,MAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,SAAShB,WAAT,CAAqBb,KAArB,EAA4BC,EAA5B,EAAgC;AAC5B,MAAMoB,eAAe,GAAGrB,KAAK,CAACqB,eAA9B;AACA,MAAMtF,8BAA8B,GAAGiE,KAAK,CAACjE,8BAA7C;AACA,MAAM+D,uBAAuB,GAAGE,KAAK,CAACF,uBAAtC;AACA,MAAM9D,WAAW,GAAGgE,KAAK,CAAChE,WAA1B;AACA,MAAMqE,GAAG,GAAGL,KAAK,CAACK,GAAlB;AACA,MAAMiB,aAAa,GAAGtB,KAAK,CAACsB,aAA5B;AACA,MAAMC,KAAK,GAAGvB,KAAK,CAACuB,KAApB;AACA,MAAMnF,gBAAgB,GAAG4D,KAAK,CAAC5D,gBAA/B;AACA,MAAMG,OAAO,GAAGyD,KAAK,CAACzD,OAAtB;AACA,MAAMC,kBAAkB,GAAGwD,KAAK,CAACxD,kBAAjC;AACA,MAAML,WAAW,GAAG6D,KAAK,CAAC7D,WAA1B;AACA,MAAMM,UAAU,GAAGuD,KAAK,CAACvD,UAAzB;AACA,MAAMiB,mBAAmB,GAAGsC,KAAK,CAACtC,mBAAlC;AACA,MAAMb,gBAAgB,GAAGmD,KAAK,CAACnD,gBAA/B;AACA,MAAMC,uBAAuB,GAAGkD,KAAK,CAAClD,uBAAtC;AACA,MAAM+C,gBAAgB,GAAG,IAAI3B,gBAAJ,CAAqBmC,GAAG,GAAG,CAA3B,EAA8BkB,KAAK,CAAC3D,MAApC,CAAzB;AACA,MAAIa,SAAS,GAAG,CAAhB;AACA,MAAIoG,aAAa,GAAGrI,kBAApB;AACA,MAAIsI,gBAAgB,GAAG,CAAvB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AACA,MAAIC,kBAAkB,GAAG,CAAzB;AACA,MAAItG,kBAAkB,GAAG,CAAzB;;AACA,MAAIvC,WAAJ,EAAiB;AACb8D,IAAAA,EAAE,CAACW,iBAAH,CAAqB,kBAArB;AACH,GAFD,MAGK;AACDX,IAAAA,EAAE,CAACW,iBAAH,CAAqB,QAArB;AACH;;AACD,OAAK,IAAIpC,SAAS,GAAG,CAAhB,EAAmBwD,SAAS,GAAGT,KAAK,CAAC3D,MAA1C,EAAkDY,SAAS,GAAGwD,SAA9D,EAAyExD,SAAS,EAAlF,EAAsF;AAClFE,IAAAA,kBAAkB,IAAIsG,kBAAtB;AACA,QAAMC,IAAI,GAAG1D,KAAK,CAAC/C,SAAD,CAAlB;AACA,QAAM0G,YAAY,GAAGD,IAAI,CAAC5J,QAA1B;AACA,QAAM8J,QAAQ,GAAGF,IAAI,CAAC3J,IAAtB;AACA,QAAM8J,qBAAqB,GAAIvI,gBAAgB,KAAK;AAAE;AAAvB,OAAqCoI,IAAI,CAACI,YAAL,EAApE;AACA,QAAMC,8BAA8B,GAAGF,qBAAqB,IAAI,CAAC/D,eAA1B,KAA8C8D,QAAQ,KAAK;AAAO;AAApB,OAA2C,CAACrF,uBAA1F,CAAvC;AACA,QAAMyF,4BAA4B,GAAI9G,SAAS,KAAKyG,YAAd,IAA8BD,IAAI,CAAC1J,QAAL,KAAkB;AAAE;AAAxF;AACAuJ,IAAAA,gBAAgB,GAAG,CAAnB;AACA7E,IAAAA,EAAE,CAACW,iBAAH,CAAqB,eAArB;AACAX,IAAAA,EAAE,CAACW,iBAAH,CAAqB0E,8BAA8B,GAAG,MAAH,GAAYH,QAA/D;AACAlF,IAAAA,EAAE,CAACuF,WAAH,CAAe;AAAG;AAAlB;;AACA,QAAIJ,qBAAJ,EAA2B;AACvB,UAAIK,cAAc,GAAG,CAArB;AACA;AACI,YAAIC,UAAU,GAAGjH,SAAjB;AACA,YAAIkH,cAAc,GAAGd,aAArB;;AACA,eAAOa,UAAU,GAAGR,YAApB,EAAkCQ,UAAU,EAA5C,EAAgD;AAC5C,cAAME,QAAQ,GAAG5J,WAAW,CAAC6G,UAAZ,CAAuB6C,UAAvB,CAAjB;AACA,cAAMG,SAAS,GAAG,CAACD,QAAQ,KAAK;AAAE;AAAf,YAA4BrJ,OAAO,GAAIoJ,cAAc,GAAGpJ,OAAxD,GAAoE,CAArE,IAA0E,CAA5F;AACAkJ,UAAAA,cAAc,IAAII,SAAlB;;AACA,cAAIH,UAAU,IAAItJ,gBAAlB,EAAoC;AAChCuJ,YAAAA,cAAc,IAAIE,SAAlB;AACH;AACJ;AACJ;;AACD,UAAIP,8BAAJ,EAAoC;AAChCrF,QAAAA,EAAE,CAACW,iBAAH,CAAqB,gBAArB;AACAX,QAAAA,EAAE,CAACW,iBAAH,CAAqBkF,MAAM,CAACrJ,UAAU,GAAGgJ,cAAd,CAA3B;AACAxF,QAAAA,EAAE,CAACW,iBAAH,CAAqB,KAArB;AACH;;AACDX,MAAAA,EAAE,CAACuF,WAAH,CAAe;AAAG;AAAlB;;AACA,aAAO/G,SAAS,GAAGyG,YAAnB,EAAiCzG,SAAS,EAA1C,EAA8C;AAC1CoB,QAAAA,gBAAgB,CAACkG,WAAjB,CAA6BtH,SAA7B,EAAwCD,SAAS,GAAGuG,gBAApD,EAAsED,gBAAtE,EAAwFpG,kBAAxF;AACAqG,QAAAA,gBAAgB,GAAG,CAAnB;;AACA,YAAMa,SAAQ,GAAG5J,WAAW,CAAC6G,UAAZ,CAAuBpE,SAAvB,CAAjB;;AACA,YAAIoH,UAAS,SAAb;;AACA,YAAID,SAAQ,KAAK;AAAE;AAAnB,UAA8B;AAC1BC,YAAAA,UAAS,GAAItJ,OAAO,GAAIsI,aAAa,GAAGtI,OAA5B,GAAwC,CAApD;;AACA,gBAAI,CAACR,8BAAD,IAAmC8J,UAAS,GAAG,CAAnD,EAAsD;AAClD5F,cAAAA,EAAE,CAAC+F,MAAH,CAAU,MAAV,EADkD,CAC/B;AACtB,aAFD,MAGK;AACD/F,cAAAA,EAAE,CAAC+F,MAAH,CAAU,MAAV,EADC,CACkB;AACtB;;AACD,iBAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,IAAIJ,UAA7B,EAAwCI,KAAK,EAA7C,EAAiD;AAC7ChG,cAAAA,EAAE,CAAC+F,MAAH,CAAU,IAAV,EAD6C,CAC5B;AACpB;AACJ,WAXD,MAYK;AAAE;AACHH,UAAAA,UAAS,GAAG,CAAZ;AACA5F,UAAAA,EAAE,CAAC+F,MAAH,CAAUtI,mBAAV,EAFC,CAE+B;AACnC;;AACDoH,QAAAA,gBAAgB,IAAIe,UAApB;;AACA,YAAIpH,SAAS,IAAIrC,gBAAjB,EAAmC;AAC/ByI,UAAAA,aAAa,IAAIgB,UAAjB;AACH;AACJ;;AACDb,MAAAA,kBAAkB,GAAGS,cAArB;AACH,KA/CD,MAgDK;AACD,UAAIA,eAAc,GAAG,CAArB;AACAxF,MAAAA,EAAE,CAACuF,WAAH,CAAe;AAAG;AAAlB;;AACA,aAAO/G,SAAS,GAAGyG,YAAnB,EAAiCzG,SAAS,EAA1C,EAA8C;AAC1CoB,QAAAA,gBAAgB,CAACkG,WAAjB,CAA6BtH,SAA7B,EAAwCD,SAAS,GAAGuG,gBAApD,EAAsED,gBAAtE,EAAwFpG,kBAAxF;AACAqG,QAAAA,gBAAgB,GAAG,CAAnB;;AACA,YAAMa,UAAQ,GAAG5J,WAAW,CAAC6G,UAAZ,CAAuBpE,SAAvB,CAAjB;;AACA,YAAIyH,kBAAkB,GAAG,CAAzB;AACA,YAAIL,WAAS,GAAG,CAAhB;;AACA,gBAAQD,UAAR;AACI,eAAK;AAAE;AAAP;AACIM,YAAAA,kBAAkB,GAAI3J,OAAO,GAAIsI,aAAa,GAAGtI,OAAjD;AACAsJ,YAAAA,WAAS,GAAGK,kBAAZ;;AACA,iBAAK,IAAID,MAAK,GAAG,CAAjB,EAAoBA,MAAK,IAAIC,kBAA7B,EAAiDD,MAAK,EAAtD,EAA0D;AACtDhG,cAAAA,EAAE,CAAC+F,MAAH,CAAU,IAAV,EADsD,CACrC;AACpB;;AACD;;AACJ,eAAK;AAAG;AAAR;AACI/F,YAAAA,EAAE,CAAC+F,MAAH,CAAU,IAAV,EADJ,CACqB;;AACjB;;AACJ,eAAK;AAAG;AAAR;AACI/F,YAAAA,EAAE,CAACW,iBAAH,CAAqB,MAArB;AACA;;AACJ,eAAK;AAAG;AAAR;AACIX,YAAAA,EAAE,CAACW,iBAAH,CAAqB,MAArB;AACA;;AACJ,eAAK;AAAG;AAAR;AACIX,YAAAA,EAAE,CAACW,iBAAH,CAAqB,OAArB;AACA;;AACJ,eAAK;AAAE;AAAP;AACIX,YAAAA,EAAE,CAACW,iBAAH,CAAqB,OAArB;AACA;;AACJ,eAAK;AAAM;AAAX;AACA,eAAK;AAAK;AAAV;AACA,eAAK;AAAK;AAAV;AACA,eAAK;AAAI;AAAT;AACIX,YAAAA,EAAE,CAAC+F,MAAH,CAAU,MAAV;AACA;;AACJ;AACI,gBAAIhL,OAAO,CAACkJ,oBAAR,CAA6B0B,UAA7B,CAAJ,EAA4C;AACxCC,cAAAA,WAAS;AACZ;;AACD,gBAAI/I,uBAAuB,IAAI8I,UAAQ,GAAG,EAA1C,EAA8C;AAC1C3F,cAAAA,EAAE,CAAC+F,MAAH,CAAU,OAAOJ,UAAjB;AACH,aAFD,MAGK;AACD3F,cAAAA,EAAE,CAAC+F,MAAH,CAAUJ,UAAV;AACH;;AAtCT;;AAwCAd,QAAAA,gBAAgB,IAAIoB,kBAApB;AACAT,QAAAA,eAAc,IAAIS,kBAAlB;;AACA,YAAIzH,SAAS,IAAIrC,gBAAjB,EAAmC;AAC/ByI,UAAAA,aAAa,IAAIgB,WAAjB;AACH;AACJ;;AACDb,MAAAA,kBAAkB,GAAGS,eAArB;AACH;;AACD,QAAIF,4BAAJ,EAAkC;AAC9BR,MAAAA,gBAAgB;AACnB,KAFD,MAGK;AACDA,MAAAA,gBAAgB,GAAG,CAAnB;AACH;;AACD9E,IAAAA,EAAE,CAACW,iBAAH,CAAqB,SAArB;AACH,GAzJ2B,CA0J5B;AACA;;;AACAf,EAAAA,gBAAgB,CAACkG,WAAjB,CAA6B1F,GAA7B,EAAkCkB,KAAK,CAAC3D,MAAN,GAAe,CAAjD,EAAoDkH,gBAApD,EAAsEpG,kBAAtE;;AACA,MAAI4C,aAAJ,EAAmB;AACfrB,IAAAA,EAAE,CAACW,iBAAH,CAAqB,uBAArB;AACH;;AACDX,EAAAA,EAAE,CAACW,iBAAH,CAAqB,SAArB;AACA,SAAO,IAAIhB,gBAAJ,CAAqBC,gBAArB,EAAuC1D,WAAvC,EAAoD2D,uBAApD,CAAP;AACH","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { createStringBuilder } from '../core/stringBuilder.js';\r\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\r\nclass LinePart {\r\n    constructor(endIndex, type, metadata) {\r\n        this.endIndex = endIndex;\r\n        this.type = type;\r\n        this.metadata = metadata;\r\n    }\r\n    isWhitespace() {\r\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\r\n    }\r\n}\r\nexport class LineRange {\r\n    constructor(startIndex, endIndex) {\r\n        this.startOffset = startIndex;\r\n        this.endOffset = endIndex;\r\n    }\r\n    equals(otherLineRange) {\r\n        return this.startOffset === otherLineRange.startOffset\r\n            && this.endOffset === otherLineRange.endOffset;\r\n    }\r\n}\r\nexport class RenderLineInput {\r\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\r\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\r\n        this.isBasicASCII = isBasicASCII;\r\n        this.containsRTL = containsRTL;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.lineTokens = lineTokens;\r\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.spaceWidth = spaceWidth;\r\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\r\n        this.renderWhitespace = (renderWhitespace === 'all'\r\n            ? 4 /* All */\r\n            : renderWhitespace === 'boundary'\r\n                ? 1 /* Boundary */\r\n                : renderWhitespace === 'selection'\r\n                    ? 2 /* Selection */\r\n                    : renderWhitespace === 'trailing'\r\n                        ? 3 /* Trailing */\r\n                        : 0 /* None */);\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        this.fontLigatures = fontLigatures;\r\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\r\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\r\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\r\n        if (wsmiddotDiff < middotDiff) {\r\n            this.renderSpaceWidth = wsmiddotWidth;\r\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\r\n        }\r\n        else {\r\n            this.renderSpaceWidth = middotWidth;\r\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\r\n        }\r\n    }\r\n    sameSelection(otherSelections) {\r\n        if (this.selectionsOnLine === null) {\r\n            return otherSelections === null;\r\n        }\r\n        if (otherSelections === null) {\r\n            return false;\r\n        }\r\n        if (otherSelections.length !== this.selectionsOnLine.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\r\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    equals(other) {\r\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\r\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\r\n            && this.lineContent === other.lineContent\r\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\r\n            && this.isBasicASCII === other.isBasicASCII\r\n            && this.containsRTL === other.containsRTL\r\n            && this.fauxIndentLength === other.fauxIndentLength\r\n            && this.tabSize === other.tabSize\r\n            && this.startVisibleColumn === other.startVisibleColumn\r\n            && this.spaceWidth === other.spaceWidth\r\n            && this.renderSpaceWidth === other.renderSpaceWidth\r\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\r\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\r\n            && this.renderWhitespace === other.renderWhitespace\r\n            && this.renderControlCharacters === other.renderControlCharacters\r\n            && this.fontLigatures === other.fontLigatures\r\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\r\n            && this.lineTokens.equals(other.lineTokens)\r\n            && this.sameSelection(other.selectionsOnLine));\r\n    }\r\n}\r\n/**\r\n * Provides a both direction mapping between a line's character and its rendered position.\r\n */\r\nexport class CharacterMapping {\r\n    constructor(length, partCount) {\r\n        this.length = length;\r\n        this._data = new Uint32Array(this.length);\r\n        this._absoluteOffsets = new Uint32Array(this.length);\r\n    }\r\n    static getPartIndex(partData) {\r\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\r\n    }\r\n    static getCharIndex(partData) {\r\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\r\n    }\r\n    setPartData(charOffset, partIndex, charIndex, partAbsoluteOffset) {\r\n        let partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        this._data[charOffset] = partData;\r\n        this._absoluteOffsets[charOffset] = partAbsoluteOffset + charIndex;\r\n    }\r\n    getAbsoluteOffsets() {\r\n        return this._absoluteOffsets;\r\n    }\r\n    charOffsetToPartData(charOffset) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        if (charOffset < 0) {\r\n            return this._data[0];\r\n        }\r\n        if (charOffset >= this.length) {\r\n            return this._data[this.length - 1];\r\n        }\r\n        return this._data[charOffset];\r\n    }\r\n    partDataToCharOffset(partIndex, partLength, charIndex) {\r\n        if (this.length === 0) {\r\n            return 0;\r\n        }\r\n        let searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\r\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\r\n        let min = 0;\r\n        let max = this.length - 1;\r\n        while (min + 1 < max) {\r\n            let mid = ((min + max) >>> 1);\r\n            let midEntry = this._data[mid];\r\n            if (midEntry === searchEntry) {\r\n                return mid;\r\n            }\r\n            else if (midEntry > searchEntry) {\r\n                max = mid;\r\n            }\r\n            else {\r\n                min = mid;\r\n            }\r\n        }\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        let minEntry = this._data[min];\r\n        let maxEntry = this._data[max];\r\n        if (minEntry === searchEntry) {\r\n            return min;\r\n        }\r\n        if (maxEntry === searchEntry) {\r\n            return max;\r\n        }\r\n        let minPartIndex = CharacterMapping.getPartIndex(minEntry);\r\n        let minCharIndex = CharacterMapping.getCharIndex(minEntry);\r\n        let maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\r\n        let maxCharIndex;\r\n        if (minPartIndex !== maxPartIndex) {\r\n            // sitting between parts\r\n            maxCharIndex = partLength;\r\n        }\r\n        else {\r\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\r\n        }\r\n        let minEntryDistance = charIndex - minCharIndex;\r\n        let maxEntryDistance = maxCharIndex - charIndex;\r\n        if (minEntryDistance <= maxEntryDistance) {\r\n            return min;\r\n        }\r\n        return max;\r\n    }\r\n}\r\nexport class RenderLineOutput {\r\n    constructor(characterMapping, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n}\r\nexport function renderViewLine(input, sb) {\r\n    if (input.lineContent.length === 0) {\r\n        let containsForeignElements = 0 /* None */;\r\n        let content = '<span><span></span></span>';\r\n        if (input.lineDecorations.length > 0) {\r\n            // This line is empty, but it contains inline decorations\r\n            const beforeClassNames = [];\r\n            const afterClassNames = [];\r\n            for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n                const lineDecoration = input.lineDecorations[i];\r\n                if (lineDecoration.type === 1 /* Before */) {\r\n                    beforeClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 1 /* Before */;\r\n                }\r\n                if (lineDecoration.type === 2 /* After */) {\r\n                    afterClassNames.push(input.lineDecorations[i].className);\r\n                    containsForeignElements |= 2 /* After */;\r\n                }\r\n            }\r\n            if (containsForeignElements !== 0 /* None */) {\r\n                const beforeSpan = (beforeClassNames.length > 0 ? `<span class=\"${beforeClassNames.join(' ')}\"></span>` : ``);\r\n                const afterSpan = (afterClassNames.length > 0 ? `<span class=\"${afterClassNames.join(' ')}\"></span>` : ``);\r\n                content = `<span>${beforeSpan}${afterSpan}</span>`;\r\n            }\r\n        }\r\n        sb.appendASCIIString(content);\r\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, containsForeignElements);\r\n    }\r\n    return _renderLine(resolveRenderLineInput(input), sb);\r\n}\r\nexport class RenderLineOutput2 {\r\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\r\n        this.characterMapping = characterMapping;\r\n        this.html = html;\r\n        this.containsRTL = containsRTL;\r\n        this.containsForeignElements = containsForeignElements;\r\n    }\r\n}\r\nexport function renderViewLine2(input) {\r\n    let sb = createStringBuilder(10000);\r\n    let out = renderViewLine(input, sb);\r\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\r\n}\r\nclass ResolvedRenderLineInput {\r\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\r\n        this.fontIsMonospace = fontIsMonospace;\r\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\r\n        this.lineContent = lineContent;\r\n        this.len = len;\r\n        this.isOverflowing = isOverflowing;\r\n        this.parts = parts;\r\n        this.containsForeignElements = containsForeignElements;\r\n        this.fauxIndentLength = fauxIndentLength;\r\n        this.tabSize = tabSize;\r\n        this.startVisibleColumn = startVisibleColumn;\r\n        this.containsRTL = containsRTL;\r\n        this.spaceWidth = spaceWidth;\r\n        this.renderSpaceCharCode = renderSpaceCharCode;\r\n        this.renderWhitespace = renderWhitespace;\r\n        this.renderControlCharacters = renderControlCharacters;\r\n        //\r\n    }\r\n}\r\nfunction resolveRenderLineInput(input) {\r\n    const lineContent = input.lineContent;\r\n    let isOverflowing;\r\n    let len;\r\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\r\n        isOverflowing = true;\r\n        len = input.stopRenderingLineAfter;\r\n    }\r\n    else {\r\n        isOverflowing = false;\r\n        len = lineContent.length;\r\n    }\r\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\r\n    if (input.renderWhitespace === 4 /* All */ ||\r\n        input.renderWhitespace === 1 /* Boundary */ ||\r\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\r\n        input.renderWhitespace === 3 /* Trailing */) {\r\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\r\n    }\r\n    let containsForeignElements = 0 /* None */;\r\n    if (input.lineDecorations.length > 0) {\r\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\r\n            const lineDecoration = input.lineDecorations[i];\r\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\r\n                // Pretend there are foreign elements... although not 100% accurate.\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 1 /* Before */) {\r\n                containsForeignElements |= 1 /* Before */;\r\n            }\r\n            else if (lineDecoration.type === 2 /* After */) {\r\n                containsForeignElements |= 2 /* After */;\r\n            }\r\n        }\r\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\r\n    }\r\n    if (!input.containsRTL) {\r\n        // We can never split RTL text, as it ruins the rendering\r\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\r\n    }\r\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\r\n}\r\n/**\r\n * In the rendering phase, characters are always looped until token.endIndex.\r\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\r\n */\r\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\r\n    let result = [], resultLen = 0;\r\n    // The faux indent part of the line should have no token type\r\n    if (fauxIndentLength > 0) {\r\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\r\n    }\r\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n        const endIndex = tokens.getEndOffset(tokenIndex);\r\n        if (endIndex <= fauxIndentLength) {\r\n            // The faux indent part of the line should have no token type\r\n            continue;\r\n        }\r\n        const type = tokens.getClassName(tokenIndex);\r\n        if (endIndex >= len) {\r\n            result[resultLen++] = new LinePart(len, type, 0);\r\n            break;\r\n        }\r\n        result[resultLen++] = new LinePart(endIndex, type, 0);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * See https://github.com/microsoft/vscode/issues/6885.\r\n * It appears that having very large spans causes very slow reading of character positions.\r\n * So here we try to avoid that.\r\n */\r\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\r\n    let lastTokenEndIndex = 0;\r\n    let result = [], resultLen = 0;\r\n    if (onlyAtSpaces) {\r\n        // Split only at spaces => we need to walk each character\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const token = tokens[i];\r\n            const tokenEndIndex = token.endIndex;\r\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\r\n                const tokenType = token.type;\r\n                const tokenMetadata = token.metadata;\r\n                let lastSpaceOffset = -1;\r\n                let currTokenStart = lastTokenEndIndex;\r\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\r\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\r\n                        lastSpaceOffset = j;\r\n                    }\r\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\r\n                        // Split at `lastSpaceOffset` + 1\r\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\r\n                        currTokenStart = lastSpaceOffset + 1;\r\n                        lastSpaceOffset = -1;\r\n                    }\r\n                }\r\n                if (currTokenStart !== tokenEndIndex) {\r\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\r\n                }\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    else {\r\n        // Split anywhere => we don't need to walk each character\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const token = tokens[i];\r\n            const tokenEndIndex = token.endIndex;\r\n            let diff = (tokenEndIndex - lastTokenEndIndex);\r\n            if (diff > 50 /* LongToken */) {\r\n                const tokenType = token.type;\r\n                const tokenMetadata = token.metadata;\r\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\r\n                for (let j = 1; j < piecesCount; j++) {\r\n                    let pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\r\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\r\n                }\r\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\r\n            }\r\n            else {\r\n                result[resultLen++] = token;\r\n            }\r\n            lastTokenEndIndex = tokenEndIndex;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\r\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\r\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\r\n */\r\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\r\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\r\n    const fauxIndentLength = input.fauxIndentLength;\r\n    const tabSize = input.tabSize;\r\n    const startVisibleColumn = input.startVisibleColumn;\r\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\r\n    const selections = input.selectionsOnLine;\r\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\r\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\r\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\r\n    let result = [], resultLen = 0;\r\n    let tokenIndex = 0;\r\n    let tokenType = tokens[tokenIndex].type;\r\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\r\n    const tokensLength = tokens.length;\r\n    let lineIsEmptyOrWhitespace = false;\r\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n    let lastNonWhitespaceIndex;\r\n    if (firstNonWhitespaceIndex === -1) {\r\n        lineIsEmptyOrWhitespace = true;\r\n        firstNonWhitespaceIndex = len;\r\n        lastNonWhitespaceIndex = len;\r\n    }\r\n    else {\r\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\r\n    }\r\n    let wasInWhitespace = false;\r\n    let currentSelectionIndex = 0;\r\n    let currentSelection = selections && selections[currentSelectionIndex];\r\n    let tmpIndent = startVisibleColumn % tabSize;\r\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\r\n        const chCode = lineContent.charCodeAt(charIndex);\r\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\r\n            currentSelectionIndex++;\r\n            currentSelection = selections && selections[currentSelectionIndex];\r\n        }\r\n        let isInWhitespace;\r\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\r\n            // in leading or trailing whitespace\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 9 /* Tab */) {\r\n            // a tab character is rendered both in all and boundary cases\r\n            isInWhitespace = true;\r\n        }\r\n        else if (chCode === 32 /* Space */) {\r\n            // hit a space character\r\n            if (onlyBoundary) {\r\n                // rendering only boundary whitespace\r\n                if (wasInWhitespace) {\r\n                    isInWhitespace = true;\r\n                }\r\n                else {\r\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\r\n                }\r\n            }\r\n            else {\r\n                isInWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            isInWhitespace = false;\r\n        }\r\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\r\n        if (isInWhitespace && selections) {\r\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\r\n        }\r\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\r\n        if (isInWhitespace && onlyTrailing) {\r\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\r\n        }\r\n        if (wasInWhitespace) {\r\n            // was in whitespace token\r\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\r\n                // leaving whitespace token or entering a new indent\r\n                if (generateLinePartForEachWhitespace) {\r\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\r\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\r\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\r\n                    }\r\n                }\r\n                else {\r\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\r\n                }\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        else {\r\n            // was in regular token\r\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\r\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\r\n                tmpIndent = tmpIndent % tabSize;\r\n            }\r\n        }\r\n        if (chCode === 9 /* Tab */) {\r\n            tmpIndent = tabSize;\r\n        }\r\n        else if (strings.isFullWidthCharacter(chCode)) {\r\n            tmpIndent += 2;\r\n        }\r\n        else {\r\n            tmpIndent++;\r\n        }\r\n        wasInWhitespace = isInWhitespace;\r\n        while (charIndex === tokenEndIndex) {\r\n            tokenIndex++;\r\n            if (tokenIndex < tokensLength) {\r\n                tokenType = tokens[tokenIndex].type;\r\n                tokenEndIndex = tokens[tokenIndex].endIndex;\r\n            }\r\n        }\r\n    }\r\n    let generateWhitespace = false;\r\n    if (wasInWhitespace) {\r\n        // was in whitespace token\r\n        if (continuesWithWrappedLine && onlyBoundary) {\r\n            let lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\r\n            let prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\r\n            let isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\r\n            if (!isSingleTrailingSpace) {\r\n                generateWhitespace = true;\r\n            }\r\n        }\r\n        else {\r\n            generateWhitespace = true;\r\n        }\r\n    }\r\n    if (generateWhitespace) {\r\n        if (generateLinePartForEachWhitespace) {\r\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\r\n            for (let i = lastEndIndex + 1; i <= len; i++) {\r\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\r\n            }\r\n        }\r\n        else {\r\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\r\n        }\r\n    }\r\n    else {\r\n        result[resultLen++] = new LinePart(len, tokenType, 0);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Inline decorations are \"merged\" on top of tokens.\r\n * Special care must be taken when multiple inline decorations are at play and they overlap.\r\n */\r\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\r\n    _lineDecorations.sort(LineDecoration.compare);\r\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\r\n    const lineDecorationsLen = lineDecorations.length;\r\n    let lineDecorationIndex = 0;\r\n    let result = [], resultLen = 0, lastResultEndIndex = 0;\r\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\r\n        const token = tokens[tokenIndex];\r\n        const tokenEndIndex = token.endIndex;\r\n        const tokenType = token.type;\r\n        const tokenMetadata = token.metadata;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\r\n            const lineDecoration = lineDecorations[lineDecorationIndex];\r\n            if (lineDecoration.startOffset > lastResultEndIndex) {\r\n                lastResultEndIndex = lineDecoration.startOffset;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\r\n            }\r\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\r\n                // This line decoration ends before this token ends\r\n                lastResultEndIndex = lineDecoration.endOffset + 1;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\r\n                lineDecorationIndex++;\r\n            }\r\n            else {\r\n                // This line decoration continues on to the next token\r\n                lastResultEndIndex = tokenEndIndex;\r\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\r\n                break;\r\n            }\r\n        }\r\n        if (tokenEndIndex > lastResultEndIndex) {\r\n            lastResultEndIndex = tokenEndIndex;\r\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\r\n        }\r\n    }\r\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\r\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n        let classNames = [];\r\n        let metadata = 0;\r\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\r\n            classNames.push(lineDecorations[lineDecorationIndex].className);\r\n            metadata |= lineDecorations[lineDecorationIndex].metadata;\r\n            lineDecorationIndex++;\r\n        }\r\n        result[resultLen++] = new LinePart(lastResultEndIndex, classNames.join(' '), metadata);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\r\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\r\n */\r\nfunction _renderLine(input, sb) {\r\n    const fontIsMonospace = input.fontIsMonospace;\r\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\r\n    const containsForeignElements = input.containsForeignElements;\r\n    const lineContent = input.lineContent;\r\n    const len = input.len;\r\n    const isOverflowing = input.isOverflowing;\r\n    const parts = input.parts;\r\n    const fauxIndentLength = input.fauxIndentLength;\r\n    const tabSize = input.tabSize;\r\n    const startVisibleColumn = input.startVisibleColumn;\r\n    const containsRTL = input.containsRTL;\r\n    const spaceWidth = input.spaceWidth;\r\n    const renderSpaceCharCode = input.renderSpaceCharCode;\r\n    const renderWhitespace = input.renderWhitespace;\r\n    const renderControlCharacters = input.renderControlCharacters;\r\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\r\n    let charIndex = 0;\r\n    let visibleColumn = startVisibleColumn;\r\n    let charOffsetInPart = 0;\r\n    let partDisplacement = 0;\r\n    let prevPartContentCnt = 0;\r\n    let partAbsoluteOffset = 0;\r\n    if (containsRTL) {\r\n        sb.appendASCIIString('<span dir=\"ltr\">');\r\n    }\r\n    else {\r\n        sb.appendASCIIString('<span>');\r\n    }\r\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\r\n        partAbsoluteOffset += prevPartContentCnt;\r\n        const part = parts[partIndex];\r\n        const partEndIndex = part.endIndex;\r\n        const partType = part.type;\r\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\r\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\r\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.metadata === 4 /* PSEUDO_AFTER */);\r\n        charOffsetInPart = 0;\r\n        sb.appendASCIIString('<span class=\"');\r\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\r\n        sb.appendASCII(34 /* DoubleQuote */);\r\n        if (partRendersWhitespace) {\r\n            let partContentCnt = 0;\r\n            {\r\n                let _charIndex = charIndex;\r\n                let _visibleColumn = visibleColumn;\r\n                for (; _charIndex < partEndIndex; _charIndex++) {\r\n                    const charCode = lineContent.charCodeAt(_charIndex);\r\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\r\n                    partContentCnt += charWidth;\r\n                    if (_charIndex >= fauxIndentLength) {\r\n                        _visibleColumn += charWidth;\r\n                    }\r\n                }\r\n            }\r\n            if (partRendersWhitespaceWithWidth) {\r\n                sb.appendASCIIString(' style=\"width:');\r\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\r\n                sb.appendASCIIString('px\"');\r\n            }\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\r\n                partDisplacement = 0;\r\n                const charCode = lineContent.charCodeAt(charIndex);\r\n                let charWidth;\r\n                if (charCode === 9 /* Tab */) {\r\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\r\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\r\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\r\n                    }\r\n                    else {\r\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\r\n                    }\r\n                    for (let space = 2; space <= charWidth; space++) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                }\r\n                else { // must be CharCode.Space\r\n                    charWidth = 1;\r\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\r\n                }\r\n                charOffsetInPart += charWidth;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        else {\r\n            let partContentCnt = 0;\r\n            sb.appendASCII(62 /* GreaterThan */);\r\n            for (; charIndex < partEndIndex; charIndex++) {\r\n                characterMapping.setPartData(charIndex, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\r\n                partDisplacement = 0;\r\n                const charCode = lineContent.charCodeAt(charIndex);\r\n                let producedCharacters = 1;\r\n                let charWidth = 1;\r\n                switch (charCode) {\r\n                    case 9 /* Tab */:\r\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                        charWidth = producedCharacters;\r\n                        for (let space = 1; space <= producedCharacters; space++) {\r\n                            sb.write1(0xA0); // &nbsp;\r\n                        }\r\n                        break;\r\n                    case 32 /* Space */:\r\n                        sb.write1(0xA0); // &nbsp;\r\n                        break;\r\n                    case 60 /* LessThan */:\r\n                        sb.appendASCIIString('&lt;');\r\n                        break;\r\n                    case 62 /* GreaterThan */:\r\n                        sb.appendASCIIString('&gt;');\r\n                        break;\r\n                    case 38 /* Ampersand */:\r\n                        sb.appendASCIIString('&amp;');\r\n                        break;\r\n                    case 0 /* Null */:\r\n                        sb.appendASCIIString('&#00;');\r\n                        break;\r\n                    case 65279 /* UTF8_BOM */:\r\n                    case 8232 /* LINE_SEPARATOR */:\r\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\r\n                    case 133 /* NEXT_LINE */:\r\n                        sb.write1(0xFFFD);\r\n                        break;\r\n                    default:\r\n                        if (strings.isFullWidthCharacter(charCode)) {\r\n                            charWidth++;\r\n                        }\r\n                        if (renderControlCharacters && charCode < 32) {\r\n                            sb.write1(9216 + charCode);\r\n                        }\r\n                        else {\r\n                            sb.write1(charCode);\r\n                        }\r\n                }\r\n                charOffsetInPart += producedCharacters;\r\n                partContentCnt += producedCharacters;\r\n                if (charIndex >= fauxIndentLength) {\r\n                    visibleColumn += charWidth;\r\n                }\r\n            }\r\n            prevPartContentCnt = partContentCnt;\r\n        }\r\n        if (partIsEmptyAndHasPseudoAfter) {\r\n            partDisplacement++;\r\n        }\r\n        else {\r\n            partDisplacement = 0;\r\n        }\r\n        sb.appendASCIIString('</span>');\r\n    }\r\n    // When getting client rects for the last character, we will position the\r\n    // text range at the end of the span, insteaf of at the beginning of next span\r\n    characterMapping.setPartData(len, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\r\n    if (isOverflowing) {\r\n        sb.appendASCIIString('<span>&hellip;</span>');\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}