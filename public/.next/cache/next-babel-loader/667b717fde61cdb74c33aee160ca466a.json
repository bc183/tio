{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n\n/**\r\n * Describes what to do with the indentation when pressing Enter.\r\n */\nexport var IndentAction;\n\n(function (IndentAction) {\n  /**\r\n   * Insert new line and copy the previous line's indentation.\r\n   */\n  IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n  /**\r\n   * Insert new line and indent once (relative to the previous line's indentation).\r\n   */\n\n  IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n  /**\r\n   * Insert two new lines:\r\n   *  - the first one indented which will hold the cursor\r\n   *  - the second one at the same indentation level\r\n   */\n\n  IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n  /**\r\n   * Insert new line and outdent once (relative to the previous line's indentation).\r\n   */\n\n  IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\r\n * @internal\r\n */\n\n\nexport var StandardAutoClosingPairConditional = /*#__PURE__*/function () {\n  function StandardAutoClosingPairConditional(source) {\n    _classCallCheck(this, StandardAutoClosingPairConditional);\n\n    this.open = source.open;\n    this.close = source.close; // initially allowed in all tokens\n\n    this._standardTokenMask = 0;\n\n    if (Array.isArray(source.notIn)) {\n      for (var i = 0, len = source.notIn.length; i < len; i++) {\n        var notIn = source.notIn[i];\n\n        switch (notIn) {\n          case 'string':\n            this._standardTokenMask |= 2\n            /* String */\n            ;\n            break;\n\n          case 'comment':\n            this._standardTokenMask |= 1\n            /* Comment */\n            ;\n            break;\n\n          case 'regex':\n            this._standardTokenMask |= 4\n            /* RegEx */\n            ;\n            break;\n        }\n      }\n    }\n  }\n\n  _createClass(StandardAutoClosingPairConditional, [{\n    key: \"isOK\",\n    value: function isOK(standardToken) {\n      return (this._standardTokenMask & standardToken) === 0;\n    }\n  }]);\n\n  return StandardAutoClosingPairConditional;\n}();\n/**\r\n * @internal\r\n */\n\nexport var AutoClosingPairs = function AutoClosingPairs(autoClosingPairs) {\n  _classCallCheck(this, AutoClosingPairs);\n\n  this.autoClosingPairsOpenByStart = new Map();\n  this.autoClosingPairsOpenByEnd = new Map();\n  this.autoClosingPairsCloseByStart = new Map();\n  this.autoClosingPairsCloseByEnd = new Map();\n  this.autoClosingPairsCloseSingleChar = new Map();\n\n  var _iterator = _createForOfIteratorHelper(autoClosingPairs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pair = _step.value;\n      appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n      appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n      appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n      appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n\n      if (pair.close.length === 1 && pair.open.length === 1) {\n        appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\n\nfunction appendEntry(target, key, value) {\n  if (target.has(key)) {\n    target.get(key).push(value);\n  } else {\n    target.set(key, [value]);\n  }\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfiguration.js"],"names":["IndentAction","StandardAutoClosingPairConditional","source","open","close","_standardTokenMask","Array","isArray","notIn","i","len","length","standardToken","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","Map","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","value","has","get","push","set"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA,OAAO,IAAIA,YAAJ;;AACP,CAAC,UAAUA,YAAV,EAAwB;AACrB;AACJ;AACA;AACIA,EAAAA,YAAY,CAACA,YAAY,CAAC,MAAD,CAAZ,GAAuB,CAAxB,CAAZ,GAAyC,MAAzC;AACA;AACJ;AACA;;AACIA,EAAAA,YAAY,CAACA,YAAY,CAAC,QAAD,CAAZ,GAAyB,CAA1B,CAAZ,GAA2C,QAA3C;AACA;AACJ;AACA;AACA;AACA;;AACIA,EAAAA,YAAY,CAACA,YAAY,CAAC,eAAD,CAAZ,GAAgC,CAAjC,CAAZ,GAAkD,eAAlD;AACA;AACJ;AACA;;AACIA,EAAAA,YAAY,CAACA,YAAY,CAAC,SAAD,CAAZ,GAA0B,CAA3B,CAAZ,GAA4C,SAA5C;AACH,CAnBD,EAmBGA,YAAY,KAAKA,YAAY,GAAG,EAApB,CAnBf;AAoBA;AACA;AACA;;;AACA,WAAaC,kCAAb;AACI,8CAAYC,MAAZ,EAAoB;AAAA;;AAChB,SAAKC,IAAL,GAAYD,MAAM,CAACC,IAAnB;AACA,SAAKC,KAAL,GAAaF,MAAM,CAACE,KAApB,CAFgB,CAGhB;;AACA,SAAKC,kBAAL,GAA0B,CAA1B;;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcL,MAAM,CAACM,KAArB,CAAJ,EAAiC;AAC7B,WAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGR,MAAM,CAACM,KAAP,CAAaG,MAAnC,EAA2CF,CAAC,GAAGC,GAA/C,EAAoDD,CAAC,EAArD,EAAyD;AACrD,YAAMD,KAAK,GAAGN,MAAM,CAACM,KAAP,CAAaC,CAAb,CAAd;;AACA,gBAAQD,KAAR;AACI,eAAK,QAAL;AACI,iBAAKH,kBAAL,IAA2B;AAAE;AAA7B;AACA;;AACJ,eAAK,SAAL;AACI,iBAAKA,kBAAL,IAA2B;AAAE;AAA7B;AACA;;AACJ,eAAK,OAAL;AACI,iBAAKA,kBAAL,IAA2B;AAAE;AAA7B;AACA;AATR;AAWH;AACJ;AACJ;;AAtBL;AAAA;AAAA,yBAuBSO,aAvBT,EAuBwB;AAChB,aAAO,CAAC,KAAKP,kBAAL,GAA0BO,aAA3B,MAA8C,CAArD;AACH;AAzBL;;AAAA;AAAA;AA2BA;AACA;AACA;;AACA,WAAaC,gBAAb,GACI,0BAAYC,gBAAZ,EAA8B;AAAA;;AAC1B,OAAKC,2BAAL,GAAmC,IAAIC,GAAJ,EAAnC;AACA,OAAKC,yBAAL,GAAiC,IAAID,GAAJ,EAAjC;AACA,OAAKE,4BAAL,GAAoC,IAAIF,GAAJ,EAApC;AACA,OAAKG,0BAAL,GAAkC,IAAIH,GAAJ,EAAlC;AACA,OAAKI,+BAAL,GAAuC,IAAIJ,GAAJ,EAAvC;;AAL0B,6CAMPF,gBANO;AAAA;;AAAA;AAM1B,wDAAqC;AAAA,UAA1BO,IAA0B;AACjCC,MAAAA,WAAW,CAAC,KAAKP,2BAAN,EAAmCM,IAAI,CAAClB,IAAL,CAAUoB,MAAV,CAAiB,CAAjB,CAAnC,EAAwDF,IAAxD,CAAX;AACAC,MAAAA,WAAW,CAAC,KAAKL,yBAAN,EAAiCI,IAAI,CAAClB,IAAL,CAAUoB,MAAV,CAAiBF,IAAI,CAAClB,IAAL,CAAUQ,MAAV,GAAmB,CAApC,CAAjC,EAAyEU,IAAzE,CAAX;AACAC,MAAAA,WAAW,CAAC,KAAKJ,4BAAN,EAAoCG,IAAI,CAACjB,KAAL,CAAWmB,MAAX,CAAkB,CAAlB,CAApC,EAA0DF,IAA1D,CAAX;AACAC,MAAAA,WAAW,CAAC,KAAKH,0BAAN,EAAkCE,IAAI,CAACjB,KAAL,CAAWmB,MAAX,CAAkBF,IAAI,CAACjB,KAAL,CAAWO,MAAX,GAAoB,CAAtC,CAAlC,EAA4EU,IAA5E,CAAX;;AACA,UAAIA,IAAI,CAACjB,KAAL,CAAWO,MAAX,KAAsB,CAAtB,IAA2BU,IAAI,CAAClB,IAAL,CAAUQ,MAAV,KAAqB,CAApD,EAAuD;AACnDW,QAAAA,WAAW,CAAC,KAAKF,+BAAN,EAAuCC,IAAI,CAACjB,KAA5C,EAAmDiB,IAAnD,CAAX;AACH;AACJ;AAdyB;AAAA;AAAA;AAAA;AAAA;AAe7B,CAhBL;;AAkBA,SAASC,WAAT,CAAqBE,MAArB,EAA6BC,GAA7B,EAAkCC,KAAlC,EAAyC;AACrC,MAAIF,MAAM,CAACG,GAAP,CAAWF,GAAX,CAAJ,EAAqB;AACjBD,IAAAA,MAAM,CAACI,GAAP,CAAWH,GAAX,EAAgBI,IAAhB,CAAqBH,KAArB;AACH,GAFD,MAGK;AACDF,IAAAA,MAAM,CAACM,GAAP,CAAWL,GAAX,EAAgB,CAACC,KAAD,CAAhB;AACH;AACJ","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * Describes what to do with the indentation when pressing Enter.\r\n */\r\nexport var IndentAction;\r\n(function (IndentAction) {\r\n    /**\r\n     * Insert new line and copy the previous line's indentation.\r\n     */\r\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * Insert new line and indent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\r\n    /**\r\n     * Insert two new lines:\r\n     *  - the first one indented which will hold the cursor\r\n     *  - the second one at the same indentation level\r\n     */\r\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\r\n    /**\r\n     * Insert new line and outdent once (relative to the previous line's indentation).\r\n     */\r\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\r\n})(IndentAction || (IndentAction = {}));\r\n/**\r\n * @internal\r\n */\r\nexport class StandardAutoClosingPairConditional {\r\n    constructor(source) {\r\n        this.open = source.open;\r\n        this.close = source.close;\r\n        // initially allowed in all tokens\r\n        this._standardTokenMask = 0;\r\n        if (Array.isArray(source.notIn)) {\r\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\r\n                const notIn = source.notIn[i];\r\n                switch (notIn) {\r\n                    case 'string':\r\n                        this._standardTokenMask |= 2 /* String */;\r\n                        break;\r\n                    case 'comment':\r\n                        this._standardTokenMask |= 1 /* Comment */;\r\n                        break;\r\n                    case 'regex':\r\n                        this._standardTokenMask |= 4 /* RegEx */;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    isOK(standardToken) {\r\n        return (this._standardTokenMask & standardToken) === 0;\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nexport class AutoClosingPairs {\r\n    constructor(autoClosingPairs) {\r\n        this.autoClosingPairsOpenByStart = new Map();\r\n        this.autoClosingPairsOpenByEnd = new Map();\r\n        this.autoClosingPairsCloseByStart = new Map();\r\n        this.autoClosingPairsCloseByEnd = new Map();\r\n        this.autoClosingPairsCloseSingleChar = new Map();\r\n        for (const pair of autoClosingPairs) {\r\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\r\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\r\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\r\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\r\n            if (pair.close.length === 1 && pair.open.length === 1) {\r\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction appendEntry(target, key, value) {\r\n    if (target.has(key)) {\r\n        target.get(key).push(value);\r\n    }\r\n    else {\r\n        target.set(key, [value]);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}