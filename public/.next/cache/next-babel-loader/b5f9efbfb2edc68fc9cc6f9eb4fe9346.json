{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { URI, uriToFsPath } from './uri.js';\nimport { compare as strCompare } from './strings.js';\nimport { Schemas } from './network.js';\nexport function originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nexport var ExtUri = /*#__PURE__*/function () {\n  function ExtUri(_ignorePathCasing) {\n    _classCallCheck(this, ExtUri);\n\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n\n  _createClass(ExtUri, [{\n    key: \"compare\",\n    value: function compare(uri1, uri2) {\n      var ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (uri1 === uri2) {\n        return 0;\n      }\n\n      return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(uri1, uri2) {\n      var ignoreFragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (uri1 === uri2) {\n        return true;\n      }\n\n      if (!uri1 || !uri2) {\n        return false;\n      }\n\n      return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n  }, {\n    key: \"getComparisonKey\",\n    value: function getComparisonKey(uri) {\n      var ignoreFragment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return uri[\"with\"]({\n        path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n        fragment: ignoreFragment ? null : undefined\n      }).toString();\n    } // --- path math\n\n  }, {\n    key: \"joinPath\",\n    value: function joinPath(resource) {\n      for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        pathFragment[_key - 1] = arguments[_key];\n      }\n\n      return URI.joinPath.apply(URI, [resource].concat(pathFragment));\n    }\n  }, {\n    key: \"basenameOrAuthority\",\n    value: function basenameOrAuthority(resource) {\n      return basename(resource) || resource.authority;\n    }\n  }, {\n    key: \"basename\",\n    value: function basename(resource) {\n      return paths.posix.basename(resource.path);\n    }\n  }, {\n    key: \"dirname\",\n    value: function dirname(resource) {\n      if (resource.path.length === 0) {\n        return resource;\n      }\n\n      var dirname;\n\n      if (resource.scheme === Schemas.file) {\n        dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n      } else {\n        dirname = paths.posix.dirname(resource.path);\n\n        if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47\n        /* Slash */\n        ) {\n            console.error(\"dirname(\\\"\".concat(resource.toString, \")) resulted in a relative path\"));\n            dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n          }\n      }\n\n      return resource[\"with\"]({\n        path: dirname\n      });\n    }\n  }, {\n    key: \"normalizePath\",\n    value: function normalizePath(resource) {\n      if (!resource.path.length) {\n        return resource;\n      }\n\n      var normalizedPath;\n\n      if (resource.scheme === Schemas.file) {\n        normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n      } else {\n        normalizedPath = paths.posix.normalize(resource.path);\n      }\n\n      return resource[\"with\"]({\n        path: normalizedPath\n      });\n    }\n  }, {\n    key: \"resolvePath\",\n    value: function resolvePath(base, path) {\n      if (base.scheme === Schemas.file) {\n        var newURI = URI.file(paths.resolve(originalFSPath(base), path));\n        return base[\"with\"]({\n          authority: newURI.authority,\n          path: newURI.path\n        });\n      }\n\n      if (path.indexOf('/') === -1) {\n        // no slashes? it's likely a Windows path\n        path = extpath.toSlashes(path);\n\n        if (/^[a-zA-Z]:(\\/|$)/.test(path)) {\n          // starts with a drive letter\n          path = '/' + path;\n        }\n      }\n\n      return base[\"with\"]({\n        path: paths.posix.resolve(base.path, path)\n      });\n    }\n  }]);\n\n  return ExtUri;\n}();\n/**\r\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\r\n * uri#toString() usages. The following is true\r\n * ```\r\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\r\n * ```\r\n */\n\nexport var extUri = new ExtUri(function () {\n  return false;\n});\nexport var isEqual = extUri.isEqual.bind(extUri);\nexport var basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport var basename = extUri.basename.bind(extUri);\nexport var dirname = extUri.dirname.bind(extUri);\nexport var joinPath = extUri.joinPath.bind(extUri);\nexport var normalizePath = extUri.normalizePath.bind(extUri);\nexport var resolvePath = extUri.resolvePath.bind(extUri);\n/**\r\n * Data URI related helpers.\r\n */\n\nexport var DataUri;\n\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n\n  function parseMetaData(dataUri) {\n    var metadata = new Map(); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\n    var meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(function (property) {\n      var _property$split = property.split(':'),\n          _property$split2 = _slicedToArray(_property$split, 2),\n          key = _property$split2[0],\n          value = _property$split2[1];\n\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    }); // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n    // the mime is: image/png\n\n    var mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n\n    return metadata;\n  }\n\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/resources.js"],"names":["extpath","paths","URI","uriToFsPath","compare","strCompare","Schemas","originalFSPath","uri","ExtUri","_ignorePathCasing","uri1","uri2","ignoreFragment","getComparisonKey","path","toLowerCase","undefined","fragment","toString","resource","pathFragment","joinPath","basename","authority","posix","length","dirname","scheme","file","charCodeAt","console","error","normalizedPath","normalize","base","newURI","resolve","indexOf","toSlashes","test","extUri","isEqual","bind","basenameOrAuthority","normalizePath","resolvePath","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","lastIndexOf","split","forEach","property","key","value","set","mime"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { URI, uriToFsPath } from './uri.js';\r\nimport { compare as strCompare } from './strings.js';\r\nimport { Schemas } from './network.js';\r\nexport function originalFSPath(uri) {\r\n    return uriToFsPath(uri, true);\r\n}\r\nexport class ExtUri {\r\n    constructor(_ignorePathCasing) {\r\n        this._ignorePathCasing = _ignorePathCasing;\r\n    }\r\n    compare(uri1, uri2, ignoreFragment = false) {\r\n        if (uri1 === uri2) {\r\n            return 0;\r\n        }\r\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\r\n    }\r\n    isEqual(uri1, uri2, ignoreFragment = false) {\r\n        if (uri1 === uri2) {\r\n            return true;\r\n        }\r\n        if (!uri1 || !uri2) {\r\n            return false;\r\n        }\r\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\r\n    }\r\n    getComparisonKey(uri, ignoreFragment = false) {\r\n        return uri.with({\r\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\r\n            fragment: ignoreFragment ? null : undefined\r\n        }).toString();\r\n    }\r\n    // --- path math\r\n    joinPath(resource, ...pathFragment) {\r\n        return URI.joinPath(resource, ...pathFragment);\r\n    }\r\n    basenameOrAuthority(resource) {\r\n        return basename(resource) || resource.authority;\r\n    }\r\n    basename(resource) {\r\n        return paths.posix.basename(resource.path);\r\n    }\r\n    dirname(resource) {\r\n        if (resource.path.length === 0) {\r\n            return resource;\r\n        }\r\n        let dirname;\r\n        if (resource.scheme === Schemas.file) {\r\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\r\n        }\r\n        else {\r\n            dirname = paths.posix.dirname(resource.path);\r\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* Slash */) {\r\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\r\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\r\n            }\r\n        }\r\n        return resource.with({\r\n            path: dirname\r\n        });\r\n    }\r\n    normalizePath(resource) {\r\n        if (!resource.path.length) {\r\n            return resource;\r\n        }\r\n        let normalizedPath;\r\n        if (resource.scheme === Schemas.file) {\r\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\r\n        }\r\n        else {\r\n            normalizedPath = paths.posix.normalize(resource.path);\r\n        }\r\n        return resource.with({\r\n            path: normalizedPath\r\n        });\r\n    }\r\n    resolvePath(base, path) {\r\n        if (base.scheme === Schemas.file) {\r\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\r\n            return base.with({\r\n                authority: newURI.authority,\r\n                path: newURI.path\r\n            });\r\n        }\r\n        if (path.indexOf('/') === -1) { // no slashes? it's likely a Windows path\r\n            path = extpath.toSlashes(path);\r\n            if (/^[a-zA-Z]:(\\/|$)/.test(path)) { // starts with a drive letter\r\n                path = '/' + path;\r\n            }\r\n        }\r\n        return base.with({\r\n            path: paths.posix.resolve(base.path, path)\r\n        });\r\n    }\r\n}\r\n/**\r\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\r\n * uri#toString() usages. The following is true\r\n * ```\r\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\r\n * ```\r\n */\r\nexport const extUri = new ExtUri(() => false);\r\nexport const isEqual = extUri.isEqual.bind(extUri);\r\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\r\nexport const basename = extUri.basename.bind(extUri);\r\nexport const dirname = extUri.dirname.bind(extUri);\r\nexport const joinPath = extUri.joinPath.bind(extUri);\r\nexport const normalizePath = extUri.normalizePath.bind(extUri);\r\nexport const resolvePath = extUri.resolvePath.bind(extUri);\r\n/**\r\n * Data URI related helpers.\r\n */\r\nexport var DataUri;\r\n(function (DataUri) {\r\n    DataUri.META_DATA_LABEL = 'label';\r\n    DataUri.META_DATA_DESCRIPTION = 'description';\r\n    DataUri.META_DATA_SIZE = 'size';\r\n    DataUri.META_DATA_MIME = 'mime';\r\n    function parseMetaData(dataUri) {\r\n        const metadata = new Map();\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\r\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\r\n        meta.split(';').forEach(property => {\r\n            const [key, value] = property.split(':');\r\n            if (key && value) {\r\n                metadata.set(key, value);\r\n            }\r\n        });\r\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\r\n        // the mime is: image/png\r\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\r\n        if (mime) {\r\n            metadata.set(DataUri.META_DATA_MIME, mime);\r\n        }\r\n        return metadata;\r\n    }\r\n    DataUri.parseMetaData = parseMetaData;\r\n})(DataUri || (DataUri = {}));\r\n"]},"metadata":{},"sourceType":"module"}