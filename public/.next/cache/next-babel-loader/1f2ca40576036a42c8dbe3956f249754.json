{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\nimport { allCharCodes } from './minimapCharSheet.js';\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\nimport { toUint8 } from '../../../../base/common/uint.js';\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\n\nexport var MinimapCharRendererFactory = /*#__PURE__*/function () {\n  function MinimapCharRendererFactory() {\n    _classCallCheck(this, MinimapCharRendererFactory);\n  }\n\n  _createClass(MinimapCharRendererFactory, null, [{\n    key: \"create\",\n\n    /**\r\n     * Creates a new character renderer factory with the given scale.\r\n     */\n    value: function create(scale, fontFamily) {\n      // renderers are immutable. By default we'll 'create' a new minimap\n      // character renderer whenever we switch editors, no need to do extra work.\n      if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\n        return this.lastCreated;\n      }\n\n      var factory;\n\n      if (prebakedMiniMaps[scale]) {\n        factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\n      } else {\n        factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\n      }\n\n      this.lastFontFamily = fontFamily;\n      this.lastCreated = factory;\n      return factory;\n    }\n    /**\r\n     * Creates the font sample data, writing to a canvas.\r\n     */\n\n  }, {\n    key: \"createSampleData\",\n    value: function createSampleData(fontFamily) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      canvas.style.height = \"\".concat(16\n      /* SAMPLED_CHAR_HEIGHT */\n      , \"px\");\n      canvas.height = 16\n      /* SAMPLED_CHAR_HEIGHT */\n      ;\n      canvas.width = 96\n      /* CHAR_COUNT */\n      * 10\n      /* SAMPLED_CHAR_WIDTH */\n      ;\n      canvas.style.width = 96\n      /* CHAR_COUNT */\n      * 10\n      /* SAMPLED_CHAR_WIDTH */\n      + 'px';\n      ctx.fillStyle = '#ffffff';\n      ctx.font = \"bold \".concat(16\n      /* SAMPLED_CHAR_HEIGHT */\n      , \"px \", fontFamily);\n      ctx.textBaseline = 'middle';\n      var x = 0;\n\n      var _iterator = _createForOfIteratorHelper(allCharCodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var code = _step.value;\n          ctx.fillText(String.fromCharCode(code), x, 16\n          /* SAMPLED_CHAR_HEIGHT */\n          / 2);\n          x += 10\n          /* SAMPLED_CHAR_WIDTH */\n          ;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return ctx.getImageData(0, 0, 96\n      /* CHAR_COUNT */\n      * 10\n      /* SAMPLED_CHAR_WIDTH */\n      , 16\n      /* SAMPLED_CHAR_HEIGHT */\n      );\n    }\n    /**\r\n     * Creates a character renderer from the canvas sample data.\r\n     */\n\n  }, {\n    key: \"createFromSampleData\",\n    value: function createFromSampleData(source, scale) {\n      var expectedLength = 16\n      /* SAMPLED_CHAR_HEIGHT */\n      * 10\n      /* SAMPLED_CHAR_WIDTH */\n      * 4\n      /* RGBA_CHANNELS_CNT */\n      * 96\n      /* CHAR_COUNT */\n      ;\n\n      if (source.length !== expectedLength) {\n        throw new Error('Unexpected source in MinimapCharRenderer');\n      }\n\n      var charData = MinimapCharRendererFactory._downsample(source, scale);\n\n      return new MinimapCharRenderer(charData, scale);\n    }\n  }, {\n    key: \"_downsampleChar\",\n    value: function _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\n      var width = 1\n      /* BASE_CHAR_WIDTH */\n      * scale;\n      var height = 2\n      /* BASE_CHAR_HEIGHT */\n      * scale;\n      var targetIndex = destOffset;\n      var brightest = 0; // This is essentially an ad-hoc rescaling algorithm. Standard approaches\n      // like bicubic interpolation are awesome for scaling between image sizes,\n      // but don't work so well when scaling to very small pixel values, we end\n      // up with blurry, indistinct forms.\n      //\n      // The approach taken here is simply mapping each source pixel to the target\n      // pixels, and taking the weighted values for all pixels in each, and then\n      // averaging them out. Finally we apply an intensity boost in _downsample,\n      // since when scaling to the smallest pixel sizes there's more black space\n      // which causes characters to be much less distinct.\n\n      for (var y = 0; y < height; y++) {\n        // 1. For this destination pixel, get the source pixels we're sampling\n        // from (x1, y1) to the next pixel (x2, y2)\n        var sourceY1 = y / height * 16\n        /* SAMPLED_CHAR_HEIGHT */\n        ;\n        var sourceY2 = (y + 1) / height * 16\n        /* SAMPLED_CHAR_HEIGHT */\n        ;\n\n        for (var x = 0; x < width; x++) {\n          var sourceX1 = x / width * 10\n          /* SAMPLED_CHAR_WIDTH */\n          ;\n          var sourceX2 = (x + 1) / width * 10\n          /* SAMPLED_CHAR_WIDTH */\n          ; // 2. Sample all of them, summing them up and weighting them. Similar\n          // to bilinear interpolation.\n\n          var value = 0;\n          var samples = 0;\n\n          for (var sy = sourceY1; sy < sourceY2; sy++) {\n            var sourceRow = sourceOffset + Math.floor(sy) * 3840\n            /* RGBA_SAMPLED_ROW_WIDTH */\n            ;\n            var yBalance = 1 - (sy - Math.floor(sy));\n\n            for (var sx = sourceX1; sx < sourceX2; sx++) {\n              var xBalance = 1 - (sx - Math.floor(sx));\n              var sourceIndex = sourceRow + Math.floor(sx) * 4\n              /* RGBA_CHANNELS_CNT */\n              ;\n              var weight = xBalance * yBalance;\n              samples += weight;\n              value += source[sourceIndex] * source[sourceIndex + 3] / 255 * weight;\n            }\n          }\n\n          var _final = value / samples;\n\n          brightest = Math.max(brightest, _final);\n          dest[targetIndex++] = toUint8(_final);\n        }\n      }\n\n      return brightest;\n    }\n  }, {\n    key: \"_downsample\",\n    value: function _downsample(data, scale) {\n      var pixelsPerCharacter = 2\n      /* BASE_CHAR_HEIGHT */\n      * scale * 1\n      /* BASE_CHAR_WIDTH */\n      * scale;\n      var resultLen = pixelsPerCharacter * 96\n      /* CHAR_COUNT */\n      ;\n      var result = new Uint8ClampedArray(resultLen);\n      var resultOffset = 0;\n      var sourceOffset = 0;\n      var brightest = 0;\n\n      for (var charIndex = 0; charIndex < 96\n      /* CHAR_COUNT */\n      ; charIndex++) {\n        brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\n        resultOffset += pixelsPerCharacter;\n        sourceOffset += 10\n        /* SAMPLED_CHAR_WIDTH */\n        * 4\n        /* RGBA_CHANNELS_CNT */\n        ;\n      }\n\n      if (brightest > 0) {\n        var adjust = 255 / brightest;\n\n        for (var i = 0; i < resultLen; i++) {\n          result[i] *= adjust;\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return MinimapCharRendererFactory;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimapCharRendererFactory.js"],"names":["MinimapCharRenderer","allCharCodes","prebakedMiniMaps","toUint8","MinimapCharRendererFactory","scale","fontFamily","lastCreated","lastFontFamily","factory","createFromSampleData","createSampleData","data","canvas","document","createElement","ctx","getContext","style","height","width","fillStyle","font","textBaseline","x","code","fillText","String","fromCharCode","getImageData","source","expectedLength","length","Error","charData","_downsample","sourceOffset","dest","destOffset","targetIndex","brightest","y","sourceY1","sourceY2","sourceX1","sourceX2","value","samples","sy","sourceRow","Math","floor","yBalance","sx","xBalance","sourceIndex","weight","final","max","pixelsPerCharacter","resultLen","result","Uint8ClampedArray","resultOffset","charIndex","_downsampleChar","adjust","i"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { MinimapCharRenderer } from './minimapCharRenderer.js';\r\nimport { allCharCodes } from './minimapCharSheet.js';\r\nimport { prebakedMiniMaps } from './minimapPreBaked.js';\r\nimport { toUint8 } from '../../../../base/common/uint.js';\r\n/**\r\n * Creates character renderers. It takes a 'scale' that determines how large\r\n * characters should be drawn. Using this, it draws data into a canvas and\r\n * then downsamples the characters as necessary for the current display.\r\n * This makes rendering more efficient, rather than drawing a full (tiny)\r\n * font, or downsampling in real-time.\r\n */\r\nexport class MinimapCharRendererFactory {\r\n    /**\r\n     * Creates a new character renderer factory with the given scale.\r\n     */\r\n    static create(scale, fontFamily) {\r\n        // renderers are immutable. By default we'll 'create' a new minimap\r\n        // character renderer whenever we switch editors, no need to do extra work.\r\n        if (this.lastCreated && scale === this.lastCreated.scale && fontFamily === this.lastFontFamily) {\r\n            return this.lastCreated;\r\n        }\r\n        let factory;\r\n        if (prebakedMiniMaps[scale]) {\r\n            factory = new MinimapCharRenderer(prebakedMiniMaps[scale](), scale);\r\n        }\r\n        else {\r\n            factory = MinimapCharRendererFactory.createFromSampleData(MinimapCharRendererFactory.createSampleData(fontFamily).data, scale);\r\n        }\r\n        this.lastFontFamily = fontFamily;\r\n        this.lastCreated = factory;\r\n        return factory;\r\n    }\r\n    /**\r\n     * Creates the font sample data, writing to a canvas.\r\n     */\r\n    static createSampleData(fontFamily) {\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        canvas.style.height = `${16 /* SAMPLED_CHAR_HEIGHT */}px`;\r\n        canvas.height = 16 /* SAMPLED_CHAR_HEIGHT */;\r\n        canvas.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */;\r\n        canvas.style.width = 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */ + 'px';\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = `bold ${16 /* SAMPLED_CHAR_HEIGHT */}px ${fontFamily}`;\r\n        ctx.textBaseline = 'middle';\r\n        let x = 0;\r\n        for (const code of allCharCodes) {\r\n            ctx.fillText(String.fromCharCode(code), x, 16 /* SAMPLED_CHAR_HEIGHT */ / 2);\r\n            x += 10 /* SAMPLED_CHAR_WIDTH */;\r\n        }\r\n        return ctx.getImageData(0, 0, 96 /* CHAR_COUNT */ * 10 /* SAMPLED_CHAR_WIDTH */, 16 /* SAMPLED_CHAR_HEIGHT */);\r\n    }\r\n    /**\r\n     * Creates a character renderer from the canvas sample data.\r\n     */\r\n    static createFromSampleData(source, scale) {\r\n        const expectedLength = 16 /* SAMPLED_CHAR_HEIGHT */ * 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */ * 96 /* CHAR_COUNT */;\r\n        if (source.length !== expectedLength) {\r\n            throw new Error('Unexpected source in MinimapCharRenderer');\r\n        }\r\n        let charData = MinimapCharRendererFactory._downsample(source, scale);\r\n        return new MinimapCharRenderer(charData, scale);\r\n    }\r\n    static _downsampleChar(source, sourceOffset, dest, destOffset, scale) {\r\n        const width = 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        const height = 2 /* BASE_CHAR_HEIGHT */ * scale;\r\n        let targetIndex = destOffset;\r\n        let brightest = 0;\r\n        // This is essentially an ad-hoc rescaling algorithm. Standard approaches\r\n        // like bicubic interpolation are awesome for scaling between image sizes,\r\n        // but don't work so well when scaling to very small pixel values, we end\r\n        // up with blurry, indistinct forms.\r\n        //\r\n        // The approach taken here is simply mapping each source pixel to the target\r\n        // pixels, and taking the weighted values for all pixels in each, and then\r\n        // averaging them out. Finally we apply an intensity boost in _downsample,\r\n        // since when scaling to the smallest pixel sizes there's more black space\r\n        // which causes characters to be much less distinct.\r\n        for (let y = 0; y < height; y++) {\r\n            // 1. For this destination pixel, get the source pixels we're sampling\r\n            // from (x1, y1) to the next pixel (x2, y2)\r\n            const sourceY1 = (y / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            const sourceY2 = ((y + 1) / height) * 16 /* SAMPLED_CHAR_HEIGHT */;\r\n            for (let x = 0; x < width; x++) {\r\n                const sourceX1 = (x / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                const sourceX2 = ((x + 1) / width) * 10 /* SAMPLED_CHAR_WIDTH */;\r\n                // 2. Sample all of them, summing them up and weighting them. Similar\r\n                // to bilinear interpolation.\r\n                let value = 0;\r\n                let samples = 0;\r\n                for (let sy = sourceY1; sy < sourceY2; sy++) {\r\n                    const sourceRow = sourceOffset + Math.floor(sy) * 3840 /* RGBA_SAMPLED_ROW_WIDTH */;\r\n                    const yBalance = 1 - (sy - Math.floor(sy));\r\n                    for (let sx = sourceX1; sx < sourceX2; sx++) {\r\n                        const xBalance = 1 - (sx - Math.floor(sx));\r\n                        const sourceIndex = sourceRow + Math.floor(sx) * 4 /* RGBA_CHANNELS_CNT */;\r\n                        const weight = xBalance * yBalance;\r\n                        samples += weight;\r\n                        value += ((source[sourceIndex] * source[sourceIndex + 3]) / 255) * weight;\r\n                    }\r\n                }\r\n                const final = value / samples;\r\n                brightest = Math.max(brightest, final);\r\n                dest[targetIndex++] = toUint8(final);\r\n            }\r\n        }\r\n        return brightest;\r\n    }\r\n    static _downsample(data, scale) {\r\n        const pixelsPerCharacter = 2 /* BASE_CHAR_HEIGHT */ * scale * 1 /* BASE_CHAR_WIDTH */ * scale;\r\n        const resultLen = pixelsPerCharacter * 96 /* CHAR_COUNT */;\r\n        const result = new Uint8ClampedArray(resultLen);\r\n        let resultOffset = 0;\r\n        let sourceOffset = 0;\r\n        let brightest = 0;\r\n        for (let charIndex = 0; charIndex < 96 /* CHAR_COUNT */; charIndex++) {\r\n            brightest = Math.max(brightest, this._downsampleChar(data, sourceOffset, result, resultOffset, scale));\r\n            resultOffset += pixelsPerCharacter;\r\n            sourceOffset += 10 /* SAMPLED_CHAR_WIDTH */ * 4 /* RGBA_CHANNELS_CNT */;\r\n        }\r\n        if (brightest > 0) {\r\n            const adjust = 255 / brightest;\r\n            for (let i = 0; i < resultLen; i++) {\r\n                result[i] *= adjust;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}