{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _assertThisInitialized from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get2 from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport './minimap.css';\nimport * as dom from '../../../../base/browser/dom.js';\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport * as platform from '../../../../base/common/platform.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\nimport { Range } from '../../../common/core/range.js';\nimport { RGBA8 } from '../../../common/core/rgba.js';\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground } from '../../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\nimport { MinimapPosition } from '../../../common/model.js';\nimport { once } from '../../../../base/common/functional.js';\n/**\r\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\r\n */\n\nvar MOUSE_DRAG_RESET_DISTANCE = 140;\nvar GUTTER_DECORATION_WIDTH = 2;\n\nvar MinimapOptions = /*#__PURE__*/function () {\n  function MinimapOptions(configuration, theme, tokensColorTracker) {\n    var _this = this;\n\n    _classCallCheck(this, MinimapOptions);\n\n    var options = configuration.options;\n    var pixelRatio = options.get(122\n    /* pixelRatio */\n    );\n    var layoutInfo = options.get(124\n    /* layoutInfo */\n    );\n    var minimapLayout = layoutInfo.minimap;\n    var fontInfo = options.get(38\n    /* fontInfo */\n    );\n    var minimapOpts = options.get(59\n    /* minimap */\n    );\n    this.renderMinimap = minimapLayout.renderMinimap;\n    this.size = minimapOpts.size;\n    this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\n    this.scrollBeyondLastLine = options.get(89\n    /* scrollBeyondLastLine */\n    );\n    this.showSlider = minimapOpts.showSlider;\n    this.pixelRatio = pixelRatio;\n    this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n    this.lineHeight = options.get(53\n    /* lineHeight */\n    );\n    this.minimapLeft = minimapLayout.minimapLeft;\n    this.minimapWidth = minimapLayout.minimapWidth;\n    this.minimapHeight = layoutInfo.height;\n    this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\n    this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\n    this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\n    this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\n    this.isSampling = minimapLayout.minimapIsSampling;\n    this.editorHeight = layoutInfo.height;\n    this.fontScale = minimapLayout.minimapScale;\n    this.minimapLineHeight = minimapLayout.minimapLineHeight;\n    this.minimapCharWidth = 1\n    /* BASE_CHAR_WIDTH */\n    * this.fontScale;\n    this.charRenderer = once(function () {\n      return MinimapCharRendererFactory.create(_this.fontScale, fontInfo.fontFamily);\n    });\n    this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);\n  }\n\n  _createClass(MinimapOptions, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.renderMinimap === other.renderMinimap && this.size === other.size && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === other.scrollBeyondLastLine && this.showSlider === other.showSlider && this.pixelRatio === other.pixelRatio && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth && this.lineHeight === other.lineHeight && this.minimapLeft === other.minimapLeft && this.minimapWidth === other.minimapWidth && this.minimapHeight === other.minimapHeight && this.canvasInnerWidth === other.canvasInnerWidth && this.canvasInnerHeight === other.canvasInnerHeight && this.canvasOuterWidth === other.canvasOuterWidth && this.canvasOuterHeight === other.canvasOuterHeight && this.isSampling === other.isSampling && this.editorHeight === other.editorHeight && this.fontScale === other.fontScale && this.minimapLineHeight === other.minimapLineHeight && this.minimapCharWidth === other.minimapCharWidth && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor);\n    }\n  }], [{\n    key: \"_getMinimapBackground\",\n    value: function _getMinimapBackground(theme, tokensColorTracker) {\n      var themeColor = theme.getColor(minimapBackground);\n\n      if (themeColor) {\n        return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);\n      }\n\n      return tokensColorTracker.getColor(2\n      /* DefaultBackground */\n      );\n    }\n  }]);\n\n  return MinimapOptions;\n}();\n\nvar MinimapLayout = /*#__PURE__*/function () {\n  function MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\n    _classCallCheck(this, MinimapLayout);\n\n    this.scrollTop = scrollTop;\n    this.scrollHeight = scrollHeight;\n    this.sliderNeeded = sliderNeeded;\n    this._computedSliderRatio = computedSliderRatio;\n    this.sliderTop = sliderTop;\n    this.sliderHeight = sliderHeight;\n    this.startLineNumber = startLineNumber;\n    this.endLineNumber = endLineNumber;\n  }\n  /**\r\n   * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n   */\n\n\n  _createClass(MinimapLayout, [{\n    key: \"getDesiredScrollTopFromDelta\",\n    value: function getDesiredScrollTopFromDelta(delta) {\n      return Math.round(this.scrollTop + delta / this._computedSliderRatio);\n    }\n  }, {\n    key: \"getDesiredScrollTopFromTouchLocation\",\n    value: function getDesiredScrollTopFromTouchLocation(pageY) {\n      return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\n      var pixelRatio = options.pixelRatio;\n      var minimapLineHeight = options.minimapLineHeight;\n      var minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\n      var lineHeight = options.lineHeight;\n\n      if (options.minimapHeightIsEditorHeight) {\n        var logicalScrollHeight = realLineCount * options.lineHeight + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0);\n\n        var _sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\n\n        var _maxMinimapSliderTop = Math.max(0, options.minimapHeight - _sliderHeight); // The slider can move from 0 to `maxMinimapSliderTop`\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\n\n        var _computedSliderRatio = _maxMinimapSliderTop / (scrollHeight - viewportHeight);\n\n        var _sliderTop = scrollTop * _computedSliderRatio;\n\n        var sliderNeeded = _maxMinimapSliderTop > 0;\n        var maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\n        return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, _computedSliderRatio, _sliderTop, _sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\n      } // The visible line count in a viewport can change due to a number of reasons:\n      //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\n      //    e.g. for a line height of 20, and a viewport height of 600\n      //          * scrollTop = 0  => visible lines are [1, 30]\n      //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\n      //          * scrollTop = 20 => visible lines are [2, 31]\n      //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\n      //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\n      // We must first establish a desirable slider height.\n\n\n      var sliderHeight;\n\n      if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\n        // case b) from above: there are whitespace gaps in the viewport.\n        // In this case, the height of the slider directly reflects the visible line count.\n        var viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\n        sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\n      } else {\n        // The slider has a stable height\n        var expectedViewportLineCount = viewportHeight / lineHeight;\n        sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\n      }\n\n      var maxMinimapSliderTop;\n\n      if (options.scrollBeyondLastLine) {\n        // The minimap slider, when dragged all the way down, will contain the last line at its top\n        maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\n      } else {\n        // The minimap slider, when dragged all the way down, will contain the last line at its bottom\n        maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\n      }\n\n      maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop); // The slider can move from 0 to `maxMinimapSliderTop`\n      // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\n\n      var computedSliderRatio = maxMinimapSliderTop / (scrollHeight - viewportHeight);\n      var sliderTop = scrollTop * computedSliderRatio;\n      var extraLinesAtTheBottom = 0;\n\n      if (options.scrollBeyondLastLine) {\n        var _expectedViewportLineCount = viewportHeight / lineHeight;\n\n        extraLinesAtTheBottom = _expectedViewportLineCount - 1;\n      }\n\n      if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\n        // All lines fit in the minimap\n        var startLineNumber = 1;\n        var endLineNumber = lineCount;\n\n        var _sliderNeeded = maxMinimapSliderTop > 0;\n\n        return new MinimapLayout(scrollTop, scrollHeight, _sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\n      } else {\n        var _startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight)); // Avoid flickering caused by a partial viewport start line\n        // by being consistent w.r.t. the previous layout decision\n\n\n        if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\n          if (previousLayout.scrollTop > scrollTop) {\n            // Scrolling up => never increase `startLineNumber`\n            _startLineNumber = Math.min(_startLineNumber, previousLayout.startLineNumber);\n          }\n\n          if (previousLayout.scrollTop < scrollTop) {\n            // Scrolling down => never decrease `startLineNumber`\n            _startLineNumber = Math.max(_startLineNumber, previousLayout.startLineNumber);\n          }\n        }\n\n        var _endLineNumber = Math.min(lineCount, _startLineNumber + minimapLinesFitting - 1);\n\n        var partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\n        var sliderTopAligned = (viewportStartLineNumber - _startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\n        return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, _startLineNumber, _endLineNumber);\n      }\n    }\n  }]);\n\n  return MinimapLayout;\n}();\n\nvar MinimapLine = /*#__PURE__*/function () {\n  function MinimapLine(dy) {\n    _classCallCheck(this, MinimapLine);\n\n    this.dy = dy;\n  }\n\n  _createClass(MinimapLine, [{\n    key: \"onContentChanged\",\n    value: function onContentChanged() {\n      this.dy = -1;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged() {\n      this.dy = -1;\n    }\n  }]);\n\n  return MinimapLine;\n}();\n\nMinimapLine.INVALID = new MinimapLine(-1);\n\nvar RenderData = /*#__PURE__*/function () {\n  function RenderData(renderedLayout, imageData, lines) {\n    _classCallCheck(this, RenderData);\n\n    this.renderedLayout = renderedLayout;\n    this._imageData = imageData;\n    this._renderedLines = new RenderedLinesCollection(function () {\n      return MinimapLine.INVALID;\n    });\n\n    this._renderedLines._set(renderedLayout.startLineNumber, lines);\n  }\n  /**\r\n   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\r\n   */\n\n\n  _createClass(RenderData, [{\n    key: \"linesEquals\",\n    value: function linesEquals(layout) {\n      if (!this.scrollEquals(layout)) {\n        return false;\n      }\n\n      var tmp = this._renderedLines._get();\n\n      var lines = tmp.lines;\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        if (lines[i].dy === -1) {\n          // This line is invalid\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Check if the current RenderData matches the new layout's scroll position\r\n     */\n\n  }, {\n    key: \"scrollEquals\",\n    value: function scrollEquals(layout) {\n      return this.renderedLayout.startLineNumber === layout.startLineNumber && this.renderedLayout.endLineNumber === layout.endLineNumber;\n    }\n  }, {\n    key: \"_get\",\n    value: function _get() {\n      var tmp = this._renderedLines._get();\n\n      return {\n        imageData: this._imageData,\n        rendLineNumberStart: tmp.rendLineNumberStart,\n        lines: tmp.lines\n      };\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n      return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n      this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n      this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(ranges) {\n      return this._renderedLines.onTokensChanged(ranges);\n    }\n  }]);\n\n  return RenderData;\n}();\n/**\r\n * Some sort of double buffering.\r\n *\r\n * Keeps two buffers around that will be rotated for painting.\r\n * Always gives a buffer that is filled with the background color.\r\n */\n\n\nvar MinimapBuffers = /*#__PURE__*/function () {\n  function MinimapBuffers(ctx, WIDTH, HEIGHT, background) {\n    _classCallCheck(this, MinimapBuffers);\n\n    this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\n    this._buffers = [ctx.createImageData(WIDTH, HEIGHT), ctx.createImageData(WIDTH, HEIGHT)];\n    this._lastUsedBuffer = 0;\n  }\n\n  _createClass(MinimapBuffers, [{\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      // rotate buffers\n      this._lastUsedBuffer = 1 - this._lastUsedBuffer;\n      var result = this._buffers[this._lastUsedBuffer]; // fill with background color\n\n      result.data.set(this._backgroundFillData);\n      return result;\n    }\n  }], [{\n    key: \"_createBackgroundFillData\",\n    value: function _createBackgroundFillData(WIDTH, HEIGHT, background) {\n      var backgroundR = background.r;\n      var backgroundG = background.g;\n      var backgroundB = background.b;\n      var result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\n      var offset = 0;\n\n      for (var i = 0; i < HEIGHT; i++) {\n        for (var j = 0; j < WIDTH; j++) {\n          result[offset] = backgroundR;\n          result[offset + 1] = backgroundG;\n          result[offset + 2] = backgroundB;\n          result[offset + 3] = 255;\n          offset += 4;\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return MinimapBuffers;\n}();\n\nvar MinimapSamplingState = /*#__PURE__*/function () {\n  function MinimapSamplingState(samplingRatio, minimapLines) {\n    _classCallCheck(this, MinimapSamplingState);\n\n    this.samplingRatio = samplingRatio;\n    this.minimapLines = minimapLines;\n  }\n\n  _createClass(MinimapSamplingState, [{\n    key: \"modelLineToMinimapLine\",\n    value: function modelLineToMinimapLine(lineNumber) {\n      return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\n    }\n    /**\r\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\r\n     */\n\n  }, {\n    key: \"modelLineRangeToMinimapLineRange\",\n    value: function modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\n      var fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\n\n      while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\n        fromLineIndex--;\n      }\n\n      var toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\n\n      while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\n        toLineIndex++;\n      }\n\n      if (fromLineIndex === toLineIndex) {\n        var sampledLineNumber = this.minimapLines[fromLineIndex];\n\n        if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\n          // This line is not part of the sampled lines ==> nothing to do\n          return null;\n        }\n      }\n\n      return [fromLineIndex + 1, toLineIndex + 1];\n    }\n    /**\r\n     * Will always return a range, even if it is not intersecting with a sampled model line.\r\n     */\n\n  }, {\n    key: \"decorationLineRangeToMinimapLineRange\",\n    value: function decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\n      var minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\n      var minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\n\n      if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\n        if (minimapLineEnd === this.minimapLines.length) {\n          if (minimapLineStart > 1) {\n            minimapLineStart--;\n          }\n        } else {\n          minimapLineEnd++;\n        }\n      }\n\n      return [minimapLineStart, minimapLineEnd];\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      // have the mapping be sticky\n      var deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n      var changeStartIndex = this.minimapLines.length;\n      var changeEndIndex = 0;\n\n      for (var i = this.minimapLines.length - 1; i >= 0; i--) {\n        if (this.minimapLines[i] < e.fromLineNumber) {\n          break;\n        }\n\n        if (this.minimapLines[i] <= e.toLineNumber) {\n          // this line got deleted => move to previous available\n          this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\n          changeStartIndex = Math.min(changeStartIndex, i);\n          changeEndIndex = Math.max(changeEndIndex, i);\n        } else {\n          this.minimapLines[i] -= deletedLineCount;\n        }\n      }\n\n      return [changeStartIndex, changeEndIndex];\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      // have the mapping be sticky\n      var insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\n\n      for (var i = this.minimapLines.length - 1; i >= 0; i--) {\n        if (this.minimapLines[i] < e.fromLineNumber) {\n          break;\n        }\n\n        this.minimapLines[i] += insertedLineCount;\n      }\n    }\n  }], [{\n    key: \"compute\",\n    value: function compute(options, viewLineCount, oldSamplingState) {\n      if (options.renderMinimap === 0\n      /* None */\n      || !options.isSampling) {\n        return [null, []];\n      } // ratio is intentionally not part of the layout to avoid the layout changing all the time\n      // so we need to recompute it again...\n\n\n      var pixelRatio = options.pixelRatio;\n      var lineHeight = options.lineHeight;\n      var scrollBeyondLastLine = options.scrollBeyondLastLine;\n\n      var _EditorLayoutInfoComp = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\n        viewLineCount: viewLineCount,\n        scrollBeyondLastLine: scrollBeyondLastLine,\n        height: options.editorHeight,\n        lineHeight: lineHeight,\n        pixelRatio: pixelRatio\n      }),\n          minimapLineCount = _EditorLayoutInfoComp.minimapLineCount;\n\n      var ratio = viewLineCount / minimapLineCount;\n      var halfRatio = ratio / 2;\n\n      if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\n        var _result = [];\n        _result[0] = 1;\n\n        if (minimapLineCount > 1) {\n          for (var i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\n            _result[i] = Math.round(i * ratio + halfRatio);\n          }\n\n          _result[minimapLineCount - 1] = viewLineCount;\n        }\n\n        return [new MinimapSamplingState(ratio, _result), []];\n      }\n\n      var oldMinimapLines = oldSamplingState.minimapLines;\n      var oldLength = oldMinimapLines.length;\n      var result = [];\n      var oldIndex = 0;\n      var oldDeltaLineCount = 0;\n      var minViewLineNumber = 1;\n      var MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\n\n      var events = [];\n      var lastEvent = null;\n\n      for (var _i = 0; _i < minimapLineCount; _i++) {\n        var fromViewLineNumber = Math.max(minViewLineNumber, Math.round(_i * ratio));\n        var toViewLineNumber = Math.max(fromViewLineNumber, Math.round((_i + 1) * ratio));\n\n        while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\n          if (events.length < MAX_EVENT_COUNT) {\n            var oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\n            if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n              lastEvent.deleteToLineNumber++;\n            } else {\n              lastEvent = {\n                type: 'deleted',\n                _oldIndex: oldIndex,\n                deleteFromLineNumber: oldMinimapLineNumber,\n                deleteToLineNumber: oldMinimapLineNumber\n              };\n              events.push(lastEvent);\n            }\n\n            oldDeltaLineCount--;\n          }\n\n          oldIndex++;\n        }\n\n        var selectedViewLineNumber = void 0;\n\n        if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\n          // reuse the old sampled line\n          selectedViewLineNumber = oldMinimapLines[oldIndex];\n          oldIndex++;\n        } else {\n          if (_i === 0) {\n            selectedViewLineNumber = 1;\n          } else if (_i + 1 === minimapLineCount) {\n            selectedViewLineNumber = viewLineCount;\n          } else {\n            selectedViewLineNumber = Math.round(_i * ratio + halfRatio);\n          }\n\n          if (events.length < MAX_EVENT_COUNT) {\n            var _oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\n\n            if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === _i - 1) {\n              lastEvent.insertToLineNumber++;\n            } else {\n              lastEvent = {\n                type: 'inserted',\n                _i: _i,\n                insertFromLineNumber: _oldMinimapLineNumber,\n                insertToLineNumber: _oldMinimapLineNumber\n              };\n              events.push(lastEvent);\n            }\n\n            oldDeltaLineCount++;\n          }\n        }\n\n        result[_i] = selectedViewLineNumber;\n        minViewLineNumber = selectedViewLineNumber;\n      }\n\n      if (events.length < MAX_EVENT_COUNT) {\n        while (oldIndex < oldLength) {\n          var _oldMinimapLineNumber2 = oldIndex + 1 + oldDeltaLineCount;\n\n          if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\n            lastEvent.deleteToLineNumber++;\n          } else {\n            lastEvent = {\n              type: 'deleted',\n              _oldIndex: oldIndex,\n              deleteFromLineNumber: _oldMinimapLineNumber2,\n              deleteToLineNumber: _oldMinimapLineNumber2\n            };\n            events.push(lastEvent);\n          }\n\n          oldDeltaLineCount--;\n          oldIndex++;\n        }\n      } else {\n        // too many events, just give up\n        events = [{\n          type: 'flush'\n        }];\n      }\n\n      return [new MinimapSamplingState(ratio, result), events];\n    }\n  }]);\n\n  return MinimapSamplingState;\n}();\n\nexport var Minimap = /*#__PURE__*/function (_ViewPart) {\n  _inherits(Minimap, _ViewPart);\n\n  var _super = _createSuper(Minimap);\n\n  function Minimap(context) {\n    var _this2;\n\n    _classCallCheck(this, Minimap);\n\n    _this2 = _super.call(this, context);\n    _this2.tokensColorTracker = MinimapTokensColorTracker.getInstance();\n    _this2._selections = [];\n    _this2._minimapSelections = null;\n    _this2.options = new MinimapOptions(_this2._context.configuration, _this2._context.theme, _this2.tokensColorTracker);\n\n    var _MinimapSamplingState = MinimapSamplingState.compute(_this2.options, _this2._context.model.getLineCount(), null),\n        _MinimapSamplingState2 = _slicedToArray(_MinimapSamplingState, 1),\n        samplingState = _MinimapSamplingState2[0];\n\n    _this2._samplingState = samplingState;\n    _this2._shouldCheckSampling = false;\n    _this2._actual = new InnerMinimap(context.theme, _assertThisInitialized(_this2));\n    return _this2;\n  }\n\n  _createClass(Minimap, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._actual.dispose();\n\n      _get2(_getPrototypeOf(Minimap.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this._actual.getDomNode();\n    }\n  }, {\n    key: \"_onOptionsMaybeChanged\",\n    value: function _onOptionsMaybeChanged() {\n      var opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\n\n      if (this.options.equals(opts)) {\n        return false;\n      }\n\n      this.options = opts;\n\n      this._recreateLineSampling();\n\n      this._actual.onDidChangeOptions();\n\n      return true;\n    } // ---- begin view event handlers\n\n  }, {\n    key: \"onConfigurationChanged\",\n    value: function onConfigurationChanged(e) {\n      return this._onOptionsMaybeChanged();\n    }\n  }, {\n    key: \"onCursorStateChanged\",\n    value: function onCursorStateChanged(e) {\n      this._selections = e.selections;\n      this._minimapSelections = null;\n      return this._actual.onSelectionChanged();\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged(e) {\n      if (e.affectsMinimap) {\n        return this._actual.onDecorationsChanged();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(e) {\n      if (this._samplingState) {\n        this._shouldCheckSampling = true;\n      }\n\n      return this._actual.onFlushed();\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(e) {\n      if (this._samplingState) {\n        var minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\n\n        if (minimapLineRange) {\n          return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\n        } else {\n          return false;\n        }\n      } else {\n        return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\n      }\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(e) {\n      if (this._samplingState) {\n        var _this$_samplingState$ = this._samplingState.onLinesDeleted(e),\n            _this$_samplingState$2 = _slicedToArray(_this$_samplingState$, 2),\n            changeStartIndex = _this$_samplingState$2[0],\n            changeEndIndex = _this$_samplingState$2[1];\n\n        if (changeStartIndex <= changeEndIndex) {\n          this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\n        }\n\n        this._shouldCheckSampling = true;\n        return true;\n      } else {\n        return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\n      }\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(e) {\n      if (this._samplingState) {\n        this._samplingState.onLinesInserted(e);\n\n        this._shouldCheckSampling = true;\n        return true;\n      } else {\n        return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\n      }\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged(e) {\n      return this._actual.onScrollChanged();\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged(e) {\n      this._context.model.invalidateMinimapColorCache();\n\n      this._actual.onThemeChanged();\n\n      this._onOptionsMaybeChanged();\n\n      return true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(e) {\n      if (this._samplingState) {\n        var ranges = [];\n\n        var _iterator = _createForOfIteratorHelper(e.ranges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var range = _step.value;\n\n            var minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\n\n            if (minimapLineRange) {\n              ranges.push({\n                fromLineNumber: minimapLineRange[0],\n                toLineNumber: minimapLineRange[1]\n              });\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (ranges.length) {\n          return this._actual.onTokensChanged(ranges);\n        } else {\n          return false;\n        }\n      } else {\n        return this._actual.onTokensChanged(e.ranges);\n      }\n    }\n  }, {\n    key: \"onTokensColorsChanged\",\n    value: function onTokensColorsChanged(e) {\n      this._onOptionsMaybeChanged();\n\n      return this._actual.onTokensColorsChanged();\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged(e) {\n      return this._actual.onZonesChanged();\n    } // --- end event handlers\n\n  }, {\n    key: \"prepareRender\",\n    value: function prepareRender(ctx) {\n      if (this._shouldCheckSampling) {\n        this._shouldCheckSampling = false;\n\n        this._recreateLineSampling();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      var viewportStartLineNumber = ctx.visibleRange.startLineNumber;\n      var viewportEndLineNumber = ctx.visibleRange.endLineNumber;\n\n      if (this._samplingState) {\n        viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\n        viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\n      }\n\n      var minimapCtx = {\n        viewportContainsWhitespaceGaps: ctx.viewportData.whitespaceViewportData.length > 0,\n        scrollWidth: ctx.scrollWidth,\n        scrollHeight: ctx.scrollHeight,\n        viewportStartLineNumber: viewportStartLineNumber,\n        viewportEndLineNumber: viewportEndLineNumber,\n        viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\n        scrollTop: ctx.scrollTop,\n        scrollLeft: ctx.scrollLeft,\n        viewportWidth: ctx.viewportWidth,\n        viewportHeight: ctx.viewportHeight\n      };\n\n      this._actual.render(minimapCtx);\n    } //#region IMinimapModel\n\n  }, {\n    key: \"_recreateLineSampling\",\n    value: function _recreateLineSampling() {\n      this._minimapSelections = null;\n      var wasSampling = Boolean(this._samplingState);\n\n      var _MinimapSamplingState3 = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState),\n          _MinimapSamplingState4 = _slicedToArray(_MinimapSamplingState3, 2),\n          samplingState = _MinimapSamplingState4[0],\n          events = _MinimapSamplingState4[1];\n\n      this._samplingState = samplingState;\n\n      if (wasSampling && this._samplingState) {\n        // was sampling, is sampling\n        var _iterator2 = _createForOfIteratorHelper(events),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var event = _step2.value;\n\n            switch (event.type) {\n              case 'deleted':\n                this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\n\n                break;\n\n              case 'inserted':\n                this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\n\n                break;\n\n              case 'flush':\n                this._actual.onFlushed();\n\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      if (this._samplingState) {\n        return this._samplingState.minimapLines.length;\n      }\n\n      return this._context.model.getLineCount();\n    }\n  }, {\n    key: \"getRealLineCount\",\n    value: function getRealLineCount() {\n      return this._context.model.getLineCount();\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      if (this._samplingState) {\n        return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\n      }\n\n      return this._context.model.getLineContent(lineNumber);\n    }\n  }, {\n    key: \"getMinimapLinesRenderingData\",\n    value: function getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n      if (this._samplingState) {\n        var result = [];\n\n        for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n          if (needed[lineIndex]) {\n            result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\n          } else {\n            result[lineIndex] = null;\n          }\n        }\n\n        return result;\n      }\n\n      return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\n    }\n  }, {\n    key: \"getSelections\",\n    value: function getSelections() {\n      if (this._minimapSelections === null) {\n        if (this._samplingState) {\n          this._minimapSelections = [];\n\n          var _iterator3 = _createForOfIteratorHelper(this._selections),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var selection = _step3.value;\n\n              var _this$_samplingState$3 = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber),\n                  _this$_samplingState$4 = _slicedToArray(_this$_samplingState$3, 2),\n                  minimapLineStart = _this$_samplingState$4[0],\n                  minimapLineEnd = _this$_samplingState$4[1];\n\n              this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          this._minimapSelections = this._selections;\n        }\n      }\n\n      return this._minimapSelections;\n    }\n  }, {\n    key: \"getMinimapDecorationsInViewport\",\n    value: function getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\n      var visibleRange;\n\n      if (this._samplingState) {\n        var modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\n        var modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\n        visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\n      } else {\n        visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\n      }\n\n      var decorations = this._context.model.getDecorationsInViewport(visibleRange);\n\n      if (this._samplingState) {\n        var result = [];\n\n        var _iterator4 = _createForOfIteratorHelper(decorations),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var decoration = _step4.value;\n\n            if (!decoration.options.minimap) {\n              continue;\n            }\n\n            var range = decoration.range;\n\n            var minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\n\n            var minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\n\n            result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return result;\n      }\n\n      return decorations;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this._context.model.getTextModelOptions();\n    }\n  }, {\n    key: \"revealLineNumber\",\n    value: function revealLineNumber(lineNumber) {\n      if (this._samplingState) {\n        lineNumber = this._samplingState.minimapLines[lineNumber - 1];\n      }\n\n      this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1\n      /* Center */\n      , 0\n      /* Smooth */\n      );\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(scrollTop) {\n      this._context.model.setScrollPosition({\n        scrollTop: scrollTop\n      }, 1\n      /* Immediate */\n      );\n    }\n  }]);\n\n  return Minimap;\n}(ViewPart);\n\nvar InnerMinimap = /*#__PURE__*/function (_Disposable) {\n  _inherits(InnerMinimap, _Disposable);\n\n  var _super2 = _createSuper(InnerMinimap);\n\n  function InnerMinimap(theme, model) {\n    var _this3;\n\n    _classCallCheck(this, InnerMinimap);\n\n    _this3 = _super2.call(this);\n    _this3._renderDecorations = false;\n    _this3._gestureInProgress = false;\n    _this3._theme = theme;\n    _this3._model = model;\n    _this3._lastRenderData = null;\n    _this3._buffers = null;\n    _this3._selectionColor = _this3._theme.getColor(minimapSelection);\n    _this3._domNode = createFastDomNode(document.createElement('div'));\n    PartFingerprints.write(_this3._domNode, 8\n    /* Minimap */\n    );\n\n    _this3._domNode.setClassName(_this3._getMinimapDomNodeClassName());\n\n    _this3._domNode.setPosition('absolute');\n\n    _this3._domNode.setAttribute('role', 'presentation');\n\n    _this3._domNode.setAttribute('aria-hidden', 'true');\n\n    _this3._shadow = createFastDomNode(document.createElement('div'));\n\n    _this3._shadow.setClassName('minimap-shadow-hidden');\n\n    _this3._domNode.appendChild(_this3._shadow);\n\n    _this3._canvas = createFastDomNode(document.createElement('canvas'));\n\n    _this3._canvas.setPosition('absolute');\n\n    _this3._canvas.setLeft(0);\n\n    _this3._domNode.appendChild(_this3._canvas);\n\n    _this3._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\n\n    _this3._decorationsCanvas.setPosition('absolute');\n\n    _this3._decorationsCanvas.setClassName('minimap-decorations-layer');\n\n    _this3._decorationsCanvas.setLeft(0);\n\n    _this3._domNode.appendChild(_this3._decorationsCanvas);\n\n    _this3._slider = createFastDomNode(document.createElement('div'));\n\n    _this3._slider.setPosition('absolute');\n\n    _this3._slider.setClassName('minimap-slider');\n\n    _this3._slider.setLayerHinting(true);\n\n    _this3._slider.setContain('strict');\n\n    _this3._domNode.appendChild(_this3._slider);\n\n    _this3._sliderHorizontal = createFastDomNode(document.createElement('div'));\n\n    _this3._sliderHorizontal.setPosition('absolute');\n\n    _this3._sliderHorizontal.setClassName('minimap-slider-horizontal');\n\n    _this3._slider.appendChild(_this3._sliderHorizontal);\n\n    _this3._applyLayout();\n\n    _this3._mouseDownListener = dom.addStandardDisposableListener(_this3._domNode.domNode, 'mousedown', function (e) {\n      e.preventDefault();\n      var renderMinimap = _this3._model.options.renderMinimap;\n\n      if (renderMinimap === 0\n      /* None */\n      ) {\n          return;\n        }\n\n      if (!_this3._lastRenderData) {\n        return;\n      }\n\n      if (_this3._model.options.size !== 'proportional') {\n        if (e.leftButton && _this3._lastRenderData) {\n          // pretend the click occured in the center of the slider\n          var position = dom.getDomNodePagePosition(_this3._slider.domNode);\n          var initialPosY = position.top + position.height / 2;\n\n          _this3._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, _this3._lastRenderData.renderedLayout);\n        }\n\n        return;\n      }\n\n      var minimapLineHeight = _this3._model.options.minimapLineHeight;\n      var internalOffsetY = _this3._model.options.canvasInnerHeight / _this3._model.options.canvasOuterHeight * e.browserEvent.offsetY;\n      var lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\n      var lineNumber = lineIndex + _this3._lastRenderData.renderedLayout.startLineNumber;\n      lineNumber = Math.min(lineNumber, _this3._model.getLineCount());\n\n      _this3._model.revealLineNumber(lineNumber);\n    });\n    _this3._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\n    _this3._sliderMouseDownListener = dom.addStandardDisposableListener(_this3._slider.domNode, 'mousedown', function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (e.leftButton && _this3._lastRenderData) {\n        _this3._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, _this3._lastRenderData.renderedLayout);\n      }\n    });\n    _this3._gestureDisposable = Gesture.addTarget(_this3._domNode.domNode);\n    _this3._sliderTouchStartListener = dom.addDisposableListener(_this3._domNode.domNode, EventType.Start, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (_this3._lastRenderData) {\n        _this3._slider.toggleClassName('active', true);\n\n        _this3._gestureInProgress = true;\n\n        _this3.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    _this3._sliderTouchMoveListener = dom.addDisposableListener(_this3._domNode.domNode, EventType.Change, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (_this3._lastRenderData && _this3._gestureInProgress) {\n        _this3.scrollDueToTouchEvent(e);\n      }\n    }, {\n      passive: false\n    });\n    _this3._sliderTouchEndListener = dom.addStandardDisposableListener(_this3._domNode.domNode, EventType.End, function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      _this3._gestureInProgress = false;\n\n      _this3._slider.toggleClassName('active', false);\n    });\n    return _this3;\n  }\n\n  _createClass(InnerMinimap, [{\n    key: \"_startSliderDragging\",\n    value: function _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\n      var _this4 = this;\n\n      this._slider.toggleClassName('active', true);\n\n      var handleMouseMove = function handleMouseMove(posy, posx) {\n        var mouseOrthogonalDelta = Math.abs(posx - initialPosX);\n\n        if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\n          // The mouse has wondered away from the scrollbar => reset dragging\n          _this4._model.setScrollTop(initialSliderState.scrollTop);\n\n          return;\n        }\n\n        var mouseDelta = posy - initialPosY;\n\n        _this4._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\n      };\n\n      if (posy !== initialPosY) {\n        handleMouseMove(posy, initialPosX);\n      }\n\n      this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, function (mouseMoveData) {\n        return handleMouseMove(mouseMoveData.posy, mouseMoveData.posx);\n      }, function () {\n        _this4._slider.toggleClassName('active', false);\n      });\n    }\n  }, {\n    key: \"scrollDueToTouchEvent\",\n    value: function scrollDueToTouchEvent(touch) {\n      var startY = this._domNode.domNode.getBoundingClientRect().top;\n\n      var scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\n\n      this._model.setScrollTop(scrollTop);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._mouseDownListener.dispose();\n\n      this._sliderMouseMoveMonitor.dispose();\n\n      this._sliderMouseDownListener.dispose();\n\n      this._gestureDisposable.dispose();\n\n      this._sliderTouchStartListener.dispose();\n\n      this._sliderTouchMoveListener.dispose();\n\n      this._sliderTouchEndListener.dispose();\n\n      _get2(_getPrototypeOf(InnerMinimap.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"_getMinimapDomNodeClassName\",\n    value: function _getMinimapDomNodeClassName() {\n      if (this._model.options.showSlider === 'always') {\n        return 'minimap slider-always';\n      }\n\n      return 'minimap slider-mouseover';\n    }\n  }, {\n    key: \"getDomNode\",\n    value: function getDomNode() {\n      return this._domNode;\n    }\n  }, {\n    key: \"_applyLayout\",\n    value: function _applyLayout() {\n      this._domNode.setLeft(this._model.options.minimapLeft);\n\n      this._domNode.setWidth(this._model.options.minimapWidth);\n\n      this._domNode.setHeight(this._model.options.minimapHeight);\n\n      this._shadow.setHeight(this._model.options.minimapHeight);\n\n      this._canvas.setWidth(this._model.options.canvasOuterWidth);\n\n      this._canvas.setHeight(this._model.options.canvasOuterHeight);\n\n      this._canvas.domNode.width = this._model.options.canvasInnerWidth;\n      this._canvas.domNode.height = this._model.options.canvasInnerHeight;\n\n      this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\n\n      this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\n\n      this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\n      this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\n\n      this._slider.setWidth(this._model.options.minimapWidth);\n    }\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer() {\n      if (!this._buffers) {\n        if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\n          this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\n        }\n      }\n\n      return this._buffers ? this._buffers.getBuffer() : null;\n    } // ---- begin view event handlers\n\n  }, {\n    key: \"onDidChangeOptions\",\n    value: function onDidChangeOptions() {\n      this._lastRenderData = null;\n      this._buffers = null;\n\n      this._applyLayout();\n\n      this._domNode.setClassName(this._getMinimapDomNodeClassName());\n    }\n  }, {\n    key: \"onSelectionChanged\",\n    value: function onSelectionChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onDecorationsChanged\",\n    value: function onDecorationsChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed() {\n      this._lastRenderData = null;\n      return true;\n    }\n  }, {\n    key: \"onLinesChanged\",\n    value: function onLinesChanged(changeFromLineNumber, changeToLineNumber) {\n      if (this._lastRenderData) {\n        return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\n      if (this._lastRenderData) {\n        this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(insertFromLineNumber, insertToLineNumber) {\n      if (this._lastRenderData) {\n        this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"onScrollChanged\",\n    value: function onScrollChanged() {\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onThemeChanged\",\n    value: function onThemeChanged() {\n      this._selectionColor = this._theme.getColor(minimapSelection);\n      this._renderDecorations = true;\n      return true;\n    }\n  }, {\n    key: \"onTokensChanged\",\n    value: function onTokensChanged(ranges) {\n      if (this._lastRenderData) {\n        return this._lastRenderData.onTokensChanged(ranges);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onTokensColorsChanged\",\n    value: function onTokensColorsChanged() {\n      this._lastRenderData = null;\n      this._buffers = null;\n      return true;\n    }\n  }, {\n    key: \"onZonesChanged\",\n    value: function onZonesChanged() {\n      this._lastRenderData = null;\n      return true;\n    } // --- end event handlers\n\n  }, {\n    key: \"render\",\n    value: function render(renderingCtx) {\n      var renderMinimap = this._model.options.renderMinimap;\n\n      if (renderMinimap === 0\n      /* None */\n      ) {\n          this._shadow.setClassName('minimap-shadow-hidden');\n\n          this._sliderHorizontal.setWidth(0);\n\n          this._sliderHorizontal.setHeight(0);\n\n          return;\n        }\n\n      if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\n        this._shadow.setClassName('minimap-shadow-hidden');\n      } else {\n        this._shadow.setClassName('minimap-shadow-visible');\n      }\n\n      var layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\n\n      this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\n\n      this._slider.setTop(layout.sliderTop);\n\n      this._slider.setHeight(layout.sliderHeight); // Compute horizontal slider coordinates\n\n\n      var scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;\n      var horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));\n\n      this._sliderHorizontal.setLeft(horizontalSliderLeft);\n\n      this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);\n\n      this._sliderHorizontal.setTop(0);\n\n      this._sliderHorizontal.setHeight(layout.sliderHeight);\n\n      this.renderDecorations(layout);\n      this._lastRenderData = this.renderLines(layout);\n    }\n  }, {\n    key: \"renderDecorations\",\n    value: function renderDecorations(layout) {\n      if (this._renderDecorations) {\n        this._renderDecorations = false;\n\n        var selections = this._model.getSelections();\n\n        var decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\n\n        var _this$_model$options = this._model.options,\n            canvasInnerWidth = _this$_model$options.canvasInnerWidth,\n            canvasInnerHeight = _this$_model$options.canvasInnerHeight;\n        var lineHeight = this._model.options.minimapLineHeight;\n        var characterWidth = this._model.options.minimapCharWidth;\n\n        var tabSize = this._model.getOptions().tabSize;\n\n        var canvasContext = this._decorationsCanvas.domNode.getContext('2d');\n\n        canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\n        var lineOffsetMap = new Map();\n\n        for (var i = 0; i < selections.length; i++) {\n          var selection = selections[i];\n\n          for (var line = selection.startLineNumber; line <= selection.endLineNumber; line++) {\n            this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\n          }\n        } // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\n\n\n        for (var _i2 = 0; _i2 < decorations.length; _i2++) {\n          var decoration = decorations[_i2];\n\n          if (!decoration.options.minimap) {\n            continue;\n          }\n\n          var decorationColor = decoration.options.minimap.getColor(this._theme);\n\n          for (var _line = decoration.range.startLineNumber; _line <= decoration.range.endLineNumber; _line++) {\n            switch (decoration.options.minimap.position) {\n              case MinimapPosition.Inline:\n                this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, _line, lineHeight, lineHeight, tabSize, characterWidth);\n                continue;\n\n              case MinimapPosition.Gutter:\n                var y = (_line - layout.startLineNumber) * lineHeight;\n                var x = 2;\n                this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\n                continue;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"renderDecorationOnLine\",\n    value: function renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\n      var y = (lineNumber - layout.startLineNumber) * lineHeight; // Skip rendering the line if it's vertically outside our viewport\n\n      if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\n        return;\n      } // Cache line offset data so that it is only read once per line\n\n\n      var lineIndexToXOffset = lineOffsetMap.get(lineNumber);\n      var isFirstDecorationForLine = !lineIndexToXOffset;\n\n      if (!lineIndexToXOffset) {\n        var lineData = this._model.getLineContent(lineNumber);\n\n        lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\n\n        for (var i = 1; i < lineData.length + 1; i++) {\n          var charCode = lineData.charCodeAt(i - 1);\n          var dx = charCode === 9\n          /* Tab */\n          ? tabSize * charWidth : strings.isFullWidthCharacter(charCode) ? 2 * charWidth : charWidth;\n          lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\n        }\n\n        lineOffsetMap.set(lineNumber, lineIndexToXOffset);\n      }\n\n      var startColumn = decorationRange.startColumn,\n          endColumn = decorationRange.endColumn,\n          startLineNumber = decorationRange.startLineNumber,\n          endLineNumber = decorationRange.endLineNumber;\n      var x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;\n      var endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\n\n      if (endColumnForLine > 0) {\n        // If the decoration starts at the last character of the column and spans over it, ensure it has a width\n        var width = lineIndexToXOffset[endColumnForLine] - x || 2;\n        this.renderDecoration(canvasContext, decorationColor, x, y, width, height);\n      }\n\n      if (isFirstDecorationForLine) {\n        this.renderLineHighlight(canvasContext, decorationColor, y, height);\n      }\n    }\n  }, {\n    key: \"renderLineHighlight\",\n    value: function renderLineHighlight(canvasContext, decorationColor, y, height) {\n      canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\n      canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);\n    }\n  }, {\n    key: \"renderDecoration\",\n    value: function renderDecoration(canvasContext, decorationColor, x, y, width, height) {\n      canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\n      canvasContext.fillRect(x, y, width, height);\n    }\n  }, {\n    key: \"renderLines\",\n    value: function renderLines(layout) {\n      var startLineNumber = layout.startLineNumber;\n      var endLineNumber = layout.endLineNumber;\n      var minimapLineHeight = this._model.options.minimapLineHeight; // Check if nothing changed w.r.t. lines from last frame\n\n      if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\n        var _lastData = this._lastRenderData._get(); // Nice!! Nothing changed from last frame\n\n\n        return new RenderData(layout, _lastData.imageData, _lastData.lines);\n      } // Oh well!! We need to repaint some lines...\n\n\n      var imageData = this._getBuffer();\n\n      if (!imageData) {\n        // 0 width or 0 height canvas, nothing to do\n        return null;\n      } // Render untouched lines by using last rendered data.\n\n\n      var _InnerMinimap$_render = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData),\n          _InnerMinimap$_render2 = _slicedToArray(_InnerMinimap$_render, 3),\n          _dirtyY1 = _InnerMinimap$_render2[0],\n          _dirtyY2 = _InnerMinimap$_render2[1],\n          needed = _InnerMinimap$_render2[2]; // Fetch rendering info from view model for rest of lines that need rendering.\n\n\n      var lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\n\n      var tabSize = this._model.getOptions().tabSize;\n\n      var background = this._model.options.backgroundColor;\n      var tokensColorTracker = this._model.tokensColorTracker;\n      var useLighterFont = tokensColorTracker.backgroundIsLight();\n      var renderMinimap = this._model.options.renderMinimap;\n\n      var charRenderer = this._model.options.charRenderer();\n\n      var fontScale = this._model.options.fontScale;\n      var minimapCharWidth = this._model.options.minimapCharWidth;\n      var baseCharHeight = renderMinimap === 1\n      /* Text */\n      ? 2\n      /* BASE_CHAR_HEIGHT */\n      : 2\n      /* BASE_CHAR_HEIGHT */\n      + 1;\n      var renderMinimapLineHeight = baseCharHeight * fontScale;\n      var innerLinePadding = minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0; // Render the rest of lines\n\n      var dy = 0;\n      var renderedLines = [];\n\n      for (var lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\n        if (needed[lineIndex]) {\n          InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\n        }\n\n        renderedLines[lineIndex] = new MinimapLine(dy);\n        dy += minimapLineHeight;\n      }\n\n      var dirtyY1 = _dirtyY1 === -1 ? 0 : _dirtyY1;\n      var dirtyY2 = _dirtyY2 === -1 ? imageData.height : _dirtyY2;\n      var dirtyHeight = dirtyY2 - dirtyY1; // Finally, paint to the canvas\n\n      var ctx = this._canvas.domNode.getContext('2d');\n\n      ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight); // Save rendered data for reuse on next frame if possible\n\n      return new RenderData(layout, imageData, renderedLines);\n    }\n  }], [{\n    key: \"_renderUntouchedLines\",\n    value: function _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\n      var needed = [];\n\n      if (!lastRenderData) {\n        for (var i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\n          needed[i] = true;\n        }\n\n        return [-1, -1, needed];\n      }\n\n      var _lastData = lastRenderData._get();\n\n      var lastTargetData = _lastData.imageData.data;\n      var lastStartLineNumber = _lastData.rendLineNumberStart;\n      var lastLines = _lastData.lines;\n      var lastLinesLength = lastLines.length;\n      var WIDTH = target.width;\n      var targetData = target.data;\n      var maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\n      var dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\n\n      var dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\n\n      var copySourceStart = -1;\n      var copySourceEnd = -1;\n      var copyDestStart = -1;\n      var copyDestEnd = -1;\n      var dest_dy = 0;\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var lineIndex = lineNumber - startLineNumber;\n        var lastLineIndex = lineNumber - lastStartLineNumber;\n        var source_dy = lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1;\n\n        if (source_dy === -1) {\n          needed[lineIndex] = true;\n          dest_dy += minimapLineHeight;\n          continue;\n        }\n\n        var sourceStart = source_dy * WIDTH * 4;\n        var sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\n        var destStart = dest_dy * WIDTH * 4;\n        var destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\n\n        if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\n          // contiguous zone => extend copy request\n          copySourceEnd = sourceEnd;\n          copyDestEnd = destEnd;\n        } else {\n          if (copySourceStart !== -1) {\n            // flush existing copy request\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n              dirtyPixel1 = copySourceEnd;\n            }\n\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n              dirtyPixel2 = copySourceStart;\n            }\n          }\n\n          copySourceStart = sourceStart;\n          copySourceEnd = sourceEnd;\n          copyDestStart = destStart;\n          copyDestEnd = destEnd;\n        }\n\n        needed[lineIndex] = false;\n        dest_dy += minimapLineHeight;\n      }\n\n      if (copySourceStart !== -1) {\n        // flush existing copy request\n        targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\n\n        if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\n          dirtyPixel1 = copySourceEnd;\n        }\n\n        if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\n          dirtyPixel2 = copySourceStart;\n        }\n      }\n\n      var dirtyY1 = dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4);\n      var dirtyY2 = dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4);\n      return [dirtyY1, dirtyY2, needed];\n    }\n  }, {\n    key: \"_renderLine\",\n    value: function _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\n      var content = lineData.content;\n      var tokens = lineData.tokens;\n      var maxDx = target.width - charWidth;\n      var force1pxHeight = minimapLineHeight === 1;\n      var dx = MINIMAP_GUTTER_WIDTH;\n      var charIndex = 0;\n      var tabsCharDelta = 0;\n\n      for (var tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        var tokenEndIndex = tokens.getEndOffset(tokenIndex);\n        var tokenColorId = tokens.getForeground(tokenIndex);\n        var tokenColor = colorTracker.getColor(tokenColorId);\n\n        for (; charIndex < tokenEndIndex; charIndex++) {\n          if (dx > maxDx) {\n            // hit edge of minimap\n            return;\n          }\n\n          var charCode = content.charCodeAt(charIndex);\n\n          if (charCode === 9\n          /* Tab */\n          ) {\n              var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n              tabsCharDelta += insertSpacesCount - 1; // No need to render anything since tab is invisible\n\n              dx += insertSpacesCount * charWidth;\n            } else if (charCode === 32\n          /* Space */\n          ) {\n              // No need to render anything since space is invisible\n              dx += charWidth;\n            } else {\n            // Render twice for a full width character\n            var count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\n\n            for (var i = 0; i < count; i++) {\n              if (renderMinimap === 2\n              /* Blocks */\n              ) {\n                  minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);\n                } else {\n                // RenderMinimap.Text\n                minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);\n              }\n\n              dx += charWidth;\n\n              if (dx > maxDx) {\n                // hit edge of minimap\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return InnerMinimap;\n}(Disposable);\n\nregisterThemingParticipant(function (theme, collector) {\n  var minimapBackgroundValue = theme.getColor(minimapBackground);\n\n  if (minimapBackgroundValue) {\n    collector.addRule(\".monaco-editor .minimap > canvas { opacity: \".concat(minimapBackgroundValue.rgba.a, \"; will-change: opacity; }\"));\n  }\n\n  var sliderBackground = theme.getColor(minimapSliderBackground);\n\n  if (sliderBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider .minimap-slider-horizontal { background: \".concat(sliderBackground, \"; }\"));\n  }\n\n  var sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\n\n  if (sliderHoverBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: \".concat(sliderHoverBackground, \"; }\"));\n  }\n\n  var sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\n\n  if (sliderActiveBackground) {\n    collector.addRule(\".monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: \".concat(sliderActiveBackground, \"; }\"));\n  }\n\n  var shadow = theme.getColor(scrollbarShadow);\n\n  if (shadow) {\n    collector.addRule(\".monaco-editor .minimap-shadow-visible { box-shadow: \".concat(shadow, \" -6px 0 6px -6px inset; }\"));\n  }\n});","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/minimap/minimap.js"],"names":["dom","createFastDomNode","GlobalMouseMoveMonitor","standardMouseMoveMerger","Disposable","platform","strings","RenderedLinesCollection","PartFingerprints","ViewPart","MINIMAP_GUTTER_WIDTH","EditorLayoutInfoComputer","Range","RGBA8","MinimapTokensColorTracker","ViewModelDecoration","minimapSelection","scrollbarShadow","minimapBackground","minimapSliderBackground","minimapSliderHoverBackground","minimapSliderActiveBackground","registerThemingParticipant","Selection","EventType","Gesture","MinimapCharRendererFactory","MinimapPosition","once","MOUSE_DRAG_RESET_DISTANCE","GUTTER_DECORATION_WIDTH","MinimapOptions","configuration","theme","tokensColorTracker","options","pixelRatio","get","layoutInfo","minimapLayout","minimap","fontInfo","minimapOpts","renderMinimap","size","minimapHeightIsEditorHeight","scrollBeyondLastLine","showSlider","typicalHalfwidthCharacterWidth","lineHeight","minimapLeft","minimapWidth","minimapHeight","height","canvasInnerWidth","minimapCanvasInnerWidth","canvasInnerHeight","minimapCanvasInnerHeight","canvasOuterWidth","minimapCanvasOuterWidth","canvasOuterHeight","minimapCanvasOuterHeight","isSampling","minimapIsSampling","editorHeight","fontScale","minimapScale","minimapLineHeight","minimapCharWidth","charRenderer","create","fontFamily","backgroundColor","_getMinimapBackground","other","equals","themeColor","getColor","rgba","r","g","b","a","MinimapLayout","scrollTop","scrollHeight","sliderNeeded","computedSliderRatio","sliderTop","sliderHeight","startLineNumber","endLineNumber","_computedSliderRatio","delta","Math","round","pageY","viewportStartLineNumber","viewportEndLineNumber","viewportStartLineNumberVerticalOffset","viewportHeight","viewportContainsWhitespaceGaps","lineCount","realLineCount","previousLayout","minimapLinesFitting","floor","logicalScrollHeight","max","maxMinimapSliderTop","maxLinesFitting","min","viewportLineCount","expectedViewportLineCount","extraLinesAtTheBottom","partialLine","sliderTopAligned","MinimapLine","dy","INVALID","RenderData","renderedLayout","imageData","lines","_imageData","_renderedLines","_set","layout","scrollEquals","tmp","_get","i","len","length","rendLineNumberStart","changeFromLineNumber","changeToLineNumber","onLinesChanged","deleteFromLineNumber","deleteToLineNumber","onLinesDeleted","insertFromLineNumber","insertToLineNumber","onLinesInserted","ranges","onTokensChanged","MinimapBuffers","ctx","WIDTH","HEIGHT","background","_backgroundFillData","_createBackgroundFillData","_buffers","createImageData","_lastUsedBuffer","result","data","set","backgroundR","backgroundG","backgroundB","Uint8ClampedArray","offset","j","MinimapSamplingState","samplingRatio","minimapLines","lineNumber","fromLineNumber","toLineNumber","fromLineIndex","modelLineToMinimapLine","toLineIndex","sampledLineNumber","minimapLineStart","minimapLineEnd","e","deletedLineCount","changeStartIndex","changeEndIndex","insertedLineCount","viewLineCount","oldSamplingState","computeContainedMinimapLineCount","minimapLineCount","ratio","halfRatio","lastIndex","oldMinimapLines","oldLength","oldIndex","oldDeltaLineCount","minViewLineNumber","MAX_EVENT_COUNT","events","lastEvent","fromViewLineNumber","toViewLineNumber","oldMinimapLineNumber","type","_oldIndex","push","selectedViewLineNumber","_i","Minimap","context","getInstance","_selections","_minimapSelections","_context","compute","model","getLineCount","samplingState","_samplingState","_shouldCheckSampling","_actual","InnerMinimap","dispose","getDomNode","opts","_recreateLineSampling","onDidChangeOptions","_onOptionsMaybeChanged","selections","onSelectionChanged","affectsMinimap","onDecorationsChanged","onFlushed","minimapLineRange","modelLineRangeToMinimapLineRange","onScrollChanged","invalidateMinimapColorCache","onThemeChanged","range","onTokensColorsChanged","onZonesChanged","visibleRange","minimapCtx","viewportData","whitespaceViewportData","scrollWidth","getVerticalOffsetForLineNumber","scrollLeft","viewportWidth","render","wasSampling","Boolean","event","getLineContent","needed","lineIndex","getViewLineData","getMinimapLinesRenderingData","selection","decorationLineRangeToMinimapLineRange","startColumn","endColumn","modelStartLineNumber","modelEndLineNumber","getLineMaxColumn","decorations","getDecorationsInViewport","decoration","minimapStartLineNumber","minimapEndLineNumber","getTextModelOptions","revealRange","setScrollPosition","_renderDecorations","_gestureInProgress","_theme","_model","_lastRenderData","_selectionColor","_domNode","document","createElement","write","setClassName","_getMinimapDomNodeClassName","setPosition","setAttribute","_shadow","appendChild","_canvas","setLeft","_decorationsCanvas","_slider","setLayerHinting","setContain","_sliderHorizontal","_applyLayout","_mouseDownListener","addStandardDisposableListener","domNode","preventDefault","leftButton","position","getDomNodePagePosition","initialPosY","top","_startSliderDragging","buttons","posx","posy","internalOffsetY","browserEvent","offsetY","revealLineNumber","_sliderMouseMoveMonitor","_sliderMouseDownListener","stopPropagation","_gestureDisposable","addTarget","_sliderTouchStartListener","addDisposableListener","Start","toggleClassName","scrollDueToTouchEvent","passive","_sliderTouchMoveListener","Change","_sliderTouchEndListener","End","initialButtons","initialPosX","initialSliderState","handleMouseMove","mouseOrthogonalDelta","abs","isWindows","setScrollTop","mouseDelta","getDesiredScrollTopFromDelta","startMonitoring","mouseMoveData","touch","startY","getBoundingClientRect","getDesiredScrollTopFromTouchLocation","setWidth","setHeight","width","getContext","getBuffer","renderingCtx","getRealLineCount","setDisplay","setTop","scrollLeftChars","horizontalSliderLeft","renderDecorations","renderLines","getSelections","getMinimapDecorationsInViewport","characterWidth","tabSize","getOptions","canvasContext","clearRect","lineOffsetMap","Map","line","renderDecorationOnLine","decorationColor","Inline","Gutter","y","x","renderDecoration","decorationRange","charWidth","lineIndexToXOffset","isFirstDecorationForLine","lineData","charCode","charCodeAt","dx","isFullWidthCharacter","endColumnForLine","renderLineHighlight","fillStyle","transparent","toString","fillRect","canvas","linesEquals","_lastData","_getBuffer","_renderUntouchedLines","_dirtyY1","_dirtyY2","lineInfo","useLighterFont","backgroundIsLight","baseCharHeight","renderMinimapLineHeight","innerLinePadding","renderedLines","_renderLine","dirtyY1","dirtyY2","dirtyHeight","putImageData","target","lastRenderData","lastTargetData","lastStartLineNumber","lastLines","lastLinesLength","targetData","maxDestPixel","dirtyPixel1","dirtyPixel2","copySourceStart","copySourceEnd","copyDestStart","copyDestEnd","dest_dy","lastLineIndex","source_dy","sourceStart","sourceEnd","destStart","destEnd","subarray","colorTracker","minimapCharRenderer","content","tokens","maxDx","force1pxHeight","charIndex","tabsCharDelta","tokenIndex","tokensLen","getCount","tokenEndIndex","getEndOffset","tokenColorId","getForeground","tokenColor","insertSpacesCount","count","blockRenderChar","renderChar","collector","minimapBackgroundValue","addRule","sliderBackground","sliderHoverBackground","sliderActiveBackground","shadow"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport './minimap.css';\r\nimport * as dom from '../../../../base/browser/dom.js';\r\nimport { createFastDomNode } from '../../../../base/browser/fastDomNode.js';\r\nimport { GlobalMouseMoveMonitor, standardMouseMoveMerger } from '../../../../base/browser/globalMouseMoveMonitor.js';\r\nimport { Disposable } from '../../../../base/common/lifecycle.js';\r\nimport * as platform from '../../../../base/common/platform.js';\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { RenderedLinesCollection } from '../../view/viewLayer.js';\r\nimport { PartFingerprints, ViewPart } from '../../view/viewPart.js';\r\nimport { MINIMAP_GUTTER_WIDTH, EditorLayoutInfoComputer } from '../../../common/config/editorOptions.js';\r\nimport { Range } from '../../../common/core/range.js';\r\nimport { RGBA8 } from '../../../common/core/rgba.js';\r\nimport { MinimapTokensColorTracker } from '../../../common/viewModel/minimapTokensColorTracker.js';\r\nimport { ViewModelDecoration } from '../../../common/viewModel/viewModel.js';\r\nimport { minimapSelection, scrollbarShadow, minimapBackground, minimapSliderBackground, minimapSliderHoverBackground, minimapSliderActiveBackground } from '../../../../platform/theme/common/colorRegistry.js';\r\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\r\nimport { Selection } from '../../../common/core/selection.js';\r\nimport { EventType, Gesture } from '../../../../base/browser/touch.js';\r\nimport { MinimapCharRendererFactory } from './minimapCharRendererFactory.js';\r\nimport { MinimapPosition } from '../../../common/model.js';\r\nimport { once } from '../../../../base/common/functional.js';\r\n/**\r\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\r\n */\r\nconst MOUSE_DRAG_RESET_DISTANCE = 140;\r\nconst GUTTER_DECORATION_WIDTH = 2;\r\nclass MinimapOptions {\r\n    constructor(configuration, theme, tokensColorTracker) {\r\n        const options = configuration.options;\r\n        const pixelRatio = options.get(122 /* pixelRatio */);\r\n        const layoutInfo = options.get(124 /* layoutInfo */);\r\n        const minimapLayout = layoutInfo.minimap;\r\n        const fontInfo = options.get(38 /* fontInfo */);\r\n        const minimapOpts = options.get(59 /* minimap */);\r\n        this.renderMinimap = minimapLayout.renderMinimap;\r\n        this.size = minimapOpts.size;\r\n        this.minimapHeightIsEditorHeight = minimapLayout.minimapHeightIsEditorHeight;\r\n        this.scrollBeyondLastLine = options.get(89 /* scrollBeyondLastLine */);\r\n        this.showSlider = minimapOpts.showSlider;\r\n        this.pixelRatio = pixelRatio;\r\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\r\n        this.lineHeight = options.get(53 /* lineHeight */);\r\n        this.minimapLeft = minimapLayout.minimapLeft;\r\n        this.minimapWidth = minimapLayout.minimapWidth;\r\n        this.minimapHeight = layoutInfo.height;\r\n        this.canvasInnerWidth = minimapLayout.minimapCanvasInnerWidth;\r\n        this.canvasInnerHeight = minimapLayout.minimapCanvasInnerHeight;\r\n        this.canvasOuterWidth = minimapLayout.minimapCanvasOuterWidth;\r\n        this.canvasOuterHeight = minimapLayout.minimapCanvasOuterHeight;\r\n        this.isSampling = minimapLayout.minimapIsSampling;\r\n        this.editorHeight = layoutInfo.height;\r\n        this.fontScale = minimapLayout.minimapScale;\r\n        this.minimapLineHeight = minimapLayout.minimapLineHeight;\r\n        this.minimapCharWidth = 1 /* BASE_CHAR_WIDTH */ * this.fontScale;\r\n        this.charRenderer = once(() => MinimapCharRendererFactory.create(this.fontScale, fontInfo.fontFamily));\r\n        this.backgroundColor = MinimapOptions._getMinimapBackground(theme, tokensColorTracker);\r\n    }\r\n    static _getMinimapBackground(theme, tokensColorTracker) {\r\n        const themeColor = theme.getColor(minimapBackground);\r\n        if (themeColor) {\r\n            return new RGBA8(themeColor.rgba.r, themeColor.rgba.g, themeColor.rgba.b, themeColor.rgba.a);\r\n        }\r\n        return tokensColorTracker.getColor(2 /* DefaultBackground */);\r\n    }\r\n    equals(other) {\r\n        return (this.renderMinimap === other.renderMinimap\r\n            && this.size === other.size\r\n            && this.minimapHeightIsEditorHeight === other.minimapHeightIsEditorHeight\r\n            && this.scrollBeyondLastLine === other.scrollBeyondLastLine\r\n            && this.showSlider === other.showSlider\r\n            && this.pixelRatio === other.pixelRatio\r\n            && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth\r\n            && this.lineHeight === other.lineHeight\r\n            && this.minimapLeft === other.minimapLeft\r\n            && this.minimapWidth === other.minimapWidth\r\n            && this.minimapHeight === other.minimapHeight\r\n            && this.canvasInnerWidth === other.canvasInnerWidth\r\n            && this.canvasInnerHeight === other.canvasInnerHeight\r\n            && this.canvasOuterWidth === other.canvasOuterWidth\r\n            && this.canvasOuterHeight === other.canvasOuterHeight\r\n            && this.isSampling === other.isSampling\r\n            && this.editorHeight === other.editorHeight\r\n            && this.fontScale === other.fontScale\r\n            && this.minimapLineHeight === other.minimapLineHeight\r\n            && this.minimapCharWidth === other.minimapCharWidth\r\n            && this.backgroundColor && this.backgroundColor.equals(other.backgroundColor));\r\n    }\r\n}\r\nclass MinimapLayout {\r\n    constructor(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber) {\r\n        this.scrollTop = scrollTop;\r\n        this.scrollHeight = scrollHeight;\r\n        this.sliderNeeded = sliderNeeded;\r\n        this._computedSliderRatio = computedSliderRatio;\r\n        this.sliderTop = sliderTop;\r\n        this.sliderHeight = sliderHeight;\r\n        this.startLineNumber = startLineNumber;\r\n        this.endLineNumber = endLineNumber;\r\n    }\r\n    /**\r\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n     */\r\n    getDesiredScrollTopFromDelta(delta) {\r\n        return Math.round(this.scrollTop + delta / this._computedSliderRatio);\r\n    }\r\n    getDesiredScrollTopFromTouchLocation(pageY) {\r\n        return Math.round((pageY - this.sliderHeight / 2) / this._computedSliderRatio);\r\n    }\r\n    static create(options, viewportStartLineNumber, viewportEndLineNumber, viewportStartLineNumberVerticalOffset, viewportHeight, viewportContainsWhitespaceGaps, lineCount, realLineCount, scrollTop, scrollHeight, previousLayout) {\r\n        const pixelRatio = options.pixelRatio;\r\n        const minimapLineHeight = options.minimapLineHeight;\r\n        const minimapLinesFitting = Math.floor(options.canvasInnerHeight / minimapLineHeight);\r\n        const lineHeight = options.lineHeight;\r\n        if (options.minimapHeightIsEditorHeight) {\r\n            const logicalScrollHeight = (realLineCount * options.lineHeight\r\n                + (options.scrollBeyondLastLine ? viewportHeight - options.lineHeight : 0));\r\n            const sliderHeight = Math.max(1, Math.floor(viewportHeight * viewportHeight / logicalScrollHeight));\r\n            const maxMinimapSliderTop = Math.max(0, options.minimapHeight - sliderHeight);\r\n            // The slider can move from 0 to `maxMinimapSliderTop`\r\n            // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\r\n            const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\r\n            const sliderTop = (scrollTop * computedSliderRatio);\r\n            const sliderNeeded = (maxMinimapSliderTop > 0);\r\n            const maxLinesFitting = Math.floor(options.canvasInnerHeight / options.minimapLineHeight);\r\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, 1, Math.min(lineCount, maxLinesFitting));\r\n        }\r\n        // The visible line count in a viewport can change due to a number of reasons:\r\n        //  a) with the same viewport width, different scroll positions can result in partial lines being visible:\r\n        //    e.g. for a line height of 20, and a viewport height of 600\r\n        //          * scrollTop = 0  => visible lines are [1, 30]\r\n        //          * scrollTop = 10 => visible lines are [1, 31] (with lines 1 and 31 partially visible)\r\n        //          * scrollTop = 20 => visible lines are [2, 31]\r\n        //  b) whitespace gaps might make their way in the viewport (which results in a decrease in the visible line count)\r\n        //  c) we could be in the scroll beyond last line case (which also results in a decrease in the visible line count, down to possibly only one line being visible)\r\n        // We must first establish a desirable slider height.\r\n        let sliderHeight;\r\n        if (viewportContainsWhitespaceGaps && viewportEndLineNumber !== lineCount) {\r\n            // case b) from above: there are whitespace gaps in the viewport.\r\n            // In this case, the height of the slider directly reflects the visible line count.\r\n            const viewportLineCount = viewportEndLineNumber - viewportStartLineNumber + 1;\r\n            sliderHeight = Math.floor(viewportLineCount * minimapLineHeight / pixelRatio);\r\n        }\r\n        else {\r\n            // The slider has a stable height\r\n            const expectedViewportLineCount = viewportHeight / lineHeight;\r\n            sliderHeight = Math.floor(expectedViewportLineCount * minimapLineHeight / pixelRatio);\r\n        }\r\n        let maxMinimapSliderTop;\r\n        if (options.scrollBeyondLastLine) {\r\n            // The minimap slider, when dragged all the way down, will contain the last line at its top\r\n            maxMinimapSliderTop = (lineCount - 1) * minimapLineHeight / pixelRatio;\r\n        }\r\n        else {\r\n            // The minimap slider, when dragged all the way down, will contain the last line at its bottom\r\n            maxMinimapSliderTop = Math.max(0, lineCount * minimapLineHeight / pixelRatio - sliderHeight);\r\n        }\r\n        maxMinimapSliderTop = Math.min(options.minimapHeight - sliderHeight, maxMinimapSliderTop);\r\n        // The slider can move from 0 to `maxMinimapSliderTop`\r\n        // in the same way `scrollTop` can move from 0 to `scrollHeight` - `viewportHeight`.\r\n        const computedSliderRatio = (maxMinimapSliderTop) / (scrollHeight - viewportHeight);\r\n        const sliderTop = (scrollTop * computedSliderRatio);\r\n        let extraLinesAtTheBottom = 0;\r\n        if (options.scrollBeyondLastLine) {\r\n            const expectedViewportLineCount = viewportHeight / lineHeight;\r\n            extraLinesAtTheBottom = expectedViewportLineCount - 1;\r\n        }\r\n        if (minimapLinesFitting >= lineCount + extraLinesAtTheBottom) {\r\n            // All lines fit in the minimap\r\n            const startLineNumber = 1;\r\n            const endLineNumber = lineCount;\r\n            const sliderNeeded = (maxMinimapSliderTop > 0);\r\n            return new MinimapLayout(scrollTop, scrollHeight, sliderNeeded, computedSliderRatio, sliderTop, sliderHeight, startLineNumber, endLineNumber);\r\n        }\r\n        else {\r\n            let startLineNumber = Math.max(1, Math.floor(viewportStartLineNumber - sliderTop * pixelRatio / minimapLineHeight));\r\n            // Avoid flickering caused by a partial viewport start line\r\n            // by being consistent w.r.t. the previous layout decision\r\n            if (previousLayout && previousLayout.scrollHeight === scrollHeight) {\r\n                if (previousLayout.scrollTop > scrollTop) {\r\n                    // Scrolling up => never increase `startLineNumber`\r\n                    startLineNumber = Math.min(startLineNumber, previousLayout.startLineNumber);\r\n                }\r\n                if (previousLayout.scrollTop < scrollTop) {\r\n                    // Scrolling down => never decrease `startLineNumber`\r\n                    startLineNumber = Math.max(startLineNumber, previousLayout.startLineNumber);\r\n                }\r\n            }\r\n            const endLineNumber = Math.min(lineCount, startLineNumber + minimapLinesFitting - 1);\r\n            const partialLine = (scrollTop - viewportStartLineNumberVerticalOffset) / lineHeight;\r\n            const sliderTopAligned = (viewportStartLineNumber - startLineNumber + partialLine) * minimapLineHeight / pixelRatio;\r\n            return new MinimapLayout(scrollTop, scrollHeight, true, computedSliderRatio, sliderTopAligned, sliderHeight, startLineNumber, endLineNumber);\r\n        }\r\n    }\r\n}\r\nclass MinimapLine {\r\n    constructor(dy) {\r\n        this.dy = dy;\r\n    }\r\n    onContentChanged() {\r\n        this.dy = -1;\r\n    }\r\n    onTokensChanged() {\r\n        this.dy = -1;\r\n    }\r\n}\r\nMinimapLine.INVALID = new MinimapLine(-1);\r\nclass RenderData {\r\n    constructor(renderedLayout, imageData, lines) {\r\n        this.renderedLayout = renderedLayout;\r\n        this._imageData = imageData;\r\n        this._renderedLines = new RenderedLinesCollection(() => MinimapLine.INVALID);\r\n        this._renderedLines._set(renderedLayout.startLineNumber, lines);\r\n    }\r\n    /**\r\n     * Check if the current RenderData matches accurately the new desired layout and no painting is needed.\r\n     */\r\n    linesEquals(layout) {\r\n        if (!this.scrollEquals(layout)) {\r\n            return false;\r\n        }\r\n        const tmp = this._renderedLines._get();\r\n        const lines = tmp.lines;\r\n        for (let i = 0, len = lines.length; i < len; i++) {\r\n            if (lines[i].dy === -1) {\r\n                // This line is invalid\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Check if the current RenderData matches the new layout's scroll position\r\n     */\r\n    scrollEquals(layout) {\r\n        return this.renderedLayout.startLineNumber === layout.startLineNumber\r\n            && this.renderedLayout.endLineNumber === layout.endLineNumber;\r\n    }\r\n    _get() {\r\n        const tmp = this._renderedLines._get();\r\n        return {\r\n            imageData: this._imageData,\r\n            rendLineNumberStart: tmp.rendLineNumberStart,\r\n            lines: tmp.lines\r\n        };\r\n    }\r\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\r\n        return this._renderedLines.onLinesChanged(changeFromLineNumber, changeToLineNumber);\r\n    }\r\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\r\n        this._renderedLines.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\r\n    }\r\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\r\n        this._renderedLines.onLinesInserted(insertFromLineNumber, insertToLineNumber);\r\n    }\r\n    onTokensChanged(ranges) {\r\n        return this._renderedLines.onTokensChanged(ranges);\r\n    }\r\n}\r\n/**\r\n * Some sort of double buffering.\r\n *\r\n * Keeps two buffers around that will be rotated for painting.\r\n * Always gives a buffer that is filled with the background color.\r\n */\r\nclass MinimapBuffers {\r\n    constructor(ctx, WIDTH, HEIGHT, background) {\r\n        this._backgroundFillData = MinimapBuffers._createBackgroundFillData(WIDTH, HEIGHT, background);\r\n        this._buffers = [\r\n            ctx.createImageData(WIDTH, HEIGHT),\r\n            ctx.createImageData(WIDTH, HEIGHT)\r\n        ];\r\n        this._lastUsedBuffer = 0;\r\n    }\r\n    getBuffer() {\r\n        // rotate buffers\r\n        this._lastUsedBuffer = 1 - this._lastUsedBuffer;\r\n        const result = this._buffers[this._lastUsedBuffer];\r\n        // fill with background color\r\n        result.data.set(this._backgroundFillData);\r\n        return result;\r\n    }\r\n    static _createBackgroundFillData(WIDTH, HEIGHT, background) {\r\n        const backgroundR = background.r;\r\n        const backgroundG = background.g;\r\n        const backgroundB = background.b;\r\n        const result = new Uint8ClampedArray(WIDTH * HEIGHT * 4);\r\n        let offset = 0;\r\n        for (let i = 0; i < HEIGHT; i++) {\r\n            for (let j = 0; j < WIDTH; j++) {\r\n                result[offset] = backgroundR;\r\n                result[offset + 1] = backgroundG;\r\n                result[offset + 2] = backgroundB;\r\n                result[offset + 3] = 255;\r\n                offset += 4;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass MinimapSamplingState {\r\n    constructor(samplingRatio, minimapLines) {\r\n        this.samplingRatio = samplingRatio;\r\n        this.minimapLines = minimapLines;\r\n    }\r\n    static compute(options, viewLineCount, oldSamplingState) {\r\n        if (options.renderMinimap === 0 /* None */ || !options.isSampling) {\r\n            return [null, []];\r\n        }\r\n        // ratio is intentionally not part of the layout to avoid the layout changing all the time\r\n        // so we need to recompute it again...\r\n        const pixelRatio = options.pixelRatio;\r\n        const lineHeight = options.lineHeight;\r\n        const scrollBeyondLastLine = options.scrollBeyondLastLine;\r\n        const { minimapLineCount } = EditorLayoutInfoComputer.computeContainedMinimapLineCount({\r\n            viewLineCount: viewLineCount,\r\n            scrollBeyondLastLine: scrollBeyondLastLine,\r\n            height: options.editorHeight,\r\n            lineHeight: lineHeight,\r\n            pixelRatio: pixelRatio\r\n        });\r\n        const ratio = viewLineCount / minimapLineCount;\r\n        const halfRatio = ratio / 2;\r\n        if (!oldSamplingState || oldSamplingState.minimapLines.length === 0) {\r\n            let result = [];\r\n            result[0] = 1;\r\n            if (minimapLineCount > 1) {\r\n                for (let i = 0, lastIndex = minimapLineCount - 1; i < lastIndex; i++) {\r\n                    result[i] = Math.round(i * ratio + halfRatio);\r\n                }\r\n                result[minimapLineCount - 1] = viewLineCount;\r\n            }\r\n            return [new MinimapSamplingState(ratio, result), []];\r\n        }\r\n        const oldMinimapLines = oldSamplingState.minimapLines;\r\n        const oldLength = oldMinimapLines.length;\r\n        let result = [];\r\n        let oldIndex = 0;\r\n        let oldDeltaLineCount = 0;\r\n        let minViewLineNumber = 1;\r\n        const MAX_EVENT_COUNT = 10; // generate at most 10 events, if there are more than 10 changes, just flush all previous data\r\n        let events = [];\r\n        let lastEvent = null;\r\n        for (let i = 0; i < minimapLineCount; i++) {\r\n            const fromViewLineNumber = Math.max(minViewLineNumber, Math.round(i * ratio));\r\n            const toViewLineNumber = Math.max(fromViewLineNumber, Math.round((i + 1) * ratio));\r\n            while (oldIndex < oldLength && oldMinimapLines[oldIndex] < fromViewLineNumber) {\r\n                if (events.length < MAX_EVENT_COUNT) {\r\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                    if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\r\n                        lastEvent.deleteToLineNumber++;\r\n                    }\r\n                    else {\r\n                        lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\r\n                        events.push(lastEvent);\r\n                    }\r\n                    oldDeltaLineCount--;\r\n                }\r\n                oldIndex++;\r\n            }\r\n            let selectedViewLineNumber;\r\n            if (oldIndex < oldLength && oldMinimapLines[oldIndex] <= toViewLineNumber) {\r\n                // reuse the old sampled line\r\n                selectedViewLineNumber = oldMinimapLines[oldIndex];\r\n                oldIndex++;\r\n            }\r\n            else {\r\n                if (i === 0) {\r\n                    selectedViewLineNumber = 1;\r\n                }\r\n                else if (i + 1 === minimapLineCount) {\r\n                    selectedViewLineNumber = viewLineCount;\r\n                }\r\n                else {\r\n                    selectedViewLineNumber = Math.round(i * ratio + halfRatio);\r\n                }\r\n                if (events.length < MAX_EVENT_COUNT) {\r\n                    const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                    if (lastEvent && lastEvent.type === 'inserted' && lastEvent._i === i - 1) {\r\n                        lastEvent.insertToLineNumber++;\r\n                    }\r\n                    else {\r\n                        lastEvent = { type: 'inserted', _i: i, insertFromLineNumber: oldMinimapLineNumber, insertToLineNumber: oldMinimapLineNumber };\r\n                        events.push(lastEvent);\r\n                    }\r\n                    oldDeltaLineCount++;\r\n                }\r\n            }\r\n            result[i] = selectedViewLineNumber;\r\n            minViewLineNumber = selectedViewLineNumber;\r\n        }\r\n        if (events.length < MAX_EVENT_COUNT) {\r\n            while (oldIndex < oldLength) {\r\n                const oldMinimapLineNumber = oldIndex + 1 + oldDeltaLineCount;\r\n                if (lastEvent && lastEvent.type === 'deleted' && lastEvent._oldIndex === oldIndex - 1) {\r\n                    lastEvent.deleteToLineNumber++;\r\n                }\r\n                else {\r\n                    lastEvent = { type: 'deleted', _oldIndex: oldIndex, deleteFromLineNumber: oldMinimapLineNumber, deleteToLineNumber: oldMinimapLineNumber };\r\n                    events.push(lastEvent);\r\n                }\r\n                oldDeltaLineCount--;\r\n                oldIndex++;\r\n            }\r\n        }\r\n        else {\r\n            // too many events, just give up\r\n            events = [{ type: 'flush' }];\r\n        }\r\n        return [new MinimapSamplingState(ratio, result), events];\r\n    }\r\n    modelLineToMinimapLine(lineNumber) {\r\n        return Math.min(this.minimapLines.length, Math.max(1, Math.round(lineNumber / this.samplingRatio)));\r\n    }\r\n    /**\r\n     * Will return null if the model line ranges are not intersecting with a sampled model line.\r\n     */\r\n    modelLineRangeToMinimapLineRange(fromLineNumber, toLineNumber) {\r\n        let fromLineIndex = this.modelLineToMinimapLine(fromLineNumber) - 1;\r\n        while (fromLineIndex > 0 && this.minimapLines[fromLineIndex - 1] >= fromLineNumber) {\r\n            fromLineIndex--;\r\n        }\r\n        let toLineIndex = this.modelLineToMinimapLine(toLineNumber) - 1;\r\n        while (toLineIndex + 1 < this.minimapLines.length && this.minimapLines[toLineIndex + 1] <= toLineNumber) {\r\n            toLineIndex++;\r\n        }\r\n        if (fromLineIndex === toLineIndex) {\r\n            const sampledLineNumber = this.minimapLines[fromLineIndex];\r\n            if (sampledLineNumber < fromLineNumber || sampledLineNumber > toLineNumber) {\r\n                // This line is not part of the sampled lines ==> nothing to do\r\n                return null;\r\n            }\r\n        }\r\n        return [fromLineIndex + 1, toLineIndex + 1];\r\n    }\r\n    /**\r\n     * Will always return a range, even if it is not intersecting with a sampled model line.\r\n     */\r\n    decorationLineRangeToMinimapLineRange(startLineNumber, endLineNumber) {\r\n        let minimapLineStart = this.modelLineToMinimapLine(startLineNumber);\r\n        let minimapLineEnd = this.modelLineToMinimapLine(endLineNumber);\r\n        if (startLineNumber !== endLineNumber && minimapLineEnd === minimapLineStart) {\r\n            if (minimapLineEnd === this.minimapLines.length) {\r\n                if (minimapLineStart > 1) {\r\n                    minimapLineStart--;\r\n                }\r\n            }\r\n            else {\r\n                minimapLineEnd++;\r\n            }\r\n        }\r\n        return [minimapLineStart, minimapLineEnd];\r\n    }\r\n    onLinesDeleted(e) {\r\n        // have the mapping be sticky\r\n        const deletedLineCount = e.toLineNumber - e.fromLineNumber + 1;\r\n        let changeStartIndex = this.minimapLines.length;\r\n        let changeEndIndex = 0;\r\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\r\n            if (this.minimapLines[i] < e.fromLineNumber) {\r\n                break;\r\n            }\r\n            if (this.minimapLines[i] <= e.toLineNumber) {\r\n                // this line got deleted => move to previous available\r\n                this.minimapLines[i] = Math.max(1, e.fromLineNumber - 1);\r\n                changeStartIndex = Math.min(changeStartIndex, i);\r\n                changeEndIndex = Math.max(changeEndIndex, i);\r\n            }\r\n            else {\r\n                this.minimapLines[i] -= deletedLineCount;\r\n            }\r\n        }\r\n        return [changeStartIndex, changeEndIndex];\r\n    }\r\n    onLinesInserted(e) {\r\n        // have the mapping be sticky\r\n        const insertedLineCount = e.toLineNumber - e.fromLineNumber + 1;\r\n        for (let i = this.minimapLines.length - 1; i >= 0; i--) {\r\n            if (this.minimapLines[i] < e.fromLineNumber) {\r\n                break;\r\n            }\r\n            this.minimapLines[i] += insertedLineCount;\r\n        }\r\n    }\r\n}\r\nexport class Minimap extends ViewPart {\r\n    constructor(context) {\r\n        super(context);\r\n        this.tokensColorTracker = MinimapTokensColorTracker.getInstance();\r\n        this._selections = [];\r\n        this._minimapSelections = null;\r\n        this.options = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\r\n        const [samplingState,] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), null);\r\n        this._samplingState = samplingState;\r\n        this._shouldCheckSampling = false;\r\n        this._actual = new InnerMinimap(context.theme, this);\r\n    }\r\n    dispose() {\r\n        this._actual.dispose();\r\n        super.dispose();\r\n    }\r\n    getDomNode() {\r\n        return this._actual.getDomNode();\r\n    }\r\n    _onOptionsMaybeChanged() {\r\n        const opts = new MinimapOptions(this._context.configuration, this._context.theme, this.tokensColorTracker);\r\n        if (this.options.equals(opts)) {\r\n            return false;\r\n        }\r\n        this.options = opts;\r\n        this._recreateLineSampling();\r\n        this._actual.onDidChangeOptions();\r\n        return true;\r\n    }\r\n    // ---- begin view event handlers\r\n    onConfigurationChanged(e) {\r\n        return this._onOptionsMaybeChanged();\r\n    }\r\n    onCursorStateChanged(e) {\r\n        this._selections = e.selections;\r\n        this._minimapSelections = null;\r\n        return this._actual.onSelectionChanged();\r\n    }\r\n    onDecorationsChanged(e) {\r\n        if (e.affectsMinimap) {\r\n            return this._actual.onDecorationsChanged();\r\n        }\r\n        return false;\r\n    }\r\n    onFlushed(e) {\r\n        if (this._samplingState) {\r\n            this._shouldCheckSampling = true;\r\n        }\r\n        return this._actual.onFlushed();\r\n    }\r\n    onLinesChanged(e) {\r\n        if (this._samplingState) {\r\n            const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.toLineNumber);\r\n            if (minimapLineRange) {\r\n                return this._actual.onLinesChanged(minimapLineRange[0], minimapLineRange[1]);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return this._actual.onLinesChanged(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onLinesDeleted(e) {\r\n        if (this._samplingState) {\r\n            const [changeStartIndex, changeEndIndex] = this._samplingState.onLinesDeleted(e);\r\n            if (changeStartIndex <= changeEndIndex) {\r\n                this._actual.onLinesChanged(changeStartIndex + 1, changeEndIndex + 1);\r\n            }\r\n            this._shouldCheckSampling = true;\r\n            return true;\r\n        }\r\n        else {\r\n            return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onLinesInserted(e) {\r\n        if (this._samplingState) {\r\n            this._samplingState.onLinesInserted(e);\r\n            this._shouldCheckSampling = true;\r\n            return true;\r\n        }\r\n        else {\r\n            return this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);\r\n        }\r\n    }\r\n    onScrollChanged(e) {\r\n        return this._actual.onScrollChanged();\r\n    }\r\n    onThemeChanged(e) {\r\n        this._context.model.invalidateMinimapColorCache();\r\n        this._actual.onThemeChanged();\r\n        this._onOptionsMaybeChanged();\r\n        return true;\r\n    }\r\n    onTokensChanged(e) {\r\n        if (this._samplingState) {\r\n            let ranges = [];\r\n            for (const range of e.ranges) {\r\n                const minimapLineRange = this._samplingState.modelLineRangeToMinimapLineRange(range.fromLineNumber, range.toLineNumber);\r\n                if (minimapLineRange) {\r\n                    ranges.push({ fromLineNumber: minimapLineRange[0], toLineNumber: minimapLineRange[1] });\r\n                }\r\n            }\r\n            if (ranges.length) {\r\n                return this._actual.onTokensChanged(ranges);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return this._actual.onTokensChanged(e.ranges);\r\n        }\r\n    }\r\n    onTokensColorsChanged(e) {\r\n        this._onOptionsMaybeChanged();\r\n        return this._actual.onTokensColorsChanged();\r\n    }\r\n    onZonesChanged(e) {\r\n        return this._actual.onZonesChanged();\r\n    }\r\n    // --- end event handlers\r\n    prepareRender(ctx) {\r\n        if (this._shouldCheckSampling) {\r\n            this._shouldCheckSampling = false;\r\n            this._recreateLineSampling();\r\n        }\r\n    }\r\n    render(ctx) {\r\n        let viewportStartLineNumber = ctx.visibleRange.startLineNumber;\r\n        let viewportEndLineNumber = ctx.visibleRange.endLineNumber;\r\n        if (this._samplingState) {\r\n            viewportStartLineNumber = this._samplingState.modelLineToMinimapLine(viewportStartLineNumber);\r\n            viewportEndLineNumber = this._samplingState.modelLineToMinimapLine(viewportEndLineNumber);\r\n        }\r\n        const minimapCtx = {\r\n            viewportContainsWhitespaceGaps: (ctx.viewportData.whitespaceViewportData.length > 0),\r\n            scrollWidth: ctx.scrollWidth,\r\n            scrollHeight: ctx.scrollHeight,\r\n            viewportStartLineNumber: viewportStartLineNumber,\r\n            viewportEndLineNumber: viewportEndLineNumber,\r\n            viewportStartLineNumberVerticalOffset: ctx.getVerticalOffsetForLineNumber(viewportStartLineNumber),\r\n            scrollTop: ctx.scrollTop,\r\n            scrollLeft: ctx.scrollLeft,\r\n            viewportWidth: ctx.viewportWidth,\r\n            viewportHeight: ctx.viewportHeight,\r\n        };\r\n        this._actual.render(minimapCtx);\r\n    }\r\n    //#region IMinimapModel\r\n    _recreateLineSampling() {\r\n        this._minimapSelections = null;\r\n        const wasSampling = Boolean(this._samplingState);\r\n        const [samplingState, events] = MinimapSamplingState.compute(this.options, this._context.model.getLineCount(), this._samplingState);\r\n        this._samplingState = samplingState;\r\n        if (wasSampling && this._samplingState) {\r\n            // was sampling, is sampling\r\n            for (const event of events) {\r\n                switch (event.type) {\r\n                    case 'deleted':\r\n                        this._actual.onLinesDeleted(event.deleteFromLineNumber, event.deleteToLineNumber);\r\n                        break;\r\n                    case 'inserted':\r\n                        this._actual.onLinesInserted(event.insertFromLineNumber, event.insertToLineNumber);\r\n                        break;\r\n                    case 'flush':\r\n                        this._actual.onFlushed();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getLineCount() {\r\n        if (this._samplingState) {\r\n            return this._samplingState.minimapLines.length;\r\n        }\r\n        return this._context.model.getLineCount();\r\n    }\r\n    getRealLineCount() {\r\n        return this._context.model.getLineCount();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        if (this._samplingState) {\r\n            return this._context.model.getLineContent(this._samplingState.minimapLines[lineNumber - 1]);\r\n        }\r\n        return this._context.model.getLineContent(lineNumber);\r\n    }\r\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\r\n        if (this._samplingState) {\r\n            let result = [];\r\n            for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\r\n                if (needed[lineIndex]) {\r\n                    result[lineIndex] = this._context.model.getViewLineData(this._samplingState.minimapLines[startLineNumber + lineIndex - 1]);\r\n                }\r\n                else {\r\n                    result[lineIndex] = null;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        return this._context.model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed).data;\r\n    }\r\n    getSelections() {\r\n        if (this._minimapSelections === null) {\r\n            if (this._samplingState) {\r\n                this._minimapSelections = [];\r\n                for (const selection of this._selections) {\r\n                    const [minimapLineStart, minimapLineEnd] = this._samplingState.decorationLineRangeToMinimapLineRange(selection.startLineNumber, selection.endLineNumber);\r\n                    this._minimapSelections.push(new Selection(minimapLineStart, selection.startColumn, minimapLineEnd, selection.endColumn));\r\n                }\r\n            }\r\n            else {\r\n                this._minimapSelections = this._selections;\r\n            }\r\n        }\r\n        return this._minimapSelections;\r\n    }\r\n    getMinimapDecorationsInViewport(startLineNumber, endLineNumber) {\r\n        let visibleRange;\r\n        if (this._samplingState) {\r\n            const modelStartLineNumber = this._samplingState.minimapLines[startLineNumber - 1];\r\n            const modelEndLineNumber = this._samplingState.minimapLines[endLineNumber - 1];\r\n            visibleRange = new Range(modelStartLineNumber, 1, modelEndLineNumber, this._context.model.getLineMaxColumn(modelEndLineNumber));\r\n        }\r\n        else {\r\n            visibleRange = new Range(startLineNumber, 1, endLineNumber, this._context.model.getLineMaxColumn(endLineNumber));\r\n        }\r\n        const decorations = this._context.model.getDecorationsInViewport(visibleRange);\r\n        if (this._samplingState) {\r\n            let result = [];\r\n            for (const decoration of decorations) {\r\n                if (!decoration.options.minimap) {\r\n                    continue;\r\n                }\r\n                const range = decoration.range;\r\n                const minimapStartLineNumber = this._samplingState.modelLineToMinimapLine(range.startLineNumber);\r\n                const minimapEndLineNumber = this._samplingState.modelLineToMinimapLine(range.endLineNumber);\r\n                result.push(new ViewModelDecoration(new Range(minimapStartLineNumber, range.startColumn, minimapEndLineNumber, range.endColumn), decoration.options));\r\n            }\r\n            return result;\r\n        }\r\n        return decorations;\r\n    }\r\n    getOptions() {\r\n        return this._context.model.getTextModelOptions();\r\n    }\r\n    revealLineNumber(lineNumber) {\r\n        if (this._samplingState) {\r\n            lineNumber = this._samplingState.minimapLines[lineNumber - 1];\r\n        }\r\n        this._context.model.revealRange('mouse', false, new Range(lineNumber, 1, lineNumber, 1), 1 /* Center */, 0 /* Smooth */);\r\n    }\r\n    setScrollTop(scrollTop) {\r\n        this._context.model.setScrollPosition({\r\n            scrollTop: scrollTop\r\n        }, 1 /* Immediate */);\r\n    }\r\n}\r\nclass InnerMinimap extends Disposable {\r\n    constructor(theme, model) {\r\n        super();\r\n        this._renderDecorations = false;\r\n        this._gestureInProgress = false;\r\n        this._theme = theme;\r\n        this._model = model;\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        this._selectionColor = this._theme.getColor(minimapSelection);\r\n        this._domNode = createFastDomNode(document.createElement('div'));\r\n        PartFingerprints.write(this._domNode, 8 /* Minimap */);\r\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\r\n        this._domNode.setPosition('absolute');\r\n        this._domNode.setAttribute('role', 'presentation');\r\n        this._domNode.setAttribute('aria-hidden', 'true');\r\n        this._shadow = createFastDomNode(document.createElement('div'));\r\n        this._shadow.setClassName('minimap-shadow-hidden');\r\n        this._domNode.appendChild(this._shadow);\r\n        this._canvas = createFastDomNode(document.createElement('canvas'));\r\n        this._canvas.setPosition('absolute');\r\n        this._canvas.setLeft(0);\r\n        this._domNode.appendChild(this._canvas);\r\n        this._decorationsCanvas = createFastDomNode(document.createElement('canvas'));\r\n        this._decorationsCanvas.setPosition('absolute');\r\n        this._decorationsCanvas.setClassName('minimap-decorations-layer');\r\n        this._decorationsCanvas.setLeft(0);\r\n        this._domNode.appendChild(this._decorationsCanvas);\r\n        this._slider = createFastDomNode(document.createElement('div'));\r\n        this._slider.setPosition('absolute');\r\n        this._slider.setClassName('minimap-slider');\r\n        this._slider.setLayerHinting(true);\r\n        this._slider.setContain('strict');\r\n        this._domNode.appendChild(this._slider);\r\n        this._sliderHorizontal = createFastDomNode(document.createElement('div'));\r\n        this._sliderHorizontal.setPosition('absolute');\r\n        this._sliderHorizontal.setClassName('minimap-slider-horizontal');\r\n        this._slider.appendChild(this._sliderHorizontal);\r\n        this._applyLayout();\r\n        this._mouseDownListener = dom.addStandardDisposableListener(this._domNode.domNode, 'mousedown', (e) => {\r\n            e.preventDefault();\r\n            const renderMinimap = this._model.options.renderMinimap;\r\n            if (renderMinimap === 0 /* None */) {\r\n                return;\r\n            }\r\n            if (!this._lastRenderData) {\r\n                return;\r\n            }\r\n            if (this._model.options.size !== 'proportional') {\r\n                if (e.leftButton && this._lastRenderData) {\r\n                    // pretend the click occured in the center of the slider\r\n                    const position = dom.getDomNodePagePosition(this._slider.domNode);\r\n                    const initialPosY = position.top + position.height / 2;\r\n                    this._startSliderDragging(e.buttons, e.posx, initialPosY, e.posy, this._lastRenderData.renderedLayout);\r\n                }\r\n                return;\r\n            }\r\n            const minimapLineHeight = this._model.options.minimapLineHeight;\r\n            const internalOffsetY = (this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight) * e.browserEvent.offsetY;\r\n            const lineIndex = Math.floor(internalOffsetY / minimapLineHeight);\r\n            let lineNumber = lineIndex + this._lastRenderData.renderedLayout.startLineNumber;\r\n            lineNumber = Math.min(lineNumber, this._model.getLineCount());\r\n            this._model.revealLineNumber(lineNumber);\r\n        });\r\n        this._sliderMouseMoveMonitor = new GlobalMouseMoveMonitor();\r\n        this._sliderMouseDownListener = dom.addStandardDisposableListener(this._slider.domNode, 'mousedown', (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (e.leftButton && this._lastRenderData) {\r\n                this._startSliderDragging(e.buttons, e.posx, e.posy, e.posy, this._lastRenderData.renderedLayout);\r\n            }\r\n        });\r\n        this._gestureDisposable = Gesture.addTarget(this._domNode.domNode);\r\n        this._sliderTouchStartListener = dom.addDisposableListener(this._domNode.domNode, EventType.Start, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (this._lastRenderData) {\r\n                this._slider.toggleClassName('active', true);\r\n                this._gestureInProgress = true;\r\n                this.scrollDueToTouchEvent(e);\r\n            }\r\n        }, { passive: false });\r\n        this._sliderTouchMoveListener = dom.addDisposableListener(this._domNode.domNode, EventType.Change, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            if (this._lastRenderData && this._gestureInProgress) {\r\n                this.scrollDueToTouchEvent(e);\r\n            }\r\n        }, { passive: false });\r\n        this._sliderTouchEndListener = dom.addStandardDisposableListener(this._domNode.domNode, EventType.End, (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            this._gestureInProgress = false;\r\n            this._slider.toggleClassName('active', false);\r\n        });\r\n    }\r\n    _startSliderDragging(initialButtons, initialPosX, initialPosY, posy, initialSliderState) {\r\n        this._slider.toggleClassName('active', true);\r\n        const handleMouseMove = (posy, posx) => {\r\n            const mouseOrthogonalDelta = Math.abs(posx - initialPosX);\r\n            if (platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {\r\n                // The mouse has wondered away from the scrollbar => reset dragging\r\n                this._model.setScrollTop(initialSliderState.scrollTop);\r\n                return;\r\n            }\r\n            const mouseDelta = posy - initialPosY;\r\n            this._model.setScrollTop(initialSliderState.getDesiredScrollTopFromDelta(mouseDelta));\r\n        };\r\n        if (posy !== initialPosY) {\r\n            handleMouseMove(posy, initialPosX);\r\n        }\r\n        this._sliderMouseMoveMonitor.startMonitoring(this._slider.domNode, initialButtons, standardMouseMoveMerger, (mouseMoveData) => handleMouseMove(mouseMoveData.posy, mouseMoveData.posx), () => {\r\n            this._slider.toggleClassName('active', false);\r\n        });\r\n    }\r\n    scrollDueToTouchEvent(touch) {\r\n        const startY = this._domNode.domNode.getBoundingClientRect().top;\r\n        const scrollTop = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(touch.pageY - startY);\r\n        this._model.setScrollTop(scrollTop);\r\n    }\r\n    dispose() {\r\n        this._mouseDownListener.dispose();\r\n        this._sliderMouseMoveMonitor.dispose();\r\n        this._sliderMouseDownListener.dispose();\r\n        this._gestureDisposable.dispose();\r\n        this._sliderTouchStartListener.dispose();\r\n        this._sliderTouchMoveListener.dispose();\r\n        this._sliderTouchEndListener.dispose();\r\n        super.dispose();\r\n    }\r\n    _getMinimapDomNodeClassName() {\r\n        if (this._model.options.showSlider === 'always') {\r\n            return 'minimap slider-always';\r\n        }\r\n        return 'minimap slider-mouseover';\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    _applyLayout() {\r\n        this._domNode.setLeft(this._model.options.minimapLeft);\r\n        this._domNode.setWidth(this._model.options.minimapWidth);\r\n        this._domNode.setHeight(this._model.options.minimapHeight);\r\n        this._shadow.setHeight(this._model.options.minimapHeight);\r\n        this._canvas.setWidth(this._model.options.canvasOuterWidth);\r\n        this._canvas.setHeight(this._model.options.canvasOuterHeight);\r\n        this._canvas.domNode.width = this._model.options.canvasInnerWidth;\r\n        this._canvas.domNode.height = this._model.options.canvasInnerHeight;\r\n        this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth);\r\n        this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight);\r\n        this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth;\r\n        this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight;\r\n        this._slider.setWidth(this._model.options.minimapWidth);\r\n    }\r\n    _getBuffer() {\r\n        if (!this._buffers) {\r\n            if (this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0) {\r\n                this._buffers = new MinimapBuffers(this._canvas.domNode.getContext('2d'), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor);\r\n            }\r\n        }\r\n        return this._buffers ? this._buffers.getBuffer() : null;\r\n    }\r\n    // ---- begin view event handlers\r\n    onDidChangeOptions() {\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        this._applyLayout();\r\n        this._domNode.setClassName(this._getMinimapDomNodeClassName());\r\n    }\r\n    onSelectionChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onDecorationsChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onFlushed() {\r\n        this._lastRenderData = null;\r\n        return true;\r\n    }\r\n    onLinesChanged(changeFromLineNumber, changeToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            return this._lastRenderData.onLinesChanged(changeFromLineNumber, changeToLineNumber);\r\n        }\r\n        return false;\r\n    }\r\n    onLinesDeleted(deleteFromLineNumber, deleteToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            this._lastRenderData.onLinesDeleted(deleteFromLineNumber, deleteToLineNumber);\r\n        }\r\n        return true;\r\n    }\r\n    onLinesInserted(insertFromLineNumber, insertToLineNumber) {\r\n        if (this._lastRenderData) {\r\n            this._lastRenderData.onLinesInserted(insertFromLineNumber, insertToLineNumber);\r\n        }\r\n        return true;\r\n    }\r\n    onScrollChanged() {\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onThemeChanged() {\r\n        this._selectionColor = this._theme.getColor(minimapSelection);\r\n        this._renderDecorations = true;\r\n        return true;\r\n    }\r\n    onTokensChanged(ranges) {\r\n        if (this._lastRenderData) {\r\n            return this._lastRenderData.onTokensChanged(ranges);\r\n        }\r\n        return false;\r\n    }\r\n    onTokensColorsChanged() {\r\n        this._lastRenderData = null;\r\n        this._buffers = null;\r\n        return true;\r\n    }\r\n    onZonesChanged() {\r\n        this._lastRenderData = null;\r\n        return true;\r\n    }\r\n    // --- end event handlers\r\n    render(renderingCtx) {\r\n        const renderMinimap = this._model.options.renderMinimap;\r\n        if (renderMinimap === 0 /* None */) {\r\n            this._shadow.setClassName('minimap-shadow-hidden');\r\n            this._sliderHorizontal.setWidth(0);\r\n            this._sliderHorizontal.setHeight(0);\r\n            return;\r\n        }\r\n        if (renderingCtx.scrollLeft + renderingCtx.viewportWidth >= renderingCtx.scrollWidth) {\r\n            this._shadow.setClassName('minimap-shadow-hidden');\r\n        }\r\n        else {\r\n            this._shadow.setClassName('minimap-shadow-visible');\r\n        }\r\n        const layout = MinimapLayout.create(this._model.options, renderingCtx.viewportStartLineNumber, renderingCtx.viewportEndLineNumber, renderingCtx.viewportStartLineNumberVerticalOffset, renderingCtx.viewportHeight, renderingCtx.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), renderingCtx.scrollTop, renderingCtx.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);\r\n        this._slider.setDisplay(layout.sliderNeeded ? 'block' : 'none');\r\n        this._slider.setTop(layout.sliderTop);\r\n        this._slider.setHeight(layout.sliderHeight);\r\n        // Compute horizontal slider coordinates\r\n        const scrollLeftChars = renderingCtx.scrollLeft / this._model.options.typicalHalfwidthCharacterWidth;\r\n        const horizontalSliderLeft = Math.min(this._model.options.minimapWidth, Math.round(scrollLeftChars * this._model.options.minimapCharWidth / this._model.options.pixelRatio));\r\n        this._sliderHorizontal.setLeft(horizontalSliderLeft);\r\n        this._sliderHorizontal.setWidth(this._model.options.minimapWidth - horizontalSliderLeft);\r\n        this._sliderHorizontal.setTop(0);\r\n        this._sliderHorizontal.setHeight(layout.sliderHeight);\r\n        this.renderDecorations(layout);\r\n        this._lastRenderData = this.renderLines(layout);\r\n    }\r\n    renderDecorations(layout) {\r\n        if (this._renderDecorations) {\r\n            this._renderDecorations = false;\r\n            const selections = this._model.getSelections();\r\n            const decorations = this._model.getMinimapDecorationsInViewport(layout.startLineNumber, layout.endLineNumber);\r\n            const { canvasInnerWidth, canvasInnerHeight } = this._model.options;\r\n            const lineHeight = this._model.options.minimapLineHeight;\r\n            const characterWidth = this._model.options.minimapCharWidth;\r\n            const tabSize = this._model.getOptions().tabSize;\r\n            const canvasContext = this._decorationsCanvas.domNode.getContext('2d');\r\n            canvasContext.clearRect(0, 0, canvasInnerWidth, canvasInnerHeight);\r\n            const lineOffsetMap = new Map();\r\n            for (let i = 0; i < selections.length; i++) {\r\n                const selection = selections[i];\r\n                for (let line = selection.startLineNumber; line <= selection.endLineNumber; line++) {\r\n                    this.renderDecorationOnLine(canvasContext, lineOffsetMap, selection, this._selectionColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\r\n                }\r\n            }\r\n            // Loop over decorations, ignoring those that don't have the minimap property set and rendering rectangles for each line the decoration spans\r\n            for (let i = 0; i < decorations.length; i++) {\r\n                const decoration = decorations[i];\r\n                if (!decoration.options.minimap) {\r\n                    continue;\r\n                }\r\n                const decorationColor = decoration.options.minimap.getColor(this._theme);\r\n                for (let line = decoration.range.startLineNumber; line <= decoration.range.endLineNumber; line++) {\r\n                    switch (decoration.options.minimap.position) {\r\n                        case MinimapPosition.Inline:\r\n                            this.renderDecorationOnLine(canvasContext, lineOffsetMap, decoration.range, decorationColor, layout, line, lineHeight, lineHeight, tabSize, characterWidth);\r\n                            continue;\r\n                        case MinimapPosition.Gutter:\r\n                            const y = (line - layout.startLineNumber) * lineHeight;\r\n                            const x = 2;\r\n                            this.renderDecoration(canvasContext, decorationColor, x, y, GUTTER_DECORATION_WIDTH, lineHeight);\r\n                            continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    renderDecorationOnLine(canvasContext, lineOffsetMap, decorationRange, decorationColor, layout, lineNumber, height, lineHeight, tabSize, charWidth) {\r\n        const y = (lineNumber - layout.startLineNumber) * lineHeight;\r\n        // Skip rendering the line if it's vertically outside our viewport\r\n        if (y + height < 0 || y > this._model.options.canvasInnerHeight) {\r\n            return;\r\n        }\r\n        // Cache line offset data so that it is only read once per line\r\n        let lineIndexToXOffset = lineOffsetMap.get(lineNumber);\r\n        const isFirstDecorationForLine = !lineIndexToXOffset;\r\n        if (!lineIndexToXOffset) {\r\n            const lineData = this._model.getLineContent(lineNumber);\r\n            lineIndexToXOffset = [MINIMAP_GUTTER_WIDTH];\r\n            for (let i = 1; i < lineData.length + 1; i++) {\r\n                const charCode = lineData.charCodeAt(i - 1);\r\n                const dx = charCode === 9 /* Tab */\r\n                    ? tabSize * charWidth\r\n                    : strings.isFullWidthCharacter(charCode)\r\n                        ? 2 * charWidth\r\n                        : charWidth;\r\n                lineIndexToXOffset[i] = lineIndexToXOffset[i - 1] + dx;\r\n            }\r\n            lineOffsetMap.set(lineNumber, lineIndexToXOffset);\r\n        }\r\n        const { startColumn, endColumn, startLineNumber, endLineNumber } = decorationRange;\r\n        const x = startLineNumber === lineNumber ? lineIndexToXOffset[startColumn - 1] : MINIMAP_GUTTER_WIDTH;\r\n        const endColumnForLine = endLineNumber > lineNumber ? lineIndexToXOffset.length - 1 : endColumn - 1;\r\n        if (endColumnForLine > 0) {\r\n            // If the decoration starts at the last character of the column and spans over it, ensure it has a width\r\n            const width = lineIndexToXOffset[endColumnForLine] - x || 2;\r\n            this.renderDecoration(canvasContext, decorationColor, x, y, width, height);\r\n        }\r\n        if (isFirstDecorationForLine) {\r\n            this.renderLineHighlight(canvasContext, decorationColor, y, height);\r\n        }\r\n    }\r\n    renderLineHighlight(canvasContext, decorationColor, y, height) {\r\n        canvasContext.fillStyle = decorationColor && decorationColor.transparent(0.5).toString() || '';\r\n        canvasContext.fillRect(MINIMAP_GUTTER_WIDTH, y, canvasContext.canvas.width, height);\r\n    }\r\n    renderDecoration(canvasContext, decorationColor, x, y, width, height) {\r\n        canvasContext.fillStyle = decorationColor && decorationColor.toString() || '';\r\n        canvasContext.fillRect(x, y, width, height);\r\n    }\r\n    renderLines(layout) {\r\n        const startLineNumber = layout.startLineNumber;\r\n        const endLineNumber = layout.endLineNumber;\r\n        const minimapLineHeight = this._model.options.minimapLineHeight;\r\n        // Check if nothing changed w.r.t. lines from last frame\r\n        if (this._lastRenderData && this._lastRenderData.linesEquals(layout)) {\r\n            const _lastData = this._lastRenderData._get();\r\n            // Nice!! Nothing changed from last frame\r\n            return new RenderData(layout, _lastData.imageData, _lastData.lines);\r\n        }\r\n        // Oh well!! We need to repaint some lines...\r\n        const imageData = this._getBuffer();\r\n        if (!imageData) {\r\n            // 0 width or 0 height canvas, nothing to do\r\n            return null;\r\n        }\r\n        // Render untouched lines by using last rendered data.\r\n        let [_dirtyY1, _dirtyY2, needed] = InnerMinimap._renderUntouchedLines(imageData, startLineNumber, endLineNumber, minimapLineHeight, this._lastRenderData);\r\n        // Fetch rendering info from view model for rest of lines that need rendering.\r\n        const lineInfo = this._model.getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed);\r\n        const tabSize = this._model.getOptions().tabSize;\r\n        const background = this._model.options.backgroundColor;\r\n        const tokensColorTracker = this._model.tokensColorTracker;\r\n        const useLighterFont = tokensColorTracker.backgroundIsLight();\r\n        const renderMinimap = this._model.options.renderMinimap;\r\n        const charRenderer = this._model.options.charRenderer();\r\n        const fontScale = this._model.options.fontScale;\r\n        const minimapCharWidth = this._model.options.minimapCharWidth;\r\n        const baseCharHeight = (renderMinimap === 1 /* Text */ ? 2 /* BASE_CHAR_HEIGHT */ : 2 /* BASE_CHAR_HEIGHT */ + 1);\r\n        const renderMinimapLineHeight = baseCharHeight * fontScale;\r\n        const innerLinePadding = (minimapLineHeight > renderMinimapLineHeight ? Math.floor((minimapLineHeight - renderMinimapLineHeight) / 2) : 0);\r\n        // Render the rest of lines\r\n        let dy = 0;\r\n        const renderedLines = [];\r\n        for (let lineIndex = 0, lineCount = endLineNumber - startLineNumber + 1; lineIndex < lineCount; lineIndex++) {\r\n            if (needed[lineIndex]) {\r\n                InnerMinimap._renderLine(imageData, background, useLighterFont, renderMinimap, minimapCharWidth, tokensColorTracker, charRenderer, dy, innerLinePadding, tabSize, lineInfo[lineIndex], fontScale, minimapLineHeight);\r\n            }\r\n            renderedLines[lineIndex] = new MinimapLine(dy);\r\n            dy += minimapLineHeight;\r\n        }\r\n        const dirtyY1 = (_dirtyY1 === -1 ? 0 : _dirtyY1);\r\n        const dirtyY2 = (_dirtyY2 === -1 ? imageData.height : _dirtyY2);\r\n        const dirtyHeight = dirtyY2 - dirtyY1;\r\n        // Finally, paint to the canvas\r\n        const ctx = this._canvas.domNode.getContext('2d');\r\n        ctx.putImageData(imageData, 0, 0, 0, dirtyY1, imageData.width, dirtyHeight);\r\n        // Save rendered data for reuse on next frame if possible\r\n        return new RenderData(layout, imageData, renderedLines);\r\n    }\r\n    static _renderUntouchedLines(target, startLineNumber, endLineNumber, minimapLineHeight, lastRenderData) {\r\n        const needed = [];\r\n        if (!lastRenderData) {\r\n            for (let i = 0, len = endLineNumber - startLineNumber + 1; i < len; i++) {\r\n                needed[i] = true;\r\n            }\r\n            return [-1, -1, needed];\r\n        }\r\n        const _lastData = lastRenderData._get();\r\n        const lastTargetData = _lastData.imageData.data;\r\n        const lastStartLineNumber = _lastData.rendLineNumberStart;\r\n        const lastLines = _lastData.lines;\r\n        const lastLinesLength = lastLines.length;\r\n        const WIDTH = target.width;\r\n        const targetData = target.data;\r\n        const maxDestPixel = (endLineNumber - startLineNumber + 1) * minimapLineHeight * WIDTH * 4;\r\n        let dirtyPixel1 = -1; // the pixel offset up to which all the data is equal to the prev frame\r\n        let dirtyPixel2 = -1; // the pixel offset after which all the data is equal to the prev frame\r\n        let copySourceStart = -1;\r\n        let copySourceEnd = -1;\r\n        let copyDestStart = -1;\r\n        let copyDestEnd = -1;\r\n        let dest_dy = 0;\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            const lineIndex = lineNumber - startLineNumber;\r\n            const lastLineIndex = lineNumber - lastStartLineNumber;\r\n            const source_dy = (lastLineIndex >= 0 && lastLineIndex < lastLinesLength ? lastLines[lastLineIndex].dy : -1);\r\n            if (source_dy === -1) {\r\n                needed[lineIndex] = true;\r\n                dest_dy += minimapLineHeight;\r\n                continue;\r\n            }\r\n            const sourceStart = source_dy * WIDTH * 4;\r\n            const sourceEnd = (source_dy + minimapLineHeight) * WIDTH * 4;\r\n            const destStart = dest_dy * WIDTH * 4;\r\n            const destEnd = (dest_dy + minimapLineHeight) * WIDTH * 4;\r\n            if (copySourceEnd === sourceStart && copyDestEnd === destStart) {\r\n                // contiguous zone => extend copy request\r\n                copySourceEnd = sourceEnd;\r\n                copyDestEnd = destEnd;\r\n            }\r\n            else {\r\n                if (copySourceStart !== -1) {\r\n                    // flush existing copy request\r\n                    targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\r\n                    if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\r\n                        dirtyPixel1 = copySourceEnd;\r\n                    }\r\n                    if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\r\n                        dirtyPixel2 = copySourceStart;\r\n                    }\r\n                }\r\n                copySourceStart = sourceStart;\r\n                copySourceEnd = sourceEnd;\r\n                copyDestStart = destStart;\r\n                copyDestEnd = destEnd;\r\n            }\r\n            needed[lineIndex] = false;\r\n            dest_dy += minimapLineHeight;\r\n        }\r\n        if (copySourceStart !== -1) {\r\n            // flush existing copy request\r\n            targetData.set(lastTargetData.subarray(copySourceStart, copySourceEnd), copyDestStart);\r\n            if (dirtyPixel1 === -1 && copySourceStart === 0 && copySourceStart === copyDestStart) {\r\n                dirtyPixel1 = copySourceEnd;\r\n            }\r\n            if (dirtyPixel2 === -1 && copySourceEnd === maxDestPixel && copySourceStart === copyDestStart) {\r\n                dirtyPixel2 = copySourceStart;\r\n            }\r\n        }\r\n        const dirtyY1 = (dirtyPixel1 === -1 ? -1 : dirtyPixel1 / (WIDTH * 4));\r\n        const dirtyY2 = (dirtyPixel2 === -1 ? -1 : dirtyPixel2 / (WIDTH * 4));\r\n        return [dirtyY1, dirtyY2, needed];\r\n    }\r\n    static _renderLine(target, backgroundColor, useLighterFont, renderMinimap, charWidth, colorTracker, minimapCharRenderer, dy, innerLinePadding, tabSize, lineData, fontScale, minimapLineHeight) {\r\n        const content = lineData.content;\r\n        const tokens = lineData.tokens;\r\n        const maxDx = target.width - charWidth;\r\n        const force1pxHeight = (minimapLineHeight === 1);\r\n        let dx = MINIMAP_GUTTER_WIDTH;\r\n        let charIndex = 0;\r\n        let tabsCharDelta = 0;\r\n        for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\r\n            const tokenEndIndex = tokens.getEndOffset(tokenIndex);\r\n            const tokenColorId = tokens.getForeground(tokenIndex);\r\n            const tokenColor = colorTracker.getColor(tokenColorId);\r\n            for (; charIndex < tokenEndIndex; charIndex++) {\r\n                if (dx > maxDx) {\r\n                    // hit edge of minimap\r\n                    return;\r\n                }\r\n                const charCode = content.charCodeAt(charIndex);\r\n                if (charCode === 9 /* Tab */) {\r\n                    const insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\r\n                    tabsCharDelta += insertSpacesCount - 1;\r\n                    // No need to render anything since tab is invisible\r\n                    dx += insertSpacesCount * charWidth;\r\n                }\r\n                else if (charCode === 32 /* Space */) {\r\n                    // No need to render anything since space is invisible\r\n                    dx += charWidth;\r\n                }\r\n                else {\r\n                    // Render twice for a full width character\r\n                    const count = strings.isFullWidthCharacter(charCode) ? 2 : 1;\r\n                    for (let i = 0; i < count; i++) {\r\n                        if (renderMinimap === 2 /* Blocks */) {\r\n                            minimapCharRenderer.blockRenderChar(target, dx, dy + innerLinePadding, tokenColor, backgroundColor, useLighterFont, force1pxHeight);\r\n                        }\r\n                        else { // RenderMinimap.Text\r\n                            minimapCharRenderer.renderChar(target, dx, dy + innerLinePadding, charCode, tokenColor, backgroundColor, fontScale, useLighterFont, force1pxHeight);\r\n                        }\r\n                        dx += charWidth;\r\n                        if (dx > maxDx) {\r\n                            // hit edge of minimap\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nregisterThemingParticipant((theme, collector) => {\r\n    const minimapBackgroundValue = theme.getColor(minimapBackground);\r\n    if (minimapBackgroundValue) {\r\n        collector.addRule(`.monaco-editor .minimap > canvas { opacity: ${minimapBackgroundValue.rgba.a}; will-change: opacity; }`);\r\n    }\r\n    const sliderBackground = theme.getColor(minimapSliderBackground);\r\n    if (sliderBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider .minimap-slider-horizontal { background: ${sliderBackground}; }`);\r\n    }\r\n    const sliderHoverBackground = theme.getColor(minimapSliderHoverBackground);\r\n    if (sliderHoverBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider:hover .minimap-slider-horizontal { background: ${sliderHoverBackground}; }`);\r\n    }\r\n    const sliderActiveBackground = theme.getColor(minimapSliderActiveBackground);\r\n    if (sliderActiveBackground) {\r\n        collector.addRule(`.monaco-editor .minimap-slider.active .minimap-slider-horizontal { background: ${sliderActiveBackground}; }`);\r\n    }\r\n    const shadow = theme.getColor(scrollbarShadow);\r\n    if (shadow) {\r\n        collector.addRule(`.monaco-editor .minimap-shadow-visible { box-shadow: ${shadow} -6px 0 6px -6px inset; }`);\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}