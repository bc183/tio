{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../controller/cursorCommon.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nvar repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n  if (!repeatCache[str]) {\n    repeatCache[str] = ['', str];\n  }\n\n  var cache = repeatCache[str];\n\n  for (var i = cache.length; i <= count; i++) {\n    cache[i] = cache[i - 1] + str;\n  }\n\n  return cache[count];\n}\nexport var ShiftCommand = /*#__PURE__*/function () {\n  function ShiftCommand(range, opts) {\n    _classCallCheck(this, ShiftCommand);\n\n    this._opts = opts;\n    this._selection = range;\n    this._selectionId = null;\n    this._useLastEditRangeForCursorEndPosition = false;\n    this._selectionStartColumnStaysPut = false;\n  }\n\n  _createClass(ShiftCommand, [{\n    key: \"_addEditOperation\",\n    value: function _addEditOperation(builder, range, text) {\n      if (this._useLastEditRangeForCursorEndPosition) {\n        builder.addTrackedEditOperation(range, text);\n      } else {\n        builder.addEditOperation(range, text);\n      }\n    }\n  }, {\n    key: \"getEditOperations\",\n    value: function getEditOperations(model, builder) {\n      var startLine = this._selection.startLineNumber;\n      var endLine = this._selection.endLineNumber;\n\n      if (this._selection.endColumn === 1 && startLine !== endLine) {\n        endLine = endLine - 1;\n      }\n\n      var _this$_opts = this._opts,\n          tabSize = _this$_opts.tabSize,\n          indentSize = _this$_opts.indentSize,\n          insertSpaces = _this$_opts.insertSpaces;\n      var shouldIndentEmptyLines = startLine === endLine;\n\n      if (this._opts.useTabStops) {\n        // if indenting or outdenting on a whitespace only line\n        if (this._selection.isEmpty()) {\n          if (/^\\s*$/.test(model.getLineContent(startLine))) {\n            this._useLastEditRangeForCursorEndPosition = true;\n          }\n        } // keep track of previous line's \"miss-alignment\"\n\n\n        var previousLineExtraSpaces = 0,\n            extraSpaces = 0;\n\n        for (var lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n          extraSpaces = 0;\n          var lineText = model.getLineContent(lineNumber);\n          var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n\n          if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n            // empty line or line with no leading whitespace => nothing to do\n            continue;\n          }\n\n          if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n            // do not indent empty lines => nothing to do\n            continue;\n          }\n\n          if (indentationEndIndex === -1) {\n            // the entire line is whitespace\n            indentationEndIndex = lineText.length;\n          }\n\n          if (lineNumber > 1) {\n            var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n\n            if (contentStartVisibleColumn % indentSize !== 0) {\n              // The current line is \"miss-aligned\", so let's see if this is expected...\n              // This can only happen when it has trailing commas in the indent\n              if (model.isCheapToTokenize(lineNumber - 1)) {\n                var enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n\n                if (enterAction) {\n                  extraSpaces = previousLineExtraSpaces;\n\n                  if (enterAction.appendText) {\n                    for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                      if (enterAction.appendText.charCodeAt(j) === 32\n                      /* Space */\n                      ) {\n                          extraSpaces++;\n                        } else {\n                        break;\n                      }\n                    }\n                  }\n\n                  if (enterAction.removeText) {\n                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                  } // Act as if `prefixSpaces` is not part of the indentation\n\n\n                  for (var _j = 0; _j < extraSpaces; _j++) {\n                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32\n                    /* Space */\n                    ) {\n                        break;\n                      }\n\n                    indentationEndIndex--;\n                  }\n                }\n              }\n            }\n          }\n\n          if (this._opts.isUnshift && indentationEndIndex === 0) {\n            // line with no leading whitespace => nothing to do\n            continue;\n          }\n\n          var desiredIndent = void 0;\n\n          if (this._opts.isUnshift) {\n            desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n          } else {\n            desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n          }\n\n          this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n\n          if (lineNumber === startLine && !this._selection.isEmpty()) {\n            // Force the startColumn to stay put because we're inserting after it\n            this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;\n          }\n        }\n      } else {\n        // if indenting or outdenting on a whitespace only line\n        if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n          this._useLastEditRangeForCursorEndPosition = true;\n        }\n\n        var oneIndent = insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t';\n\n        for (var _lineNumber = startLine; _lineNumber <= endLine; _lineNumber++) {\n          var _lineText = model.getLineContent(_lineNumber);\n\n          var _indentationEndIndex = strings.firstNonWhitespaceIndex(_lineText);\n\n          if (this._opts.isUnshift && (_lineText.length === 0 || _indentationEndIndex === 0)) {\n            // empty line or line with no leading whitespace => nothing to do\n            continue;\n          }\n\n          if (!shouldIndentEmptyLines && !this._opts.isUnshift && _lineText.length === 0) {\n            // do not indent empty lines => nothing to do\n            continue;\n          }\n\n          if (_indentationEndIndex === -1) {\n            // the entire line is whitespace\n            _indentationEndIndex = _lineText.length;\n          }\n\n          if (this._opts.isUnshift && _indentationEndIndex === 0) {\n            // line with no leading whitespace => nothing to do\n            continue;\n          }\n\n          if (this._opts.isUnshift) {\n            _indentationEndIndex = Math.min(_indentationEndIndex, indentSize);\n\n            for (var i = 0; i < _indentationEndIndex; i++) {\n              var chr = _lineText.charCodeAt(i);\n\n              if (chr === 9\n              /* Tab */\n              ) {\n                  _indentationEndIndex = i + 1;\n                  break;\n                }\n            }\n\n            this._addEditOperation(builder, new Range(_lineNumber, 1, _lineNumber, _indentationEndIndex + 1), '');\n          } else {\n            this._addEditOperation(builder, new Range(_lineNumber, 1, _lineNumber, 1), oneIndent);\n\n            if (_lineNumber === startLine && !this._selection.isEmpty()) {\n              // Force the startColumn to stay put because we're inserting after it\n              this._selectionStartColumnStaysPut = this._selection.startColumn === 1;\n            }\n          }\n        }\n      }\n\n      this._selectionId = builder.trackSelection(this._selection);\n    }\n  }, {\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      if (this._useLastEditRangeForCursorEndPosition) {\n        var lastOp = helper.getInverseEditOperations()[0];\n        return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n      }\n\n      var result = helper.getTrackedSelection(this._selectionId);\n\n      if (this._selectionStartColumnStaysPut) {\n        // The selection start should not move\n        var initialStartColumn = this._selection.startColumn;\n        var resultStartColumn = result.startColumn;\n\n        if (resultStartColumn <= initialStartColumn) {\n          return result;\n        }\n\n        if (result.getDirection() === 0\n        /* LTR */\n        ) {\n            return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n          }\n\n        return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"unshiftIndent\",\n    value: function unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n      // Determine the visible column where the content starts\n      var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n      if (insertSpaces) {\n        var indent = cachedStringRepeat(' ', indentSize);\n        var desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n        var indentCount = desiredTabStop / indentSize; // will be an integer\n\n        return cachedStringRepeat(indent, indentCount);\n      } else {\n        var _indent = '\\t';\n\n        var _desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n\n        var _indentCount = _desiredTabStop / tabSize; // will be an integer\n\n\n        return cachedStringRepeat(_indent, _indentCount);\n      }\n    }\n  }, {\n    key: \"shiftIndent\",\n    value: function shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n      // Determine the visible column where the content starts\n      var contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n\n      if (insertSpaces) {\n        var indent = cachedStringRepeat(' ', indentSize);\n        var desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n        var indentCount = desiredTabStop / indentSize; // will be an integer\n\n        return cachedStringRepeat(indent, indentCount);\n      } else {\n        var _indent2 = '\\t';\n\n        var _desiredTabStop2 = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n\n        var _indentCount2 = _desiredTabStop2 / tabSize; // will be an integer\n\n\n        return cachedStringRepeat(_indent2, _indentCount2);\n      }\n    }\n  }]);\n\n  return ShiftCommand;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js"],"names":["strings","CursorColumns","Range","Selection","LanguageConfigurationRegistry","repeatCache","Object","create","cachedStringRepeat","str","count","cache","i","length","ShiftCommand","range","opts","_opts","_selection","_selectionId","_useLastEditRangeForCursorEndPosition","_selectionStartColumnStaysPut","builder","text","addTrackedEditOperation","addEditOperation","model","startLine","startLineNumber","endLine","endLineNumber","endColumn","tabSize","indentSize","insertSpaces","shouldIndentEmptyLines","useTabStops","isEmpty","test","getLineContent","previousLineExtraSpaces","extraSpaces","lineNumber","lineText","indentationEndIndex","firstNonWhitespaceIndex","isUnshift","contentStartVisibleColumn","visibleColumnFromColumn","isCheapToTokenize","enterAction","getEnterAction","autoIndent","getLineMaxColumn","appendText","j","lenJ","charCodeAt","removeText","Math","max","desiredIndent","unshiftIndent","shiftIndent","_addEditOperation","startColumn","getLineLength","oneIndent","min","chr","trackSelection","helper","lastOp","getInverseEditOperations","result","getTrackedSelection","initialStartColumn","resultStartColumn","getDirection","line","column","indent","desiredTabStop","prevIndentTabStop","indentCount","prevRenderTabStop","nextIndentTabStop","nextRenderTabStop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CursorColumns } from '../controller/cursorCommon.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nconst repeatCache = Object.create(null);\r\nexport function cachedStringRepeat(str, count) {\r\n    if (!repeatCache[str]) {\r\n        repeatCache[str] = ['', str];\r\n    }\r\n    const cache = repeatCache[str];\r\n    for (let i = cache.length; i <= count; i++) {\r\n        cache[i] = cache[i - 1] + str;\r\n    }\r\n    return cache[count];\r\n}\r\nexport class ShiftCommand {\r\n    constructor(range, opts) {\r\n        this._opts = opts;\r\n        this._selection = range;\r\n        this._selectionId = null;\r\n        this._useLastEditRangeForCursorEndPosition = false;\r\n        this._selectionStartColumnStaysPut = false;\r\n    }\r\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            const indent = cachedStringRepeat(' ', indentSize);\r\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            const indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            const indent = '\\t';\r\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            const indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    }\r\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\r\n        // Determine the visible column where the content starts\r\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\r\n        if (insertSpaces) {\r\n            const indent = cachedStringRepeat(' ', indentSize);\r\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\r\n            const indentCount = desiredTabStop / indentSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n        else {\r\n            const indent = '\\t';\r\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\r\n            const indentCount = desiredTabStop / tabSize; // will be an integer\r\n            return cachedStringRepeat(indent, indentCount);\r\n        }\r\n    }\r\n    _addEditOperation(builder, range, text) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            builder.addTrackedEditOperation(range, text);\r\n        }\r\n        else {\r\n            builder.addEditOperation(range, text);\r\n        }\r\n    }\r\n    getEditOperations(model, builder) {\r\n        const startLine = this._selection.startLineNumber;\r\n        let endLine = this._selection.endLineNumber;\r\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\r\n            endLine = endLine - 1;\r\n        }\r\n        const { tabSize, indentSize, insertSpaces } = this._opts;\r\n        const shouldIndentEmptyLines = (startLine === endLine);\r\n        if (this._opts.useTabStops) {\r\n            // if indenting or outdenting on a whitespace only line\r\n            if (this._selection.isEmpty()) {\r\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\r\n                    this._useLastEditRangeForCursorEndPosition = true;\r\n                }\r\n            }\r\n            // keep track of previous line's \"miss-alignment\"\r\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\r\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\r\n                extraSpaces = 0;\r\n                let lineText = model.getLineContent(lineNumber);\r\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (lineNumber > 1) {\r\n                    let contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\r\n                    if (contentStartVisibleColumn % indentSize !== 0) {\r\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\r\n                        // This can only happen when it has trailing commas in the indent\r\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\r\n                            let enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\r\n                            if (enterAction) {\r\n                                extraSpaces = previousLineExtraSpaces;\r\n                                if (enterAction.appendText) {\r\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\r\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\r\n                                            extraSpaces++;\r\n                                        }\r\n                                        else {\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                if (enterAction.removeText) {\r\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\r\n                                }\r\n                                // Act as if `prefixSpaces` is not part of the indentation\r\n                                for (let j = 0; j < extraSpaces; j++) {\r\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\r\n                                        break;\r\n                                    }\r\n                                    indentationEndIndex--;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                let desiredIndent;\r\n                if (this._opts.isUnshift) {\r\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                else {\r\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\r\n                }\r\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\r\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                    // Force the startColumn to stay put because we're inserting after it\r\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // if indenting or outdenting on a whitespace only line\r\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\r\n                this._useLastEditRangeForCursorEndPosition = true;\r\n            }\r\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\r\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\r\n                const lineText = model.getLineContent(lineNumber);\r\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\r\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\r\n                    // empty line or line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\r\n                    // do not indent empty lines => nothing to do\r\n                    continue;\r\n                }\r\n                if (indentationEndIndex === -1) {\r\n                    // the entire line is whitespace\r\n                    indentationEndIndex = lineText.length;\r\n                }\r\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\r\n                    // line with no leading whitespace => nothing to do\r\n                    continue;\r\n                }\r\n                if (this._opts.isUnshift) {\r\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\r\n                    for (let i = 0; i < indentationEndIndex; i++) {\r\n                        const chr = lineText.charCodeAt(i);\r\n                        if (chr === 9 /* Tab */) {\r\n                            indentationEndIndex = i + 1;\r\n                            break;\r\n                        }\r\n                    }\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\r\n                }\r\n                else {\r\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\r\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\r\n                        // Force the startColumn to stay put because we're inserting after it\r\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this._selectionId = builder.trackSelection(this._selection);\r\n    }\r\n    computeCursorState(model, helper) {\r\n        if (this._useLastEditRangeForCursorEndPosition) {\r\n            let lastOp = helper.getInverseEditOperations()[0];\r\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\r\n        }\r\n        const result = helper.getTrackedSelection(this._selectionId);\r\n        if (this._selectionStartColumnStaysPut) {\r\n            // The selection start should not move\r\n            let initialStartColumn = this._selection.startColumn;\r\n            let resultStartColumn = result.startColumn;\r\n            if (resultStartColumn <= initialStartColumn) {\r\n                return result;\r\n            }\r\n            if (result.getDirection() === 0 /* LTR */) {\r\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\r\n            }\r\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}