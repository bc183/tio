{"ast":null,"code":"import _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _toConsumableArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from './errors.js';\nimport { Disposable, combinedDisposable, DisposableStore } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nexport var Event;\n\n(function (Event) {\n  Event.None = function () {\n    return Disposable.None;\n  };\n  /**\r\n   * Given an event, returns another event which only fires once.\r\n   */\n\n\n  function _once(event) {\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      // we need this, in case the event fires during the listener call\n      var didFire = false;\n      var result;\n      result = event(function (e) {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n\n      if (didFire) {\n        result.dispose();\n      }\n\n      return result;\n    };\n  }\n\n  Event.once = _once;\n  /**\r\n   * Given an event and a `map` function, returns another event which maps each element\r\n   * through the mapping function.\r\n   */\n\n  function _map(event, map) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        return listener.call(thisArgs, map(i));\n      }, null, disposables);\n    });\n  }\n\n  Event.map = _map;\n  /**\r\n   * Given an event and an `each` function, returns another identical event and calls\r\n   * the `each` function per each element.\r\n   */\n\n  function _forEach(event, each) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (i) {\n        each(i);\n        listener.call(thisArgs, i);\n      }, null, disposables);\n    });\n  }\n\n  Event.forEach = _forEach;\n\n  function _filter(event, filter) {\n    return snapshot(function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return event(function (e) {\n        return filter(e) && listener.call(thisArgs, e);\n      }, null, disposables);\n    });\n  }\n\n  Event.filter = _filter;\n  /**\r\n   * Given an event, returns the same event but typed as `Event<void>`.\r\n   */\n\n  function signal(event) {\n    return event;\n  }\n\n  Event.signal = signal;\n\n  function any() {\n    for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {\n      events[_key] = arguments[_key];\n    }\n\n    return function (listener) {\n      var thisArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var disposables = arguments.length > 2 ? arguments[2] : undefined;\n      return combinedDisposable.apply(void 0, _toConsumableArray(events.map(function (event) {\n        return event(function (e) {\n          return listener.call(thisArgs, e);\n        }, null, disposables);\n      })));\n    };\n  }\n\n  Event.any = any;\n  /**\r\n   * Given an event and a `merge` function, returns another event which maps each element\r\n   * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n   */\n\n  function _reduce(event, merge, initial) {\n    var output = initial;\n    return _map(event, function (e) {\n      output = merge(output, e);\n      return output;\n    });\n  }\n\n  Event.reduce = _reduce;\n  /**\r\n   * Given a chain of event processing functions (filter, map, etc), each\r\n   * function will be invoked per event & per listener. Snapshotting an event\r\n   * chain allows each function to be invoked just once per event.\r\n   */\n\n  function snapshot(event) {\n    var listener;\n    var emitter = new Emitter({\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        listener = event(emitter.fire, emitter);\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        listener.dispose();\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.snapshot = snapshot;\n\n  function _debounce(event, merge) {\n    var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n    var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var leakWarningThreshold = arguments.length > 4 ? arguments[4] : undefined;\n    var subscription;\n    var output = undefined;\n    var handle = undefined;\n    var numDebouncedCalls = 0;\n    var emitter = new Emitter({\n      leakWarningThreshold: leakWarningThreshold,\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        subscription = event(function (cur) {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n\n          clearTimeout(handle);\n          handle = setTimeout(function () {\n            var _output = output;\n            output = undefined;\n            handle = undefined;\n\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n\n            numDebouncedCalls = 0;\n          }, delay);\n        });\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        subscription.dispose();\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.debounce = _debounce;\n  /**\r\n   * Given an event, it returns another event which fires only once and as soon as\r\n   * the input event emits. The event data is the number of millis it took for the\r\n   * event to fire.\r\n   */\n\n  function stopwatch(event) {\n    var start = new Date().getTime();\n    return _map(_once(event), function (_) {\n      return new Date().getTime() - start;\n    });\n  }\n\n  Event.stopwatch = stopwatch;\n  /**\r\n   * Given an event, it returns another event which fires only when the event\r\n   * element changes.\r\n   */\n\n  function _latch(event) {\n    var firstCall = true;\n    var cache;\n    return _filter(event, function (value) {\n      var shouldEmit = firstCall || value !== cache;\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    });\n  }\n\n  Event.latch = _latch;\n  /**\r\n   * Buffers the provided event until a first listener comes\r\n   * along, at which point fire all the events at once and\r\n   * pipe the event from then on.\r\n   *\r\n   * ```typescript\r\n   * const emitter = new Emitter<number>();\r\n   * const event = emitter.event;\r\n   * const bufferedEvent = buffer(event);\r\n   *\r\n   * emitter.fire(1);\r\n   * emitter.fire(2);\r\n   * emitter.fire(3);\r\n   * // nothing...\r\n   *\r\n   * const listener = bufferedEvent(num => console.log(num));\r\n   * // 1, 2, 3\r\n   *\r\n   * emitter.fire(4);\r\n   * // 4\r\n   * ```\r\n   */\n\n  function buffer(event) {\n    var nextTick = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var _buffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var buffer = _buffer.slice();\n\n    var listener = event(function (e) {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n\n    var flush = function flush() {\n      if (buffer) {\n        buffer.forEach(function (e) {\n          return emitter.fire(e);\n        });\n      }\n\n      buffer = null;\n    };\n\n    var emitter = new Emitter({\n      onFirstListenerAdd: function onFirstListenerAdd() {\n        if (!listener) {\n          listener = event(function (e) {\n            return emitter.fire(e);\n          });\n        }\n      },\n      onFirstListenerDidAdd: function onFirstListenerDidAdd() {\n        if (buffer) {\n          if (nextTick) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        if (listener) {\n          listener.dispose();\n        }\n\n        listener = null;\n      }\n    });\n    return emitter.event;\n  }\n\n  Event.buffer = buffer;\n\n  var ChainableEvent = /*#__PURE__*/function () {\n    function ChainableEvent(event) {\n      _classCallCheck(this, ChainableEvent);\n\n      this.event = event;\n    }\n\n    _createClass(ChainableEvent, [{\n      key: \"map\",\n      value: function map(fn) {\n        return new ChainableEvent(_map(this.event, fn));\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(fn) {\n        return new ChainableEvent(_forEach(this.event, fn));\n      }\n    }, {\n      key: \"filter\",\n      value: function filter(fn) {\n        return new ChainableEvent(_filter(this.event, fn));\n      }\n    }, {\n      key: \"reduce\",\n      value: function reduce(merge, initial) {\n        return new ChainableEvent(_reduce(this.event, merge, initial));\n      }\n    }, {\n      key: \"latch\",\n      value: function latch() {\n        return new ChainableEvent(_latch(this.event));\n      }\n    }, {\n      key: \"debounce\",\n      value: function debounce(merge) {\n        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n        var leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var leakWarningThreshold = arguments.length > 3 ? arguments[3] : undefined;\n        return new ChainableEvent(_debounce(this.event, merge, delay, leading, leakWarningThreshold));\n      }\n    }, {\n      key: \"on\",\n      value: function on(listener, thisArgs, disposables) {\n        return this.event(listener, thisArgs, disposables);\n      }\n    }, {\n      key: \"once\",\n      value: function once(listener, thisArgs, disposables) {\n        return _once(this.event)(listener, thisArgs, disposables);\n      }\n    }]);\n\n    return ChainableEvent;\n  }();\n\n  function chain(event) {\n    return new ChainableEvent(event);\n  }\n\n  Event.chain = chain;\n\n  function fromNodeEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.on(eventName, fn);\n    };\n\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeListener(eventName, fn);\n    };\n\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n\n  function fromDOMEventEmitter(emitter, eventName) {\n    var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (id) {\n      return id;\n    };\n\n    var fn = function fn() {\n      return result.fire(map.apply(void 0, arguments));\n    };\n\n    var onFirstListenerAdd = function onFirstListenerAdd() {\n      return emitter.addEventListener(eventName, fn);\n    };\n\n    var onLastListenerRemove = function onLastListenerRemove() {\n      return emitter.removeEventListener(eventName, fn);\n    };\n\n    var result = new Emitter({\n      onFirstListenerAdd: onFirstListenerAdd,\n      onLastListenerRemove: onLastListenerRemove\n    });\n    return result.event;\n  }\n\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n\n  function fromPromise(promise) {\n    var emitter = new Emitter();\n    var shouldEmit = false;\n    promise.then(undefined, function () {\n      return null;\n    }).then(function () {\n      if (!shouldEmit) {\n        setTimeout(function () {\n          return emitter.fire(undefined);\n        }, 0);\n      } else {\n        emitter.fire(undefined);\n      }\n    });\n    shouldEmit = true;\n    return emitter.event;\n  }\n\n  Event.fromPromise = fromPromise;\n\n  function toPromise(event) {\n    return new Promise(function (resolve) {\n      return _once(event)(resolve);\n    });\n  }\n\n  Event.toPromise = toPromise;\n})(Event || (Event = {}));\n\nvar EventProfiling = /*#__PURE__*/function () {\n  function EventProfiling(name) {\n    _classCallCheck(this, EventProfiling);\n\n    this._listenerCount = 0;\n    this._invocationCount = 0;\n    this._elapsedOverall = 0;\n    this._name = \"\".concat(name, \"_\").concat(EventProfiling._idPool++);\n  }\n\n  _createClass(EventProfiling, [{\n    key: \"start\",\n    value: function start(listenerCount) {\n      this._stopWatch = new StopWatch(true);\n      this._listenerCount = listenerCount;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._stopWatch) {\n        var elapsed = this._stopWatch.elapsed();\n\n        this._elapsedOverall += elapsed;\n        this._invocationCount += 1;\n        console.info(\"did FIRE \".concat(this._name, \": elapsed_ms: \").concat(elapsed.toFixed(5), \", listener: \").concat(this._listenerCount, \" (elapsed_overall: \").concat(this._elapsedOverall.toFixed(2), \", invocations: \").concat(this._invocationCount, \")\"));\n        this._stopWatch = undefined;\n      }\n    }\n  }]);\n\n  return EventProfiling;\n}();\n\nEventProfiling._idPool = 0;\n\nvar _globalLeakWarningThreshold = -1;\n\nvar LeakageMonitor = /*#__PURE__*/function () {\n  function LeakageMonitor(customThreshold) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random().toString(18).slice(2, 5);\n\n    _classCallCheck(this, LeakageMonitor);\n\n    this.customThreshold = customThreshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n\n  _createClass(LeakageMonitor, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._stacks) {\n        this._stacks.clear();\n      }\n    }\n  }, {\n    key: \"check\",\n    value: function check(listenerCount) {\n      var _this = this;\n\n      var threshold = _globalLeakWarningThreshold;\n\n      if (typeof this.customThreshold === 'number') {\n        threshold = this.customThreshold;\n      }\n\n      if (threshold <= 0 || listenerCount < threshold) {\n        return undefined;\n      }\n\n      if (!this._stacks) {\n        this._stacks = new Map();\n      }\n\n      var stack = new Error().stack.split('\\n').slice(3).join('\\n');\n      var count = this._stacks.get(stack) || 0;\n\n      this._stacks.set(stack, count + 1);\n\n      this._warnCountdown -= 1;\n\n      if (this._warnCountdown <= 0) {\n        // only warn on first exceed and then every time the limit\n        // is exceeded by 50% again\n        this._warnCountdown = threshold * 0.5; // find most frequent listener and print warning\n\n        var topStack;\n        var topCount = 0;\n\n        var _iterator = _createForOfIteratorHelper(this._stacks),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                _stack = _step$value[0],\n                _count = _step$value[1];\n\n            if (!topStack || topCount < _count) {\n              topStack = _stack;\n              topCount = _count;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        console.warn(\"[\".concat(this.name, \"] potential listener LEAK detected, having \").concat(listenerCount, \" listeners already. MOST frequent listener (\").concat(topCount, \"):\"));\n        console.warn(topStack);\n      }\n\n      return function () {\n        var count = _this._stacks.get(stack) || 0;\n\n        _this._stacks.set(stack, count - 1);\n      };\n    }\n  }]);\n\n  return LeakageMonitor;\n}();\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\n\n\nexport var Emitter = /*#__PURE__*/function () {\n  function Emitter(options) {\n    _classCallCheck(this, Emitter);\n\n    var _a;\n\n    this._disposed = false;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n    this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n  }\n  /**\r\n   * For the public to allow to subscribe\r\n   * to events from this Emitter\r\n   */\n\n\n  _createClass(Emitter, [{\n    key: \"fire\",\n\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\n    value: function fire(event) {\n      var _a, _b;\n\n      if (this._listeners) {\n        // put all [listener,event]-pairs into delivery queue\n        // then emit all event. an inner/nested event might be\n        // the driver of this\n        if (!this._deliveryQueue) {\n          this._deliveryQueue = new LinkedList();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this._listeners),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _listener = _step2.value;\n\n            this._deliveryQueue.push([_listener, event]);\n          } // start/stop performance insight collection\n\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n\n        while (this._deliveryQueue.size > 0) {\n          var _this$_deliveryQueue$ = this._deliveryQueue.shift(),\n              _this$_deliveryQueue$2 = _slicedToArray(_this$_deliveryQueue$, 2),\n              listener = _this$_deliveryQueue$2[0],\n              _event = _this$_deliveryQueue$2[1];\n\n          try {\n            if (typeof listener === 'function') {\n              listener.call(undefined, _event);\n            } else {\n              listener[0].call(listener[1], _event);\n            }\n          } catch (e) {\n            onUnexpectedError(e);\n          }\n        }\n\n        (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _a, _b, _c;\n\n      (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\n      (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\n      (_c = this._leakageMon) === null || _c === void 0 ? void 0 : _c.dispose();\n      this._disposed = true;\n    }\n  }, {\n    key: \"event\",\n    get: function get() {\n      var _this2 = this;\n\n      if (!this._event) {\n        this._event = function (listener, thisArgs, disposables) {\n          var _a;\n\n          if (!_this2._listeners) {\n            _this2._listeners = new LinkedList();\n          }\n\n          var firstListener = _this2._listeners.isEmpty();\n\n          if (firstListener && _this2._options && _this2._options.onFirstListenerAdd) {\n            _this2._options.onFirstListenerAdd(_this2);\n          }\n\n          var remove = _this2._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\n\n          if (firstListener && _this2._options && _this2._options.onFirstListenerDidAdd) {\n            _this2._options.onFirstListenerDidAdd(_this2);\n          }\n\n          if (_this2._options && _this2._options.onListenerDidAdd) {\n            _this2._options.onListenerDidAdd(_this2, listener, thisArgs);\n          } // check and record this emitter for potential leakage\n\n\n          var removeMonitor = (_a = _this2._leakageMon) === null || _a === void 0 ? void 0 : _a.check(_this2._listeners.size);\n          var result;\n          result = {\n            dispose: function dispose() {\n              if (removeMonitor) {\n                removeMonitor();\n              }\n\n              result.dispose = Emitter._noop;\n\n              if (!_this2._disposed) {\n                remove();\n\n                if (_this2._options && _this2._options.onLastListenerRemove) {\n                  var hasListeners = _this2._listeners && !_this2._listeners.isEmpty();\n\n                  if (!hasListeners) {\n                    _this2._options.onLastListenerRemove(_this2);\n                  }\n                }\n              }\n            }\n          };\n\n          if (disposables instanceof DisposableStore) {\n            disposables.add(result);\n          } else if (Array.isArray(disposables)) {\n            disposables.push(result);\n          }\n\n          return result;\n        };\n      }\n\n      return this._event;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nEmitter._noop = function () {};\n\nexport var PauseableEmitter = /*#__PURE__*/function (_Emitter) {\n  _inherits(PauseableEmitter, _Emitter);\n\n  var _super = _createSuper(PauseableEmitter);\n\n  function PauseableEmitter(options) {\n    var _this3;\n\n    _classCallCheck(this, PauseableEmitter);\n\n    _this3 = _super.call(this, options);\n    _this3._isPaused = 0;\n    _this3._eventQueue = new LinkedList();\n    _this3._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    return _this3;\n  }\n\n  _createClass(PauseableEmitter, [{\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused++;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._isPaused !== 0 && --this._isPaused === 0) {\n        if (this._mergeFn) {\n          // use the merge function to create a single composite\n          // event. make a copy in case firing pauses this emitter\n          var events = Array.from(this._eventQueue);\n\n          this._eventQueue.clear();\n\n          _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._mergeFn(events));\n        } else {\n          // no merging, fire each event individually and test\n          // that this emitter isn't paused halfway through\n          while (!this._isPaused && this._eventQueue.size !== 0) {\n            _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, this._eventQueue.shift());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(event) {\n      if (this._listeners) {\n        if (this._isPaused !== 0) {\n          this._eventQueue.push(event);\n        } else {\n          _get(_getPrototypeOf(PauseableEmitter.prototype), \"fire\", this).call(this, event);\n        }\n      }\n    }\n  }]);\n\n  return PauseableEmitter;\n}(Emitter);\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\n\nexport var EventBufferer = /*#__PURE__*/function () {\n  function EventBufferer() {\n    _classCallCheck(this, EventBufferer);\n\n    this.buffers = [];\n  }\n\n  _createClass(EventBufferer, [{\n    key: \"wrapEvent\",\n    value: function wrapEvent(event) {\n      var _this4 = this;\n\n      return function (listener, thisArgs, disposables) {\n        return event(function (i) {\n          var buffer = _this4.buffers[_this4.buffers.length - 1];\n\n          if (buffer) {\n            buffer.push(function () {\n              return listener.call(thisArgs, i);\n            });\n          } else {\n            listener.call(thisArgs, i);\n          }\n        }, undefined, disposables);\n      };\n    }\n  }, {\n    key: \"bufferEvents\",\n    value: function bufferEvents(fn) {\n      var buffer = [];\n      this.buffers.push(buffer);\n      var r = fn();\n      this.buffers.pop();\n      buffer.forEach(function (flush) {\n        return flush();\n      });\n      return r;\n    }\n  }]);\n\n  return EventBufferer;\n}();\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\n\nexport var Relay = /*#__PURE__*/function () {\n  function Relay() {\n    var _this5 = this;\n\n    _classCallCheck(this, Relay);\n\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onFirstListenerDidAdd: function onFirstListenerDidAdd() {\n        _this5.listening = true;\n        _this5.inputEventListener = _this5.inputEvent(_this5.emitter.fire, _this5.emitter);\n      },\n      onLastListenerRemove: function onLastListenerRemove() {\n        _this5.listening = false;\n\n        _this5.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n\n  _createClass(Relay, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.inputEventListener.dispose();\n      this.emitter.dispose();\n    }\n  }, {\n    key: \"input\",\n    set: function set(event) {\n      this.inputEvent = event;\n\n      if (this.listening) {\n        this.inputEventListener.dispose();\n        this.inputEventListener = event(this.emitter.fire, this.emitter);\n      }\n    }\n  }]);\n\n  return Relay;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/event.js"],"names":["onUnexpectedError","Disposable","combinedDisposable","DisposableStore","LinkedList","StopWatch","Event","None","once","event","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","reduce","merge","initial","output","emitter","Emitter","onFirstListenerAdd","fire","onLastListenerRemove","debounce","delay","leading","leakWarningThreshold","subscription","undefined","handle","numDebouncedCalls","cur","clearTimeout","setTimeout","_output","stopwatch","start","Date","getTime","_","latch","firstCall","cache","value","shouldEmit","buffer","nextTick","_buffer","slice","push","flush","onFirstListenerDidAdd","ChainableEvent","fn","chain","fromNodeEventEmitter","eventName","id","on","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","fromPromise","promise","then","toPromise","Promise","resolve","EventProfiling","name","_listenerCount","_invocationCount","_elapsedOverall","_name","_idPool","listenerCount","_stopWatch","elapsed","console","info","toFixed","_globalLeakWarningThreshold","LeakageMonitor","customThreshold","Math","random","toString","_warnCountdown","_stacks","clear","threshold","Map","stack","Error","split","join","count","get","set","topStack","topCount","warn","options","_a","_disposed","_options","_leakageMon","_perfMon","_profName","_b","_listeners","_deliveryQueue","size","shift","stop","_c","_event","firstListener","isEmpty","remove","onListenerDidAdd","removeMonitor","check","_noop","hasListeners","add","Array","isArray","PauseableEmitter","_isPaused","_eventQueue","_mergeFn","from","EventBufferer","buffers","length","r","pop","Relay","listening","inputEvent","inputEventListener"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from './errors.js';\r\nimport { Disposable, combinedDisposable, DisposableStore } from './lifecycle.js';\r\nimport { LinkedList } from './linkedList.js';\r\nimport { StopWatch } from './stopwatch.js';\r\nexport var Event;\r\n(function (Event) {\r\n    Event.None = () => Disposable.None;\r\n    /**\r\n     * Given an event, returns another event which only fires once.\r\n     */\r\n    function once(event) {\r\n        return (listener, thisArgs = null, disposables) => {\r\n            // we need this, in case the event fires during the listener call\r\n            let didFire = false;\r\n            let result;\r\n            result = event(e => {\r\n                if (didFire) {\r\n                    return;\r\n                }\r\n                else if (result) {\r\n                    result.dispose();\r\n                }\r\n                else {\r\n                    didFire = true;\r\n                }\r\n                return listener.call(thisArgs, e);\r\n            }, null, disposables);\r\n            if (didFire) {\r\n                result.dispose();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    Event.once = once;\r\n    /**\r\n     * Given an event and a `map` function, returns another event which maps each element\r\n     * through the mapping function.\r\n     */\r\n    function map(event, map) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables));\r\n    }\r\n    Event.map = map;\r\n    /**\r\n     * Given an event and an `each` function, returns another identical event and calls\r\n     * the `each` function per each element.\r\n     */\r\n    function forEach(event, each) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables));\r\n    }\r\n    Event.forEach = forEach;\r\n    function filter(event, filter) {\r\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables));\r\n    }\r\n    Event.filter = filter;\r\n    /**\r\n     * Given an event, returns the same event but typed as `Event<void>`.\r\n     */\r\n    function signal(event) {\r\n        return event;\r\n    }\r\n    Event.signal = signal;\r\n    function any(...events) {\r\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\r\n    }\r\n    Event.any = any;\r\n    /**\r\n     * Given an event and a `merge` function, returns another event which maps each element\r\n     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.\r\n     */\r\n    function reduce(event, merge, initial) {\r\n        let output = initial;\r\n        return map(event, e => {\r\n            output = merge(output, e);\r\n            return output;\r\n        });\r\n    }\r\n    Event.reduce = reduce;\r\n    /**\r\n     * Given a chain of event processing functions (filter, map, etc), each\r\n     * function will be invoked per event & per listener. Snapshotting an event\r\n     * chain allows each function to be invoked just once per event.\r\n     */\r\n    function snapshot(event) {\r\n        let listener;\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                listener = event(emitter.fire, emitter);\r\n            },\r\n            onLastListenerRemove() {\r\n                listener.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.snapshot = snapshot;\r\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {\r\n        let subscription;\r\n        let output = undefined;\r\n        let handle = undefined;\r\n        let numDebouncedCalls = 0;\r\n        const emitter = new Emitter({\r\n            leakWarningThreshold,\r\n            onFirstListenerAdd() {\r\n                subscription = event(cur => {\r\n                    numDebouncedCalls++;\r\n                    output = merge(output, cur);\r\n                    if (leading && !handle) {\r\n                        emitter.fire(output);\r\n                        output = undefined;\r\n                    }\r\n                    clearTimeout(handle);\r\n                    handle = setTimeout(() => {\r\n                        const _output = output;\r\n                        output = undefined;\r\n                        handle = undefined;\r\n                        if (!leading || numDebouncedCalls > 1) {\r\n                            emitter.fire(_output);\r\n                        }\r\n                        numDebouncedCalls = 0;\r\n                    }, delay);\r\n                });\r\n            },\r\n            onLastListenerRemove() {\r\n                subscription.dispose();\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.debounce = debounce;\r\n    /**\r\n     * Given an event, it returns another event which fires only once and as soon as\r\n     * the input event emits. The event data is the number of millis it took for the\r\n     * event to fire.\r\n     */\r\n    function stopwatch(event) {\r\n        const start = new Date().getTime();\r\n        return map(once(event), _ => new Date().getTime() - start);\r\n    }\r\n    Event.stopwatch = stopwatch;\r\n    /**\r\n     * Given an event, it returns another event which fires only when the event\r\n     * element changes.\r\n     */\r\n    function latch(event) {\r\n        let firstCall = true;\r\n        let cache;\r\n        return filter(event, value => {\r\n            const shouldEmit = firstCall || value !== cache;\r\n            firstCall = false;\r\n            cache = value;\r\n            return shouldEmit;\r\n        });\r\n    }\r\n    Event.latch = latch;\r\n    /**\r\n     * Buffers the provided event until a first listener comes\r\n     * along, at which point fire all the events at once and\r\n     * pipe the event from then on.\r\n     *\r\n     * ```typescript\r\n     * const emitter = new Emitter<number>();\r\n     * const event = emitter.event;\r\n     * const bufferedEvent = buffer(event);\r\n     *\r\n     * emitter.fire(1);\r\n     * emitter.fire(2);\r\n     * emitter.fire(3);\r\n     * // nothing...\r\n     *\r\n     * const listener = bufferedEvent(num => console.log(num));\r\n     * // 1, 2, 3\r\n     *\r\n     * emitter.fire(4);\r\n     * // 4\r\n     * ```\r\n     */\r\n    function buffer(event, nextTick = false, _buffer = []) {\r\n        let buffer = _buffer.slice();\r\n        let listener = event(e => {\r\n            if (buffer) {\r\n                buffer.push(e);\r\n            }\r\n            else {\r\n                emitter.fire(e);\r\n            }\r\n        });\r\n        const flush = () => {\r\n            if (buffer) {\r\n                buffer.forEach(e => emitter.fire(e));\r\n            }\r\n            buffer = null;\r\n        };\r\n        const emitter = new Emitter({\r\n            onFirstListenerAdd() {\r\n                if (!listener) {\r\n                    listener = event(e => emitter.fire(e));\r\n                }\r\n            },\r\n            onFirstListenerDidAdd() {\r\n                if (buffer) {\r\n                    if (nextTick) {\r\n                        setTimeout(flush);\r\n                    }\r\n                    else {\r\n                        flush();\r\n                    }\r\n                }\r\n            },\r\n            onLastListenerRemove() {\r\n                if (listener) {\r\n                    listener.dispose();\r\n                }\r\n                listener = null;\r\n            }\r\n        });\r\n        return emitter.event;\r\n    }\r\n    Event.buffer = buffer;\r\n    class ChainableEvent {\r\n        constructor(event) {\r\n            this.event = event;\r\n        }\r\n        map(fn) {\r\n            return new ChainableEvent(map(this.event, fn));\r\n        }\r\n        forEach(fn) {\r\n            return new ChainableEvent(forEach(this.event, fn));\r\n        }\r\n        filter(fn) {\r\n            return new ChainableEvent(filter(this.event, fn));\r\n        }\r\n        reduce(merge, initial) {\r\n            return new ChainableEvent(reduce(this.event, merge, initial));\r\n        }\r\n        latch() {\r\n            return new ChainableEvent(latch(this.event));\r\n        }\r\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\r\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\r\n        }\r\n        on(listener, thisArgs, disposables) {\r\n            return this.event(listener, thisArgs, disposables);\r\n        }\r\n        once(listener, thisArgs, disposables) {\r\n            return once(this.event)(listener, thisArgs, disposables);\r\n        }\r\n    }\r\n    function chain(event) {\r\n        return new ChainableEvent(event);\r\n    }\r\n    Event.chain = chain;\r\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\r\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\r\n        const fn = (...args) => result.fire(map(...args));\r\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\r\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\r\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\r\n        return result.event;\r\n    }\r\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\r\n    function fromPromise(promise) {\r\n        const emitter = new Emitter();\r\n        let shouldEmit = false;\r\n        promise\r\n            .then(undefined, () => null)\r\n            .then(() => {\r\n            if (!shouldEmit) {\r\n                setTimeout(() => emitter.fire(undefined), 0);\r\n            }\r\n            else {\r\n                emitter.fire(undefined);\r\n            }\r\n        });\r\n        shouldEmit = true;\r\n        return emitter.event;\r\n    }\r\n    Event.fromPromise = fromPromise;\r\n    function toPromise(event) {\r\n        return new Promise(resolve => once(event)(resolve));\r\n    }\r\n    Event.toPromise = toPromise;\r\n})(Event || (Event = {}));\r\nclass EventProfiling {\r\n    constructor(name) {\r\n        this._listenerCount = 0;\r\n        this._invocationCount = 0;\r\n        this._elapsedOverall = 0;\r\n        this._name = `${name}_${EventProfiling._idPool++}`;\r\n    }\r\n    start(listenerCount) {\r\n        this._stopWatch = new StopWatch(true);\r\n        this._listenerCount = listenerCount;\r\n    }\r\n    stop() {\r\n        if (this._stopWatch) {\r\n            const elapsed = this._stopWatch.elapsed();\r\n            this._elapsedOverall += elapsed;\r\n            this._invocationCount += 1;\r\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\r\n            this._stopWatch = undefined;\r\n        }\r\n    }\r\n}\r\nEventProfiling._idPool = 0;\r\nlet _globalLeakWarningThreshold = -1;\r\nclass LeakageMonitor {\r\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\r\n        this.customThreshold = customThreshold;\r\n        this.name = name;\r\n        this._warnCountdown = 0;\r\n    }\r\n    dispose() {\r\n        if (this._stacks) {\r\n            this._stacks.clear();\r\n        }\r\n    }\r\n    check(listenerCount) {\r\n        let threshold = _globalLeakWarningThreshold;\r\n        if (typeof this.customThreshold === 'number') {\r\n            threshold = this.customThreshold;\r\n        }\r\n        if (threshold <= 0 || listenerCount < threshold) {\r\n            return undefined;\r\n        }\r\n        if (!this._stacks) {\r\n            this._stacks = new Map();\r\n        }\r\n        const stack = new Error().stack.split('\\n').slice(3).join('\\n');\r\n        const count = (this._stacks.get(stack) || 0);\r\n        this._stacks.set(stack, count + 1);\r\n        this._warnCountdown -= 1;\r\n        if (this._warnCountdown <= 0) {\r\n            // only warn on first exceed and then every time the limit\r\n            // is exceeded by 50% again\r\n            this._warnCountdown = threshold * 0.5;\r\n            // find most frequent listener and print warning\r\n            let topStack;\r\n            let topCount = 0;\r\n            for (const [stack, count] of this._stacks) {\r\n                if (!topStack || topCount < count) {\r\n                    topStack = stack;\r\n                    topCount = count;\r\n                }\r\n            }\r\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\r\n            console.warn(topStack);\r\n        }\r\n        return () => {\r\n            const count = (this._stacks.get(stack) || 0);\r\n            this._stacks.set(stack, count - 1);\r\n        };\r\n    }\r\n}\r\n/**\r\n * The Emitter can be used to expose an Event to the public\r\n * to fire it from the insides.\r\n * Sample:\r\n    class Document {\r\n\r\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\r\n\r\n        public onDidChange = this._onDidChange.event;\r\n\r\n        // getter-style\r\n        // get onDidChange(): Event<(value:string)=>any> {\r\n        // \treturn this._onDidChange.event;\r\n        // }\r\n\r\n        private _doIt() {\r\n            //...\r\n            this._onDidChange.fire(value);\r\n        }\r\n    }\r\n */\r\nexport class Emitter {\r\n    constructor(options) {\r\n        var _a;\r\n        this._disposed = false;\r\n        this._options = options;\r\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\r\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                var _a;\r\n                if (!this._listeners) {\r\n                    this._listeners = new LinkedList();\r\n                }\r\n                const firstListener = this._listeners.isEmpty();\r\n                if (firstListener && this._options && this._options.onFirstListenerAdd) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);\r\n                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {\r\n                    this._options.onFirstListenerDidAdd(this);\r\n                }\r\n                if (this._options && this._options.onListenerDidAdd) {\r\n                    this._options.onListenerDidAdd(this, listener, thisArgs);\r\n                }\r\n                // check and record this emitter for potential leakage\r\n                const removeMonitor = (_a = this._leakageMon) === null || _a === void 0 ? void 0 : _a.check(this._listeners.size);\r\n                let result;\r\n                result = {\r\n                    dispose: () => {\r\n                        if (removeMonitor) {\r\n                            removeMonitor();\r\n                        }\r\n                        result.dispose = Emitter._noop;\r\n                        if (!this._disposed) {\r\n                            remove();\r\n                            if (this._options && this._options.onLastListenerRemove) {\r\n                                const hasListeners = (this._listeners && !this._listeners.isEmpty());\r\n                                if (!hasListeners) {\r\n                                    this._options.onLastListenerRemove(this);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                if (disposables instanceof DisposableStore) {\r\n                    disposables.add(result);\r\n                }\r\n                else if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        var _a, _b;\r\n        if (this._listeners) {\r\n            // put all [listener,event]-pairs into delivery queue\r\n            // then emit all event. an inner/nested event might be\r\n            // the driver of this\r\n            if (!this._deliveryQueue) {\r\n                this._deliveryQueue = new LinkedList();\r\n            }\r\n            for (let listener of this._listeners) {\r\n                this._deliveryQueue.push([listener, event]);\r\n            }\r\n            // start/stop performance insight collection\r\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\r\n            while (this._deliveryQueue.size > 0) {\r\n                const [listener, event] = this._deliveryQueue.shift();\r\n                try {\r\n                    if (typeof listener === 'function') {\r\n                        listener.call(undefined, event);\r\n                    }\r\n                    else {\r\n                        listener[0].call(listener[1], event);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    onUnexpectedError(e);\r\n                }\r\n            }\r\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\r\n        }\r\n    }\r\n    dispose() {\r\n        var _a, _b, _c;\r\n        (_a = this._listeners) === null || _a === void 0 ? void 0 : _a.clear();\r\n        (_b = this._deliveryQueue) === null || _b === void 0 ? void 0 : _b.clear();\r\n        (_c = this._leakageMon) === null || _c === void 0 ? void 0 : _c.dispose();\r\n        this._disposed = true;\r\n    }\r\n}\r\nEmitter._noop = function () { };\r\nexport class PauseableEmitter extends Emitter {\r\n    constructor(options) {\r\n        super(options);\r\n        this._isPaused = 0;\r\n        this._eventQueue = new LinkedList();\r\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\r\n    }\r\n    pause() {\r\n        this._isPaused++;\r\n    }\r\n    resume() {\r\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\r\n            if (this._mergeFn) {\r\n                // use the merge function to create a single composite\r\n                // event. make a copy in case firing pauses this emitter\r\n                const events = Array.from(this._eventQueue);\r\n                this._eventQueue.clear();\r\n                super.fire(this._mergeFn(events));\r\n            }\r\n            else {\r\n                // no merging, fire each event individually and test\r\n                // that this emitter isn't paused halfway through\r\n                while (!this._isPaused && this._eventQueue.size !== 0) {\r\n                    super.fire(this._eventQueue.shift());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    fire(event) {\r\n        if (this._listeners) {\r\n            if (this._isPaused !== 0) {\r\n                this._eventQueue.push(event);\r\n            }\r\n            else {\r\n                super.fire(event);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * The EventBufferer is useful in situations in which you want\r\n * to delay firing your events during some code.\r\n * You can wrap that code and be sure that the event will not\r\n * be fired during that wrap.\r\n *\r\n * ```\r\n * const emitter: Emitter;\r\n * const delayer = new EventDelayer();\r\n * const delayedEvent = delayer.wrapEvent(emitter.event);\r\n *\r\n * delayedEvent(console.log);\r\n *\r\n * delayer.bufferEvents(() => {\r\n *   emitter.fire(); // event will not be fired yet\r\n * });\r\n *\r\n * // event will only be fired at this point\r\n * ```\r\n */\r\nexport class EventBufferer {\r\n    constructor() {\r\n        this.buffers = [];\r\n    }\r\n    wrapEvent(event) {\r\n        return (listener, thisArgs, disposables) => {\r\n            return event(i => {\r\n                const buffer = this.buffers[this.buffers.length - 1];\r\n                if (buffer) {\r\n                    buffer.push(() => listener.call(thisArgs, i));\r\n                }\r\n                else {\r\n                    listener.call(thisArgs, i);\r\n                }\r\n            }, undefined, disposables);\r\n        };\r\n    }\r\n    bufferEvents(fn) {\r\n        const buffer = [];\r\n        this.buffers.push(buffer);\r\n        const r = fn();\r\n        this.buffers.pop();\r\n        buffer.forEach(flush => flush());\r\n        return r;\r\n    }\r\n}\r\n/**\r\n * A Relay is an event forwarder which functions as a replugabble event pipe.\r\n * Once created, you can connect an input event to it and it will simply forward\r\n * events from that input event through its own `event` property. The `input`\r\n * can be changed at any point in time.\r\n */\r\nexport class Relay {\r\n    constructor() {\r\n        this.listening = false;\r\n        this.inputEvent = Event.None;\r\n        this.inputEventListener = Disposable.None;\r\n        this.emitter = new Emitter({\r\n            onFirstListenerDidAdd: () => {\r\n                this.listening = true;\r\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\r\n            },\r\n            onLastListenerRemove: () => {\r\n                this.listening = false;\r\n                this.inputEventListener.dispose();\r\n            }\r\n        });\r\n        this.event = this.emitter.event;\r\n    }\r\n    set input(event) {\r\n        this.inputEvent = event;\r\n        if (this.listening) {\r\n            this.inputEventListener.dispose();\r\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.inputEventListener.dispose();\r\n        this.emitter.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}