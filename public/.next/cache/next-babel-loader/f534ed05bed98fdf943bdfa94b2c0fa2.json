{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _construct from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { illegalState } from '../../../base/common/errors.js';\nimport { Graph } from './graph.js';\nimport { SyncDescriptor } from './descriptors.js';\nimport { IInstantiationService, _util, optional } from './instantiation.js';\nimport { ServiceCollection } from './serviceCollection.js';\nimport { IdleValue } from '../../../base/common/async.js'; // TRACING\n\nvar _enableTracing = false;\n\nvar CyclicDependencyError = /*#__PURE__*/function (_Error) {\n  _inherits(CyclicDependencyError, _Error);\n\n  var _super = _createSuper(CyclicDependencyError);\n\n  function CyclicDependencyError(graph) {\n    var _this;\n\n    _classCallCheck(this, CyclicDependencyError);\n\n    _this = _super.call(this, 'cyclic dependency between services');\n    _this.message = graph.toString();\n    return _this;\n  }\n\n  return CyclicDependencyError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexport var InstantiationService = /*#__PURE__*/function () {\n  function InstantiationService() {\n    var services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new ServiceCollection();\n    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var parent = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, InstantiationService);\n\n    this._activeInstantiations = new Set();\n    this._services = services;\n    this._strict = strict;\n    this._parent = parent;\n\n    this._services.set(IInstantiationService, this);\n  }\n\n  _createClass(InstantiationService, [{\n    key: \"createChild\",\n    value: function createChild(services) {\n      return new InstantiationService(services, this._strict, this);\n    }\n  }, {\n    key: \"invokeFunction\",\n    value: function invokeFunction(fn) {\n      var _this2 = this;\n\n      var _trace = Trace.traceInvocation(fn);\n\n      var _done = false;\n\n      try {\n        var accessor = {\n          get: function get(id, isOptional) {\n            if (_done) {\n              throw illegalState('service accessor is only valid during the invocation of its target method');\n            }\n\n            var result = _this2._getOrCreateServiceInstance(id, _trace);\n\n            if (!result && isOptional !== optional) {\n              throw new Error(\"[invokeFunction] unknown service '\".concat(id, \"'\"));\n            }\n\n            return result;\n          }\n        };\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return fn.apply(void 0, [accessor].concat(args));\n      } finally {\n        _done = true;\n\n        _trace.stop();\n      }\n    }\n  }, {\n    key: \"createInstance\",\n    value: function createInstance(ctorOrDescriptor) {\n      var _trace;\n\n      var result;\n\n      for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        rest[_key2 - 1] = arguments[_key2];\n      }\n\n      if (ctorOrDescriptor instanceof SyncDescriptor) {\n        _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\n        result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\n      } else {\n        _trace = Trace.traceCreation(ctorOrDescriptor);\n        result = this._createInstance(ctorOrDescriptor, rest, _trace);\n      }\n\n      _trace.stop();\n\n      return result;\n    }\n  }, {\n    key: \"_createInstance\",\n    value: function _createInstance(ctor) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var _trace = arguments.length > 2 ? arguments[2] : undefined;\n\n      // arguments defined by service decorators\n      var serviceDependencies = _util.getServiceDependencies(ctor).sort(function (a, b) {\n        return a.index - b.index;\n      });\n\n      var serviceArgs = [];\n\n      var _iterator = _createForOfIteratorHelper(serviceDependencies),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dependency = _step.value;\n\n          var service = this._getOrCreateServiceInstance(dependency.id, _trace);\n\n          if (!service && this._strict && !dependency.optional) {\n            throw new Error(\"[createInstance] \".concat(ctor.name, \" depends on UNKNOWN service \").concat(dependency.id, \".\"));\n          }\n\n          serviceArgs.push(service);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length; // check for argument mismatches, adjust static args if needed\n\n      if (args.length !== firstServiceArgPos) {\n        console.warn(\"[createInstance] First service dependency of \".concat(ctor.name, \" at position \").concat(firstServiceArgPos + 1, \" conflicts with \").concat(args.length, \" static arguments\"));\n        var delta = firstServiceArgPos - args.length;\n\n        if (delta > 0) {\n          args = args.concat(new Array(delta));\n        } else {\n          args = args.slice(0, firstServiceArgPos);\n        }\n      } // now create the instance\n\n\n      return _construct(ctor, [].concat(_toConsumableArray(args), serviceArgs));\n    }\n  }, {\n    key: \"_setServiceInstance\",\n    value: function _setServiceInstance(id, instance) {\n      if (this._services.get(id) instanceof SyncDescriptor) {\n        this._services.set(id, instance);\n      } else if (this._parent) {\n        this._parent._setServiceInstance(id, instance);\n      } else {\n        throw new Error('illegalState - setting UNKNOWN service instance');\n      }\n    }\n  }, {\n    key: \"_getServiceInstanceOrDescriptor\",\n    value: function _getServiceInstanceOrDescriptor(id) {\n      var instanceOrDesc = this._services.get(id);\n\n      if (!instanceOrDesc && this._parent) {\n        return this._parent._getServiceInstanceOrDescriptor(id);\n      } else {\n        return instanceOrDesc;\n      }\n    }\n  }, {\n    key: \"_getOrCreateServiceInstance\",\n    value: function _getOrCreateServiceInstance(id, _trace) {\n      var thing = this._getServiceInstanceOrDescriptor(id);\n\n      if (thing instanceof SyncDescriptor) {\n        return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\n      } else {\n        _trace.branch(id, false);\n\n        return thing;\n      }\n    }\n  }, {\n    key: \"_safeCreateAndCacheServiceInstance\",\n    value: function _safeCreateAndCacheServiceInstance(id, desc, _trace) {\n      if (this._activeInstantiations.has(id)) {\n        throw new Error(\"illegal state - RECURSIVELY instantiating service '\".concat(id, \"'\"));\n      }\n\n      this._activeInstantiations.add(id);\n\n      try {\n        return this._createAndCacheServiceInstance(id, desc, _trace);\n      } finally {\n        this._activeInstantiations[\"delete\"](id);\n      }\n    }\n  }, {\n    key: \"_createAndCacheServiceInstance\",\n    value: function _createAndCacheServiceInstance(id, desc, _trace) {\n      var graph = new Graph(function (data) {\n        return data.id.toString();\n      });\n      var cycleCount = 0;\n      var stack = [{\n        id: id,\n        desc: desc,\n        _trace: _trace\n      }];\n\n      while (stack.length) {\n        var item = stack.pop();\n        graph.lookupOrInsertNode(item); // a weak but working heuristic for cycle checks\n\n        if (cycleCount++ > 1000) {\n          throw new CyclicDependencyError(graph);\n        } // check all dependencies for existence and if they need to be created first\n\n\n        var _iterator2 = _createForOfIteratorHelper(_util.getServiceDependencies(item.desc.ctor)),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var dependency = _step2.value;\n\n            var instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\n\n            if (!instanceOrDesc && !dependency.optional) {\n              console.warn(\"[createInstance] \".concat(id, \" depends on \").concat(dependency.id, \" which is NOT registered.\"));\n            }\n\n            if (instanceOrDesc instanceof SyncDescriptor) {\n              var d = {\n                id: dependency.id,\n                desc: instanceOrDesc,\n                _trace: item._trace.branch(dependency.id, true)\n              };\n              graph.insertEdge(item, d);\n              stack.push(d);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      while (true) {\n        var roots = graph.roots(); // if there is no more roots but still\n        // nodes in the graph we have a cycle\n\n        if (roots.length === 0) {\n          if (!graph.isEmpty()) {\n            throw new CyclicDependencyError(graph);\n          }\n\n          break;\n        }\n\n        var _iterator3 = _createForOfIteratorHelper(roots),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var data = _step3.value.data;\n\n            // Repeat the check for this still being a service sync descriptor. That's because\n            // instantiating a dependency might have side-effect and recursively trigger instantiation\n            // so that some dependencies are now fullfilled already.\n            var _instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\n\n            if (_instanceOrDesc instanceof SyncDescriptor) {\n              // create instance and overwrite the service collections\n              var instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\n\n              this._setServiceInstance(data.id, instance);\n            }\n\n            graph.removeNode(data);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return this._getServiceInstanceOrDescriptor(id);\n    }\n  }, {\n    key: \"_createServiceInstanceWithOwner\",\n    value: function _createServiceInstanceWithOwner(id, ctor) {\n      var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var supportsDelayedInstantiation = arguments.length > 3 ? arguments[3] : undefined;\n\n      var _trace = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (this._services.get(id) instanceof SyncDescriptor) {\n        return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\n      } else if (this._parent) {\n        return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\n      } else {\n        throw new Error(\"illegalState - creating UNKNOWN service instance \".concat(ctor.name));\n      }\n    }\n  }, {\n    key: \"_createServiceInstance\",\n    value: function _createServiceInstance(ctor) {\n      var _this3 = this;\n\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var _supportsDelayedInstantiation = arguments.length > 2 ? arguments[2] : undefined;\n\n      var _trace = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!_supportsDelayedInstantiation) {\n        // eager instantiation\n        return this._createInstance(ctor, args, _trace);\n      } else {\n        // Return a proxy object that's backed by an idle value. That\n        // strategy is to instantiate services in our idle time or when actually\n        // needed but not when injected into a consumer\n        var idle = new IdleValue(function () {\n          return _this3._createInstance(ctor, args, _trace);\n        });\n        return new Proxy(Object.create(null), {\n          get: function get(target, key) {\n            if (key in target) {\n              return target[key];\n            }\n\n            var obj = idle.value;\n            var prop = obj[key];\n\n            if (typeof prop !== 'function') {\n              return prop;\n            }\n\n            prop = prop.bind(obj);\n            target[key] = prop;\n            return prop;\n          },\n          set: function set(_target, p, value) {\n            idle.value[p] = value;\n            return true;\n          }\n        });\n      }\n    }\n  }]);\n\n  return InstantiationService;\n}();\n\nvar Trace = /*#__PURE__*/function () {\n  function Trace(type, name) {\n    _classCallCheck(this, Trace);\n\n    this.type = type;\n    this.name = name;\n    this._start = Date.now();\n    this._dep = [];\n  }\n\n  _createClass(Trace, [{\n    key: \"branch\",\n    value: function branch(id, first) {\n      var child = new Trace(2\n      /* Branch */\n      , id.toString());\n\n      this._dep.push([id, first, child]);\n\n      return child;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var dur = Date.now() - this._start;\n\n      Trace._totals += dur;\n      var causedCreation = false;\n\n      function printChild(n, trace) {\n        var res = [];\n        var prefix = new Array(n + 1).join('\\t');\n\n        var _iterator4 = _createForOfIteratorHelper(trace._dep),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 3),\n                id = _step4$value[0],\n                first = _step4$value[1],\n                child = _step4$value[2];\n\n            if (first && child) {\n              causedCreation = true;\n              res.push(\"\".concat(prefix, \"CREATES -> \").concat(id));\n              var nested = printChild(n + 1, child);\n\n              if (nested) {\n                res.push(nested);\n              }\n            } else {\n              res.push(\"\".concat(prefix, \"uses -> \").concat(id));\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return res.join('\\n');\n      }\n\n      var lines = [\"\".concat(this.type === 0\n      /* Creation */\n      ? 'CREATE' : 'CALL', \" \").concat(this.name), \"\".concat(printChild(1, this)), \"DONE, took \".concat(dur.toFixed(2), \"ms (grand total \").concat(Trace._totals.toFixed(2), \"ms)\")];\n\n      if (dur > 2 || causedCreation) {\n        console.log(lines.join('\\n'));\n      }\n    }\n  }], [{\n    key: \"traceInvocation\",\n    value: function traceInvocation(ctor) {\n      return !_enableTracing ? Trace._None : new Trace(1\n      /* Invocation */\n      , ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\n    }\n  }, {\n    key: \"traceCreation\",\n    value: function traceCreation(ctor) {\n      return !_enableTracing ? Trace._None : new Trace(0\n      /* Creation */\n      , ctor.name);\n    }\n  }]);\n\n  return Trace;\n}();\n\nTrace._None = new ( /*#__PURE__*/function (_Trace) {\n  _inherits(_class, _Trace);\n\n  var _super2 = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super2.call(this, -1, null);\n  }\n\n  _createClass(_class, [{\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"branch\",\n    value: function branch() {\n      return this;\n    }\n  }]);\n\n  return _class;\n}(Trace))();\nTrace._totals = 0; //#endregion","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiationService.js"],"names":["illegalState","Graph","SyncDescriptor","IInstantiationService","_util","optional","ServiceCollection","IdleValue","_enableTracing","CyclicDependencyError","graph","message","toString","Error","InstantiationService","services","strict","parent","_activeInstantiations","Set","_services","_strict","_parent","set","fn","_trace","Trace","traceInvocation","_done","accessor","get","id","isOptional","result","_getOrCreateServiceInstance","args","stop","ctorOrDescriptor","rest","traceCreation","ctor","_createInstance","staticArguments","concat","serviceDependencies","getServiceDependencies","sort","a","b","index","serviceArgs","dependency","service","name","push","firstServiceArgPos","length","console","warn","delta","Array","slice","instance","_setServiceInstance","instanceOrDesc","_getServiceInstanceOrDescriptor","thing","_safeCreateAndCacheServiceInstance","branch","desc","has","add","_createAndCacheServiceInstance","data","cycleCount","stack","item","pop","lookupOrInsertNode","d","insertEdge","roots","isEmpty","_createServiceInstanceWithOwner","supportsDelayedInstantiation","removeNode","_createServiceInstance","_supportsDelayedInstantiation","idle","Proxy","Object","create","target","key","obj","value","prop","bind","_target","p","type","_start","Date","now","_dep","first","child","dur","_totals","causedCreation","printChild","n","trace","res","prefix","join","nested","lines","toFixed","log","_None","substring","replace"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { illegalState } from '../../../base/common/errors.js';\r\nimport { Graph } from './graph.js';\r\nimport { SyncDescriptor } from './descriptors.js';\r\nimport { IInstantiationService, _util, optional } from './instantiation.js';\r\nimport { ServiceCollection } from './serviceCollection.js';\r\nimport { IdleValue } from '../../../base/common/async.js';\r\n// TRACING\r\nconst _enableTracing = false;\r\nclass CyclicDependencyError extends Error {\r\n    constructor(graph) {\r\n        super('cyclic dependency between services');\r\n        this.message = graph.toString();\r\n    }\r\n}\r\nexport class InstantiationService {\r\n    constructor(services = new ServiceCollection(), strict = false, parent) {\r\n        this._activeInstantiations = new Set();\r\n        this._services = services;\r\n        this._strict = strict;\r\n        this._parent = parent;\r\n        this._services.set(IInstantiationService, this);\r\n    }\r\n    createChild(services) {\r\n        return new InstantiationService(services, this._strict, this);\r\n    }\r\n    invokeFunction(fn, ...args) {\r\n        let _trace = Trace.traceInvocation(fn);\r\n        let _done = false;\r\n        try {\r\n            const accessor = {\r\n                get: (id, isOptional) => {\r\n                    if (_done) {\r\n                        throw illegalState('service accessor is only valid during the invocation of its target method');\r\n                    }\r\n                    const result = this._getOrCreateServiceInstance(id, _trace);\r\n                    if (!result && isOptional !== optional) {\r\n                        throw new Error(`[invokeFunction] unknown service '${id}'`);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            return fn(accessor, ...args);\r\n        }\r\n        finally {\r\n            _done = true;\r\n            _trace.stop();\r\n        }\r\n    }\r\n    createInstance(ctorOrDescriptor, ...rest) {\r\n        let _trace;\r\n        let result;\r\n        if (ctorOrDescriptor instanceof SyncDescriptor) {\r\n            _trace = Trace.traceCreation(ctorOrDescriptor.ctor);\r\n            result = this._createInstance(ctorOrDescriptor.ctor, ctorOrDescriptor.staticArguments.concat(rest), _trace);\r\n        }\r\n        else {\r\n            _trace = Trace.traceCreation(ctorOrDescriptor);\r\n            result = this._createInstance(ctorOrDescriptor, rest, _trace);\r\n        }\r\n        _trace.stop();\r\n        return result;\r\n    }\r\n    _createInstance(ctor, args = [], _trace) {\r\n        // arguments defined by service decorators\r\n        let serviceDependencies = _util.getServiceDependencies(ctor).sort((a, b) => a.index - b.index);\r\n        let serviceArgs = [];\r\n        for (const dependency of serviceDependencies) {\r\n            let service = this._getOrCreateServiceInstance(dependency.id, _trace);\r\n            if (!service && this._strict && !dependency.optional) {\r\n                throw new Error(`[createInstance] ${ctor.name} depends on UNKNOWN service ${dependency.id}.`);\r\n            }\r\n            serviceArgs.push(service);\r\n        }\r\n        let firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : args.length;\r\n        // check for argument mismatches, adjust static args if needed\r\n        if (args.length !== firstServiceArgPos) {\r\n            console.warn(`[createInstance] First service dependency of ${ctor.name} at position ${firstServiceArgPos + 1} conflicts with ${args.length} static arguments`);\r\n            let delta = firstServiceArgPos - args.length;\r\n            if (delta > 0) {\r\n                args = args.concat(new Array(delta));\r\n            }\r\n            else {\r\n                args = args.slice(0, firstServiceArgPos);\r\n            }\r\n        }\r\n        // now create the instance\r\n        return new ctor(...[...args, ...serviceArgs]);\r\n    }\r\n    _setServiceInstance(id, instance) {\r\n        if (this._services.get(id) instanceof SyncDescriptor) {\r\n            this._services.set(id, instance);\r\n        }\r\n        else if (this._parent) {\r\n            this._parent._setServiceInstance(id, instance);\r\n        }\r\n        else {\r\n            throw new Error('illegalState - setting UNKNOWN service instance');\r\n        }\r\n    }\r\n    _getServiceInstanceOrDescriptor(id) {\r\n        let instanceOrDesc = this._services.get(id);\r\n        if (!instanceOrDesc && this._parent) {\r\n            return this._parent._getServiceInstanceOrDescriptor(id);\r\n        }\r\n        else {\r\n            return instanceOrDesc;\r\n        }\r\n    }\r\n    _getOrCreateServiceInstance(id, _trace) {\r\n        let thing = this._getServiceInstanceOrDescriptor(id);\r\n        if (thing instanceof SyncDescriptor) {\r\n            return this._safeCreateAndCacheServiceInstance(id, thing, _trace.branch(id, true));\r\n        }\r\n        else {\r\n            _trace.branch(id, false);\r\n            return thing;\r\n        }\r\n    }\r\n    _safeCreateAndCacheServiceInstance(id, desc, _trace) {\r\n        if (this._activeInstantiations.has(id)) {\r\n            throw new Error(`illegal state - RECURSIVELY instantiating service '${id}'`);\r\n        }\r\n        this._activeInstantiations.add(id);\r\n        try {\r\n            return this._createAndCacheServiceInstance(id, desc, _trace);\r\n        }\r\n        finally {\r\n            this._activeInstantiations.delete(id);\r\n        }\r\n    }\r\n    _createAndCacheServiceInstance(id, desc, _trace) {\r\n        const graph = new Graph(data => data.id.toString());\r\n        let cycleCount = 0;\r\n        const stack = [{ id, desc, _trace }];\r\n        while (stack.length) {\r\n            const item = stack.pop();\r\n            graph.lookupOrInsertNode(item);\r\n            // a weak but working heuristic for cycle checks\r\n            if (cycleCount++ > 1000) {\r\n                throw new CyclicDependencyError(graph);\r\n            }\r\n            // check all dependencies for existence and if they need to be created first\r\n            for (let dependency of _util.getServiceDependencies(item.desc.ctor)) {\r\n                let instanceOrDesc = this._getServiceInstanceOrDescriptor(dependency.id);\r\n                if (!instanceOrDesc && !dependency.optional) {\r\n                    console.warn(`[createInstance] ${id} depends on ${dependency.id} which is NOT registered.`);\r\n                }\r\n                if (instanceOrDesc instanceof SyncDescriptor) {\r\n                    const d = { id: dependency.id, desc: instanceOrDesc, _trace: item._trace.branch(dependency.id, true) };\r\n                    graph.insertEdge(item, d);\r\n                    stack.push(d);\r\n                }\r\n            }\r\n        }\r\n        while (true) {\r\n            const roots = graph.roots();\r\n            // if there is no more roots but still\r\n            // nodes in the graph we have a cycle\r\n            if (roots.length === 0) {\r\n                if (!graph.isEmpty()) {\r\n                    throw new CyclicDependencyError(graph);\r\n                }\r\n                break;\r\n            }\r\n            for (const { data } of roots) {\r\n                // Repeat the check for this still being a service sync descriptor. That's because\r\n                // instantiating a dependency might have side-effect and recursively trigger instantiation\r\n                // so that some dependencies are now fullfilled already.\r\n                const instanceOrDesc = this._getServiceInstanceOrDescriptor(data.id);\r\n                if (instanceOrDesc instanceof SyncDescriptor) {\r\n                    // create instance and overwrite the service collections\r\n                    const instance = this._createServiceInstanceWithOwner(data.id, data.desc.ctor, data.desc.staticArguments, data.desc.supportsDelayedInstantiation, data._trace);\r\n                    this._setServiceInstance(data.id, instance);\r\n                }\r\n                graph.removeNode(data);\r\n            }\r\n        }\r\n        return this._getServiceInstanceOrDescriptor(id);\r\n    }\r\n    _createServiceInstanceWithOwner(id, ctor, args = [], supportsDelayedInstantiation, _trace) {\r\n        if (this._services.get(id) instanceof SyncDescriptor) {\r\n            return this._createServiceInstance(ctor, args, supportsDelayedInstantiation, _trace);\r\n        }\r\n        else if (this._parent) {\r\n            return this._parent._createServiceInstanceWithOwner(id, ctor, args, supportsDelayedInstantiation, _trace);\r\n        }\r\n        else {\r\n            throw new Error(`illegalState - creating UNKNOWN service instance ${ctor.name}`);\r\n        }\r\n    }\r\n    _createServiceInstance(ctor, args = [], _supportsDelayedInstantiation, _trace) {\r\n        if (!_supportsDelayedInstantiation) {\r\n            // eager instantiation\r\n            return this._createInstance(ctor, args, _trace);\r\n        }\r\n        else {\r\n            // Return a proxy object that's backed by an idle value. That\r\n            // strategy is to instantiate services in our idle time or when actually\r\n            // needed but not when injected into a consumer\r\n            const idle = new IdleValue(() => this._createInstance(ctor, args, _trace));\r\n            return new Proxy(Object.create(null), {\r\n                get(target, key) {\r\n                    if (key in target) {\r\n                        return target[key];\r\n                    }\r\n                    let obj = idle.value;\r\n                    let prop = obj[key];\r\n                    if (typeof prop !== 'function') {\r\n                        return prop;\r\n                    }\r\n                    prop = prop.bind(obj);\r\n                    target[key] = prop;\r\n                    return prop;\r\n                },\r\n                set(_target, p, value) {\r\n                    idle.value[p] = value;\r\n                    return true;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nclass Trace {\r\n    constructor(type, name) {\r\n        this.type = type;\r\n        this.name = name;\r\n        this._start = Date.now();\r\n        this._dep = [];\r\n    }\r\n    static traceInvocation(ctor) {\r\n        return !_enableTracing ? Trace._None : new Trace(1 /* Invocation */, ctor.name || ctor.toString().substring(0, 42).replace(/\\n/g, ''));\r\n    }\r\n    static traceCreation(ctor) {\r\n        return !_enableTracing ? Trace._None : new Trace(0 /* Creation */, ctor.name);\r\n    }\r\n    branch(id, first) {\r\n        let child = new Trace(2 /* Branch */, id.toString());\r\n        this._dep.push([id, first, child]);\r\n        return child;\r\n    }\r\n    stop() {\r\n        let dur = Date.now() - this._start;\r\n        Trace._totals += dur;\r\n        let causedCreation = false;\r\n        function printChild(n, trace) {\r\n            let res = [];\r\n            let prefix = new Array(n + 1).join('\\t');\r\n            for (const [id, first, child] of trace._dep) {\r\n                if (first && child) {\r\n                    causedCreation = true;\r\n                    res.push(`${prefix}CREATES -> ${id}`);\r\n                    let nested = printChild(n + 1, child);\r\n                    if (nested) {\r\n                        res.push(nested);\r\n                    }\r\n                }\r\n                else {\r\n                    res.push(`${prefix}uses -> ${id}`);\r\n                }\r\n            }\r\n            return res.join('\\n');\r\n        }\r\n        let lines = [\r\n            `${this.type === 0 /* Creation */ ? 'CREATE' : 'CALL'} ${this.name}`,\r\n            `${printChild(1, this)}`,\r\n            `DONE, took ${dur.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`\r\n        ];\r\n        if (dur > 2 || causedCreation) {\r\n            console.log(lines.join('\\n'));\r\n        }\r\n    }\r\n}\r\nTrace._None = new class extends Trace {\r\n    constructor() { super(-1, null); }\r\n    stop() { }\r\n    branch() { return this; }\r\n};\r\nTrace._totals = 0;\r\n//#endregion\r\n"]},"metadata":{},"sourceType":"module"}