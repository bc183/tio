{"ast":null,"code":"var memoizeId = 0;\nexport function createMemoizer() {\n  var memoizeKeyPrefix = \"$memoize\".concat(memoizeId++);\n  var self = undefined;\n\n  var result = function memoize(target, key, descriptor) {\n    var fnKey = null;\n    var fn = null;\n\n    if (typeof descriptor.value === 'function') {\n      fnKey = 'value';\n      fn = descriptor.value;\n\n      if (fn.length !== 0) {\n        console.warn('Memoize should only be used in functions with zero parameters');\n      }\n    } else if (typeof descriptor.get === 'function') {\n      fnKey = 'get';\n      fn = descriptor.get;\n    }\n\n    if (!fn) {\n      throw new Error('not supported');\n    }\n\n    var memoizeKey = \"\".concat(memoizeKeyPrefix, \":\").concat(key);\n\n    descriptor[fnKey] = function () {\n      self = this;\n\n      if (!this.hasOwnProperty(memoizeKey)) {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        Object.defineProperty(this, memoizeKey, {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: fn.apply(this, args)\n        });\n      }\n\n      return this[memoizeKey];\n    };\n  };\n\n  result.clear = function () {\n    if (typeof self === 'undefined') {\n      return;\n    }\n\n    Object.getOwnPropertyNames(self).forEach(function (property) {\n      if (property.indexOf(memoizeKeyPrefix) === 0) {\n        delete self[property];\n      }\n    });\n  };\n\n  return result;\n}\nexport function memoize(target, key, descriptor) {\n  return createMemoizer()(target, key, descriptor);\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/decorators.js"],"names":["memoizeId","createMemoizer","memoizeKeyPrefix","self","undefined","result","memoize","target","key","descriptor","fnKey","fn","value","length","console","warn","get","Error","memoizeKey","hasOwnProperty","args","Object","defineProperty","configurable","enumerable","writable","apply","clear","getOwnPropertyNames","forEach","property","indexOf"],"mappings":"AAAA,IAAIA,SAAS,GAAG,CAAhB;AACA,OAAO,SAASC,cAAT,GAA0B;AAC7B,MAAMC,gBAAgB,qBAAcF,SAAS,EAAvB,CAAtB;AACA,MAAIG,IAAI,GAAGC,SAAX;;AACA,MAAMC,MAAM,GAAG,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,GAAzB,EAA8BC,UAA9B,EAA0C;AACrD,QAAIC,KAAK,GAAG,IAAZ;AACA,QAAIC,EAAE,GAAG,IAAT;;AACA,QAAI,OAAOF,UAAU,CAACG,KAAlB,KAA4B,UAAhC,EAA4C;AACxCF,MAAAA,KAAK,GAAG,OAAR;AACAC,MAAAA,EAAE,GAAGF,UAAU,CAACG,KAAhB;;AACA,UAAID,EAAE,CAACE,MAAH,KAAc,CAAlB,EAAqB;AACjBC,QAAAA,OAAO,CAACC,IAAR,CAAa,+DAAb;AACH;AACJ,KAND,MAOK,IAAI,OAAON,UAAU,CAACO,GAAlB,KAA0B,UAA9B,EAA0C;AAC3CN,MAAAA,KAAK,GAAG,KAAR;AACAC,MAAAA,EAAE,GAAGF,UAAU,CAACO,GAAhB;AACH;;AACD,QAAI,CAACL,EAAL,EAAS;AACL,YAAM,IAAIM,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,QAAMC,UAAU,aAAMhB,gBAAN,cAA0BM,GAA1B,CAAhB;;AACAC,IAAAA,UAAU,CAACC,KAAD,CAAV,GAAoB,YAAmB;AACnCP,MAAAA,IAAI,GAAG,IAAP;;AACA,UAAI,CAAC,KAAKgB,cAAL,CAAoBD,UAApB,CAAL,EAAsC;AAAA,0CAFTE,IAES;AAFTA,UAAAA,IAES;AAAA;;AAClCC,QAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BJ,UAA5B,EAAwC;AACpCK,UAAAA,YAAY,EAAE,IADsB;AAEpCC,UAAAA,UAAU,EAAE,KAFwB;AAGpCC,UAAAA,QAAQ,EAAE,IAH0B;AAIpCb,UAAAA,KAAK,EAAED,EAAE,CAACe,KAAH,CAAS,IAAT,EAAeN,IAAf;AAJ6B,SAAxC;AAMH;;AACD,aAAO,KAAKF,UAAL,CAAP;AACH,KAXD;AAYH,GA9BD;;AA+BAb,EAAAA,MAAM,CAACsB,KAAP,GAAe,YAAM;AACjB,QAAI,OAAOxB,IAAP,KAAgB,WAApB,EAAiC;AAC7B;AACH;;AACDkB,IAAAA,MAAM,CAACO,mBAAP,CAA2BzB,IAA3B,EAAiC0B,OAAjC,CAAyC,UAAAC,QAAQ,EAAI;AACjD,UAAIA,QAAQ,CAACC,OAAT,CAAiB7B,gBAAjB,MAAuC,CAA3C,EAA8C;AAC1C,eAAOC,IAAI,CAAC2B,QAAD,CAAX;AACH;AACJ,KAJD;AAKH,GATD;;AAUA,SAAOzB,MAAP;AACH;AACD,OAAO,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,GAAzB,EAA8BC,UAA9B,EAA0C;AAC7C,SAAOR,cAAc,GAAGM,MAAH,EAAWC,GAAX,EAAgBC,UAAhB,CAArB;AACH","sourcesContent":["let memoizeId = 0;\r\nexport function createMemoizer() {\r\n    const memoizeKeyPrefix = `$memoize${memoizeId++}`;\r\n    let self = undefined;\r\n    const result = function memoize(target, key, descriptor) {\r\n        let fnKey = null;\r\n        let fn = null;\r\n        if (typeof descriptor.value === 'function') {\r\n            fnKey = 'value';\r\n            fn = descriptor.value;\r\n            if (fn.length !== 0) {\r\n                console.warn('Memoize should only be used in functions with zero parameters');\r\n            }\r\n        }\r\n        else if (typeof descriptor.get === 'function') {\r\n            fnKey = 'get';\r\n            fn = descriptor.get;\r\n        }\r\n        if (!fn) {\r\n            throw new Error('not supported');\r\n        }\r\n        const memoizeKey = `${memoizeKeyPrefix}:${key}`;\r\n        descriptor[fnKey] = function (...args) {\r\n            self = this;\r\n            if (!this.hasOwnProperty(memoizeKey)) {\r\n                Object.defineProperty(this, memoizeKey, {\r\n                    configurable: true,\r\n                    enumerable: false,\r\n                    writable: true,\r\n                    value: fn.apply(this, args)\r\n                });\r\n            }\r\n            return this[memoizeKey];\r\n        };\r\n    };\r\n    result.clear = () => {\r\n        if (typeof self === 'undefined') {\r\n            return;\r\n        }\r\n        Object.getOwnPropertyNames(self).forEach(property => {\r\n            if (property.indexOf(memoizeKeyPrefix) === 0) {\r\n                delete self[property];\r\n            }\r\n        });\r\n    };\r\n    return result;\r\n}\r\nexport function memoize(target, key, descriptor) {\r\n    return createMemoizer()(target, key, descriptor);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}