{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport var ErrorHandler = /*#__PURE__*/function () {\n  function ErrorHandler() {\n    _classCallCheck(this, ErrorHandler);\n\n    this.listeners = [];\n\n    this.unexpectedErrorHandler = function (e) {\n      setTimeout(function () {\n        if (e.stack) {\n          throw new Error(e.message + '\\n\\n' + e.stack);\n        }\n\n        throw e;\n      }, 0);\n    };\n  }\n\n  _createClass(ErrorHandler, [{\n    key: \"emit\",\n    value: function emit(e) {\n      this.listeners.forEach(function (listener) {\n        listener(e);\n      });\n    }\n  }, {\n    key: \"onUnexpectedError\",\n    value: function onUnexpectedError(e) {\n      this.unexpectedErrorHandler(e);\n      this.emit(e);\n    } // For external errors, we don't want the listeners to be called\n\n  }, {\n    key: \"onUnexpectedExternalError\",\n    value: function onUnexpectedExternalError(e) {\n      this.unexpectedErrorHandler(e);\n    }\n  }]);\n\n  return ErrorHandler;\n}();\nexport var errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedError(e);\n  }\n\n  return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n  // ignore errors from cancelled promises\n  if (!isPromiseCanceledError(e)) {\n    errorHandler.onUnexpectedExternalError(e);\n  }\n\n  return undefined;\n}\nexport function transformErrorForSerialization(error) {\n  if (error instanceof Error) {\n    var name = error.name,\n        message = error.message;\n    var stack = error.stacktrace || error.stack;\n    return {\n      $isError: true,\n      name: name,\n      message: message,\n      stack: stack\n    };\n  } // return as is\n\n\n  return error;\n}\nvar canceledName = 'Canceled';\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\n\nexport function isPromiseCanceledError(error) {\n  return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n/**\r\n * Returns an error that signals cancellation.\r\n */\n\nexport function canceled() {\n  var error = new Error(canceledName);\n  error.name = error.message;\n  return error;\n}\nexport function illegalArgument(name) {\n  if (name) {\n    return new Error(\"Illegal argument: \".concat(name));\n  } else {\n    return new Error('Illegal argument');\n  }\n}\nexport function illegalState(name) {\n  if (name) {\n    return new Error(\"Illegal state: \".concat(name));\n  } else {\n    return new Error('Illegal state');\n  }\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/errors.js"],"names":["ErrorHandler","listeners","unexpectedErrorHandler","e","setTimeout","stack","Error","message","forEach","listener","emit","errorHandler","onUnexpectedError","isPromiseCanceledError","undefined","onUnexpectedExternalError","transformErrorForSerialization","error","name","stacktrace","$isError","canceledName","canceled","illegalArgument","illegalState"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\r\nexport class ErrorHandler {\r\n    constructor() {\r\n        this.listeners = [];\r\n        this.unexpectedErrorHandler = function (e) {\r\n            setTimeout(() => {\r\n                if (e.stack) {\r\n                    throw new Error(e.message + '\\n\\n' + e.stack);\r\n                }\r\n                throw e;\r\n            }, 0);\r\n        };\r\n    }\r\n    emit(e) {\r\n        this.listeners.forEach((listener) => {\r\n            listener(e);\r\n        });\r\n    }\r\n    onUnexpectedError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n        this.emit(e);\r\n    }\r\n    // For external errors, we don't want the listeners to be called\r\n    onUnexpectedExternalError(e) {\r\n        this.unexpectedErrorHandler(e);\r\n    }\r\n}\r\nexport const errorHandler = new ErrorHandler();\r\nexport function onUnexpectedError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedError(e);\r\n    }\r\n    return undefined;\r\n}\r\nexport function onUnexpectedExternalError(e) {\r\n    // ignore errors from cancelled promises\r\n    if (!isPromiseCanceledError(e)) {\r\n        errorHandler.onUnexpectedExternalError(e);\r\n    }\r\n    return undefined;\r\n}\r\nexport function transformErrorForSerialization(error) {\r\n    if (error instanceof Error) {\r\n        let { name, message } = error;\r\n        const stack = error.stacktrace || error.stack;\r\n        return {\r\n            $isError: true,\r\n            name,\r\n            message,\r\n            stack\r\n        };\r\n    }\r\n    // return as is\r\n    return error;\r\n}\r\nconst canceledName = 'Canceled';\r\n/**\r\n * Checks if the given error is a promise in canceled state\r\n */\r\nexport function isPromiseCanceledError(error) {\r\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\r\n}\r\n/**\r\n * Returns an error that signals cancellation.\r\n */\r\nexport function canceled() {\r\n    const error = new Error(canceledName);\r\n    error.name = error.message;\r\n    return error;\r\n}\r\nexport function illegalArgument(name) {\r\n    if (name) {\r\n        return new Error(`Illegal argument: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal argument');\r\n    }\r\n}\r\nexport function illegalState(name) {\r\n    if (name) {\r\n        return new Error(`Illegal state: ${name}`);\r\n    }\r\n    else {\r\n        return new Error('Illegal state');\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}