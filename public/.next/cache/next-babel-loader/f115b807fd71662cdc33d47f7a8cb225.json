{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../common/range.js';\n/**\r\n * Returns the intersection between a ranged group and a range.\r\n * Returns `[]` if the intersection is empty.\r\n */\n\nexport function groupIntersect(range, groups) {\n  var result = [];\n\n  var _iterator = _createForOfIteratorHelper(groups),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var r = _step.value;\n\n      if (range.start >= r.range.end) {\n        continue;\n      }\n\n      if (range.end < r.range.start) {\n        break;\n      }\n\n      var intersection = Range.intersect(range, r.range);\n\n      if (Range.isEmpty(intersection)) {\n        continue;\n      }\n\n      result.push({\n        range: intersection,\n        size: r.size\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result;\n}\n/**\r\n * Shifts a range by that `much`.\r\n */\n\nexport function shift(_ref, much) {\n  var start = _ref.start,\n      end = _ref.end;\n  return {\n    start: start + much,\n    end: end + much\n  };\n}\n/**\r\n * Consolidates a collection of ranged groups.\r\n *\r\n * Consolidation is the process of merging consecutive ranged groups\r\n * that share the same `size`.\r\n */\n\nexport function consolidate(groups) {\n  var result = [];\n  var previousGroup = null;\n\n  var _iterator2 = _createForOfIteratorHelper(groups),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var group = _step2.value;\n      var start = group.range.start;\n      var end = group.range.end;\n      var size = group.size;\n\n      if (previousGroup && size === previousGroup.size) {\n        previousGroup.range.end = end;\n        continue;\n      }\n\n      previousGroup = {\n        range: {\n          start: start,\n          end: end\n        },\n        size: size\n      };\n      result.push(previousGroup);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return result;\n}\n/**\r\n * Concatenates several collections of ranged groups into a single\r\n * collection.\r\n */\n\nfunction concat() {\n  for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {\n    groups[_key] = arguments[_key];\n  }\n\n  return consolidate(groups.reduce(function (r, g) {\n    return r.concat(g);\n  }, []));\n}\n\nexport var RangeMap = /*#__PURE__*/function () {\n  function RangeMap() {\n    _classCallCheck(this, RangeMap);\n\n    this.groups = [];\n    this._size = 0;\n  }\n\n  _createClass(RangeMap, [{\n    key: \"splice\",\n    value: function splice(index, deleteCount) {\n      var items = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var diff = items.length - deleteCount;\n      var before = groupIntersect({\n        start: 0,\n        end: index\n      }, this.groups);\n      var after = groupIntersect({\n        start: index + deleteCount,\n        end: Number.POSITIVE_INFINITY\n      }, this.groups).map(function (g) {\n        return {\n          range: shift(g.range, diff),\n          size: g.size\n        };\n      });\n      var middle = items.map(function (item, i) {\n        return {\n          range: {\n            start: index + i,\n            end: index + i + 1\n          },\n          size: item.size\n        };\n      });\n      this.groups = concat(before, middle, after);\n      this._size = this.groups.reduce(function (t, g) {\n        return t + g.size * (g.range.end - g.range.start);\n      }, 0);\n    }\n    /**\r\n     * Returns the number of items in the range map.\r\n     */\n\n  }, {\n    key: \"indexAt\",\n\n    /**\r\n     * Returns the index of the item at the given position.\r\n     */\n    value: function indexAt(position) {\n      if (position < 0) {\n        return -1;\n      }\n\n      var index = 0;\n      var size = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(this.groups),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var group = _step3.value;\n          var count = group.range.end - group.range.start;\n          var newSize = size + count * group.size;\n\n          if (position < newSize) {\n            return index + Math.floor((position - size) / group.size);\n          }\n\n          index += count;\n          size = newSize;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return index;\n    }\n    /**\r\n     * Returns the index of the item right after the item at the\r\n     * index of the given position.\r\n     */\n\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(position) {\n      return Math.min(this.indexAt(position) + 1, this.count);\n    }\n    /**\r\n     * Returns the start position of the item at the given index.\r\n     */\n\n  }, {\n    key: \"positionAt\",\n    value: function positionAt(index) {\n      if (index < 0) {\n        return -1;\n      }\n\n      var position = 0;\n      var count = 0;\n\n      var _iterator4 = _createForOfIteratorHelper(this.groups),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var group = _step4.value;\n          var groupCount = group.range.end - group.range.start;\n          var newCount = count + groupCount;\n\n          if (index < newCount) {\n            return position + (index - count) * group.size;\n          }\n\n          position += groupCount * group.size;\n          count = newCount;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      var len = this.groups.length;\n\n      if (!len) {\n        return 0;\n      }\n\n      return this.groups[len - 1].range.end;\n    }\n    /**\r\n     * Returns the sum of the sizes of all items in the range map.\r\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n  }]);\n\n  return RangeMap;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/browser/ui/list/rangeMap.js"],"names":["Range","groupIntersect","range","groups","result","r","start","end","intersection","intersect","isEmpty","push","size","shift","much","consolidate","previousGroup","group","concat","reduce","g","RangeMap","_size","index","deleteCount","items","diff","length","before","after","Number","POSITIVE_INFINITY","map","middle","item","i","t","position","count","newSize","Math","floor","min","indexAt","groupCount","newCount","len"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Range } from '../../../common/range.js';\r\n/**\r\n * Returns the intersection between a ranged group and a range.\r\n * Returns `[]` if the intersection is empty.\r\n */\r\nexport function groupIntersect(range, groups) {\r\n    const result = [];\r\n    for (let r of groups) {\r\n        if (range.start >= r.range.end) {\r\n            continue;\r\n        }\r\n        if (range.end < r.range.start) {\r\n            break;\r\n        }\r\n        const intersection = Range.intersect(range, r.range);\r\n        if (Range.isEmpty(intersection)) {\r\n            continue;\r\n        }\r\n        result.push({\r\n            range: intersection,\r\n            size: r.size\r\n        });\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Shifts a range by that `much`.\r\n */\r\nexport function shift({ start, end }, much) {\r\n    return { start: start + much, end: end + much };\r\n}\r\n/**\r\n * Consolidates a collection of ranged groups.\r\n *\r\n * Consolidation is the process of merging consecutive ranged groups\r\n * that share the same `size`.\r\n */\r\nexport function consolidate(groups) {\r\n    const result = [];\r\n    let previousGroup = null;\r\n    for (let group of groups) {\r\n        const start = group.range.start;\r\n        const end = group.range.end;\r\n        const size = group.size;\r\n        if (previousGroup && size === previousGroup.size) {\r\n            previousGroup.range.end = end;\r\n            continue;\r\n        }\r\n        previousGroup = { range: { start, end }, size };\r\n        result.push(previousGroup);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Concatenates several collections of ranged groups into a single\r\n * collection.\r\n */\r\nfunction concat(...groups) {\r\n    return consolidate(groups.reduce((r, g) => r.concat(g), []));\r\n}\r\nexport class RangeMap {\r\n    constructor() {\r\n        this.groups = [];\r\n        this._size = 0;\r\n    }\r\n    splice(index, deleteCount, items = []) {\r\n        const diff = items.length - deleteCount;\r\n        const before = groupIntersect({ start: 0, end: index }, this.groups);\r\n        const after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)\r\n            .map(g => ({ range: shift(g.range, diff), size: g.size }));\r\n        const middle = items.map((item, i) => ({\r\n            range: { start: index + i, end: index + i + 1 },\r\n            size: item.size\r\n        }));\r\n        this.groups = concat(before, middle, after);\r\n        this._size = this.groups.reduce((t, g) => t + (g.size * (g.range.end - g.range.start)), 0);\r\n    }\r\n    /**\r\n     * Returns the number of items in the range map.\r\n     */\r\n    get count() {\r\n        const len = this.groups.length;\r\n        if (!len) {\r\n            return 0;\r\n        }\r\n        return this.groups[len - 1].range.end;\r\n    }\r\n    /**\r\n     * Returns the sum of the sizes of all items in the range map.\r\n     */\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    /**\r\n     * Returns the index of the item at the given position.\r\n     */\r\n    indexAt(position) {\r\n        if (position < 0) {\r\n            return -1;\r\n        }\r\n        let index = 0;\r\n        let size = 0;\r\n        for (let group of this.groups) {\r\n            const count = group.range.end - group.range.start;\r\n            const newSize = size + (count * group.size);\r\n            if (position < newSize) {\r\n                return index + Math.floor((position - size) / group.size);\r\n            }\r\n            index += count;\r\n            size = newSize;\r\n        }\r\n        return index;\r\n    }\r\n    /**\r\n     * Returns the index of the item right after the item at the\r\n     * index of the given position.\r\n     */\r\n    indexAfter(position) {\r\n        return Math.min(this.indexAt(position) + 1, this.count);\r\n    }\r\n    /**\r\n     * Returns the start position of the item at the given index.\r\n     */\r\n    positionAt(index) {\r\n        if (index < 0) {\r\n            return -1;\r\n        }\r\n        let position = 0;\r\n        let count = 0;\r\n        for (let group of this.groups) {\r\n            const groupCount = group.range.end - group.range.start;\r\n            const newCount = count + groupCount;\r\n            if (index < newCount) {\r\n                return position + ((index - count) * group.size);\r\n            }\r\n            position += groupCount * group.size;\r\n            count = newCount;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}