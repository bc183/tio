{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../tokensStore.js';\nimport { TextChange } from '../textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport var PieceTreeTextBuffer = /*#__PURE__*/function (_Disposable) {\n  _inherits(PieceTreeTextBuffer, _Disposable);\n\n  var _super = _createSuper(PieceTreeTextBuffer);\n\n  function PieceTreeTextBuffer(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n    var _this;\n\n    _classCallCheck(this, PieceTreeTextBuffer);\n\n    _this = _super.call(this);\n    _this._onDidChangeContent = _this._register(new Emitter());\n    _this._BOM = BOM;\n    _this._mightContainNonBasicASCII = !isBasicASCII;\n    _this._mightContainRTL = containsRTL;\n    _this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n    _this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    return _this;\n  }\n\n  _createClass(PieceTreeTextBuffer, [{\n    key: \"mightContainRTL\",\n    value: function mightContainRTL() {\n      return this._mightContainRTL;\n    }\n  }, {\n    key: \"mightContainUnusualLineTerminators\",\n    value: function mightContainUnusualLineTerminators() {\n      return this._mightContainUnusualLineTerminators;\n    }\n  }, {\n    key: \"resetMightContainUnusualLineTerminators\",\n    value: function resetMightContainUnusualLineTerminators() {\n      this._mightContainUnusualLineTerminators = false;\n    }\n  }, {\n    key: \"mightContainNonBasicASCII\",\n    value: function mightContainNonBasicASCII() {\n      return this._mightContainNonBasicASCII;\n    }\n  }, {\n    key: \"getBOM\",\n    value: function getBOM() {\n      return this._BOM;\n    }\n  }, {\n    key: \"getEOL\",\n    value: function getEOL() {\n      return this._pieceTree.getEOL();\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(preserveBOM) {\n      return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n  }, {\n    key: \"getOffsetAt\",\n    value: function getOffsetAt(lineNumber, column) {\n      return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n  }, {\n    key: \"getPositionAt\",\n    value: function getPositionAt(offset) {\n      return this._pieceTree.getPositionAt(offset);\n    }\n  }, {\n    key: \"getRangeAt\",\n    value: function getRangeAt(start, length) {\n      var end = start + length;\n      var startPosition = this.getPositionAt(start);\n      var endPosition = this.getPositionAt(end);\n      return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n  }, {\n    key: \"getValueInRange\",\n    value: function getValueInRange(range)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (range.isEmpty()) {\n        return '';\n      }\n\n      var lineEnding = this._getEndOfLine(eol);\n\n      return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n  }, {\n    key: \"getValueLengthInRange\",\n    value: function getValueLengthInRange(range)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (range.isEmpty()) {\n        return 0;\n      }\n\n      if (range.startLineNumber === range.endLineNumber) {\n        return range.endColumn - range.startColumn;\n      }\n\n      var startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n      var endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n      return endOffset - startOffset;\n    }\n  }, {\n    key: \"getCharacterCountInRange\",\n    value: function getCharacterCountInRange(range)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this._mightContainNonBasicASCII) {\n        // we must count by iterating\n        var result = 0;\n        var fromLineNumber = range.startLineNumber;\n        var toLineNumber = range.endLineNumber;\n\n        for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n          var lineContent = this.getLineContent(lineNumber);\n          var fromOffset = lineNumber === fromLineNumber ? range.startColumn - 1 : 0;\n          var toOffset = lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length;\n\n          for (var offset = fromOffset; offset < toOffset; offset++) {\n            if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n              result = result + 1;\n              offset = offset + 1;\n            } else {\n              result = result + 1;\n            }\n          }\n        }\n\n        result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n        return result;\n      }\n\n      return this.getValueLengthInRange(range, eol);\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._pieceTree.getLength();\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      return this._pieceTree.getLineCount();\n    }\n  }, {\n    key: \"getLinesContent\",\n    value: function getLinesContent() {\n      return this._pieceTree.getLinesContent();\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      return this._pieceTree.getLineContent(lineNumber);\n    }\n  }, {\n    key: \"getLineCharCode\",\n    value: function getLineCharCode(lineNumber, index) {\n      return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(lineNumber) {\n      return this._pieceTree.getLineLength(lineNumber);\n    }\n  }, {\n    key: \"getLineFirstNonWhitespaceColumn\",\n    value: function getLineFirstNonWhitespaceColumn(lineNumber) {\n      var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n      if (result === -1) {\n        return 0;\n      }\n\n      return result + 1;\n    }\n  }, {\n    key: \"getLineLastNonWhitespaceColumn\",\n    value: function getLineLastNonWhitespaceColumn(lineNumber) {\n      var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n\n      if (result === -1) {\n        return 0;\n      }\n\n      return result + 2;\n    }\n  }, {\n    key: \"_getEndOfLine\",\n    value: function _getEndOfLine(eol) {\n      switch (eol) {\n        case 1\n        /* LF */\n        :\n          return '\\n';\n\n        case 2\n        /* CRLF */\n        :\n          return '\\r\\n';\n\n        case 0\n        /* TextDefined */\n        :\n          return this.getEOL();\n\n        default:\n          throw new Error('Unknown EOL preference');\n      }\n    }\n  }, {\n    key: \"setEOL\",\n    value: function setEOL(newEOL) {\n      this._pieceTree.setEOL(newEOL);\n    }\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n      var mightContainRTL = this._mightContainRTL;\n      var mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n      var mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n      var canReduceOperations = true;\n      var operations = [];\n\n      for (var i = 0; i < rawOperations.length; i++) {\n        var op = rawOperations[i];\n\n        if (canReduceOperations && op._isTracked) {\n          canReduceOperations = false;\n        }\n\n        var validatedRange = op.range;\n\n        if (op.text) {\n          var textMightContainNonBasicASCII = true;\n\n          if (!mightContainNonBasicASCII) {\n            textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n            mightContainNonBasicASCII = textMightContainNonBasicASCII;\n          }\n\n          if (!mightContainRTL && textMightContainNonBasicASCII) {\n            // check if the new inserted text contains RTL\n            mightContainRTL = strings.containsRTL(op.text);\n          }\n\n          if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n            // check if the new inserted text contains unusual line terminators\n            mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n          }\n        }\n\n        var validText = '';\n        var eolCount = 0;\n        var firstLineLength = 0;\n        var lastLineLength = 0;\n\n        if (op.text) {\n          var strEOL = void 0;\n\n          var _countEOL = countEOL(op.text);\n\n          var _countEOL2 = _slicedToArray(_countEOL, 4);\n\n          eolCount = _countEOL2[0];\n          firstLineLength = _countEOL2[1];\n          lastLineLength = _countEOL2[2];\n          strEOL = _countEOL2[3];\n          var bufferEOL = this.getEOL();\n          var expectedStrEOL = bufferEOL === '\\r\\n' ? 2\n          /* CRLF */\n          : 1\n          /* LF */\n          ;\n\n          if (strEOL === 0\n          /* Unknown */\n          || strEOL === expectedStrEOL) {\n            validText = op.text;\n          } else {\n            validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n          }\n        }\n\n        operations[i] = {\n          sortIndex: i,\n          identifier: op.identifier || null,\n          range: validatedRange,\n          rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n          rangeLength: this.getValueLengthInRange(validatedRange),\n          text: validText,\n          eolCount: eolCount,\n          firstLineLength: firstLineLength,\n          lastLineLength: lastLineLength,\n          forceMoveMarkers: Boolean(op.forceMoveMarkers),\n          isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n        };\n      } // Sort operations ascending\n\n\n      operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n      var hasTouchingRanges = false;\n\n      for (var _i = 0, count = operations.length - 1; _i < count; _i++) {\n        var rangeEnd = operations[_i].range.getEndPosition();\n\n        var nextRangeStart = operations[_i + 1].range.getStartPosition();\n\n        if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n          if (nextRangeStart.isBefore(rangeEnd)) {\n            // overlapping ranges\n            throw new Error('Overlapping ranges are not allowed!');\n          }\n\n          hasTouchingRanges = true;\n        }\n      }\n\n      if (canReduceOperations) {\n        operations = this._reduceOperations(operations);\n      } // Delta encode operations\n\n\n      var reverseRanges = computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : [];\n      var newTrimAutoWhitespaceCandidates = [];\n\n      if (recordTrimAutoWhitespace) {\n        for (var _i2 = 0; _i2 < operations.length; _i2++) {\n          var _op = operations[_i2];\n          var reverseRange = reverseRanges[_i2];\n\n          if (_op.isAutoWhitespaceEdit && _op.range.isEmpty()) {\n            // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n            for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n              var currentLineContent = '';\n\n              if (lineNumber === reverseRange.startLineNumber) {\n                currentLineContent = this.getLineContent(_op.range.startLineNumber);\n\n                if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                  continue;\n                }\n              }\n\n              newTrimAutoWhitespaceCandidates.push({\n                lineNumber: lineNumber,\n                oldContent: currentLineContent\n              });\n            }\n          }\n        }\n      }\n\n      var reverseOperations = null;\n\n      if (computeUndoEdits) {\n        var reverseRangeDeltaOffset = 0;\n        reverseOperations = [];\n\n        for (var _i3 = 0; _i3 < operations.length; _i3++) {\n          var _op2 = operations[_i3];\n          var _reverseRange = reverseRanges[_i3];\n          var bufferText = this.getValueInRange(_op2.range);\n          var reverseRangeOffset = _op2.rangeOffset + reverseRangeDeltaOffset;\n          reverseRangeDeltaOffset += _op2.text.length - bufferText.length;\n          reverseOperations[_i3] = {\n            sortIndex: _op2.sortIndex,\n            identifier: _op2.identifier,\n            range: _reverseRange,\n            text: bufferText,\n            textChange: new TextChange(_op2.rangeOffset, bufferText, reverseRangeOffset, _op2.text)\n          };\n        } // Can only sort reverse operations when the order is not significant\n\n\n        if (!hasTouchingRanges) {\n          reverseOperations.sort(function (a, b) {\n            return a.sortIndex - b.sortIndex;\n          });\n        }\n      }\n\n      this._mightContainRTL = mightContainRTL;\n      this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n      this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n\n      var contentChanges = this._doApplyEdits(operations);\n\n      var trimAutoWhitespaceLineNumbers = null;\n\n      if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n        // sort line numbers auto whitespace removal candidates for next edit descending\n        newTrimAutoWhitespaceCandidates.sort(function (a, b) {\n          return b.lineNumber - a.lineNumber;\n        });\n        trimAutoWhitespaceLineNumbers = [];\n\n        for (var _i4 = 0, len = newTrimAutoWhitespaceCandidates.length; _i4 < len; _i4++) {\n          var _lineNumber = newTrimAutoWhitespaceCandidates[_i4].lineNumber;\n\n          if (_i4 > 0 && newTrimAutoWhitespaceCandidates[_i4 - 1].lineNumber === _lineNumber) {\n            // Do not have the same line number twice\n            continue;\n          }\n\n          var prevContent = newTrimAutoWhitespaceCandidates[_i4].oldContent;\n          var lineContent = this.getLineContent(_lineNumber);\n\n          if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n            continue;\n          }\n\n          trimAutoWhitespaceLineNumbers.push(_lineNumber);\n        }\n      }\n\n      this._onDidChangeContent.fire();\n\n      return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\r\n     * Transform operations such that they represent the same logic edit,\r\n     * but that they also do not cause OOM crashes.\r\n     */\n\n  }, {\n    key: \"_reduceOperations\",\n    value: function _reduceOperations(operations) {\n      if (operations.length < 1000) {\n        // We know from empirical testing that a thousand edits work fine regardless of their shape.\n        return operations;\n      } // At one point, due to how events are emitted and how each operation is handled,\n      // some operations can trigger a high amount of temporary string allocations,\n      // that will immediately get edited again.\n      // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n      // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n\n\n      return [this._toSingleEditOperation(operations)];\n    }\n  }, {\n    key: \"_toSingleEditOperation\",\n    value: function _toSingleEditOperation(operations) {\n      var forceMoveMarkers = false;\n      var firstEditRange = operations[0].range;\n      var lastEditRange = operations[operations.length - 1].range;\n      var entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n      var lastEndLineNumber = firstEditRange.startLineNumber;\n      var lastEndColumn = firstEditRange.startColumn;\n      var result = [];\n\n      for (var i = 0, len = operations.length; i < len; i++) {\n        var operation = operations[i];\n        var range = operation.range;\n        forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers; // (1) -- Push old text\n\n        result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn))); // (2) -- Push new text\n\n        if (operation.text.length > 0) {\n          result.push(operation.text);\n        }\n\n        lastEndLineNumber = range.endLineNumber;\n        lastEndColumn = range.endColumn;\n      }\n\n      var text = result.join('');\n\n      var _countEOL3 = countEOL(text),\n          _countEOL4 = _slicedToArray(_countEOL3, 3),\n          eolCount = _countEOL4[0],\n          firstLineLength = _countEOL4[1],\n          lastLineLength = _countEOL4[2];\n\n      return {\n        sortIndex: 0,\n        identifier: operations[0].identifier,\n        range: entireEditRange,\n        rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n        rangeLength: this.getValueLengthInRange(entireEditRange, 0\n        /* TextDefined */\n        ),\n        text: text,\n        eolCount: eolCount,\n        firstLineLength: firstLineLength,\n        lastLineLength: lastLineLength,\n        forceMoveMarkers: forceMoveMarkers,\n        isAutoWhitespaceEdit: false\n      };\n    }\n  }, {\n    key: \"_doApplyEdits\",\n    value: function _doApplyEdits(operations) {\n      operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n      var contentChanges = []; // operations are from bottom to top\n\n      for (var i = 0; i < operations.length; i++) {\n        var op = operations[i];\n        var startLineNumber = op.range.startLineNumber;\n        var startColumn = op.range.startColumn;\n        var endLineNumber = op.range.endLineNumber;\n        var endColumn = op.range.endColumn;\n\n        if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n          // no-op\n          continue;\n        }\n\n        if (op.text) {\n          // replacement\n          this._pieceTree[\"delete\"](op.rangeOffset, op.rangeLength);\n\n          this._pieceTree.insert(op.rangeOffset, op.text, true);\n        } else {\n          // deletion\n          this._pieceTree[\"delete\"](op.rangeOffset, op.rangeLength);\n        }\n\n        var contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        contentChanges.push({\n          range: contentChangeRange,\n          rangeLength: op.rangeLength,\n          text: op.text,\n          rangeOffset: op.rangeOffset,\n          forceMoveMarkers: op.forceMoveMarkers\n        });\n      }\n\n      return contentChanges;\n    }\n  }, {\n    key: \"findMatchesLineByLine\",\n    value: function findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n      return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\r\n     * Assumes `operations` are validated and sorted ascending\r\n     */\n\n  }], [{\n    key: \"_getInverseEditRanges\",\n    value: function _getInverseEditRanges(operations) {\n      var result = [];\n      var prevOpEndLineNumber = 0;\n      var prevOpEndColumn = 0;\n      var prevOp = null;\n\n      for (var i = 0, len = operations.length; i < len; i++) {\n        var op = operations[i];\n        var startLineNumber = void 0;\n        var startColumn = void 0;\n\n        if (prevOp) {\n          if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n            startLineNumber = prevOpEndLineNumber;\n            startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n          } else {\n            startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n            startColumn = op.range.startColumn;\n          }\n        } else {\n          startLineNumber = op.range.startLineNumber;\n          startColumn = op.range.startColumn;\n        }\n\n        var resultRange = void 0;\n\n        if (op.text.length > 0) {\n          // the operation inserts something\n          var lineCount = op.eolCount + 1;\n\n          if (lineCount === 1) {\n            // single line insert\n            resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n          } else {\n            // multi line insert\n            resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n          }\n        } else {\n          // There is nothing to insert\n          resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n        }\n\n        prevOpEndLineNumber = resultRange.endLineNumber;\n        prevOpEndColumn = resultRange.endColumn;\n        result.push(resultRange);\n        prevOp = op;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_sortOpsAscending\",\n    value: function _sortOpsAscending(a, b) {\n      var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n      if (r === 0) {\n        return a.sortIndex - b.sortIndex;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"_sortOpsDescending\",\n    value: function _sortOpsDescending(a, b) {\n      var r = Range.compareRangesUsingEnds(a.range, b.range);\n\n      if (r === 0) {\n        return b.sortIndex - a.sortIndex;\n      }\n\n      return -r;\n    }\n  }]);\n\n  return PieceTreeTextBuffer;\n}(Disposable);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js"],"names":["Emitter","strings","Range","ApplyEditsResult","PieceTreeBase","countEOL","TextChange","Disposable","PieceTreeTextBuffer","chunks","BOM","eol","containsRTL","containsUnusualLineTerminators","isBasicASCII","eolNormalized","_onDidChangeContent","_register","_BOM","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","getEOL","preserveBOM","createSnapshot","lineNumber","column","getOffsetAt","offset","getPositionAt","start","length","end","startPosition","endPosition","range","isEmpty","lineEnding","_getEndOfLine","getValueInRange","startLineNumber","endLineNumber","endColumn","startColumn","startOffset","endOffset","result","fromLineNumber","toLineNumber","lineContent","getLineContent","fromOffset","toOffset","isHighSurrogate","charCodeAt","getValueLengthInRange","getLength","getLineCount","getLinesContent","index","getLineCharCode","getLineLength","firstNonWhitespaceIndex","lastNonWhitespaceIndex","Error","newEOL","setEOL","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","i","op","_isTracked","validatedRange","text","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","expectedStrEOL","replace","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","count","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","push","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","len","prevContent","fire","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","insert","contentChangeRange","searchRange","searchData","captureMatches","limitResultCount","findMatchesLineByLine","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","r","compareRangesUsingEnds"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../../base/common/event.js';\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { ApplyEditsResult } from '../../model.js';\r\nimport { PieceTreeBase } from './pieceTreeBase.js';\r\nimport { countEOL } from '../tokensStore.js';\r\nimport { TextChange } from '../textChange.js';\r\nimport { Disposable } from '../../../../base/common/lifecycle.js';\r\nexport class PieceTreeTextBuffer extends Disposable {\r\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\r\n        super();\r\n        this._onDidChangeContent = this._register(new Emitter());\r\n        this._BOM = BOM;\r\n        this._mightContainNonBasicASCII = !isBasicASCII;\r\n        this._mightContainRTL = containsRTL;\r\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\r\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\r\n    }\r\n    mightContainRTL() {\r\n        return this._mightContainRTL;\r\n    }\r\n    mightContainUnusualLineTerminators() {\r\n        return this._mightContainUnusualLineTerminators;\r\n    }\r\n    resetMightContainUnusualLineTerminators() {\r\n        this._mightContainUnusualLineTerminators = false;\r\n    }\r\n    mightContainNonBasicASCII() {\r\n        return this._mightContainNonBasicASCII;\r\n    }\r\n    getBOM() {\r\n        return this._BOM;\r\n    }\r\n    getEOL() {\r\n        return this._pieceTree.getEOL();\r\n    }\r\n    createSnapshot(preserveBOM) {\r\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\r\n    }\r\n    getOffsetAt(lineNumber, column) {\r\n        return this._pieceTree.getOffsetAt(lineNumber, column);\r\n    }\r\n    getPositionAt(offset) {\r\n        return this._pieceTree.getPositionAt(offset);\r\n    }\r\n    getRangeAt(start, length) {\r\n        let end = start + length;\r\n        const startPosition = this.getPositionAt(start);\r\n        const endPosition = this.getPositionAt(end);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    }\r\n    getValueInRange(range, eol = 0 /* TextDefined */) {\r\n        if (range.isEmpty()) {\r\n            return '';\r\n        }\r\n        const lineEnding = this._getEndOfLine(eol);\r\n        return this._pieceTree.getValueInRange(range, lineEnding);\r\n    }\r\n    getValueLengthInRange(range, eol = 0 /* TextDefined */) {\r\n        if (range.isEmpty()) {\r\n            return 0;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            return (range.endColumn - range.startColumn);\r\n        }\r\n        let startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        let endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        return endOffset - startOffset;\r\n    }\r\n    getCharacterCountInRange(range, eol = 0 /* TextDefined */) {\r\n        if (this._mightContainNonBasicASCII) {\r\n            // we must count by iterating\r\n            let result = 0;\r\n            const fromLineNumber = range.startLineNumber;\r\n            const toLineNumber = range.endLineNumber;\r\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\r\n                const lineContent = this.getLineContent(lineNumber);\r\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\r\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\r\n                for (let offset = fromOffset; offset < toOffset; offset++) {\r\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\r\n                        result = result + 1;\r\n                        offset = offset + 1;\r\n                    }\r\n                    else {\r\n                        result = result + 1;\r\n                    }\r\n                }\r\n            }\r\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\r\n            return result;\r\n        }\r\n        return this.getValueLengthInRange(range, eol);\r\n    }\r\n    getLength() {\r\n        return this._pieceTree.getLength();\r\n    }\r\n    getLineCount() {\r\n        return this._pieceTree.getLineCount();\r\n    }\r\n    getLinesContent() {\r\n        return this._pieceTree.getLinesContent();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        return this._pieceTree.getLineContent(lineNumber);\r\n    }\r\n    getLineCharCode(lineNumber, index) {\r\n        return this._pieceTree.getLineCharCode(lineNumber, index);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        return this._pieceTree.getLineLength(lineNumber);\r\n    }\r\n    getLineFirstNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 1;\r\n    }\r\n    getLineLastNonWhitespaceColumn(lineNumber) {\r\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\r\n        if (result === -1) {\r\n            return 0;\r\n        }\r\n        return result + 2;\r\n    }\r\n    _getEndOfLine(eol) {\r\n        switch (eol) {\r\n            case 1 /* LF */:\r\n                return '\\n';\r\n            case 2 /* CRLF */:\r\n                return '\\r\\n';\r\n            case 0 /* TextDefined */:\r\n                return this.getEOL();\r\n            default:\r\n                throw new Error('Unknown EOL preference');\r\n        }\r\n    }\r\n    setEOL(newEOL) {\r\n        this._pieceTree.setEOL(newEOL);\r\n    }\r\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\r\n        let mightContainRTL = this._mightContainRTL;\r\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\r\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\r\n        let canReduceOperations = true;\r\n        let operations = [];\r\n        for (let i = 0; i < rawOperations.length; i++) {\r\n            let op = rawOperations[i];\r\n            if (canReduceOperations && op._isTracked) {\r\n                canReduceOperations = false;\r\n            }\r\n            let validatedRange = op.range;\r\n            if (op.text) {\r\n                let textMightContainNonBasicASCII = true;\r\n                if (!mightContainNonBasicASCII) {\r\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\r\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\r\n                }\r\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\r\n                    // check if the new inserted text contains RTL\r\n                    mightContainRTL = strings.containsRTL(op.text);\r\n                }\r\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\r\n                    // check if the new inserted text contains unusual line terminators\r\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\r\n                }\r\n            }\r\n            let validText = '';\r\n            let eolCount = 0;\r\n            let firstLineLength = 0;\r\n            let lastLineLength = 0;\r\n            if (op.text) {\r\n                let strEOL;\r\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\r\n                const bufferEOL = this.getEOL();\r\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* CRLF */ : 1 /* LF */);\r\n                if (strEOL === 0 /* Unknown */ || strEOL === expectedStrEOL) {\r\n                    validText = op.text;\r\n                }\r\n                else {\r\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\r\n                }\r\n            }\r\n            operations[i] = {\r\n                sortIndex: i,\r\n                identifier: op.identifier || null,\r\n                range: validatedRange,\r\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\r\n                rangeLength: this.getValueLengthInRange(validatedRange),\r\n                text: validText,\r\n                eolCount: eolCount,\r\n                firstLineLength: firstLineLength,\r\n                lastLineLength: lastLineLength,\r\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\r\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\r\n            };\r\n        }\r\n        // Sort operations ascending\r\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\r\n        let hasTouchingRanges = false;\r\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\r\n            let rangeEnd = operations[i].range.getEndPosition();\r\n            let nextRangeStart = operations[i + 1].range.getStartPosition();\r\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\r\n                if (nextRangeStart.isBefore(rangeEnd)) {\r\n                    // overlapping ranges\r\n                    throw new Error('Overlapping ranges are not allowed!');\r\n                }\r\n                hasTouchingRanges = true;\r\n            }\r\n        }\r\n        if (canReduceOperations) {\r\n            operations = this._reduceOperations(operations);\r\n        }\r\n        // Delta encode operations\r\n        let reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\r\n        let newTrimAutoWhitespaceCandidates = [];\r\n        if (recordTrimAutoWhitespace) {\r\n            for (let i = 0; i < operations.length; i++) {\r\n                let op = operations[i];\r\n                let reverseRange = reverseRanges[i];\r\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\r\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\r\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\r\n                        let currentLineContent = '';\r\n                        if (lineNumber === reverseRange.startLineNumber) {\r\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\r\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let reverseOperations = null;\r\n        if (computeUndoEdits) {\r\n            let reverseRangeDeltaOffset = 0;\r\n            reverseOperations = [];\r\n            for (let i = 0; i < operations.length; i++) {\r\n                const op = operations[i];\r\n                const reverseRange = reverseRanges[i];\r\n                const bufferText = this.getValueInRange(op.range);\r\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\r\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\r\n                reverseOperations[i] = {\r\n                    sortIndex: op.sortIndex,\r\n                    identifier: op.identifier,\r\n                    range: reverseRange,\r\n                    text: bufferText,\r\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\r\n                };\r\n            }\r\n            // Can only sort reverse operations when the order is not significant\r\n            if (!hasTouchingRanges) {\r\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\r\n            }\r\n        }\r\n        this._mightContainRTL = mightContainRTL;\r\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\r\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\r\n        const contentChanges = this._doApplyEdits(operations);\r\n        let trimAutoWhitespaceLineNumbers = null;\r\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\r\n            // sort line numbers auto whitespace removal candidates for next edit descending\r\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\r\n            trimAutoWhitespaceLineNumbers = [];\r\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\r\n                let lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\r\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\r\n                    // Do not have the same line number twice\r\n                    continue;\r\n                }\r\n                let prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\r\n                let lineContent = this.getLineContent(lineNumber);\r\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\r\n                    continue;\r\n                }\r\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\r\n            }\r\n        }\r\n        this._onDidChangeContent.fire();\r\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\r\n    }\r\n    /**\r\n     * Transform operations such that they represent the same logic edit,\r\n     * but that they also do not cause OOM crashes.\r\n     */\r\n    _reduceOperations(operations) {\r\n        if (operations.length < 1000) {\r\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\r\n            return operations;\r\n        }\r\n        // At one point, due to how events are emitted and how each operation is handled,\r\n        // some operations can trigger a high amount of temporary string allocations,\r\n        // that will immediately get edited again.\r\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\r\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\r\n        return [this._toSingleEditOperation(operations)];\r\n    }\r\n    _toSingleEditOperation(operations) {\r\n        let forceMoveMarkers = false;\r\n        const firstEditRange = operations[0].range;\r\n        const lastEditRange = operations[operations.length - 1].range;\r\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\r\n        let lastEndLineNumber = firstEditRange.startLineNumber;\r\n        let lastEndColumn = firstEditRange.startColumn;\r\n        const result = [];\r\n        for (let i = 0, len = operations.length; i < len; i++) {\r\n            const operation = operations[i];\r\n            const range = operation.range;\r\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\r\n            // (1) -- Push old text\r\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\r\n            // (2) -- Push new text\r\n            if (operation.text.length > 0) {\r\n                result.push(operation.text);\r\n            }\r\n            lastEndLineNumber = range.endLineNumber;\r\n            lastEndColumn = range.endColumn;\r\n        }\r\n        const text = result.join('');\r\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\r\n        return {\r\n            sortIndex: 0,\r\n            identifier: operations[0].identifier,\r\n            range: entireEditRange,\r\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\r\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* TextDefined */),\r\n            text: text,\r\n            eolCount: eolCount,\r\n            firstLineLength: firstLineLength,\r\n            lastLineLength: lastLineLength,\r\n            forceMoveMarkers: forceMoveMarkers,\r\n            isAutoWhitespaceEdit: false\r\n        };\r\n    }\r\n    _doApplyEdits(operations) {\r\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\r\n        let contentChanges = [];\r\n        // operations are from bottom to top\r\n        for (let i = 0; i < operations.length; i++) {\r\n            let op = operations[i];\r\n            const startLineNumber = op.range.startLineNumber;\r\n            const startColumn = op.range.startColumn;\r\n            const endLineNumber = op.range.endLineNumber;\r\n            const endColumn = op.range.endColumn;\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\r\n                // no-op\r\n                continue;\r\n            }\r\n            if (op.text) {\r\n                // replacement\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\r\n            }\r\n            else {\r\n                // deletion\r\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\r\n            }\r\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            contentChanges.push({\r\n                range: contentChangeRange,\r\n                rangeLength: op.rangeLength,\r\n                text: op.text,\r\n                rangeOffset: op.rangeOffset,\r\n                forceMoveMarkers: op.forceMoveMarkers\r\n            });\r\n        }\r\n        return contentChanges;\r\n    }\r\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    /**\r\n     * Assumes `operations` are validated and sorted ascending\r\n     */\r\n    static _getInverseEditRanges(operations) {\r\n        let result = [];\r\n        let prevOpEndLineNumber = 0;\r\n        let prevOpEndColumn = 0;\r\n        let prevOp = null;\r\n        for (let i = 0, len = operations.length; i < len; i++) {\r\n            let op = operations[i];\r\n            let startLineNumber;\r\n            let startColumn;\r\n            if (prevOp) {\r\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\r\n                    startLineNumber = prevOpEndLineNumber;\r\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\r\n                }\r\n                else {\r\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\r\n                    startColumn = op.range.startColumn;\r\n                }\r\n            }\r\n            else {\r\n                startLineNumber = op.range.startLineNumber;\r\n                startColumn = op.range.startColumn;\r\n            }\r\n            let resultRange;\r\n            if (op.text.length > 0) {\r\n                // the operation inserts something\r\n                const lineCount = op.eolCount + 1;\r\n                if (lineCount === 1) {\r\n                    // single line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\r\n                }\r\n                else {\r\n                    // multi line insert\r\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\r\n                }\r\n            }\r\n            else {\r\n                // There is nothing to insert\r\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\r\n            }\r\n            prevOpEndLineNumber = resultRange.endLineNumber;\r\n            prevOpEndColumn = resultRange.endColumn;\r\n            result.push(resultRange);\r\n            prevOp = op;\r\n        }\r\n        return result;\r\n    }\r\n    static _sortOpsAscending(a, b) {\r\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return a.sortIndex - b.sortIndex;\r\n        }\r\n        return r;\r\n    }\r\n    static _sortOpsDescending(a, b) {\r\n        let r = Range.compareRangesUsingEnds(a.range, b.range);\r\n        if (r === 0) {\r\n            return b.sortIndex - a.sortIndex;\r\n        }\r\n        return -r;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}