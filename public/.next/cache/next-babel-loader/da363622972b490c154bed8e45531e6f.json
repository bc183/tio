{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nimport { sep, posix, normalize } from './path.js';\n/**\r\n * Takes a Windows OS path and changes backward slashes to forward slashes.\r\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\r\n * Using it on a Linux or MaxOS path might change it.\r\n */\n\nexport function toSlashes(osPath) {\n  return osPath.replace(/[\\\\/]/g, posix.sep);\n}\nexport function isEqualOrParent(base, parentCandidate, ignoreCase) {\n  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sep;\n\n  if (base === parentCandidate) {\n    return true;\n  }\n\n  if (!base || !parentCandidate) {\n    return false;\n  }\n\n  if (parentCandidate.length > base.length) {\n    return false;\n  }\n\n  if (ignoreCase) {\n    var beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\n    if (!beginsWith) {\n      return false;\n    }\n\n    if (parentCandidate.length === base.length) {\n      return true; // same path, different casing\n    }\n\n    var sepOffset = parentCandidate.length;\n\n    if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n      sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n    }\n\n    return base.charAt(sepOffset) === separator;\n  }\n\n  if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n    parentCandidate += separator;\n  }\n\n  return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n  return char0 >= 65\n  /* A */\n  && char0 <= 90\n  /* Z */\n  || char0 >= 97\n  /* a */\n  && char0 <= 122\n  /* z */\n  ;\n}\nexport function isRootOrDriveLetter(path) {\n  var pathNormalized = normalize(path);\n\n  if (isWindows) {\n    if (path.length > 3) {\n      return false;\n    }\n\n    return hasDriveLetter(pathNormalized) && (path.length === 2 || pathNormalized.charCodeAt(2) === 92\n    /* Backslash */\n    );\n  }\n\n  return pathNormalized === posix.sep;\n}\nexport function hasDriveLetter(path) {\n  if (isWindows) {\n    return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58\n    /* Colon */\n    ;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/extpath.js"],"names":["isWindows","startsWithIgnoreCase","sep","posix","normalize","toSlashes","osPath","replace","isEqualOrParent","base","parentCandidate","ignoreCase","separator","length","beginsWith","sepOffset","charAt","indexOf","isWindowsDriveLetter","char0","isRootOrDriveLetter","path","pathNormalized","hasDriveLetter","charCodeAt"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,eAA1B;AACA,SAASC,oBAAT,QAAqC,cAArC;AACA,SAASC,GAAT,EAAcC,KAAd,EAAqBC,SAArB,QAAsC,WAAtC;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;AAC9B,SAAOA,MAAM,CAACC,OAAP,CAAe,QAAf,EAAyBJ,KAAK,CAACD,GAA/B,CAAP;AACH;AACD,OAAO,SAASM,eAAT,CAAyBC,IAAzB,EAA+BC,eAA/B,EAAgDC,UAAhD,EAA6E;AAAA,MAAjBC,SAAiB,uEAALV,GAAK;;AAChF,MAAIO,IAAI,KAAKC,eAAb,EAA8B;AAC1B,WAAO,IAAP;AACH;;AACD,MAAI,CAACD,IAAD,IAAS,CAACC,eAAd,EAA+B;AAC3B,WAAO,KAAP;AACH;;AACD,MAAIA,eAAe,CAACG,MAAhB,GAAyBJ,IAAI,CAACI,MAAlC,EAA0C;AACtC,WAAO,KAAP;AACH;;AACD,MAAIF,UAAJ,EAAgB;AACZ,QAAMG,UAAU,GAAGb,oBAAoB,CAACQ,IAAD,EAAOC,eAAP,CAAvC;;AACA,QAAI,CAACI,UAAL,EAAiB;AACb,aAAO,KAAP;AACH;;AACD,QAAIJ,eAAe,CAACG,MAAhB,KAA2BJ,IAAI,CAACI,MAApC,EAA4C;AACxC,aAAO,IAAP,CADwC,CAC3B;AAChB;;AACD,QAAIE,SAAS,GAAGL,eAAe,CAACG,MAAhC;;AACA,QAAIH,eAAe,CAACM,MAAhB,CAAuBN,eAAe,CAACG,MAAhB,GAAyB,CAAhD,MAAuDD,SAA3D,EAAsE;AAClEG,MAAAA,SAAS,GADyD,CACrD;AAChB;;AACD,WAAON,IAAI,CAACO,MAAL,CAAYD,SAAZ,MAA2BH,SAAlC;AACH;;AACD,MAAIF,eAAe,CAACM,MAAhB,CAAuBN,eAAe,CAACG,MAAhB,GAAyB,CAAhD,MAAuDD,SAA3D,EAAsE;AAClEF,IAAAA,eAAe,IAAIE,SAAnB;AACH;;AACD,SAAOH,IAAI,CAACQ,OAAL,CAAaP,eAAb,MAAkC,CAAzC;AACH;AACD,OAAO,SAASQ,oBAAT,CAA8BC,KAA9B,EAAqC;AACxC,SAAOA,KAAK,IAAI;AAAG;AAAZ,KAAuBA,KAAK,IAAI;AAAG;AAAnC,KAA8CA,KAAK,IAAI;AAAG;AAAZ,KAAuBA,KAAK,IAAI;AAAI;AAAzF;AACH;AACD,OAAO,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AACtC,MAAMC,cAAc,GAAGlB,SAAS,CAACiB,IAAD,CAAhC;;AACA,MAAIrB,SAAJ,EAAe;AACX,QAAIqB,IAAI,CAACR,MAAL,GAAc,CAAlB,EAAqB;AACjB,aAAO,KAAP;AACH;;AACD,WAAOU,cAAc,CAACD,cAAD,CAAd,KACFD,IAAI,CAACR,MAAL,KAAgB,CAAhB,IAAqBS,cAAc,CAACE,UAAf,CAA0B,CAA1B,MAAiC;AAAG;AADvD,KAAP;AAEH;;AACD,SAAOF,cAAc,KAAKnB,KAAK,CAACD,GAAhC;AACH;AACD,OAAO,SAASqB,cAAT,CAAwBF,IAAxB,EAA8B;AACjC,MAAIrB,SAAJ,EAAe;AACX,WAAOkB,oBAAoB,CAACG,IAAI,CAACG,UAAL,CAAgB,CAAhB,CAAD,CAApB,IAA4CH,IAAI,CAACG,UAAL,CAAgB,CAAhB,MAAuB;AAAG;AAA7E;AACH;;AACD,SAAO,KAAP;AACH","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { isWindows } from './platform.js';\r\nimport { startsWithIgnoreCase } from './strings.js';\r\nimport { sep, posix, normalize } from './path.js';\r\n/**\r\n * Takes a Windows OS path and changes backward slashes to forward slashes.\r\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\r\n * Using it on a Linux or MaxOS path might change it.\r\n */\r\nexport function toSlashes(osPath) {\r\n    return osPath.replace(/[\\\\/]/g, posix.sep);\r\n}\r\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\r\n    if (base === parentCandidate) {\r\n        return true;\r\n    }\r\n    if (!base || !parentCandidate) {\r\n        return false;\r\n    }\r\n    if (parentCandidate.length > base.length) {\r\n        return false;\r\n    }\r\n    if (ignoreCase) {\r\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\r\n        if (!beginsWith) {\r\n            return false;\r\n        }\r\n        if (parentCandidate.length === base.length) {\r\n            return true; // same path, different casing\r\n        }\r\n        let sepOffset = parentCandidate.length;\r\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\r\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\r\n        }\r\n        return base.charAt(sepOffset) === separator;\r\n    }\r\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\r\n        parentCandidate += separator;\r\n    }\r\n    return base.indexOf(parentCandidate) === 0;\r\n}\r\nexport function isWindowsDriveLetter(char0) {\r\n    return char0 >= 65 /* A */ && char0 <= 90 /* Z */ || char0 >= 97 /* a */ && char0 <= 122 /* z */;\r\n}\r\nexport function isRootOrDriveLetter(path) {\r\n    const pathNormalized = normalize(path);\r\n    if (isWindows) {\r\n        if (path.length > 3) {\r\n            return false;\r\n        }\r\n        return hasDriveLetter(pathNormalized) &&\r\n            (path.length === 2 || pathNormalized.charCodeAt(2) === 92 /* Backslash */);\r\n    }\r\n    return pathNormalized === posix.sep;\r\n}\r\nexport function hasDriveLetter(path) {\r\n    if (isWindows) {\r\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* Colon */;\r\n    }\r\n    return false;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}