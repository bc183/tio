{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { IntervalTimer } from '../../../base/common/async.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport var AbstractKeybindingService = /*#__PURE__*/function (_Disposable) {\n  _inherits(AbstractKeybindingService, _Disposable);\n\n  var _super = _createSuper(AbstractKeybindingService);\n\n  function AbstractKeybindingService(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\n    var _this;\n\n    _classCallCheck(this, AbstractKeybindingService);\n\n    _this = _super.call(this);\n    _this._contextKeyService = _contextKeyService;\n    _this._commandService = _commandService;\n    _this._telemetryService = _telemetryService;\n    _this._notificationService = _notificationService;\n    _this._logService = _logService;\n    _this._onDidUpdateKeybindings = _this._register(new Emitter());\n    _this._currentChord = null;\n    _this._currentChordChecker = new IntervalTimer();\n    _this._currentChordStatusMessage = null;\n    _this._logging = false;\n    return _this;\n  }\n\n  _createClass(AbstractKeybindingService, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(AbstractKeybindingService.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"_log\",\n    value: function _log(str) {\n      if (this._logging) {\n        this._logService.info(\"[KeybindingService]: \".concat(str));\n      }\n    }\n  }, {\n    key: \"getKeybindings\",\n    value: function getKeybindings() {\n      return this._getResolver().getKeybindings();\n    }\n  }, {\n    key: \"lookupKeybinding\",\n    value: function lookupKeybinding(commandId) {\n      var result = this._getResolver().lookupPrimaryKeybinding(commandId);\n\n      if (!result) {\n        return undefined;\n      }\n\n      return result.resolvedKeybinding;\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(e, target) {\n      return this._dispatch(e, target);\n    }\n  }, {\n    key: \"softDispatch\",\n    value: function softDispatch(e, target) {\n      var keybinding = this.resolveKeyboardEvent(e);\n\n      if (keybinding.isChord()) {\n        console.warn('Unexpected keyboard event mapped to a chord');\n        return null;\n      }\n\n      var _keybinding$getDispat = keybinding.getDispatchParts(),\n          _keybinding$getDispat2 = _slicedToArray(_keybinding$getDispat, 1),\n          firstPart = _keybinding$getDispat2[0];\n\n      if (firstPart === null) {\n        // cannot be dispatched, probably only modifier keys\n        return null;\n      }\n\n      var contextValue = this._contextKeyService.getContext(target);\n\n      var currentChord = this._currentChord ? this._currentChord.keypress : null;\n      return this._getResolver().resolve(contextValue, currentChord, firstPart);\n    }\n  }, {\n    key: \"_enterChordMode\",\n    value: function _enterChordMode(firstPart, keypressLabel) {\n      var _this2 = this;\n\n      this._currentChord = {\n        keypress: firstPart,\n        label: keypressLabel\n      };\n      this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\n      var chordEnterTime = Date.now();\n\n      this._currentChordChecker.cancelAndSet(function () {\n        if (!_this2._documentHasFocus()) {\n          // Focus has been lost => leave chord mode\n          _this2._leaveChordMode();\n\n          return;\n        }\n\n        if (Date.now() - chordEnterTime > 5000) {\n          // 5 seconds elapsed => leave chord mode\n          _this2._leaveChordMode();\n        }\n      }, 500);\n    }\n  }, {\n    key: \"_leaveChordMode\",\n    value: function _leaveChordMode() {\n      if (this._currentChordStatusMessage) {\n        this._currentChordStatusMessage.dispose();\n\n        this._currentChordStatusMessage = null;\n      }\n\n      this._currentChordChecker.cancel();\n\n      this._currentChord = null;\n    }\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(e, target) {\n      return this._doDispatch(this.resolveKeyboardEvent(e), target);\n    }\n  }, {\n    key: \"_doDispatch\",\n    value: function _doDispatch(keybinding, target) {\n      var _this3 = this;\n\n      var shouldPreventDefault = false;\n\n      if (keybinding.isChord()) {\n        console.warn('Unexpected keyboard event mapped to a chord');\n        return false;\n      }\n\n      var _keybinding$getDispat3 = keybinding.getDispatchParts(),\n          _keybinding$getDispat4 = _slicedToArray(_keybinding$getDispat3, 1),\n          firstPart = _keybinding$getDispat4[0];\n\n      if (firstPart === null) {\n        this._log(\"\\\\ Keyboard event cannot be dispatched.\"); // cannot be dispatched, probably only modifier keys\n\n\n        return shouldPreventDefault;\n      }\n\n      var contextValue = this._contextKeyService.getContext(target);\n\n      var currentChord = this._currentChord ? this._currentChord.keypress : null;\n      var keypressLabel = keybinding.getLabel();\n\n      var resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\n\n      this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\n\n      if (resolveResult && resolveResult.enterChord) {\n        shouldPreventDefault = true;\n\n        this._enterChordMode(firstPart, keypressLabel);\n\n        return shouldPreventDefault;\n      }\n\n      if (this._currentChord) {\n        if (!resolveResult || !resolveResult.commandId) {\n          this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), {\n            hideAfter: 10 * 1000\n            /* 10s */\n\n          });\n\n          shouldPreventDefault = true;\n        }\n      }\n\n      this._leaveChordMode();\n\n      if (resolveResult && resolveResult.commandId) {\n        if (!resolveResult.bubble) {\n          shouldPreventDefault = true;\n        }\n\n        if (typeof resolveResult.commandArgs === 'undefined') {\n          this._commandService.executeCommand(resolveResult.commandId).then(undefined, function (err) {\n            return _this3._notificationService.warn(err);\n          });\n        } else {\n          this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, function (err) {\n            return _this3._notificationService.warn(err);\n          });\n        }\n\n        this._telemetryService.publicLog2('workbenchActionExecuted', {\n          id: resolveResult.commandId,\n          from: 'keybinding'\n        });\n      }\n\n      return shouldPreventDefault;\n    }\n  }, {\n    key: \"mightProducePrintableCharacter\",\n    value: function mightProducePrintableCharacter(event) {\n      if (event.ctrlKey || event.metaKey) {\n        // ignore ctrl/cmd-combination but not shift/alt-combinatios\n        return false;\n      } // weak check for certain ranges. this is properly implemented in a subclass\n      // with access to the KeyboardMapperFactory.\n\n\n      if (event.keyCode >= 31\n      /* KEY_A */\n      && event.keyCode <= 56\n      /* KEY_Z */\n      || event.keyCode >= 21\n      /* KEY_0 */\n      && event.keyCode <= 30\n      /* KEY_9 */\n      ) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"onDidUpdateKeybindings\",\n    get: function get() {\n      return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\n    }\n  }]);\n\n  return AbstractKeybindingService;\n}(Disposable);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js"],"names":["nls","IntervalTimer","Emitter","Event","Disposable","AbstractKeybindingService","_contextKeyService","_commandService","_telemetryService","_notificationService","_logService","_onDidUpdateKeybindings","_register","_currentChord","_currentChordChecker","_currentChordStatusMessage","_logging","str","info","_getResolver","getKeybindings","commandId","result","lookupPrimaryKeybinding","undefined","resolvedKeybinding","e","target","_dispatch","keybinding","resolveKeyboardEvent","isChord","console","warn","getDispatchParts","firstPart","contextValue","getContext","currentChord","keypress","resolve","keypressLabel","label","status","localize","chordEnterTime","Date","now","cancelAndSet","_documentHasFocus","_leaveChordMode","dispose","cancel","_doDispatch","shouldPreventDefault","_log","getLabel","resolveResult","trace","enterChord","_enterChordMode","hideAfter","bubble","commandArgs","executeCommand","then","err","publicLog2","id","from","event","ctrlKey","metaKey","keyCode","None"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as nls from '../../../nls.js';\r\nimport { IntervalTimer } from '../../../base/common/async.js';\r\nimport { Emitter, Event } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nexport class AbstractKeybindingService extends Disposable {\r\n    constructor(_contextKeyService, _commandService, _telemetryService, _notificationService, _logService) {\r\n        super();\r\n        this._contextKeyService = _contextKeyService;\r\n        this._commandService = _commandService;\r\n        this._telemetryService = _telemetryService;\r\n        this._notificationService = _notificationService;\r\n        this._logService = _logService;\r\n        this._onDidUpdateKeybindings = this._register(new Emitter());\r\n        this._currentChord = null;\r\n        this._currentChordChecker = new IntervalTimer();\r\n        this._currentChordStatusMessage = null;\r\n        this._logging = false;\r\n    }\r\n    get onDidUpdateKeybindings() {\r\n        return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : Event.None; // Sinon stubbing walks properties on prototype\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n    }\r\n    _log(str) {\r\n        if (this._logging) {\r\n            this._logService.info(`[KeybindingService]: ${str}`);\r\n        }\r\n    }\r\n    getKeybindings() {\r\n        return this._getResolver().getKeybindings();\r\n    }\r\n    lookupKeybinding(commandId) {\r\n        const result = this._getResolver().lookupPrimaryKeybinding(commandId);\r\n        if (!result) {\r\n            return undefined;\r\n        }\r\n        return result.resolvedKeybinding;\r\n    }\r\n    dispatchEvent(e, target) {\r\n        return this._dispatch(e, target);\r\n    }\r\n    softDispatch(e, target) {\r\n        const keybinding = this.resolveKeyboardEvent(e);\r\n        if (keybinding.isChord()) {\r\n            console.warn('Unexpected keyboard event mapped to a chord');\r\n            return null;\r\n        }\r\n        const [firstPart,] = keybinding.getDispatchParts();\r\n        if (firstPart === null) {\r\n            // cannot be dispatched, probably only modifier keys\r\n            return null;\r\n        }\r\n        const contextValue = this._contextKeyService.getContext(target);\r\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\r\n        return this._getResolver().resolve(contextValue, currentChord, firstPart);\r\n    }\r\n    _enterChordMode(firstPart, keypressLabel) {\r\n        this._currentChord = {\r\n            keypress: firstPart,\r\n            label: keypressLabel\r\n        };\r\n        this._currentChordStatusMessage = this._notificationService.status(nls.localize('first.chord', \"({0}) was pressed. Waiting for second key of chord...\", keypressLabel));\r\n        const chordEnterTime = Date.now();\r\n        this._currentChordChecker.cancelAndSet(() => {\r\n            if (!this._documentHasFocus()) {\r\n                // Focus has been lost => leave chord mode\r\n                this._leaveChordMode();\r\n                return;\r\n            }\r\n            if (Date.now() - chordEnterTime > 5000) {\r\n                // 5 seconds elapsed => leave chord mode\r\n                this._leaveChordMode();\r\n            }\r\n        }, 500);\r\n    }\r\n    _leaveChordMode() {\r\n        if (this._currentChordStatusMessage) {\r\n            this._currentChordStatusMessage.dispose();\r\n            this._currentChordStatusMessage = null;\r\n        }\r\n        this._currentChordChecker.cancel();\r\n        this._currentChord = null;\r\n    }\r\n    _dispatch(e, target) {\r\n        return this._doDispatch(this.resolveKeyboardEvent(e), target);\r\n    }\r\n    _doDispatch(keybinding, target) {\r\n        let shouldPreventDefault = false;\r\n        if (keybinding.isChord()) {\r\n            console.warn('Unexpected keyboard event mapped to a chord');\r\n            return false;\r\n        }\r\n        const [firstPart,] = keybinding.getDispatchParts();\r\n        if (firstPart === null) {\r\n            this._log(`\\\\ Keyboard event cannot be dispatched.`);\r\n            // cannot be dispatched, probably only modifier keys\r\n            return shouldPreventDefault;\r\n        }\r\n        const contextValue = this._contextKeyService.getContext(target);\r\n        const currentChord = this._currentChord ? this._currentChord.keypress : null;\r\n        const keypressLabel = keybinding.getLabel();\r\n        const resolveResult = this._getResolver().resolve(contextValue, currentChord, firstPart);\r\n        this._logService.trace('KeybindingService#dispatch', keypressLabel, resolveResult === null || resolveResult === void 0 ? void 0 : resolveResult.commandId);\r\n        if (resolveResult && resolveResult.enterChord) {\r\n            shouldPreventDefault = true;\r\n            this._enterChordMode(firstPart, keypressLabel);\r\n            return shouldPreventDefault;\r\n        }\r\n        if (this._currentChord) {\r\n            if (!resolveResult || !resolveResult.commandId) {\r\n                this._notificationService.status(nls.localize('missing.chord', \"The key combination ({0}, {1}) is not a command.\", this._currentChord.label, keypressLabel), { hideAfter: 10 * 1000 /* 10s */ });\r\n                shouldPreventDefault = true;\r\n            }\r\n        }\r\n        this._leaveChordMode();\r\n        if (resolveResult && resolveResult.commandId) {\r\n            if (!resolveResult.bubble) {\r\n                shouldPreventDefault = true;\r\n            }\r\n            if (typeof resolveResult.commandArgs === 'undefined') {\r\n                this._commandService.executeCommand(resolveResult.commandId).then(undefined, err => this._notificationService.warn(err));\r\n            }\r\n            else {\r\n                this._commandService.executeCommand(resolveResult.commandId, resolveResult.commandArgs).then(undefined, err => this._notificationService.warn(err));\r\n            }\r\n            this._telemetryService.publicLog2('workbenchActionExecuted', { id: resolveResult.commandId, from: 'keybinding' });\r\n        }\r\n        return shouldPreventDefault;\r\n    }\r\n    mightProducePrintableCharacter(event) {\r\n        if (event.ctrlKey || event.metaKey) {\r\n            // ignore ctrl/cmd-combination but not shift/alt-combinatios\r\n            return false;\r\n        }\r\n        // weak check for certain ranges. this is properly implemented in a subclass\r\n        // with access to the KeyboardMapperFactory.\r\n        if ((event.keyCode >= 31 /* KEY_A */ && event.keyCode <= 56 /* KEY_Z */)\r\n            || (event.keyCode >= 21 /* KEY_0 */ && event.keyCode <= 30 /* KEY_9 */)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}