{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nexport var RichEditSupport = /*#__PURE__*/function () {\n  function RichEditSupport(languageIdentifier, previous, rawConf) {\n    _classCallCheck(this, RichEditSupport);\n\n    this._languageIdentifier = languageIdentifier;\n    this._brackets = null;\n    this._electricCharacter = null;\n    var prev = null;\n\n    if (previous) {\n      prev = previous._conf;\n    }\n\n    this._conf = RichEditSupport._mergeConf(prev, rawConf);\n    this._onEnterSupport = this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null;\n    this.comments = RichEditSupport._handleComments(this._conf);\n    this.characterPair = new CharacterPairSupport(this._conf);\n    this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\n    this.indentationRules = this._conf.indentationRules;\n\n    if (this._conf.indentationRules) {\n      this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\n    } else {\n      this.indentRulesSupport = null;\n    }\n\n    this.foldingRules = this._conf.folding || {};\n  }\n\n  _createClass(RichEditSupport, [{\n    key: \"onEnter\",\n    value: function onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n      if (!this._onEnterSupport) {\n        return null;\n      }\n\n      return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n  }, {\n    key: \"brackets\",\n    get: function get() {\n      if (!this._brackets && this._conf.brackets) {\n        this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\n      }\n\n      return this._brackets;\n    }\n  }, {\n    key: \"electricCharacter\",\n    get: function get() {\n      if (!this._electricCharacter) {\n        this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n      }\n\n      return this._electricCharacter;\n    }\n  }], [{\n    key: \"_mergeConf\",\n    value: function _mergeConf(prev, current) {\n      return {\n        comments: prev ? current.comments || prev.comments : current.comments,\n        brackets: prev ? current.brackets || prev.brackets : current.brackets,\n        wordPattern: prev ? current.wordPattern || prev.wordPattern : current.wordPattern,\n        indentationRules: prev ? current.indentationRules || prev.indentationRules : current.indentationRules,\n        onEnterRules: prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules,\n        autoClosingPairs: prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs,\n        surroundingPairs: prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs,\n        autoCloseBefore: prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore,\n        folding: prev ? current.folding || prev.folding : current.folding,\n        __electricCharacterSupport: prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport\n      };\n    }\n  }, {\n    key: \"_handleComments\",\n    value: function _handleComments(conf) {\n      var commentRule = conf.comments;\n\n      if (!commentRule) {\n        return null;\n      } // comment configuration\n\n\n      var comments = {};\n\n      if (commentRule.lineComment) {\n        comments.lineCommentToken = commentRule.lineComment;\n      }\n\n      if (commentRule.blockComment) {\n        var _commentRule$blockCom = _slicedToArray(commentRule.blockComment, 2),\n            blockStart = _commentRule$blockCom[0],\n            blockEnd = _commentRule$blockCom[1];\n\n        comments.blockCommentStartToken = blockStart;\n        comments.blockCommentEndToken = blockEnd;\n      }\n\n      return comments;\n    }\n  }]);\n\n  return RichEditSupport;\n}();\nexport var LanguageConfigurationChangeEvent = function LanguageConfigurationChangeEvent(languageIdentifier) {\n  _classCallCheck(this, LanguageConfigurationChangeEvent);\n\n  this.languageIdentifier = languageIdentifier;\n};\nexport var LanguageConfigurationRegistryImpl = /*#__PURE__*/function () {\n  function LanguageConfigurationRegistryImpl() {\n    _classCallCheck(this, LanguageConfigurationRegistryImpl);\n\n    this._entries = new Map();\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n\n  _createClass(LanguageConfigurationRegistryImpl, [{\n    key: \"register\",\n    value: function register(languageIdentifier, configuration) {\n      var _this = this;\n\n      var previous = this._getRichEditSupport(languageIdentifier.id);\n\n      var current = new RichEditSupport(languageIdentifier, previous, configuration);\n\n      this._entries.set(languageIdentifier.id, current);\n\n      this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n\n      return toDisposable(function () {\n        if (_this._entries.get(languageIdentifier.id) === current) {\n          _this._entries.set(languageIdentifier.id, previous);\n\n          _this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\n        }\n      });\n    }\n  }, {\n    key: \"_getRichEditSupport\",\n    value: function _getRichEditSupport(languageId) {\n      return this._entries.get(languageId);\n    }\n  }, {\n    key: \"getIndentationRules\",\n    value: function getIndentationRules(languageId) {\n      var value = this._entries.get(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.indentationRules || null;\n    } // begin electricCharacter\n\n  }, {\n    key: \"_getElectricCharacterSupport\",\n    value: function _getElectricCharacterSupport(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.electricCharacter || null;\n    }\n  }, {\n    key: \"getElectricCharacters\",\n    value: function getElectricCharacters(languageId) {\n      var electricCharacterSupport = this._getElectricCharacterSupport(languageId);\n\n      if (!electricCharacterSupport) {\n        return [];\n      }\n\n      return electricCharacterSupport.getElectricCharacters();\n    }\n    /**\r\n     * Should return opening bracket type to match indentation with\r\n     */\n\n  }, {\n    key: \"onElectricCharacter\",\n    value: function onElectricCharacter(character, context, column) {\n      var scopedLineTokens = createScopedLineTokens(context, column - 1);\n\n      var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\n\n      if (!electricCharacterSupport) {\n        return null;\n      }\n\n      return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    } // end electricCharacter\n\n  }, {\n    key: \"getComments\",\n    value: function getComments(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.comments || null;\n    } // begin characterPair\n\n  }, {\n    key: \"_getCharacterPairSupport\",\n    value: function _getCharacterPairSupport(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.characterPair || null;\n    }\n  }, {\n    key: \"getAutoClosingPairs\",\n    value: function getAutoClosingPairs(languageId) {\n      var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n      return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\n    }\n  }, {\n    key: \"getAutoCloseBeforeSet\",\n    value: function getAutoCloseBeforeSet(languageId) {\n      var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n      if (!characterPairSupport) {\n        return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n      }\n\n      return characterPairSupport.getAutoCloseBeforeSet();\n    }\n  }, {\n    key: \"getSurroundingPairs\",\n    value: function getSurroundingPairs(languageId) {\n      var characterPairSupport = this._getCharacterPairSupport(languageId);\n\n      if (!characterPairSupport) {\n        return [];\n      }\n\n      return characterPairSupport.getSurroundingPairs();\n    }\n  }, {\n    key: \"shouldAutoClosePair\",\n    value: function shouldAutoClosePair(autoClosingPair, context, column) {\n      var scopedLineTokens = createScopedLineTokens(context, column - 1);\n      return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    } // end characterPair\n\n  }, {\n    key: \"getWordDefinition\",\n    value: function getWordDefinition(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return ensureValidWordDefinition(null);\n      }\n\n      return ensureValidWordDefinition(value.wordDefinition || null);\n    }\n  }, {\n    key: \"getFoldingRules\",\n    value: function getFoldingRules(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return {};\n      }\n\n      return value.foldingRules;\n    } // begin Indent Rules\n\n  }, {\n    key: \"getIndentRulesSupport\",\n    value: function getIndentRulesSupport(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.indentRulesSupport || null;\n    }\n    /**\r\n     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\r\n     * Result:\r\n     * -1: run into the boundary of embedded languages\r\n     * 0: every line above are invalid\r\n     * else: nearest preceding line of the same language\r\n     */\n\n  }, {\n    key: \"getPrecedingValidLine\",\n    value: function getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n      var languageID = model.getLanguageIdAtPosition(lineNumber, 0);\n\n      if (lineNumber > 1) {\n        var lastLineNumber;\n        var resultLineNumber = -1;\n\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n          if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\n            return resultLineNumber;\n          }\n\n          var text = model.getLineContent(lastLineNumber);\n\n          if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n            resultLineNumber = lastLineNumber;\n            continue;\n          }\n\n          return lastLineNumber;\n        }\n      }\n\n      return -1;\n    }\n    /**\r\n     * Get inherited indentation from above lines.\r\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\r\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\r\n     * 3. If this line doesn't match any indent rules\r\n     *   a. check whether the line above it matches indentNextLinePattern\r\n     *   b. If not, the indent level of this line is the result\r\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\r\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\r\n     *\r\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\r\n     */\n\n  }, {\n    key: \"getInheritIndentForLine\",\n    value: function getInheritIndentForLine(autoIndent, model, lineNumber) {\n      var honorIntentialIndent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (autoIndent < 4\n      /* Full */\n      ) {\n          return null;\n        }\n\n      var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\n      if (!indentRulesSupport) {\n        return null;\n      }\n\n      if (lineNumber <= 1) {\n        return {\n          indentation: '',\n          action: null\n        };\n      }\n\n      var precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n\n      if (precedingUnIgnoredLine < 0) {\n        return null;\n      } else if (precedingUnIgnoredLine < 1) {\n        return {\n          indentation: '',\n          action: null\n        };\n      }\n\n      var precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n\n      if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n          indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n          action: IndentAction.Indent,\n          line: precedingUnIgnoredLine\n        };\n      } else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n          indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n          action: null,\n          line: precedingUnIgnoredLine\n        };\n      } else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n            action: null,\n            line: precedingUnIgnoredLine\n          };\n        }\n\n        var previousLine = precedingUnIgnoredLine - 1;\n        var previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n\n        if (!(previousLineIndentMetadata & (1\n        /* INCREASE_MASK */\n        | 2\n        /* DECREASE_MASK */\n        )) && previousLineIndentMetadata & 4\n        /* INDENT_NEXTLINE_MASK */\n        ) {\n          var stopLine = 0;\n\n          for (var i = previousLine - 1; i > 0; i--) {\n            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n              continue;\n            }\n\n            stopLine = i;\n            break;\n          }\n\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n            action: null,\n            line: stopLine + 1\n          };\n        }\n\n        if (honorIntentialIndent) {\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n            action: null,\n            line: precedingUnIgnoredLine\n          };\n        } else {\n          // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n          for (var _i = precedingUnIgnoredLine; _i > 0; _i--) {\n            var lineContent = model.getLineContent(_i);\n\n            if (indentRulesSupport.shouldIncrease(lineContent)) {\n              return {\n                indentation: strings.getLeadingWhitespace(lineContent),\n                action: IndentAction.Indent,\n                line: _i\n              };\n            } else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n              var _stopLine = 0;\n\n              for (var j = _i - 1; j > 0; j--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(_i))) {\n                  continue;\n                }\n\n                _stopLine = j;\n                break;\n              }\n\n              return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(_stopLine + 1)),\n                action: null,\n                line: _stopLine + 1\n              };\n            } else if (indentRulesSupport.shouldDecrease(lineContent)) {\n              return {\n                indentation: strings.getLeadingWhitespace(lineContent),\n                action: null,\n                line: _i\n              };\n            }\n          }\n\n          return {\n            indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n            action: null,\n            line: 1\n          };\n        }\n      }\n    }\n  }, {\n    key: \"getGoodIndentForLine\",\n    value: function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n      if (autoIndent < 4\n      /* Full */\n      ) {\n          return null;\n        }\n\n      var richEditSupport = this._getRichEditSupport(languageId);\n\n      if (!richEditSupport) {\n        return null;\n      }\n\n      var indentRulesSupport = this.getIndentRulesSupport(languageId);\n\n      if (!indentRulesSupport) {\n        return null;\n      }\n\n      var indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n      var lineContent = virtualModel.getLineContent(lineNumber);\n\n      if (indent) {\n        var inheritLine = indent.line;\n\n        if (inheritLine !== undefined) {\n          var enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n\n          if (enterResult) {\n            var indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n\n            if (enterResult.removeText) {\n              indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n            }\n\n            if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) {\n              indentation = indentConverter.shiftIndent(indentation);\n            } else if (enterResult.indentAction === IndentAction.Outdent) {\n              indentation = indentConverter.unshiftIndent(indentation);\n            }\n\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n              indentation = indentConverter.unshiftIndent(indentation);\n            }\n\n            if (enterResult.appendText) {\n              indentation += enterResult.appendText;\n            }\n\n            return strings.getLeadingWhitespace(indentation);\n          }\n        }\n\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n          if (indent.action === IndentAction.Indent) {\n            return indent.indentation;\n          } else {\n            return indentConverter.unshiftIndent(indent.indentation);\n          }\n        } else {\n          if (indent.action === IndentAction.Indent) {\n            return indentConverter.shiftIndent(indent.indentation);\n          } else {\n            return indent.indentation;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getIndentForEnter\",\n    value: function getIndentForEnter(autoIndent, model, range, indentConverter) {\n      if (autoIndent < 4\n      /* Full */\n      ) {\n          return null;\n        }\n\n      model.forceTokenization(range.startLineNumber);\n      var lineTokens = model.getLineTokens(range.startLineNumber);\n      var scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n      var scopedLineText = scopedLineTokens.getLineContent();\n      var embeddedLanguage = false;\n      var beforeEnterText;\n\n      if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n      } else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n      }\n\n      var afterEnterText;\n\n      if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n      } else {\n        var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n      }\n\n      var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n      if (!indentRulesSupport) {\n        return null;\n      }\n\n      var beforeEnterResult = beforeEnterText;\n      var beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n      var virtualModel = {\n        getLineTokens: function getLineTokens(lineNumber) {\n          return model.getLineTokens(lineNumber);\n        },\n        getLanguageIdentifier: function getLanguageIdentifier() {\n          return model.getLanguageIdentifier();\n        },\n        getLanguageIdAtPosition: function getLanguageIdAtPosition(lineNumber, column) {\n          return model.getLanguageIdAtPosition(lineNumber, column);\n        },\n        getLineContent: function getLineContent(lineNumber) {\n          if (lineNumber === range.startLineNumber) {\n            return beforeEnterResult;\n          } else {\n            return model.getLineContent(lineNumber);\n          }\n        }\n      };\n      var currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n      var afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n\n      if (!afterEnterAction) {\n        var beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n          beforeEnter: beforeEnter,\n          afterEnter: beforeEnter\n        };\n      }\n\n      var afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n\n      if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n      }\n\n      if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n      }\n\n      return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n      };\n    }\n    /**\r\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\r\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\r\n     */\n\n  }, {\n    key: \"getIndentActionForType\",\n    value: function getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n      if (autoIndent < 4\n      /* Full */\n      ) {\n          return null;\n        }\n\n      var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n      if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n      }\n\n      var indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n\n      if (!indentRulesSupport) {\n        return null;\n      }\n\n      var scopedLineText = scopedLineTokens.getLineContent();\n      var beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n      var afterTypeText;\n\n      if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n      } else {\n        var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n      } // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n      // Users might change the indentation by purpose and we should honor that instead of readjusting.\n\n\n      if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        var r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n\n        if (!r) {\n          return null;\n        }\n\n        var indentation = r.indentation;\n\n        if (r.action !== IndentAction.Indent) {\n          indentation = indentConverter.unshiftIndent(indentation);\n        }\n\n        return indentation;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getIndentMetadata\",\n    value: function getIndentMetadata(model, lineNumber) {\n      var indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\n\n      if (!indentRulesSupport) {\n        return null;\n      }\n\n      if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n      }\n\n      return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    } // end Indent Rules\n    // begin onEnter\n\n  }, {\n    key: \"getEnterAction\",\n    value: function getEnterAction(autoIndent, model, range) {\n      var scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n\n      var richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);\n\n      if (!richEditSupport) {\n        return null;\n      }\n\n      var scopedLineText = scopedLineTokens.getLineContent();\n      var beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset); // selection support\n\n      var afterEnterText;\n\n      if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n      } else {\n        var endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n      }\n\n      var previousLineText = '';\n\n      if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        var oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n          // The line above ends with text belonging to the same mode\n          previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n      }\n\n      var enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n\n      if (!enterResult) {\n        return null;\n      }\n\n      var indentAction = enterResult.indentAction;\n      var appendText = enterResult.appendText;\n      var removeText = enterResult.removeText || 0; // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n\n      if (!appendText) {\n        if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) {\n          appendText = '\\t';\n        } else {\n          appendText = '';\n        }\n      } else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n      }\n\n      var indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n\n      if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n      }\n\n      return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n      };\n    }\n  }, {\n    key: \"getIndentationAtPosition\",\n    value: function getIndentationAtPosition(model, lineNumber, column) {\n      var lineText = model.getLineContent(lineNumber);\n      var indentation = strings.getLeadingWhitespace(lineText);\n\n      if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n      }\n\n      return indentation;\n    }\n  }, {\n    key: \"getScopedLineTokens\",\n    value: function getScopedLineTokens(model, lineNumber, columnNumber) {\n      model.forceTokenization(lineNumber);\n      var lineTokens = model.getLineTokens(lineNumber);\n      var column = typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1;\n      return createScopedLineTokens(lineTokens, column);\n    } // end onEnter\n\n  }, {\n    key: \"getBracketsSupport\",\n    value: function getBracketsSupport(languageId) {\n      var value = this._getRichEditSupport(languageId);\n\n      if (!value) {\n        return null;\n      }\n\n      return value.brackets || null;\n    }\n  }]);\n\n  return LanguageConfigurationRegistryImpl;\n}();\nexport var LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js"],"names":["Emitter","toDisposable","strings","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","IndentAction","AutoClosingPairs","createScopedLineTokens","CharacterPairSupport","BracketElectricCharacterSupport","IndentRulesSupport","OnEnterSupport","RichEditBrackets","RichEditSupport","languageIdentifier","previous","rawConf","_languageIdentifier","_brackets","_electricCharacter","prev","_conf","_mergeConf","_onEnterSupport","brackets","indentationRules","onEnterRules","comments","_handleComments","characterPair","wordDefinition","wordPattern","indentRulesSupport","foldingRules","folding","autoIndent","previousLineText","beforeEnterText","afterEnterText","onEnter","current","autoClosingPairs","surroundingPairs","autoCloseBefore","__electricCharacterSupport","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","LanguageConfigurationChangeEvent","LanguageConfigurationRegistryImpl","_entries","Map","_onDidChange","onDidChange","event","configuration","_getRichEditSupport","id","set","fire","get","languageId","value","electricCharacter","electricCharacterSupport","_getElectricCharacterSupport","getElectricCharacters","character","context","column","scopedLineTokens","onElectricCharacter","firstCharOffset","characterPairSupport","_getCharacterPairSupport","getAutoClosingPairs","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","getAutoCloseBeforeSet","getSurroundingPairs","autoClosingPair","shouldAutoClosePair","model","lineNumber","languageID","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","honorIntentialIndent","getIndentRulesSupport","getLanguageIdentifier","indentation","action","precedingUnIgnoredLine","getPrecedingValidLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","getLeadingWhitespace","Indent","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","lineContent","j","virtualModel","indentConverter","richEditSupport","indent","getInheritIndentForLine","inheritLine","undefined","enterResult","removeText","substring","length","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","range","forceTokenization","startLineNumber","lineTokens","getLineTokens","startColumn","scopedLineText","embeddedLanguage","getLanguageId","substr","isEmpty","endScopedLineTokens","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","ch","beforeTypeText","afterTypeText","r","getLineCount","oneLineAboveScopedLineTokens","getIndentationAtPosition","lineText","columnNumber","getLineMaxColumn","LanguageConfigurationRegistry"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { toDisposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../model/wordHelper.js';\r\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\r\nimport { createScopedLineTokens } from './supports.js';\r\nimport { CharacterPairSupport } from './supports/characterPair.js';\r\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\r\nimport { IndentRulesSupport } from './supports/indentRules.js';\r\nimport { OnEnterSupport } from './supports/onEnter.js';\r\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\r\nexport class RichEditSupport {\r\n    constructor(languageIdentifier, previous, rawConf) {\r\n        this._languageIdentifier = languageIdentifier;\r\n        this._brackets = null;\r\n        this._electricCharacter = null;\r\n        let prev = null;\r\n        if (previous) {\r\n            prev = previous._conf;\r\n        }\r\n        this._conf = RichEditSupport._mergeConf(prev, rawConf);\r\n        this._onEnterSupport = (this._conf.brackets || this._conf.indentationRules || this._conf.onEnterRules ? new OnEnterSupport(this._conf) : null);\r\n        this.comments = RichEditSupport._handleComments(this._conf);\r\n        this.characterPair = new CharacterPairSupport(this._conf);\r\n        this.wordDefinition = this._conf.wordPattern || DEFAULT_WORD_REGEXP;\r\n        this.indentationRules = this._conf.indentationRules;\r\n        if (this._conf.indentationRules) {\r\n            this.indentRulesSupport = new IndentRulesSupport(this._conf.indentationRules);\r\n        }\r\n        else {\r\n            this.indentRulesSupport = null;\r\n        }\r\n        this.foldingRules = this._conf.folding || {};\r\n    }\r\n    get brackets() {\r\n        if (!this._brackets && this._conf.brackets) {\r\n            this._brackets = new RichEditBrackets(this._languageIdentifier, this._conf.brackets);\r\n        }\r\n        return this._brackets;\r\n    }\r\n    get electricCharacter() {\r\n        if (!this._electricCharacter) {\r\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\r\n        }\r\n        return this._electricCharacter;\r\n    }\r\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\r\n        if (!this._onEnterSupport) {\r\n            return null;\r\n        }\r\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\r\n    }\r\n    static _mergeConf(prev, current) {\r\n        return {\r\n            comments: (prev ? current.comments || prev.comments : current.comments),\r\n            brackets: (prev ? current.brackets || prev.brackets : current.brackets),\r\n            wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),\r\n            indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),\r\n            onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),\r\n            autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),\r\n            surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),\r\n            autoCloseBefore: (prev ? current.autoCloseBefore || prev.autoCloseBefore : current.autoCloseBefore),\r\n            folding: (prev ? current.folding || prev.folding : current.folding),\r\n            __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),\r\n        };\r\n    }\r\n    static _handleComments(conf) {\r\n        let commentRule = conf.comments;\r\n        if (!commentRule) {\r\n            return null;\r\n        }\r\n        // comment configuration\r\n        let comments = {};\r\n        if (commentRule.lineComment) {\r\n            comments.lineCommentToken = commentRule.lineComment;\r\n        }\r\n        if (commentRule.blockComment) {\r\n            let [blockStart, blockEnd] = commentRule.blockComment;\r\n            comments.blockCommentStartToken = blockStart;\r\n            comments.blockCommentEndToken = blockEnd;\r\n        }\r\n        return comments;\r\n    }\r\n}\r\nexport class LanguageConfigurationChangeEvent {\r\n    constructor(languageIdentifier) {\r\n        this.languageIdentifier = languageIdentifier;\r\n    }\r\n}\r\nexport class LanguageConfigurationRegistryImpl {\r\n    constructor() {\r\n        this._entries = new Map();\r\n        this._onDidChange = new Emitter();\r\n        this.onDidChange = this._onDidChange.event;\r\n    }\r\n    register(languageIdentifier, configuration) {\r\n        let previous = this._getRichEditSupport(languageIdentifier.id);\r\n        let current = new RichEditSupport(languageIdentifier, previous, configuration);\r\n        this._entries.set(languageIdentifier.id, current);\r\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\r\n        return toDisposable(() => {\r\n            if (this._entries.get(languageIdentifier.id) === current) {\r\n                this._entries.set(languageIdentifier.id, previous);\r\n                this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageIdentifier));\r\n            }\r\n        });\r\n    }\r\n    _getRichEditSupport(languageId) {\r\n        return this._entries.get(languageId);\r\n    }\r\n    getIndentationRules(languageId) {\r\n        const value = this._entries.get(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.indentationRules || null;\r\n    }\r\n    // begin electricCharacter\r\n    _getElectricCharacterSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.electricCharacter || null;\r\n    }\r\n    getElectricCharacters(languageId) {\r\n        let electricCharacterSupport = this._getElectricCharacterSupport(languageId);\r\n        if (!electricCharacterSupport) {\r\n            return [];\r\n        }\r\n        return electricCharacterSupport.getElectricCharacters();\r\n    }\r\n    /**\r\n     * Should return opening bracket type to match indentation with\r\n     */\r\n    onElectricCharacter(character, context, column) {\r\n        let scopedLineTokens = createScopedLineTokens(context, column - 1);\r\n        let electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);\r\n        if (!electricCharacterSupport) {\r\n            return null;\r\n        }\r\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\r\n    }\r\n    // end electricCharacter\r\n    getComments(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.comments || null;\r\n    }\r\n    // begin characterPair\r\n    _getCharacterPairSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.characterPair || null;\r\n    }\r\n    getAutoClosingPairs(languageId) {\r\n        const characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        return new AutoClosingPairs(characterPairSupport ? characterPairSupport.getAutoClosingPairs() : []);\r\n    }\r\n    getAutoCloseBeforeSet(languageId) {\r\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        if (!characterPairSupport) {\r\n            return CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\r\n        }\r\n        return characterPairSupport.getAutoCloseBeforeSet();\r\n    }\r\n    getSurroundingPairs(languageId) {\r\n        let characterPairSupport = this._getCharacterPairSupport(languageId);\r\n        if (!characterPairSupport) {\r\n            return [];\r\n        }\r\n        return characterPairSupport.getSurroundingPairs();\r\n    }\r\n    shouldAutoClosePair(autoClosingPair, context, column) {\r\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\r\n        return CharacterPairSupport.shouldAutoClosePair(autoClosingPair, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\r\n    }\r\n    // end characterPair\r\n    getWordDefinition(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return ensureValidWordDefinition(null);\r\n        }\r\n        return ensureValidWordDefinition(value.wordDefinition || null);\r\n    }\r\n    getFoldingRules(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return {};\r\n        }\r\n        return value.foldingRules;\r\n    }\r\n    // begin Indent Rules\r\n    getIndentRulesSupport(languageId) {\r\n        let value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.indentRulesSupport || null;\r\n    }\r\n    /**\r\n     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.\r\n     * Result:\r\n     * -1: run into the boundary of embedded languages\r\n     * 0: every line above are invalid\r\n     * else: nearest preceding line of the same language\r\n     */\r\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\r\n        let languageID = model.getLanguageIdAtPosition(lineNumber, 0);\r\n        if (lineNumber > 1) {\r\n            let lastLineNumber;\r\n            let resultLineNumber = -1;\r\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\r\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageID) {\r\n                    return resultLineNumber;\r\n                }\r\n                let text = model.getLineContent(lastLineNumber);\r\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\r\n                    resultLineNumber = lastLineNumber;\r\n                    continue;\r\n                }\r\n                return lastLineNumber;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Get inherited indentation from above lines.\r\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\r\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\r\n     * 3. If this line doesn't match any indent rules\r\n     *   a. check whether the line above it matches indentNextLinePattern\r\n     *   b. If not, the indent level of this line is the result\r\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\r\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\r\n     *\r\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\r\n     */\r\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        if (lineNumber <= 1) {\r\n            return {\r\n                indentation: '',\r\n                action: null\r\n            };\r\n        }\r\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\r\n        if (precedingUnIgnoredLine < 0) {\r\n            return null;\r\n        }\r\n        else if (precedingUnIgnoredLine < 1) {\r\n            return {\r\n                indentation: '',\r\n                action: null\r\n            };\r\n        }\r\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\r\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\r\n            return {\r\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\r\n                action: IndentAction.Indent,\r\n                line: precedingUnIgnoredLine\r\n            };\r\n        }\r\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\r\n            return {\r\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\r\n                action: null,\r\n                line: precedingUnIgnoredLine\r\n            };\r\n        }\r\n        else {\r\n            // precedingUnIgnoredLine can not be ignored.\r\n            // it doesn't increase indent of following lines\r\n            // it doesn't increase just next line\r\n            // so current line is not affect by precedingUnIgnoredLine\r\n            // and then we should get a correct inheritted indentation from above lines\r\n            if (precedingUnIgnoredLine === 1) {\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\r\n                    action: null,\r\n                    line: precedingUnIgnoredLine\r\n                };\r\n            }\r\n            const previousLine = precedingUnIgnoredLine - 1;\r\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\r\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\r\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\r\n                let stopLine = 0;\r\n                for (let i = previousLine - 1; i > 0; i--) {\r\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\r\n                        continue;\r\n                    }\r\n                    stopLine = i;\r\n                    break;\r\n                }\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\r\n                    action: null,\r\n                    line: stopLine + 1\r\n                };\r\n            }\r\n            if (honorIntentialIndent) {\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\r\n                    action: null,\r\n                    line: precedingUnIgnoredLine\r\n                };\r\n            }\r\n            else {\r\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\r\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\r\n                    const lineContent = model.getLineContent(i);\r\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(lineContent),\r\n                            action: IndentAction.Indent,\r\n                            line: i\r\n                        };\r\n                    }\r\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\r\n                        let stopLine = 0;\r\n                        for (let j = i - 1; j > 0; j--) {\r\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\r\n                                continue;\r\n                            }\r\n                            stopLine = j;\r\n                            break;\r\n                        }\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\r\n                            action: null,\r\n                            line: stopLine + 1\r\n                        };\r\n                    }\r\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                        return {\r\n                            indentation: strings.getLeadingWhitespace(lineContent),\r\n                            action: null,\r\n                            line: i\r\n                        };\r\n                    }\r\n                }\r\n                return {\r\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\r\n                    action: null,\r\n                    line: 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const richEditSupport = this._getRichEditSupport(languageId);\r\n        if (!richEditSupport) {\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\r\n        const lineContent = virtualModel.getLineContent(lineNumber);\r\n        if (indent) {\r\n            const inheritLine = indent.line;\r\n            if (inheritLine !== undefined) {\r\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\r\n                if (enterResult) {\r\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\r\n                    if (enterResult.removeText) {\r\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\r\n                    }\r\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\r\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\r\n                        indentation = indentConverter.shiftIndent(indentation);\r\n                    }\r\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\r\n                        indentation = indentConverter.unshiftIndent(indentation);\r\n                    }\r\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                        indentation = indentConverter.unshiftIndent(indentation);\r\n                    }\r\n                    if (enterResult.appendText) {\r\n                        indentation += enterResult.appendText;\r\n                    }\r\n                    return strings.getLeadingWhitespace(indentation);\r\n                }\r\n            }\r\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\r\n                if (indent.action === IndentAction.Indent) {\r\n                    return indent.indentation;\r\n                }\r\n                else {\r\n                    return indentConverter.unshiftIndent(indent.indentation);\r\n                }\r\n            }\r\n            else {\r\n                if (indent.action === IndentAction.Indent) {\r\n                    return indentConverter.shiftIndent(indent.indentation);\r\n                }\r\n                else {\r\n                    return indent.indentation;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        model.forceTokenization(range.startLineNumber);\r\n        const lineTokens = model.getLineTokens(range.startLineNumber);\r\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        let embeddedLanguage = false;\r\n        let beforeEnterText;\r\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\r\n            // we are in the embeded language content\r\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\r\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\r\n        }\r\n        let afterEnterText;\r\n        if (range.isEmpty()) {\r\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const beforeEnterResult = beforeEnterText;\r\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\r\n        const virtualModel = {\r\n            getLineTokens: (lineNumber) => {\r\n                return model.getLineTokens(lineNumber);\r\n            },\r\n            getLanguageIdentifier: () => {\r\n                return model.getLanguageIdentifier();\r\n            },\r\n            getLanguageIdAtPosition: (lineNumber, column) => {\r\n                return model.getLanguageIdAtPosition(lineNumber, column);\r\n            },\r\n            getLineContent: (lineNumber) => {\r\n                if (lineNumber === range.startLineNumber) {\r\n                    return beforeEnterResult;\r\n                }\r\n                else {\r\n                    return model.getLineContent(lineNumber);\r\n                }\r\n            }\r\n        };\r\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\r\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\r\n        if (!afterEnterAction) {\r\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\r\n            return {\r\n                beforeEnter: beforeEnter,\r\n                afterEnter: beforeEnter\r\n            };\r\n        }\r\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\r\n        if (afterEnterAction.action === IndentAction.Indent) {\r\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\r\n        }\r\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\r\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\r\n        }\r\n        return {\r\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\r\n            afterEnter: afterEnterIndent\r\n        };\r\n    }\r\n    /**\r\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\r\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\r\n     */\r\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\r\n        if (autoIndent < 4 /* Full */) {\r\n            return null;\r\n        }\r\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\r\n        if (scopedLineTokens.firstCharOffset) {\r\n            // this line has mixed languages and indentation rules will not work\r\n            return null;\r\n        }\r\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        // selection support\r\n        let afterTypeText;\r\n        if (range.isEmpty()) {\r\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\r\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\r\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\r\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\r\n            // 1. Get inherited indent action\r\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\r\n            if (!r) {\r\n                return null;\r\n            }\r\n            let indentation = r.indentation;\r\n            if (r.action !== IndentAction.Indent) {\r\n                indentation = indentConverter.unshiftIndent(indentation);\r\n            }\r\n            return indentation;\r\n        }\r\n        return null;\r\n    }\r\n    getIndentMetadata(model, lineNumber) {\r\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageIdentifier().id);\r\n        if (!indentRulesSupport) {\r\n            return null;\r\n        }\r\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\r\n            return null;\r\n        }\r\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\r\n    }\r\n    // end Indent Rules\r\n    // begin onEnter\r\n    getEnterAction(autoIndent, model, range) {\r\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\r\n        const richEditSupport = this._getRichEditSupport(scopedLineTokens.languageId);\r\n        if (!richEditSupport) {\r\n            return null;\r\n        }\r\n        const scopedLineText = scopedLineTokens.getLineContent();\r\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        // selection support\r\n        let afterEnterText;\r\n        if (range.isEmpty()) {\r\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        else {\r\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\r\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\r\n        }\r\n        let previousLineText = '';\r\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\r\n            // This is not the first line and the entire line belongs to this mode\r\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\r\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\r\n                // The line above ends with text belonging to the same mode\r\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\r\n            }\r\n        }\r\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\r\n        if (!enterResult) {\r\n            return null;\r\n        }\r\n        const indentAction = enterResult.indentAction;\r\n        let appendText = enterResult.appendText;\r\n        const removeText = enterResult.removeText || 0;\r\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\r\n        if (!appendText) {\r\n            if ((indentAction === IndentAction.Indent) ||\r\n                (indentAction === IndentAction.IndentOutdent)) {\r\n                appendText = '\\t';\r\n            }\r\n            else {\r\n                appendText = '';\r\n            }\r\n        }\r\n        else if (indentAction === IndentAction.Indent) {\r\n            appendText = '\\t' + appendText;\r\n        }\r\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\r\n        if (removeText) {\r\n            indentation = indentation.substring(0, indentation.length - removeText);\r\n        }\r\n        return {\r\n            indentAction: indentAction,\r\n            appendText: appendText,\r\n            removeText: removeText,\r\n            indentation: indentation\r\n        };\r\n    }\r\n    getIndentationAtPosition(model, lineNumber, column) {\r\n        const lineText = model.getLineContent(lineNumber);\r\n        let indentation = strings.getLeadingWhitespace(lineText);\r\n        if (indentation.length > column - 1) {\r\n            indentation = indentation.substring(0, column - 1);\r\n        }\r\n        return indentation;\r\n    }\r\n    getScopedLineTokens(model, lineNumber, columnNumber) {\r\n        model.forceTokenization(lineNumber);\r\n        const lineTokens = model.getLineTokens(lineNumber);\r\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\r\n        return createScopedLineTokens(lineTokens, column);\r\n    }\r\n    // end onEnter\r\n    getBracketsSupport(languageId) {\r\n        const value = this._getRichEditSupport(languageId);\r\n        if (!value) {\r\n            return null;\r\n        }\r\n        return value.brackets || null;\r\n    }\r\n}\r\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\r\n"]},"metadata":{},"sourceType":"module"}