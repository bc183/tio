{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var KeybindingResolver = /*#__PURE__*/function () {\n  function KeybindingResolver(defaultKeybindings, overrides, log) {\n    _classCallCheck(this, KeybindingResolver);\n\n    this._log = log;\n    this._defaultKeybindings = defaultKeybindings;\n    this._defaultBoundCommands = new Map();\n\n    for (var i = 0, len = defaultKeybindings.length; i < len; i++) {\n      var command = defaultKeybindings[i].command;\n\n      if (command) {\n        this._defaultBoundCommands.set(command, true);\n      }\n    }\n\n    this._map = new Map();\n    this._lookupMap = new Map();\n    this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\n\n    for (var _i = 0, _len = this._keybindings.length; _i < _len; _i++) {\n      var k = this._keybindings[_i];\n\n      if (k.keypressParts.length === 0) {\n        // unbound\n        continue;\n      }\n\n      if (k.when && k.when.type === 0\n      /* False */\n      ) {\n          // when condition is false\n          continue;\n        } // TODO@chords\n\n\n      this._addKeyPress(k.keypressParts[0], k);\n    }\n  }\n\n  _createClass(KeybindingResolver, [{\n    key: \"_addKeyPress\",\n    value: function _addKeyPress(keypress, item) {\n      var conflicts = this._map.get(keypress);\n\n      if (typeof conflicts === 'undefined') {\n        // There is no conflict so far\n        this._map.set(keypress, [item]);\n\n        this._addToLookupMap(item);\n\n        return;\n      }\n\n      for (var i = conflicts.length - 1; i >= 0; i--) {\n        var conflict = conflicts[i];\n\n        if (conflict.command === item.command) {\n          continue;\n        }\n\n        var conflictIsChord = conflict.keypressParts.length > 1;\n        var itemIsChord = item.keypressParts.length > 1; // TODO@chords\n\n        if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\n          // The conflict only shares the chord start with this command\n          continue;\n        }\n\n        if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\n          // `item` completely overwrites `conflict`\n          // Remove conflict from the lookupMap\n          this._removeFromLookupMap(conflict);\n        }\n      }\n\n      conflicts.push(item);\n\n      this._addToLookupMap(item);\n    }\n  }, {\n    key: \"_addToLookupMap\",\n    value: function _addToLookupMap(item) {\n      if (!item.command) {\n        return;\n      }\n\n      var arr = this._lookupMap.get(item.command);\n\n      if (typeof arr === 'undefined') {\n        arr = [item];\n\n        this._lookupMap.set(item.command, arr);\n      } else {\n        arr.push(item);\n      }\n    }\n  }, {\n    key: \"_removeFromLookupMap\",\n    value: function _removeFromLookupMap(item) {\n      if (!item.command) {\n        return;\n      }\n\n      var arr = this._lookupMap.get(item.command);\n\n      if (typeof arr === 'undefined') {\n        return;\n      }\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i] === item) {\n          arr.splice(i, 1);\n          return;\n        }\n      }\n    }\n    /**\r\n     * Returns true if it is provable `a` implies `b`.\r\n     */\n\n  }, {\n    key: \"getKeybindings\",\n    value: function getKeybindings() {\n      return this._keybindings;\n    }\n  }, {\n    key: \"lookupPrimaryKeybinding\",\n    value: function lookupPrimaryKeybinding(commandId) {\n      var items = this._lookupMap.get(commandId);\n\n      if (typeof items === 'undefined' || items.length === 0) {\n        return null;\n      }\n\n      return items[items.length - 1];\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(context, currentChord, keypress) {\n      this._log(\"| Resolving \".concat(keypress).concat(currentChord ? \" chorded from \".concat(currentChord) : \"\"));\n\n      var lookupMap = null;\n\n      if (currentChord !== null) {\n        // Fetch all chord bindings for `currentChord`\n        var candidates = this._map.get(currentChord);\n\n        if (typeof candidates === 'undefined') {\n          // No chords starting with `currentChord`\n          this._log(\"\\\\ No keybinding entries.\");\n\n          return null;\n        }\n\n        lookupMap = [];\n\n        for (var i = 0, len = candidates.length; i < len; i++) {\n          var candidate = candidates[i]; // TODO@chords\n\n          if (candidate.keypressParts[1] === keypress) {\n            lookupMap.push(candidate);\n          }\n        }\n      } else {\n        var _candidates = this._map.get(keypress);\n\n        if (typeof _candidates === 'undefined') {\n          // No bindings with `keypress`\n          this._log(\"\\\\ No keybinding entries.\");\n\n          return null;\n        }\n\n        lookupMap = _candidates;\n      }\n\n      var result = this._findCommand(context, lookupMap);\n\n      if (!result) {\n        this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, no when clauses matched the context.\"));\n\n        return null;\n      } // TODO@chords\n\n\n      if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\n        this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, matched chord, when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n\n        return {\n          enterChord: true,\n          leaveChord: false,\n          commandId: null,\n          commandArgs: null,\n          bubble: false\n        };\n      }\n\n      this._log(\"\\\\ From \".concat(lookupMap.length, \" keybinding entries, matched \").concat(result.command, \", when: \").concat(printWhenExplanation(result.when), \", source: \").concat(printSourceExplanation(result), \".\"));\n\n      return {\n        enterChord: false,\n        leaveChord: result.keypressParts.length > 1,\n        commandId: result.command,\n        commandArgs: result.commandArgs,\n        bubble: result.bubble\n      };\n    }\n  }, {\n    key: \"_findCommand\",\n    value: function _findCommand(context, matches) {\n      for (var i = matches.length - 1; i >= 0; i--) {\n        var k = matches[i];\n\n        if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\n          continue;\n        }\n\n        return k;\n      }\n\n      return null;\n    }\n  }], [{\n    key: \"_isTargetedForRemoval\",\n    value: function _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\n      if (defaultKb.command !== command) {\n        return false;\n      } // TODO@chords\n\n\n      if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\n        return false;\n      } // TODO@chords\n\n\n      if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\n        return false;\n      }\n\n      if (when) {\n        if (!defaultKb.when) {\n          return false;\n        }\n\n        if (!when.equals(defaultKb.when)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n     */\n\n  }, {\n    key: \"combine\",\n    value: function combine(defaults, rawOverrides) {\n      defaults = defaults.slice(0);\n      var overrides = [];\n\n      var _iterator = _createForOfIteratorHelper(rawOverrides),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var override = _step.value;\n\n          if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\n            overrides.push(override);\n            continue;\n          }\n\n          var command = override.command.substr(1); // TODO@chords\n\n          var keypressFirstPart = override.keypressParts[0];\n          var keypressChordPart = override.keypressParts[1];\n          var when = override.when;\n\n          for (var j = defaults.length - 1; j >= 0; j--) {\n            if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\n              defaults.splice(j, 1);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return defaults.concat(overrides);\n    }\n  }, {\n    key: \"whenIsEntirelyIncluded\",\n    value: function whenIsEntirelyIncluded(a, b) {\n      if (!b) {\n        return true;\n      }\n\n      if (!a) {\n        return false;\n      }\n\n      return this._implies(a, b);\n    }\n    /**\r\n     * Returns true if it is provable `p` implies `q`.\r\n     */\n\n  }, {\n    key: \"_implies\",\n    value: function _implies(p, q) {\n      var notP = p.negate();\n\n      var terminals = function terminals(node) {\n        if (node.type === 9\n        /* Or */\n        ) {\n            return node.expr;\n          }\n\n        return [node];\n      };\n\n      var expr = terminals(notP).concat(terminals(q));\n\n      for (var i = 0; i < expr.length; i++) {\n        var a = expr[i];\n        var notA = a.negate();\n\n        for (var j = i + 1; j < expr.length; j++) {\n          var b = expr[j];\n\n          if (notA.equals(b)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"contextMatchesRules\",\n    value: function contextMatchesRules(context, rules) {\n      if (!rules) {\n        return true;\n      }\n\n      return rules.evaluate(context);\n    }\n  }]);\n\n  return KeybindingResolver;\n}();\n\nfunction printWhenExplanation(when) {\n  if (!when) {\n    return \"no when condition\";\n  }\n\n  return \"\".concat(when.serialize());\n}\n\nfunction printSourceExplanation(kb) {\n  return kb.extensionId ? kb.isBuiltinExtension ? \"built-in extension \".concat(kb.extensionId) : \"user extension \".concat(kb.extensionId) : kb.isDefault ? \"built-in\" : \"user\";\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js"],"names":["KeybindingResolver","defaultKeybindings","overrides","log","_log","_defaultKeybindings","_defaultBoundCommands","Map","i","len","length","command","set","_map","_lookupMap","_keybindings","combine","k","keypressParts","when","type","_addKeyPress","keypress","item","conflicts","get","_addToLookupMap","conflict","conflictIsChord","itemIsChord","whenIsEntirelyIncluded","_removeFromLookupMap","push","arr","splice","commandId","items","context","currentChord","lookupMap","candidates","candidate","result","_findCommand","printWhenExplanation","printSourceExplanation","enterChord","leaveChord","commandArgs","bubble","matches","contextMatchesRules","defaultKb","keypressFirstPart","keypressChordPart","equals","defaults","rawOverrides","slice","override","charAt","substr","j","_isTargetedForRemoval","concat","a","b","_implies","p","q","notP","negate","terminals","node","expr","notA","rules","evaluate","serialize","kb","extensionId","isBuiltinExtension","isDefault"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport class KeybindingResolver {\r\n    constructor(defaultKeybindings, overrides, log) {\r\n        this._log = log;\r\n        this._defaultKeybindings = defaultKeybindings;\r\n        this._defaultBoundCommands = new Map();\r\n        for (let i = 0, len = defaultKeybindings.length; i < len; i++) {\r\n            const command = defaultKeybindings[i].command;\r\n            if (command) {\r\n                this._defaultBoundCommands.set(command, true);\r\n            }\r\n        }\r\n        this._map = new Map();\r\n        this._lookupMap = new Map();\r\n        this._keybindings = KeybindingResolver.combine(defaultKeybindings, overrides);\r\n        for (let i = 0, len = this._keybindings.length; i < len; i++) {\r\n            let k = this._keybindings[i];\r\n            if (k.keypressParts.length === 0) {\r\n                // unbound\r\n                continue;\r\n            }\r\n            if (k.when && k.when.type === 0 /* False */) {\r\n                // when condition is false\r\n                continue;\r\n            }\r\n            // TODO@chords\r\n            this._addKeyPress(k.keypressParts[0], k);\r\n        }\r\n    }\r\n    static _isTargetedForRemoval(defaultKb, keypressFirstPart, keypressChordPart, command, when) {\r\n        if (defaultKb.command !== command) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressFirstPart && defaultKb.keypressParts[0] !== keypressFirstPart) {\r\n            return false;\r\n        }\r\n        // TODO@chords\r\n        if (keypressChordPart && defaultKb.keypressParts[1] !== keypressChordPart) {\r\n            return false;\r\n        }\r\n        if (when) {\r\n            if (!defaultKb.when) {\r\n                return false;\r\n            }\r\n            if (!when.equals(defaultKb.when)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.\r\n     */\r\n    static combine(defaults, rawOverrides) {\r\n        defaults = defaults.slice(0);\r\n        let overrides = [];\r\n        for (const override of rawOverrides) {\r\n            if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {\r\n                overrides.push(override);\r\n                continue;\r\n            }\r\n            const command = override.command.substr(1);\r\n            // TODO@chords\r\n            const keypressFirstPart = override.keypressParts[0];\r\n            const keypressChordPart = override.keypressParts[1];\r\n            const when = override.when;\r\n            for (let j = defaults.length - 1; j >= 0; j--) {\r\n                if (this._isTargetedForRemoval(defaults[j], keypressFirstPart, keypressChordPart, command, when)) {\r\n                    defaults.splice(j, 1);\r\n                }\r\n            }\r\n        }\r\n        return defaults.concat(overrides);\r\n    }\r\n    _addKeyPress(keypress, item) {\r\n        const conflicts = this._map.get(keypress);\r\n        if (typeof conflicts === 'undefined') {\r\n            // There is no conflict so far\r\n            this._map.set(keypress, [item]);\r\n            this._addToLookupMap(item);\r\n            return;\r\n        }\r\n        for (let i = conflicts.length - 1; i >= 0; i--) {\r\n            let conflict = conflicts[i];\r\n            if (conflict.command === item.command) {\r\n                continue;\r\n            }\r\n            const conflictIsChord = (conflict.keypressParts.length > 1);\r\n            const itemIsChord = (item.keypressParts.length > 1);\r\n            // TODO@chords\r\n            if (conflictIsChord && itemIsChord && conflict.keypressParts[1] !== item.keypressParts[1]) {\r\n                // The conflict only shares the chord start with this command\r\n                continue;\r\n            }\r\n            if (KeybindingResolver.whenIsEntirelyIncluded(conflict.when, item.when)) {\r\n                // `item` completely overwrites `conflict`\r\n                // Remove conflict from the lookupMap\r\n                this._removeFromLookupMap(conflict);\r\n            }\r\n        }\r\n        conflicts.push(item);\r\n        this._addToLookupMap(item);\r\n    }\r\n    _addToLookupMap(item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        let arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            arr = [item];\r\n            this._lookupMap.set(item.command, arr);\r\n        }\r\n        else {\r\n            arr.push(item);\r\n        }\r\n    }\r\n    _removeFromLookupMap(item) {\r\n        if (!item.command) {\r\n            return;\r\n        }\r\n        let arr = this._lookupMap.get(item.command);\r\n        if (typeof arr === 'undefined') {\r\n            return;\r\n        }\r\n        for (let i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i] === item) {\r\n                arr.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if it is provable `a` implies `b`.\r\n     */\r\n    static whenIsEntirelyIncluded(a, b) {\r\n        if (!b) {\r\n            return true;\r\n        }\r\n        if (!a) {\r\n            return false;\r\n        }\r\n        return this._implies(a, b);\r\n    }\r\n    /**\r\n     * Returns true if it is provable `p` implies `q`.\r\n     */\r\n    static _implies(p, q) {\r\n        const notP = p.negate();\r\n        const terminals = (node) => {\r\n            if (node.type === 9 /* Or */) {\r\n                return node.expr;\r\n            }\r\n            return [node];\r\n        };\r\n        let expr = terminals(notP).concat(terminals(q));\r\n        for (let i = 0; i < expr.length; i++) {\r\n            const a = expr[i];\r\n            const notA = a.negate();\r\n            for (let j = i + 1; j < expr.length; j++) {\r\n                const b = expr[j];\r\n                if (notA.equals(b)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getKeybindings() {\r\n        return this._keybindings;\r\n    }\r\n    lookupPrimaryKeybinding(commandId) {\r\n        let items = this._lookupMap.get(commandId);\r\n        if (typeof items === 'undefined' || items.length === 0) {\r\n            return null;\r\n        }\r\n        return items[items.length - 1];\r\n    }\r\n    resolve(context, currentChord, keypress) {\r\n        this._log(`| Resolving ${keypress}${currentChord ? ` chorded from ${currentChord}` : ``}`);\r\n        let lookupMap = null;\r\n        if (currentChord !== null) {\r\n            // Fetch all chord bindings for `currentChord`\r\n            const candidates = this._map.get(currentChord);\r\n            if (typeof candidates === 'undefined') {\r\n                // No chords starting with `currentChord`\r\n                this._log(`\\\\ No keybinding entries.`);\r\n                return null;\r\n            }\r\n            lookupMap = [];\r\n            for (let i = 0, len = candidates.length; i < len; i++) {\r\n                let candidate = candidates[i];\r\n                // TODO@chords\r\n                if (candidate.keypressParts[1] === keypress) {\r\n                    lookupMap.push(candidate);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            const candidates = this._map.get(keypress);\r\n            if (typeof candidates === 'undefined') {\r\n                // No bindings with `keypress`\r\n                this._log(`\\\\ No keybinding entries.`);\r\n                return null;\r\n            }\r\n            lookupMap = candidates;\r\n        }\r\n        let result = this._findCommand(context, lookupMap);\r\n        if (!result) {\r\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`);\r\n            return null;\r\n        }\r\n        // TODO@chords\r\n        if (currentChord === null && result.keypressParts.length > 1 && result.keypressParts[1] !== null) {\r\n            this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\r\n            return {\r\n                enterChord: true,\r\n                leaveChord: false,\r\n                commandId: null,\r\n                commandArgs: null,\r\n                bubble: false\r\n            };\r\n        }\r\n        this._log(`\\\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`);\r\n        return {\r\n            enterChord: false,\r\n            leaveChord: result.keypressParts.length > 1,\r\n            commandId: result.command,\r\n            commandArgs: result.commandArgs,\r\n            bubble: result.bubble\r\n        };\r\n    }\r\n    _findCommand(context, matches) {\r\n        for (let i = matches.length - 1; i >= 0; i--) {\r\n            let k = matches[i];\r\n            if (!KeybindingResolver.contextMatchesRules(context, k.when)) {\r\n                continue;\r\n            }\r\n            return k;\r\n        }\r\n        return null;\r\n    }\r\n    static contextMatchesRules(context, rules) {\r\n        if (!rules) {\r\n            return true;\r\n        }\r\n        return rules.evaluate(context);\r\n    }\r\n}\r\nfunction printWhenExplanation(when) {\r\n    if (!when) {\r\n        return `no when condition`;\r\n    }\r\n    return `${when.serialize()}`;\r\n}\r\nfunction printSourceExplanation(kb) {\r\n    return (kb.extensionId\r\n        ? (kb.isBuiltinExtension ? `built-in extension ${kb.extensionId}` : `user extension ${kb.extensionId}`)\r\n        : (kb.isDefault ? `built-in` : `user`));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}