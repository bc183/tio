{"ast":null,"code":"import _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport var WordOperations = /*#__PURE__*/function () {\n  function WordOperations() {\n    _classCallCheck(this, WordOperations);\n  }\n\n  _createClass(WordOperations, null, [{\n    key: \"_createWord\",\n    value: function _createWord(lineContent, wordType, nextCharClass, start, end) {\n      // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n      return {\n        start: start,\n        end: end,\n        wordType: wordType,\n        nextCharClass: nextCharClass\n      };\n    }\n  }, {\n    key: \"_findPreviousWordOnLine\",\n    value: function _findPreviousWordOnLine(wordSeparators, model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n  }, {\n    key: \"_doFindPreviousWordOnLine\",\n    value: function _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n      var wordType = 0\n      /* None */\n      ;\n\n      for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n\n        if (chClass === 0\n        /* Regular */\n        ) {\n            if (wordType === 2\n            /* Separator */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n              }\n\n            wordType = 1\n            /* Regular */\n            ;\n          } else if (chClass === 2\n        /* WordSeparator */\n        ) {\n            if (wordType === 1\n            /* Regular */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n              }\n\n            wordType = 2\n            /* Separator */\n            ;\n          } else if (chClass === 1\n        /* Whitespace */\n        ) {\n            if (wordType !== 0\n            /* None */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n              }\n          }\n      }\n\n      if (wordType !== 0\n      /* None */\n      ) {\n          return this._createWord(lineContent, wordType, 1\n          /* Whitespace */\n          , 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n\n      return null;\n    }\n  }, {\n    key: \"_findEndOfWord\",\n    value: function _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n      var len = lineContent.length;\n\n      for (var chIndex = startIndex; chIndex < len; chIndex++) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n\n        if (chClass === 1\n        /* Whitespace */\n        ) {\n            return chIndex;\n          }\n\n        if (wordType === 1\n        /* Regular */\n        && chClass === 2\n        /* WordSeparator */\n        ) {\n            return chIndex;\n          }\n\n        if (wordType === 2\n        /* Separator */\n        && chClass === 0\n        /* Regular */\n        ) {\n            return chIndex;\n          }\n      }\n\n      return len;\n    }\n  }, {\n    key: \"_findNextWordOnLine\",\n    value: function _findNextWordOnLine(wordSeparators, model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n  }, {\n    key: \"_doFindNextWordOnLine\",\n    value: function _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n      var wordType = 0\n      /* None */\n      ;\n      var len = lineContent.length;\n\n      for (var chIndex = position.column - 1; chIndex < len; chIndex++) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n\n        if (chClass === 0\n        /* Regular */\n        ) {\n            if (wordType === 2\n            /* Separator */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n              }\n\n            wordType = 1\n            /* Regular */\n            ;\n          } else if (chClass === 2\n        /* WordSeparator */\n        ) {\n            if (wordType === 1\n            /* Regular */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n              }\n\n            wordType = 2\n            /* Separator */\n            ;\n          } else if (chClass === 1\n        /* Whitespace */\n        ) {\n            if (wordType !== 0\n            /* None */\n            ) {\n                return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n              }\n          }\n      }\n\n      if (wordType !== 0\n      /* None */\n      ) {\n          return this._createWord(lineContent, wordType, 1\n          /* Whitespace */\n          , this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n\n      return null;\n    }\n  }, {\n    key: \"_findStartOfWord\",\n    value: function _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n      for (var chIndex = startIndex; chIndex >= 0; chIndex--) {\n        var chCode = lineContent.charCodeAt(chIndex);\n        var chClass = wordSeparators.get(chCode);\n\n        if (chClass === 1\n        /* Whitespace */\n        ) {\n            return chIndex + 1;\n          }\n\n        if (wordType === 1\n        /* Regular */\n        && chClass === 2\n        /* WordSeparator */\n        ) {\n            return chIndex + 1;\n          }\n\n        if (wordType === 2\n        /* Separator */\n        && chClass === 0\n        /* Regular */\n        ) {\n            return chIndex + 1;\n          }\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"moveWordLeft\",\n    value: function moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n\n      if (column === 1) {\n        if (lineNumber > 1) {\n          lineNumber = lineNumber - 1;\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n      if (wordNavigationType === 0\n      /* WordStart */\n      ) {\n          return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n\n      if (wordNavigationType === 1\n      /* WordStartFast */\n      ) {\n          if (prevWordOnLine && prevWordOnLine.wordType === 2\n          /* Separator */\n          && prevWordOnLine.end - prevWordOnLine.start === 1 && prevWordOnLine.nextCharClass === 0\n          /* Regular */\n          ) {\n              // Skip over a word made up of one single separator and followed by a regular character\n              prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n\n          return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n\n      if (wordNavigationType === 3\n      /* WordAccessibility */\n      ) {\n          while (prevWordOnLine && prevWordOnLine.wordType === 2\n          /* Separator */\n          ) {\n            // Skip over words made up of only separators\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n          }\n\n          return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        } // We are stopping at the ending of words\n\n\n      if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n        prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n      }\n\n      return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n  }, {\n    key: \"_moveWordPartLeft\",\n    value: function _moveWordPartLeft(model, position) {\n      var lineNumber = position.lineNumber;\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n\n      if (position.column === 1) {\n        return lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position;\n      }\n\n      var lineContent = model.getLineContent(lineNumber);\n\n      for (var column = position.column - 1; column > 1; column--) {\n        var left = lineContent.charCodeAt(column - 2);\n        var right = lineContent.charCodeAt(column - 1);\n\n        if (left === 95\n        /* Underline */\n        && right !== 95\n        /* Underline */\n        ) {\n            // snake_case_variables\n            return new Position(lineNumber, column);\n          }\n\n        if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // camelCaseVariables\n          return new Position(lineNumber, column);\n        }\n\n        if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // thisIsACamelCaseWithOneLetterWords\n          if (column + 1 < maxColumn) {\n            var rightRight = lineContent.charCodeAt(column);\n\n            if (strings.isLowerAsciiLetter(rightRight)) {\n              return new Position(lineNumber, column);\n            }\n          }\n        }\n      }\n\n      return new Position(lineNumber, 1);\n    }\n  }, {\n    key: \"moveWordRight\",\n    value: function moveWordRight(wordSeparators, model, position, wordNavigationType) {\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      var movedDown = false;\n\n      if (column === model.getLineMaxColumn(lineNumber)) {\n        if (lineNumber < model.getLineCount()) {\n          movedDown = true;\n          lineNumber = lineNumber + 1;\n          column = 1;\n        }\n      }\n\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n\n      if (wordNavigationType === 2\n      /* WordEnd */\n      ) {\n          if (nextWordOnLine && nextWordOnLine.wordType === 2\n          /* Separator */\n          ) {\n              if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0\n              /* Regular */\n              ) {\n                  // Skip over a word made up of one single separator and followed by a regular character\n                  nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n\n          if (nextWordOnLine) {\n            column = nextWordOnLine.end + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        } else if (wordNavigationType === 3\n      /* WordAccessibility */\n      ) {\n          if (movedDown) {\n            // If we move to the next line, pretend that the cursor is right before the first character.\n            // This is needed when the first word starts right at the first character - and in order not to miss it,\n            // we need to start before.\n            column = 0;\n          }\n\n          while (nextWordOnLine && (nextWordOnLine.wordType === 2\n          /* Separator */\n          || nextWordOnLine.start + 1 <= column)) {\n            // Skip over a word made up of one single separator\n            // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n          }\n\n          if (nextWordOnLine) {\n            column = nextWordOnLine.start + 1;\n          } else {\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        } else {\n        if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n\n        if (nextWordOnLine) {\n          column = nextWordOnLine.start + 1;\n        } else {\n          column = model.getLineMaxColumn(lineNumber);\n        }\n      }\n\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"_moveWordPartRight\",\n    value: function _moveWordPartRight(model, position) {\n      var lineNumber = position.lineNumber;\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n\n      if (position.column === maxColumn) {\n        return lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position;\n      }\n\n      var lineContent = model.getLineContent(lineNumber);\n\n      for (var column = position.column + 1; column < maxColumn; column++) {\n        var left = lineContent.charCodeAt(column - 2);\n        var right = lineContent.charCodeAt(column - 1);\n\n        if (left !== 95\n        /* Underline */\n        && right === 95\n        /* Underline */\n        ) {\n            // snake_case_variables\n            return new Position(lineNumber, column);\n          }\n\n        if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // camelCaseVariables\n          return new Position(lineNumber, column);\n        }\n\n        if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n          // thisIsACamelCaseWithOneLetterWords\n          if (column + 1 < maxColumn) {\n            var rightRight = lineContent.charCodeAt(column);\n\n            if (strings.isLowerAsciiLetter(rightRight)) {\n              return new Position(lineNumber, column);\n            }\n          }\n        }\n      }\n\n      return new Position(lineNumber, maxColumn);\n    }\n  }, {\n    key: \"_deleteWordLeftWhitespace\",\n    value: function _deleteWordLeftWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var startIndex = position.column - 2;\n      var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n\n      if (lastNonWhitespace + 1 < startIndex) {\n        return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"deleteWordLeft\",\n    value: function deleteWordLeft(ctx, wordNavigationType) {\n      var wordSeparators = ctx.wordSeparators;\n      var model = ctx.model;\n      var selection = ctx.selection;\n      var whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n\n      if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection])) {\n        var _position = ctx.selection.getPosition();\n\n        return new Range(_position.lineNumber, _position.column - 1, _position.lineNumber, _position.column + 1);\n      }\n\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n\n      if (lineNumber === 1 && column === 1) {\n        // Ignore deleting at beginning of file\n        return null;\n      }\n\n      if (whitespaceHeuristics) {\n        var r = this._deleteWordLeftWhitespace(model, position);\n\n        if (r) {\n          return r;\n        }\n      }\n\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n      if (wordNavigationType === 0\n      /* WordStart */\n      ) {\n          if (prevWordOnLine) {\n            column = prevWordOnLine.start + 1;\n          } else {\n            if (column > 1) {\n              column = 1;\n            } else {\n              lineNumber--;\n              column = model.getLineMaxColumn(lineNumber);\n            }\n          }\n        } else {\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n          prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n\n        if (prevWordOnLine) {\n          column = prevWordOnLine.end + 1;\n        } else {\n          if (column > 1) {\n            column = 1;\n          } else {\n            lineNumber--;\n            column = model.getLineMaxColumn(lineNumber);\n          }\n        }\n      }\n\n      return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n  }, {\n    key: \"deleteInsideWord\",\n    value: function deleteInsideWord(wordSeparators, model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n\n      var r = this._deleteInsideWordWhitespace(model, position);\n\n      if (r) {\n        return r;\n      }\n\n      return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n  }, {\n    key: \"_charAtIsWhitespace\",\n    value: function _charAtIsWhitespace(str, index) {\n      var charCode = str.charCodeAt(index);\n      return charCode === 32\n      /* Space */\n      || charCode === 9\n      /* Tab */\n      ;\n    }\n  }, {\n    key: \"_deleteInsideWordWhitespace\",\n    value: function _deleteInsideWordWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var lineContentLength = lineContent.length;\n\n      if (lineContentLength === 0) {\n        // empty line\n        return null;\n      }\n\n      var leftIndex = Math.max(position.column - 2, 0);\n\n      if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n        // touches a non-whitespace character to the left\n        return null;\n      }\n\n      var rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n\n      if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n        // touches a non-whitespace character to the right\n        return null;\n      } // walk over whitespace to the left\n\n\n      while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n        leftIndex--;\n      } // walk over whitespace to the right\n\n\n      while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n        rightIndex++;\n      }\n\n      return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n  }, {\n    key: \"_deleteInsideWordDetermineDeleteRange\",\n    value: function _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n      var _this = this;\n\n      var lineContent = model.getLineContent(position.lineNumber);\n      var lineLength = lineContent.length;\n\n      if (lineLength === 0) {\n        // empty line\n        if (position.lineNumber > 1) {\n          return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n        } else {\n          if (position.lineNumber < model.getLineCount()) {\n            return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n          } else {\n            // empty model\n            return new Range(position.lineNumber, 1, position.lineNumber, 1);\n          }\n        }\n      }\n\n      var touchesWord = function touchesWord(word) {\n        return word.start + 1 <= position.column && position.column <= word.end + 1;\n      };\n\n      var createRangeWithPosition = function createRangeWithPosition(startColumn, endColumn) {\n        startColumn = Math.min(startColumn, position.column);\n        endColumn = Math.max(endColumn, position.column);\n        return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n      };\n\n      var deleteWordAndAdjacentWhitespace = function deleteWordAndAdjacentWhitespace(word) {\n        var startColumn = word.start + 1;\n        var endColumn = word.end + 1;\n        var expandedToTheRight = false;\n\n        while (endColumn - 1 < lineLength && _this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n          expandedToTheRight = true;\n          endColumn++;\n        }\n\n        if (!expandedToTheRight) {\n          while (startColumn > 1 && _this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n            startColumn--;\n          }\n        }\n\n        return createRangeWithPosition(startColumn, endColumn);\n      };\n\n      var prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n      if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n        return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n      }\n\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n      if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n        return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n      }\n\n      if (prevWordOnLine && nextWordOnLine) {\n        return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n      }\n\n      if (prevWordOnLine) {\n        return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n      }\n\n      if (nextWordOnLine) {\n        return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n      }\n\n      return createRangeWithPosition(1, lineLength + 1);\n    }\n  }, {\n    key: \"_deleteWordPartLeft\",\n    value: function _deleteWordPartLeft(model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n\n      var pos = selection.getPosition();\n\n      var toPosition = WordOperations._moveWordPartLeft(model, pos);\n\n      return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n  }, {\n    key: \"_findFirstNonWhitespaceChar\",\n    value: function _findFirstNonWhitespaceChar(str, startIndex) {\n      var len = str.length;\n\n      for (var chIndex = startIndex; chIndex < len; chIndex++) {\n        var ch = str.charAt(chIndex);\n\n        if (ch !== ' ' && ch !== '\\t') {\n          return chIndex;\n        }\n      }\n\n      return len;\n    }\n  }, {\n    key: \"_deleteWordRightWhitespace\",\n    value: function _deleteWordRightWhitespace(model, position) {\n      var lineContent = model.getLineContent(position.lineNumber);\n      var startIndex = position.column - 1;\n\n      var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n\n      if (startIndex + 1 < firstNonWhitespace) {\n        // bingo\n        return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"deleteWordRight\",\n    value: function deleteWordRight(ctx, wordNavigationType) {\n      var wordSeparators = ctx.wordSeparators;\n      var model = ctx.model;\n      var selection = ctx.selection;\n      var whitespaceHeuristics = ctx.whitespaceHeuristics;\n\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n\n      var position = new Position(selection.positionLineNumber, selection.positionColumn);\n      var lineNumber = position.lineNumber;\n      var column = position.column;\n      var lineCount = model.getLineCount();\n      var maxColumn = model.getLineMaxColumn(lineNumber);\n\n      if (lineNumber === lineCount && column === maxColumn) {\n        // Ignore deleting at end of file\n        return null;\n      }\n\n      if (whitespaceHeuristics) {\n        var r = this._deleteWordRightWhitespace(model, position);\n\n        if (r) {\n          return r;\n        }\n      }\n\n      var nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n      if (wordNavigationType === 2\n      /* WordEnd */\n      ) {\n          if (nextWordOnLine) {\n            column = nextWordOnLine.end + 1;\n          } else {\n            if (column < maxColumn || lineNumber === lineCount) {\n              column = maxColumn;\n            } else {\n              lineNumber++;\n              nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n              if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n              } else {\n                column = model.getLineMaxColumn(lineNumber);\n              }\n            }\n          }\n        } else {\n        if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n          nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n        }\n\n        if (nextWordOnLine) {\n          column = nextWordOnLine.start + 1;\n        } else {\n          if (column < maxColumn || lineNumber === lineCount) {\n            column = maxColumn;\n          } else {\n            lineNumber++;\n            nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n\n            if (nextWordOnLine) {\n              column = nextWordOnLine.start + 1;\n            } else {\n              column = model.getLineMaxColumn(lineNumber);\n            }\n          }\n        }\n      }\n\n      return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n  }, {\n    key: \"_deleteWordPartRight\",\n    value: function _deleteWordPartRight(model, selection) {\n      if (!selection.isEmpty()) {\n        return selection;\n      }\n\n      var pos = selection.getPosition();\n\n      var toPosition = WordOperations._moveWordPartRight(model, pos);\n\n      return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n  }, {\n    key: \"_createWordAtPosition\",\n    value: function _createWordAtPosition(model, lineNumber, word) {\n      var range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n      return {\n        word: model.getValueInRange(range),\n        startColumn: range.startColumn,\n        endColumn: range.endColumn\n      };\n    }\n  }, {\n    key: \"getWordAtPosition\",\n    value: function getWordAtPosition(model, _wordSeparators, position) {\n      var wordSeparators = getMapForWordSeparators(_wordSeparators);\n\n      var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n      if (prevWord && prevWord.wordType === 1\n      /* Regular */\n      && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n        return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n      }\n\n      var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n      if (nextWord && nextWord.wordType === 1\n      /* Regular */\n      && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n        return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"word\",\n    value: function word(config, model, cursor, inSelectionMode, position) {\n      var wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n      var prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n\n      var nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n\n      if (!inSelectionMode) {\n        // Entering word selection for the first time\n        var _startColumn;\n\n        var _endColumn;\n\n        if (prevWord && prevWord.wordType === 1\n        /* Regular */\n        && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n          // isTouchingPrevWord\n          _startColumn = prevWord.start + 1;\n          _endColumn = prevWord.end + 1;\n        } else if (nextWord && nextWord.wordType === 1\n        /* Regular */\n        && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n          // isTouchingNextWord\n          _startColumn = nextWord.start + 1;\n          _endColumn = nextWord.end + 1;\n        } else {\n          if (prevWord) {\n            _startColumn = prevWord.end + 1;\n          } else {\n            _startColumn = 1;\n          }\n\n          if (nextWord) {\n            _endColumn = nextWord.start + 1;\n          } else {\n            _endColumn = model.getLineMaxColumn(position.lineNumber);\n          }\n        }\n\n        return new SingleCursorState(new Range(position.lineNumber, _startColumn, position.lineNumber, _endColumn), 0, new Position(position.lineNumber, _endColumn), 0);\n      }\n\n      var startColumn;\n      var endColumn;\n\n      if (prevWord && prevWord.wordType === 1\n      /* Regular */\n      && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n        // isInsidePrevWord\n        startColumn = prevWord.start + 1;\n        endColumn = prevWord.end + 1;\n      } else if (nextWord && nextWord.wordType === 1\n      /* Regular */\n      && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n        // isInsideNextWord\n        startColumn = nextWord.start + 1;\n        endColumn = nextWord.end + 1;\n      } else {\n        startColumn = position.column;\n        endColumn = position.column;\n      }\n\n      var lineNumber = position.lineNumber;\n      var column;\n\n      if (cursor.selectionStart.containsPosition(position)) {\n        column = cursor.selectionStart.endColumn;\n      } else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n        column = startColumn;\n        var possiblePosition = new Position(lineNumber, column);\n\n        if (cursor.selectionStart.containsPosition(possiblePosition)) {\n          column = cursor.selectionStart.endColumn;\n        }\n      } else {\n        column = endColumn;\n\n        var _possiblePosition = new Position(lineNumber, column);\n\n        if (cursor.selectionStart.containsPosition(_possiblePosition)) {\n          column = cursor.selectionStart.startColumn;\n        }\n      }\n\n      return cursor.move(true, lineNumber, column, 0);\n    }\n  }]);\n\n  return WordOperations;\n}();\nexport var WordPartOperations = /*#__PURE__*/function (_WordOperations) {\n  _inherits(WordPartOperations, _WordOperations);\n\n  var _super = _createSuper(WordPartOperations);\n\n  function WordPartOperations() {\n    _classCallCheck(this, WordPartOperations);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(WordPartOperations, null, [{\n    key: \"deleteWordPartLeft\",\n    value: function deleteWordPartLeft(ctx) {\n      var candidates = enforceDefined([WordOperations.deleteWordLeft(ctx, 0\n      /* WordStart */\n      ), WordOperations.deleteWordLeft(ctx, 2\n      /* WordEnd */\n      ), WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)]);\n      candidates.sort(Range.compareRangesUsingEnds);\n      return candidates[2];\n    }\n  }, {\n    key: \"deleteWordPartRight\",\n    value: function deleteWordPartRight(ctx) {\n      var candidates = enforceDefined([WordOperations.deleteWordRight(ctx, 0\n      /* WordStart */\n      ), WordOperations.deleteWordRight(ctx, 2\n      /* WordEnd */\n      ), WordOperations._deleteWordPartRight(ctx.model, ctx.selection)]);\n      candidates.sort(Range.compareRangesUsingStarts);\n      return candidates[0];\n    }\n  }, {\n    key: \"moveWordPartLeft\",\n    value: function moveWordPartLeft(wordSeparators, model, position) {\n      var candidates = enforceDefined([WordOperations.moveWordLeft(wordSeparators, model, position, 0\n      /* WordStart */\n      ), WordOperations.moveWordLeft(wordSeparators, model, position, 2\n      /* WordEnd */\n      ), WordOperations._moveWordPartLeft(model, position)]);\n      candidates.sort(Position.compare);\n      return candidates[2];\n    }\n  }, {\n    key: \"moveWordPartRight\",\n    value: function moveWordPartRight(wordSeparators, model, position) {\n      var candidates = enforceDefined([WordOperations.moveWordRight(wordSeparators, model, position, 0\n      /* WordStart */\n      ), WordOperations.moveWordRight(wordSeparators, model, position, 2\n      /* WordEnd */\n      ), WordOperations._moveWordPartRight(model, position)]);\n      candidates.sort(Position.compare);\n      return candidates[0];\n    }\n  }]);\n\n  return WordPartOperations;\n}(WordOperations);\n\nfunction enforceDefined(arr) {\n  return arr.filter(function (el) {\n    return Boolean(el);\n  });\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorWordOperations.js"],"names":["strings","SingleCursorState","DeleteOperations","getMapForWordSeparators","Position","Range","WordOperations","lineContent","wordType","nextCharClass","start","end","wordSeparators","model","position","getLineContent","lineNumber","_doFindPreviousWordOnLine","chIndex","column","chCode","charCodeAt","chClass","get","_createWord","_findEndOfWord","startIndex","len","length","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","getLineMaxColumn","prevWordOnLine","_findPreviousWordOnLine","maxColumn","left","right","isLowerAsciiLetter","isUpperAsciiLetter","rightRight","movedDown","getLineCount","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","lastNonWhitespaceIndex","ctx","selection","whitespaceHeuristics","isEmpty","isAutoClosingPairDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairs","autoClosingPairsOpenByEnd","getPosition","positionLineNumber","positionColumn","r","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","str","index","charCode","lineContentLength","leftIndex","Math","max","_charAtIsWhitespace","rightIndex","min","lineLength","touchesWord","word","createRangeWithPosition","startColumn","endColumn","deleteWordAndAdjacentWhitespace","expandedToTheRight","pos","toPosition","_moveWordPartLeft","ch","charAt","firstNonWhitespace","_findFirstNonWhitespaceChar","lineCount","_deleteWordRightWhitespace","_moveWordPartRight","range","getValueInRange","_wordSeparators","prevWord","_createWordAtPosition","nextWord","config","cursor","inSelectionMode","selectionStart","containsPosition","isBeforeOrEqual","getStartPosition","possiblePosition","move","WordPartOperations","candidates","enforceDefined","deleteWordLeft","_deleteWordPartLeft","sort","compareRangesUsingEnds","deleteWordRight","_deleteWordPartRight","compareRangesUsingStarts","moveWordLeft","compare","moveWordRight","arr","filter","el","Boolean"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,iCAAzB;AACA,SAASC,iBAAT,QAAkC,mBAAlC;AACA,SAASC,gBAAT,QAAiC,6BAAjC;AACA,SAASC,uBAAT,QAAwC,8BAAxC;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,WAAaC,cAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,gCACuBC,WADvB,EACoCC,QADpC,EAC8CC,aAD9C,EAC6DC,KAD7D,EACoEC,GADpE,EACyE;AACjE;AACA,aAAO;AAAED,QAAAA,KAAK,EAAEA,KAAT;AAAgBC,QAAAA,GAAG,EAAEA,GAArB;AAA0BH,QAAAA,QAAQ,EAAEA,QAApC;AAA8CC,QAAAA,aAAa,EAAEA;AAA7D,OAAP;AACH;AAJL;AAAA;AAAA,4CAKmCG,cALnC,EAKmDC,KALnD,EAK0DC,QAL1D,EAKoE;AAC5D,UAAIP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAAlB;AACA,aAAO,KAAKC,yBAAL,CAA+BV,WAA/B,EAA4CK,cAA5C,EAA4DE,QAA5D,CAAP;AACH;AARL;AAAA;AAAA,8CASqCP,WATrC,EASkDK,cATlD,EASkEE,QATlE,EAS4E;AACpE,UAAIN,QAAQ,GAAG;AAAE;AAAjB;;AACA,WAAK,IAAIU,OAAO,GAAGJ,QAAQ,CAACK,MAAT,GAAkB,CAArC,EAAwCD,OAAO,IAAI,CAAnD,EAAsDA,OAAO,EAA7D,EAAiE;AAC7D,YAAIE,MAAM,GAAGb,WAAW,CAACc,UAAZ,CAAuBH,OAAvB,CAAb;AACA,YAAII,OAAO,GAAGV,cAAc,CAACW,GAAf,CAAmBH,MAAnB,CAAd;;AACA,YAAIE,OAAO,KAAK;AAAE;AAAlB,UAAiC;AAC7B,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAAoC;AAChC,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiDJ,OAAO,GAAG,CAA3D,EAA8D,KAAKO,cAAL,CAAoBlB,WAApB,EAAiCK,cAAjC,EAAiDJ,QAAjD,EAA2DU,OAAO,GAAG,CAArE,CAA9D,CAAP;AACH;;AACDV,YAAAA,QAAQ,GAAG;AAAE;AAAb;AACH,WALD,MAMK,IAAIc,OAAO,KAAK;AAAE;AAAlB,UAAuC;AACxC,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAAkC;AAC9B,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiDJ,OAAO,GAAG,CAA3D,EAA8D,KAAKO,cAAL,CAAoBlB,WAApB,EAAiCK,cAAjC,EAAiDJ,QAAjD,EAA2DU,OAAO,GAAG,CAArE,CAA9D,CAAP;AACH;;AACDV,YAAAA,QAAQ,GAAG;AAAE;AAAb;AACH,WALI,MAMA,IAAIc,OAAO,KAAK;AAAE;AAAlB,UAAoC;AACrC,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAA+B;AAC3B,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiDJ,OAAO,GAAG,CAA3D,EAA8D,KAAKO,cAAL,CAAoBlB,WAApB,EAAiCK,cAAjC,EAAiDJ,QAAjD,EAA2DU,OAAO,GAAG,CAArE,CAA9D,CAAP;AACH;AACJ;AACJ;;AACD,UAAIV,QAAQ,KAAK;AAAE;AAAnB,QAA+B;AAC3B,iBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwC;AAAE;AAA1C,YAA4D,CAA5D,EAA+D,KAAKiB,cAAL,CAAoBlB,WAApB,EAAiCK,cAAjC,EAAiDJ,QAAjD,EAA2D,CAA3D,CAA/D,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AApCL;AAAA;AAAA,mCAqC0BD,WArC1B,EAqCuCK,cArCvC,EAqCuDJ,QArCvD,EAqCiEkB,UArCjE,EAqC6E;AACrE,UAAIC,GAAG,GAAGpB,WAAW,CAACqB,MAAtB;;AACA,WAAK,IAAIV,OAAO,GAAGQ,UAAnB,EAA+BR,OAAO,GAAGS,GAAzC,EAA8CT,OAAO,EAArD,EAAyD;AACrD,YAAIE,MAAM,GAAGb,WAAW,CAACc,UAAZ,CAAuBH,OAAvB,CAAb;AACA,YAAII,OAAO,GAAGV,cAAc,CAACW,GAAf,CAAmBH,MAAnB,CAAd;;AACA,YAAIE,OAAO,KAAK;AAAE;AAAlB,UAAoC;AAChC,mBAAOJ,OAAP;AACH;;AACD,YAAIV,QAAQ,KAAK;AAAE;AAAf,WAAgCc,OAAO,KAAK;AAAE;AAAlD,UAAuE;AACnE,mBAAOJ,OAAP;AACH;;AACD,YAAIV,QAAQ,KAAK;AAAE;AAAf,WAAkCc,OAAO,KAAK;AAAE;AAApD,UAAmE;AAC/D,mBAAOJ,OAAP;AACH;AACJ;;AACD,aAAOS,GAAP;AACH;AArDL;AAAA;AAAA,wCAsD+Bf,cAtD/B,EAsD+CC,KAtD/C,EAsDsDC,QAtDtD,EAsDgE;AACxD,UAAIP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAAlB;AACA,aAAO,KAAKa,qBAAL,CAA2BtB,WAA3B,EAAwCK,cAAxC,EAAwDE,QAAxD,CAAP;AACH;AAzDL;AAAA;AAAA,0CA0DiCP,WA1DjC,EA0D8CK,cA1D9C,EA0D8DE,QA1D9D,EA0DwE;AAChE,UAAIN,QAAQ,GAAG;AAAE;AAAjB;AACA,UAAImB,GAAG,GAAGpB,WAAW,CAACqB,MAAtB;;AACA,WAAK,IAAIV,OAAO,GAAGJ,QAAQ,CAACK,MAAT,GAAkB,CAArC,EAAwCD,OAAO,GAAGS,GAAlD,EAAuDT,OAAO,EAA9D,EAAkE;AAC9D,YAAIE,MAAM,GAAGb,WAAW,CAACc,UAAZ,CAAuBH,OAAvB,CAAb;AACA,YAAII,OAAO,GAAGV,cAAc,CAACW,GAAf,CAAmBH,MAAnB,CAAd;;AACA,YAAIE,OAAO,KAAK;AAAE;AAAlB,UAAiC;AAC7B,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAAoC;AAChC,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiD,KAAKQ,gBAAL,CAAsBvB,WAAtB,EAAmCK,cAAnC,EAAmDJ,QAAnD,EAA6DU,OAAO,GAAG,CAAvE,CAAjD,EAA4HA,OAA5H,CAAP;AACH;;AACDV,YAAAA,QAAQ,GAAG;AAAE;AAAb;AACH,WALD,MAMK,IAAIc,OAAO,KAAK;AAAE;AAAlB,UAAuC;AACxC,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAAkC;AAC9B,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiD,KAAKQ,gBAAL,CAAsBvB,WAAtB,EAAmCK,cAAnC,EAAmDJ,QAAnD,EAA6DU,OAAO,GAAG,CAAvE,CAAjD,EAA4HA,OAA5H,CAAP;AACH;;AACDV,YAAAA,QAAQ,GAAG;AAAE;AAAb;AACH,WALI,MAMA,IAAIc,OAAO,KAAK;AAAE;AAAlB,UAAoC;AACrC,gBAAId,QAAQ,KAAK;AAAE;AAAnB,cAA+B;AAC3B,uBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwCc,OAAxC,EAAiD,KAAKQ,gBAAL,CAAsBvB,WAAtB,EAAmCK,cAAnC,EAAmDJ,QAAnD,EAA6DU,OAAO,GAAG,CAAvE,CAAjD,EAA4HA,OAA5H,CAAP;AACH;AACJ;AACJ;;AACD,UAAIV,QAAQ,KAAK;AAAE;AAAnB,QAA+B;AAC3B,iBAAO,KAAKgB,WAAL,CAAiBjB,WAAjB,EAA8BC,QAA9B,EAAwC;AAAE;AAA1C,YAA4D,KAAKsB,gBAAL,CAAsBvB,WAAtB,EAAmCK,cAAnC,EAAmDJ,QAAnD,EAA6DmB,GAAG,GAAG,CAAnE,CAA5D,EAAmIA,GAAnI,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AAtFL;AAAA;AAAA,qCAuF4BpB,WAvF5B,EAuFyCK,cAvFzC,EAuFyDJ,QAvFzD,EAuFmEkB,UAvFnE,EAuF+E;AACvE,WAAK,IAAIR,OAAO,GAAGQ,UAAnB,EAA+BR,OAAO,IAAI,CAA1C,EAA6CA,OAAO,EAApD,EAAwD;AACpD,YAAIE,MAAM,GAAGb,WAAW,CAACc,UAAZ,CAAuBH,OAAvB,CAAb;AACA,YAAII,OAAO,GAAGV,cAAc,CAACW,GAAf,CAAmBH,MAAnB,CAAd;;AACA,YAAIE,OAAO,KAAK;AAAE;AAAlB,UAAoC;AAChC,mBAAOJ,OAAO,GAAG,CAAjB;AACH;;AACD,YAAIV,QAAQ,KAAK;AAAE;AAAf,WAAgCc,OAAO,KAAK;AAAE;AAAlD,UAAuE;AACnE,mBAAOJ,OAAO,GAAG,CAAjB;AACH;;AACD,YAAIV,QAAQ,KAAK;AAAE;AAAf,WAAkCc,OAAO,KAAK;AAAE;AAApD,UAAmE;AAC/D,mBAAOJ,OAAO,GAAG,CAAjB;AACH;AACJ;;AACD,aAAO,CAAP;AACH;AAtGL;AAAA;AAAA,iCAuGwBN,cAvGxB,EAuGwCC,KAvGxC,EAuG+CC,QAvG/C,EAuGyDiB,kBAvGzD,EAuG6E;AACrE,UAAIf,UAAU,GAAGF,QAAQ,CAACE,UAA1B;AACA,UAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAtB;;AACA,UAAIA,MAAM,KAAK,CAAf,EAAkB;AACd,YAAIH,UAAU,GAAG,CAAjB,EAAoB;AAChBA,UAAAA,UAAU,GAAGA,UAAU,GAAG,CAA1B;AACAG,UAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;;AACD,UAAIiB,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAA9D,CAArB;;AACA,UAAIY,kBAAkB,KAAK;AAAE;AAA7B,QAA8C;AAC1C,iBAAO,IAAI3B,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,GAAGA,cAAc,CAACvB,KAAf,GAAuB,CAA1B,GAA8B,CAArE,CAAP;AACH;;AACD,UAAIqB,kBAAkB,KAAK;AAAE;AAA7B,QAAkD;AAC9C,cAAIE,cAAc,IACXA,cAAc,CAACzB,QAAf,KAA4B;AAAE;AADjC,aAEGyB,cAAc,CAACtB,GAAf,GAAqBsB,cAAc,CAACvB,KAApC,KAA8C,CAFjD,IAGGuB,cAAc,CAACxB,aAAf,KAAiC;AAAE;AAH1C,YAGyD;AACrD;AACAwB,cAAAA,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,CAACvB,KAAf,GAAuB,CAAhD,CAA9D,CAAjB;AACH;;AACD,iBAAO,IAAIN,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,GAAGA,cAAc,CAACvB,KAAf,GAAuB,CAA1B,GAA8B,CAArE,CAAP;AACH;;AACD,UAAIqB,kBAAkB,KAAK;AAAE;AAA7B,QAAsD;AAClD,iBAAOE,cAAc,IACdA,cAAc,CAACzB,QAAf,KAA4B;AAAE;AADrC,YACsD;AAClD;AACAyB,YAAAA,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,CAACvB,KAAf,GAAuB,CAAhD,CAA9D,CAAjB;AACH;;AACD,iBAAO,IAAIN,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,GAAGA,cAAc,CAACvB,KAAf,GAAuB,CAA1B,GAA8B,CAArE,CAAP;AACH,SA9BoE,CA+BrE;;;AACA,UAAIuB,cAAc,IAAId,MAAM,IAAIc,cAAc,CAACtB,GAAf,GAAqB,CAArD,EAAwD;AACpDsB,QAAAA,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,CAACvB,KAAf,GAAuB,CAAhD,CAA9D,CAAjB;AACH;;AACD,aAAO,IAAIN,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,GAAGA,cAAc,CAACtB,GAAf,GAAqB,CAAxB,GAA4B,CAAnE,CAAP;AACH;AA3IL;AAAA;AAAA,sCA4I6BE,KA5I7B,EA4IoCC,QA5IpC,EA4I8C;AACtC,UAAME,UAAU,GAAGF,QAAQ,CAACE,UAA5B;AACA,UAAMmB,SAAS,GAAGtB,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAlB;;AACA,UAAIF,QAAQ,CAACK,MAAT,KAAoB,CAAxB,EAA2B;AACvB,eAAQH,UAAU,GAAG,CAAb,GAAiB,IAAIZ,QAAJ,CAAaY,UAAU,GAAG,CAA1B,EAA6BH,KAAK,CAACmB,gBAAN,CAAuBhB,UAAU,GAAG,CAApC,CAA7B,CAAjB,GAAwFF,QAAhG;AACH;;AACD,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBC,UAArB,CAApB;;AACA,WAAK,IAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAT,GAAkB,CAApC,EAAuCA,MAAM,GAAG,CAAhD,EAAmDA,MAAM,EAAzD,EAA6D;AACzD,YAAMiB,IAAI,GAAG7B,WAAW,CAACc,UAAZ,CAAuBF,MAAM,GAAG,CAAhC,CAAb;AACA,YAAMkB,KAAK,GAAG9B,WAAW,CAACc,UAAZ,CAAuBF,MAAM,GAAG,CAAhC,CAAd;;AACA,YAAIiB,IAAI,KAAK;AAAG;AAAZ,WAA+BC,KAAK,KAAK;AAAG;AAAhD,UAAiE;AAC7D;AACA,mBAAO,IAAIjC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;;AACD,YAAInB,OAAO,CAACsC,kBAAR,CAA2BF,IAA3B,KAAoCpC,OAAO,CAACuC,kBAAR,CAA2BF,KAA3B,CAAxC,EAA2E;AACvE;AACA,iBAAO,IAAIjC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;;AACD,YAAInB,OAAO,CAACuC,kBAAR,CAA2BH,IAA3B,KAAoCpC,OAAO,CAACuC,kBAAR,CAA2BF,KAA3B,CAAxC,EAA2E;AACvE;AACA,cAAIlB,MAAM,GAAG,CAAT,GAAagB,SAAjB,EAA4B;AACxB,gBAAMK,UAAU,GAAGjC,WAAW,CAACc,UAAZ,CAAuBF,MAAvB,CAAnB;;AACA,gBAAInB,OAAO,CAACsC,kBAAR,CAA2BE,UAA3B,CAAJ,EAA4C;AACxC,qBAAO,IAAIpC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;AACJ;AACJ;AACJ;;AACD,aAAO,IAAIf,QAAJ,CAAaY,UAAb,EAAyB,CAAzB,CAAP;AACH;AAzKL;AAAA;AAAA,kCA0KyBJ,cA1KzB,EA0KyCC,KA1KzC,EA0KgDC,QA1KhD,EA0K0DiB,kBA1K1D,EA0K8E;AACtE,UAAIf,UAAU,GAAGF,QAAQ,CAACE,UAA1B;AACA,UAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAtB;AACA,UAAIsB,SAAS,GAAG,KAAhB;;AACA,UAAItB,MAAM,KAAKN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAf,EAAmD;AAC/C,YAAIA,UAAU,GAAGH,KAAK,CAAC6B,YAAN,EAAjB,EAAuC;AACnCD,UAAAA,SAAS,GAAG,IAAZ;AACAzB,UAAAA,UAAU,GAAGA,UAAU,GAAG,CAA1B;AACAG,UAAAA,MAAM,GAAG,CAAT;AACH;AACJ;;AACD,UAAIwB,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAA1D,CAArB;;AACA,UAAIY,kBAAkB,KAAK;AAAE;AAA7B,QAA4C;AACxC,cAAIY,cAAc,IAAIA,cAAc,CAACnC,QAAf,KAA4B;AAAE;AAApD,YAAqE;AACjE,kBAAImC,cAAc,CAAChC,GAAf,GAAqBgC,cAAc,CAACjC,KAApC,KAA8C,CAA9C,IAAmDiC,cAAc,CAAClC,aAAf,KAAiC;AAAE;AAA1F,gBAAyG;AACrG;AACAkC,kBAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB2B,cAAc,CAAChC,GAAf,GAAqB,CAA9C,CAA1D,CAAjB;AACH;AACJ;;AACD,cAAIgC,cAAJ,EAAoB;AAChBxB,YAAAA,MAAM,GAAGwB,cAAc,CAAChC,GAAf,GAAqB,CAA9B;AACH,WAFD,MAGK;AACDQ,YAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ,SAbD,MAcK,IAAIe,kBAAkB,KAAK;AAAE;AAA7B,QAAsD;AACvD,cAAIU,SAAJ,EAAe;AACX;AACA;AACA;AACAtB,YAAAA,MAAM,GAAG,CAAT;AACH;;AACD,iBAAOwB,cAAc,KACbA,cAAc,CAACnC,QAAf,KAA4B;AAAE;AAA9B,aACGmC,cAAc,CAACjC,KAAf,GAAuB,CAAvB,IAA4BS,MAFlB,CAArB,EAEgD;AAC5C;AACA;AACAwB,YAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB2B,cAAc,CAAChC,GAAf,GAAqB,CAA9C,CAA1D,CAAjB;AACH;;AACD,cAAIgC,cAAJ,EAAoB;AAChBxB,YAAAA,MAAM,GAAGwB,cAAc,CAACjC,KAAf,GAAuB,CAAhC;AACH,WAFD,MAGK;AACDS,YAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ,SApBI,MAqBA;AACD,YAAI2B,cAAc,IAAI,CAACF,SAAnB,IAAgCtB,MAAM,IAAIwB,cAAc,CAACjC,KAAf,GAAuB,CAArE,EAAwE;AACpEiC,UAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB2B,cAAc,CAAChC,GAAf,GAAqB,CAA9C,CAA1D,CAAjB;AACH;;AACD,YAAIgC,cAAJ,EAAoB;AAChBxB,UAAAA,MAAM,GAAGwB,cAAc,CAACjC,KAAf,GAAuB,CAAhC;AACH,SAFD,MAGK;AACDS,UAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;;AACD,aAAO,IAAIZ,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;AArOL;AAAA;AAAA,uCAsO8BN,KAtO9B,EAsOqCC,QAtOrC,EAsO+C;AACvC,UAAME,UAAU,GAAGF,QAAQ,CAACE,UAA5B;AACA,UAAMmB,SAAS,GAAGtB,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAlB;;AACA,UAAIF,QAAQ,CAACK,MAAT,KAAoBgB,SAAxB,EAAmC;AAC/B,eAAQnB,UAAU,GAAGH,KAAK,CAAC6B,YAAN,EAAb,GAAoC,IAAItC,QAAJ,CAAaY,UAAU,GAAG,CAA1B,EAA6B,CAA7B,CAApC,GAAsEF,QAA9E;AACH;;AACD,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBC,UAArB,CAApB;;AACA,WAAK,IAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAT,GAAkB,CAApC,EAAuCA,MAAM,GAAGgB,SAAhD,EAA2DhB,MAAM,EAAjE,EAAqE;AACjE,YAAMiB,IAAI,GAAG7B,WAAW,CAACc,UAAZ,CAAuBF,MAAM,GAAG,CAAhC,CAAb;AACA,YAAMkB,KAAK,GAAG9B,WAAW,CAACc,UAAZ,CAAuBF,MAAM,GAAG,CAAhC,CAAd;;AACA,YAAIiB,IAAI,KAAK;AAAG;AAAZ,WAA+BC,KAAK,KAAK;AAAG;AAAhD,UAAiE;AAC7D;AACA,mBAAO,IAAIjC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;;AACD,YAAInB,OAAO,CAACsC,kBAAR,CAA2BF,IAA3B,KAAoCpC,OAAO,CAACuC,kBAAR,CAA2BF,KAA3B,CAAxC,EAA2E;AACvE;AACA,iBAAO,IAAIjC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;;AACD,YAAInB,OAAO,CAACuC,kBAAR,CAA2BH,IAA3B,KAAoCpC,OAAO,CAACuC,kBAAR,CAA2BF,KAA3B,CAAxC,EAA2E;AACvE;AACA,cAAIlB,MAAM,GAAG,CAAT,GAAagB,SAAjB,EAA4B;AACxB,gBAAMK,UAAU,GAAGjC,WAAW,CAACc,UAAZ,CAAuBF,MAAvB,CAAnB;;AACA,gBAAInB,OAAO,CAACsC,kBAAR,CAA2BE,UAA3B,CAAJ,EAA4C;AACxC,qBAAO,IAAIpC,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAP;AACH;AACJ;AACJ;AACJ;;AACD,aAAO,IAAIf,QAAJ,CAAaY,UAAb,EAAyBmB,SAAzB,CAAP;AACH;AAnQL;AAAA;AAAA,8CAoQqCtB,KApQrC,EAoQ4CC,QApQ5C,EAoQsD;AAC9C,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAApB;AACA,UAAMU,UAAU,GAAGZ,QAAQ,CAACK,MAAT,GAAkB,CAArC;AACA,UAAM0B,iBAAiB,GAAG7C,OAAO,CAAC8C,sBAAR,CAA+BvC,WAA/B,EAA4CmB,UAA5C,CAA1B;;AACA,UAAImB,iBAAiB,GAAG,CAApB,GAAwBnB,UAA5B,EAAwC;AACpC,eAAO,IAAIrB,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+B6B,iBAAiB,GAAG,CAAnD,EAAsD/B,QAAQ,CAACE,UAA/D,EAA2EF,QAAQ,CAACK,MAApF,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AA5QL;AAAA;AAAA,mCA6Q0B4B,GA7Q1B,EA6Q+BhB,kBA7Q/B,EA6QmD;AAC3C,UAAMnB,cAAc,GAAGmC,GAAG,CAACnC,cAA3B;AACA,UAAMC,KAAK,GAAGkC,GAAG,CAAClC,KAAlB;AACA,UAAMmC,SAAS,GAAGD,GAAG,CAACC,SAAtB;AACA,UAAMC,oBAAoB,GAAGF,GAAG,CAACE,oBAAjC;;AACA,UAAI,CAACD,SAAS,CAACE,OAAV,EAAL,EAA0B;AACtB,eAAOF,SAAP;AACH;;AACD,UAAI9C,gBAAgB,CAACiD,uBAAjB,CAAyCJ,GAAG,CAACK,mBAA7C,EAAkEL,GAAG,CAACM,iBAAtE,EAAyFN,GAAG,CAACO,gBAAJ,CAAqBC,yBAA9G,EAAyIR,GAAG,CAAClC,KAA7I,EAAoJ,CAACkC,GAAG,CAACC,SAAL,CAApJ,CAAJ,EAA0K;AACtK,YAAMlC,SAAQ,GAAGiC,GAAG,CAACC,SAAJ,CAAcQ,WAAd,EAAjB;;AACA,eAAO,IAAInD,KAAJ,CAAUS,SAAQ,CAACE,UAAnB,EAA+BF,SAAQ,CAACK,MAAT,GAAkB,CAAjD,EAAoDL,SAAQ,CAACE,UAA7D,EAAyEF,SAAQ,CAACK,MAAT,GAAkB,CAA3F,CAAP;AACH;;AACD,UAAML,QAAQ,GAAG,IAAIV,QAAJ,CAAa4C,SAAS,CAACS,kBAAvB,EAA2CT,SAAS,CAACU,cAArD,CAAjB;AACA,UAAI1C,UAAU,GAAGF,QAAQ,CAACE,UAA1B;AACA,UAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAtB;;AACA,UAAIH,UAAU,KAAK,CAAf,IAAoBG,MAAM,KAAK,CAAnC,EAAsC;AAClC;AACA,eAAO,IAAP;AACH;;AACD,UAAI8B,oBAAJ,EAA0B;AACtB,YAAIU,CAAC,GAAG,KAAKC,yBAAL,CAA+B/C,KAA/B,EAAsCC,QAAtC,CAAR;;AACA,YAAI6C,CAAJ,EAAO;AACH,iBAAOA,CAAP;AACH;AACJ;;AACD,UAAI1B,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8DC,QAA9D,CAArB;;AACA,UAAIiB,kBAAkB,KAAK;AAAE;AAA7B,QAA8C;AAC1C,cAAIE,cAAJ,EAAoB;AAChBd,YAAAA,MAAM,GAAGc,cAAc,CAACvB,KAAf,GAAuB,CAAhC;AACH,WAFD,MAGK;AACD,gBAAIS,MAAM,GAAG,CAAb,EAAgB;AACZA,cAAAA,MAAM,GAAG,CAAT;AACH,aAFD,MAGK;AACDH,cAAAA,UAAU;AACVG,cAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;AACJ,SAbD,MAcK;AACD,YAAIiB,cAAc,IAAId,MAAM,IAAIc,cAAc,CAACtB,GAAf,GAAqB,CAArD,EAAwD;AACpDsB,UAAAA,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8D,IAAIT,QAAJ,CAAaY,UAAb,EAAyBiB,cAAc,CAACvB,KAAf,GAAuB,CAAhD,CAA9D,CAAjB;AACH;;AACD,YAAIuB,cAAJ,EAAoB;AAChBd,UAAAA,MAAM,GAAGc,cAAc,CAACtB,GAAf,GAAqB,CAA9B;AACH,SAFD,MAGK;AACD,cAAIQ,MAAM,GAAG,CAAb,EAAgB;AACZA,YAAAA,MAAM,GAAG,CAAT;AACH,WAFD,MAGK;AACDH,YAAAA,UAAU;AACVG,YAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;AACJ;;AACD,aAAO,IAAIX,KAAJ,CAAUW,UAAV,EAAsBG,MAAtB,EAA8BL,QAAQ,CAACE,UAAvC,EAAmDF,QAAQ,CAACK,MAA5D,CAAP;AACH;AAvUL;AAAA;AAAA,qCAwU4BP,cAxU5B,EAwU4CC,KAxU5C,EAwUmDmC,SAxUnD,EAwU8D;AACtD,UAAI,CAACA,SAAS,CAACE,OAAV,EAAL,EAA0B;AACtB,eAAOF,SAAP;AACH;;AACD,UAAMlC,QAAQ,GAAG,IAAIV,QAAJ,CAAa4C,SAAS,CAACS,kBAAvB,EAA2CT,SAAS,CAACU,cAArD,CAAjB;;AACA,UAAIC,CAAC,GAAG,KAAKE,2BAAL,CAAiChD,KAAjC,EAAwCC,QAAxC,CAAR;;AACA,UAAI6C,CAAJ,EAAO;AACH,eAAOA,CAAP;AACH;;AACD,aAAO,KAAKG,qCAAL,CAA2ClD,cAA3C,EAA2DC,KAA3D,EAAkEC,QAAlE,CAAP;AACH;AAlVL;AAAA;AAAA,wCAmV+BiD,GAnV/B,EAmVoCC,KAnVpC,EAmV2C;AACnC,UAAMC,QAAQ,GAAGF,GAAG,CAAC1C,UAAJ,CAAe2C,KAAf,CAAjB;AACA,aAAQC,QAAQ,KAAK;AAAG;AAAhB,SAA+BA,QAAQ,KAAK;AAAE;AAAtD;AACH;AAtVL;AAAA;AAAA,gDAuVuCpD,KAvVvC,EAuV8CC,QAvV9C,EAuVwD;AAChD,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAApB;AACA,UAAMkD,iBAAiB,GAAG3D,WAAW,CAACqB,MAAtC;;AACA,UAAIsC,iBAAiB,KAAK,CAA1B,EAA6B;AACzB;AACA,eAAO,IAAP;AACH;;AACD,UAAIC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASvD,QAAQ,CAACK,MAAT,GAAkB,CAA3B,EAA8B,CAA9B,CAAhB;;AACA,UAAI,CAAC,KAAKmD,mBAAL,CAAyB/D,WAAzB,EAAsC4D,SAAtC,CAAL,EAAuD;AACnD;AACA,eAAO,IAAP;AACH;;AACD,UAAII,UAAU,GAAGH,IAAI,CAACI,GAAL,CAAS1D,QAAQ,CAACK,MAAT,GAAkB,CAA3B,EAA8B+C,iBAAiB,GAAG,CAAlD,CAAjB;;AACA,UAAI,CAAC,KAAKI,mBAAL,CAAyB/D,WAAzB,EAAsCgE,UAAtC,CAAL,EAAwD;AACpD;AACA,eAAO,IAAP;AACH,OAhB+C,CAiBhD;;;AACA,aAAOJ,SAAS,GAAG,CAAZ,IAAiB,KAAKG,mBAAL,CAAyB/D,WAAzB,EAAsC4D,SAAS,GAAG,CAAlD,CAAxB,EAA8E;AAC1EA,QAAAA,SAAS;AACZ,OApB+C,CAqBhD;;;AACA,aAAOI,UAAU,GAAG,CAAb,GAAiBL,iBAAjB,IAAsC,KAAKI,mBAAL,CAAyB/D,WAAzB,EAAsCgE,UAAU,GAAG,CAAnD,CAA7C,EAAoG;AAChGA,QAAAA,UAAU;AACb;;AACD,aAAO,IAAIlE,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+BmD,SAAS,GAAG,CAA3C,EAA8CrD,QAAQ,CAACE,UAAvD,EAAmEuD,UAAU,GAAG,CAAhF,CAAP;AACH;AAjXL;AAAA;AAAA,0DAkXiD3D,cAlXjD,EAkXiEC,KAlXjE,EAkXwEC,QAlXxE,EAkXkF;AAAA;;AAC1E,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAApB;AACA,UAAMyD,UAAU,GAAGlE,WAAW,CAACqB,MAA/B;;AACA,UAAI6C,UAAU,KAAK,CAAnB,EAAsB;AAClB;AACA,YAAI3D,QAAQ,CAACE,UAAT,GAAsB,CAA1B,EAA6B;AACzB,iBAAO,IAAIX,KAAJ,CAAUS,QAAQ,CAACE,UAAT,GAAsB,CAAhC,EAAmCH,KAAK,CAACmB,gBAAN,CAAuBlB,QAAQ,CAACE,UAAT,GAAsB,CAA7C,CAAnC,EAAoFF,QAAQ,CAACE,UAA7F,EAAyG,CAAzG,CAAP;AACH,SAFD,MAGK;AACD,cAAIF,QAAQ,CAACE,UAAT,GAAsBH,KAAK,CAAC6B,YAAN,EAA1B,EAAgD;AAC5C,mBAAO,IAAIrC,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+B,CAA/B,EAAkCF,QAAQ,CAACE,UAAT,GAAsB,CAAxD,EAA2D,CAA3D,CAAP;AACH,WAFD,MAGK;AACD;AACA,mBAAO,IAAIX,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+B,CAA/B,EAAkCF,QAAQ,CAACE,UAA3C,EAAuD,CAAvD,CAAP;AACH;AACJ;AACJ;;AACD,UAAM0D,WAAW,GAAG,SAAdA,WAAc,CAACC,IAAD,EAAU;AAC1B,eAAQA,IAAI,CAACjE,KAAL,GAAa,CAAb,IAAkBI,QAAQ,CAACK,MAA3B,IAAqCL,QAAQ,CAACK,MAAT,IAAmBwD,IAAI,CAAChE,GAAL,GAAW,CAA3E;AACH,OAFD;;AAGA,UAAMiE,uBAAuB,GAAG,SAA1BA,uBAA0B,CAACC,WAAD,EAAcC,SAAd,EAA4B;AACxDD,QAAAA,WAAW,GAAGT,IAAI,CAACI,GAAL,CAASK,WAAT,EAAsB/D,QAAQ,CAACK,MAA/B,CAAd;AACA2D,QAAAA,SAAS,GAAGV,IAAI,CAACC,GAAL,CAASS,SAAT,EAAoBhE,QAAQ,CAACK,MAA7B,CAAZ;AACA,eAAO,IAAId,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+B6D,WAA/B,EAA4C/D,QAAQ,CAACE,UAArD,EAAiE8D,SAAjE,CAAP;AACH,OAJD;;AAKA,UAAMC,+BAA+B,GAAG,SAAlCA,+BAAkC,CAACJ,IAAD,EAAU;AAC9C,YAAIE,WAAW,GAAGF,IAAI,CAACjE,KAAL,GAAa,CAA/B;AACA,YAAIoE,SAAS,GAAGH,IAAI,CAAChE,GAAL,GAAW,CAA3B;AACA,YAAIqE,kBAAkB,GAAG,KAAzB;;AACA,eAAOF,SAAS,GAAG,CAAZ,GAAgBL,UAAhB,IAA8B,KAAI,CAACH,mBAAL,CAAyB/D,WAAzB,EAAsCuE,SAAS,GAAG,CAAlD,CAArC,EAA2F;AACvFE,UAAAA,kBAAkB,GAAG,IAArB;AACAF,UAAAA,SAAS;AACZ;;AACD,YAAI,CAACE,kBAAL,EAAyB;AACrB,iBAAOH,WAAW,GAAG,CAAd,IAAmB,KAAI,CAACP,mBAAL,CAAyB/D,WAAzB,EAAsCsE,WAAW,GAAG,CAApD,CAA1B,EAAkF;AAC9EA,YAAAA,WAAW;AACd;AACJ;;AACD,eAAOD,uBAAuB,CAACC,WAAD,EAAcC,SAAd,CAA9B;AACH,OAdD;;AAeA,UAAM7C,cAAc,GAAG3B,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8DC,QAA9D,CAAvB;;AACA,UAAImB,cAAc,IAAIyC,WAAW,CAACzC,cAAD,CAAjC,EAAmD;AAC/C,eAAO8C,+BAA+B,CAAC9C,cAAD,CAAtC;AACH;;AACD,UAAMU,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0DC,QAA1D,CAAvB;;AACA,UAAI6B,cAAc,IAAI+B,WAAW,CAAC/B,cAAD,CAAjC,EAAmD;AAC/C,eAAOoC,+BAA+B,CAACpC,cAAD,CAAtC;AACH;;AACD,UAAIV,cAAc,IAAIU,cAAtB,EAAsC;AAClC,eAAOiC,uBAAuB,CAAC3C,cAAc,CAACtB,GAAf,GAAqB,CAAtB,EAAyBgC,cAAc,CAACjC,KAAf,GAAuB,CAAhD,CAA9B;AACH;;AACD,UAAIuB,cAAJ,EAAoB;AAChB,eAAO2C,uBAAuB,CAAC3C,cAAc,CAACvB,KAAf,GAAuB,CAAxB,EAA2BuB,cAAc,CAACtB,GAAf,GAAqB,CAAhD,CAA9B;AACH;;AACD,UAAIgC,cAAJ,EAAoB;AAChB,eAAOiC,uBAAuB,CAACjC,cAAc,CAACjC,KAAf,GAAuB,CAAxB,EAA2BiC,cAAc,CAAChC,GAAf,GAAqB,CAAhD,CAA9B;AACH;;AACD,aAAOiE,uBAAuB,CAAC,CAAD,EAAIH,UAAU,GAAG,CAAjB,CAA9B;AACH;AA7aL;AAAA;AAAA,wCA8a+B5D,KA9a/B,EA8asCmC,SA9atC,EA8aiD;AACzC,UAAI,CAACA,SAAS,CAACE,OAAV,EAAL,EAA0B;AACtB,eAAOF,SAAP;AACH;;AACD,UAAMiC,GAAG,GAAGjC,SAAS,CAACQ,WAAV,EAAZ;;AACA,UAAM0B,UAAU,GAAG5E,cAAc,CAAC6E,iBAAf,CAAiCtE,KAAjC,EAAwCoE,GAAxC,CAAnB;;AACA,aAAO,IAAI5E,KAAJ,CAAU4E,GAAG,CAACjE,UAAd,EAA0BiE,GAAG,CAAC9D,MAA9B,EAAsC+D,UAAU,CAAClE,UAAjD,EAA6DkE,UAAU,CAAC/D,MAAxE,CAAP;AACH;AArbL;AAAA;AAAA,gDAsbuC4C,GAtbvC,EAsb4CrC,UAtb5C,EAsbwD;AAChD,UAAIC,GAAG,GAAGoC,GAAG,CAACnC,MAAd;;AACA,WAAK,IAAIV,OAAO,GAAGQ,UAAnB,EAA+BR,OAAO,GAAGS,GAAzC,EAA8CT,OAAO,EAArD,EAAyD;AACrD,YAAIkE,EAAE,GAAGrB,GAAG,CAACsB,MAAJ,CAAWnE,OAAX,CAAT;;AACA,YAAIkE,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,IAAzB,EAA+B;AAC3B,iBAAOlE,OAAP;AACH;AACJ;;AACD,aAAOS,GAAP;AACH;AA/bL;AAAA;AAAA,+CAgcsCd,KAhctC,EAgc6CC,QAhc7C,EAgcuD;AAC/C,UAAMP,WAAW,GAAGM,KAAK,CAACE,cAAN,CAAqBD,QAAQ,CAACE,UAA9B,CAApB;AACA,UAAMU,UAAU,GAAGZ,QAAQ,CAACK,MAAT,GAAkB,CAArC;;AACA,UAAMmE,kBAAkB,GAAG,KAAKC,2BAAL,CAAiChF,WAAjC,EAA8CmB,UAA9C,CAA3B;;AACA,UAAIA,UAAU,GAAG,CAAb,GAAiB4D,kBAArB,EAAyC;AACrC;AACA,eAAO,IAAIjF,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+BF,QAAQ,CAACK,MAAxC,EAAgDL,QAAQ,CAACE,UAAzD,EAAqEsE,kBAAkB,GAAG,CAA1F,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AAzcL;AAAA;AAAA,oCA0c2BvC,GA1c3B,EA0cgChB,kBA1chC,EA0coD;AAC5C,UAAMnB,cAAc,GAAGmC,GAAG,CAACnC,cAA3B;AACA,UAAMC,KAAK,GAAGkC,GAAG,CAAClC,KAAlB;AACA,UAAMmC,SAAS,GAAGD,GAAG,CAACC,SAAtB;AACA,UAAMC,oBAAoB,GAAGF,GAAG,CAACE,oBAAjC;;AACA,UAAI,CAACD,SAAS,CAACE,OAAV,EAAL,EAA0B;AACtB,eAAOF,SAAP;AACH;;AACD,UAAMlC,QAAQ,GAAG,IAAIV,QAAJ,CAAa4C,SAAS,CAACS,kBAAvB,EAA2CT,SAAS,CAACU,cAArD,CAAjB;AACA,UAAI1C,UAAU,GAAGF,QAAQ,CAACE,UAA1B;AACA,UAAIG,MAAM,GAAGL,QAAQ,CAACK,MAAtB;AACA,UAAMqE,SAAS,GAAG3E,KAAK,CAAC6B,YAAN,EAAlB;AACA,UAAMP,SAAS,GAAGtB,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAlB;;AACA,UAAIA,UAAU,KAAKwE,SAAf,IAA4BrE,MAAM,KAAKgB,SAA3C,EAAsD;AAClD;AACA,eAAO,IAAP;AACH;;AACD,UAAIc,oBAAJ,EAA0B;AACtB,YAAIU,CAAC,GAAG,KAAK8B,0BAAL,CAAgC5E,KAAhC,EAAuCC,QAAvC,CAAR;;AACA,YAAI6C,CAAJ,EAAO;AACH,iBAAOA,CAAP;AACH;AACJ;;AACD,UAAIhB,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0DC,QAA1D,CAArB;;AACA,UAAIiB,kBAAkB,KAAK;AAAE;AAA7B,QAA4C;AACxC,cAAIY,cAAJ,EAAoB;AAChBxB,YAAAA,MAAM,GAAGwB,cAAc,CAAChC,GAAf,GAAqB,CAA9B;AACH,WAFD,MAGK;AACD,gBAAIQ,MAAM,GAAGgB,SAAT,IAAsBnB,UAAU,KAAKwE,SAAzC,EAAoD;AAChDrE,cAAAA,MAAM,GAAGgB,SAAT;AACH,aAFD,MAGK;AACDnB,cAAAA,UAAU;AACV2B,cAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB,CAAzB,CAA1D,CAAjB;;AACA,kBAAI2B,cAAJ,EAAoB;AAChBxB,gBAAAA,MAAM,GAAGwB,cAAc,CAACjC,KAAf,GAAuB,CAAhC;AACH,eAFD,MAGK;AACDS,gBAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;AACJ;AACJ,SAnBD,MAoBK;AACD,YAAI2B,cAAc,IAAIxB,MAAM,IAAIwB,cAAc,CAACjC,KAAf,GAAuB,CAAvD,EAA0D;AACtDiC,UAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB2B,cAAc,CAAChC,GAAf,GAAqB,CAA9C,CAA1D,CAAjB;AACH;;AACD,YAAIgC,cAAJ,EAAoB;AAChBxB,UAAAA,MAAM,GAAGwB,cAAc,CAACjC,KAAf,GAAuB,CAAhC;AACH,SAFD,MAGK;AACD,cAAIS,MAAM,GAAGgB,SAAT,IAAsBnB,UAAU,KAAKwE,SAAzC,EAAoD;AAChDrE,YAAAA,MAAM,GAAGgB,SAAT;AACH,WAFD,MAGK;AACDnB,YAAAA,UAAU;AACV2B,YAAAA,cAAc,GAAGrC,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0D,IAAIT,QAAJ,CAAaY,UAAb,EAAyB,CAAzB,CAA1D,CAAjB;;AACA,gBAAI2B,cAAJ,EAAoB;AAChBxB,cAAAA,MAAM,GAAGwB,cAAc,CAACjC,KAAf,GAAuB,CAAhC;AACH,aAFD,MAGK;AACDS,cAAAA,MAAM,GAAGN,KAAK,CAACmB,gBAAN,CAAuBhB,UAAvB,CAAT;AACH;AACJ;AACJ;AACJ;;AACD,aAAO,IAAIX,KAAJ,CAAUW,UAAV,EAAsBG,MAAtB,EAA8BL,QAAQ,CAACE,UAAvC,EAAmDF,QAAQ,CAACK,MAA5D,CAAP;AACH;AA9gBL;AAAA;AAAA,yCA+gBgCN,KA/gBhC,EA+gBuCmC,SA/gBvC,EA+gBkD;AAC1C,UAAI,CAACA,SAAS,CAACE,OAAV,EAAL,EAA0B;AACtB,eAAOF,SAAP;AACH;;AACD,UAAMiC,GAAG,GAAGjC,SAAS,CAACQ,WAAV,EAAZ;;AACA,UAAM0B,UAAU,GAAG5E,cAAc,CAACoF,kBAAf,CAAkC7E,KAAlC,EAAyCoE,GAAzC,CAAnB;;AACA,aAAO,IAAI5E,KAAJ,CAAU4E,GAAG,CAACjE,UAAd,EAA0BiE,GAAG,CAAC9D,MAA9B,EAAsC+D,UAAU,CAAClE,UAAjD,EAA6DkE,UAAU,CAAC/D,MAAxE,CAAP;AACH;AAthBL;AAAA;AAAA,0CAuhBiCN,KAvhBjC,EAuhBwCG,UAvhBxC,EAuhBoD2D,IAvhBpD,EAuhB0D;AAClD,UAAMgB,KAAK,GAAG,IAAItF,KAAJ,CAAUW,UAAV,EAAsB2D,IAAI,CAACjE,KAAL,GAAa,CAAnC,EAAsCM,UAAtC,EAAkD2D,IAAI,CAAChE,GAAL,GAAW,CAA7D,CAAd;AACA,aAAO;AACHgE,QAAAA,IAAI,EAAE9D,KAAK,CAAC+E,eAAN,CAAsBD,KAAtB,CADH;AAEHd,QAAAA,WAAW,EAAEc,KAAK,CAACd,WAFhB;AAGHC,QAAAA,SAAS,EAAEa,KAAK,CAACb;AAHd,OAAP;AAKH;AA9hBL;AAAA;AAAA,sCA+hB6BjE,KA/hB7B,EA+hBoCgF,eA/hBpC,EA+hBqD/E,QA/hBrD,EA+hB+D;AACvD,UAAMF,cAAc,GAAGT,uBAAuB,CAAC0F,eAAD,CAA9C;;AACA,UAAMC,QAAQ,GAAGxF,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8DC,QAA9D,CAAjB;;AACA,UAAIgF,QAAQ,IAAIA,QAAQ,CAACtF,QAAT,KAAsB;AAAE;AAApC,SAAqDsF,QAAQ,CAACpF,KAAT,IAAkBI,QAAQ,CAACK,MAAT,GAAkB,CAAzF,IAA8FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,IAAuB2E,QAAQ,CAACnF,GAAlI,EAAuI;AACnI,eAAOL,cAAc,CAACyF,qBAAf,CAAqClF,KAArC,EAA4CC,QAAQ,CAACE,UAArD,EAAiE8E,QAAjE,CAAP;AACH;;AACD,UAAME,QAAQ,GAAG1F,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0DC,QAA1D,CAAjB;;AACA,UAAIkF,QAAQ,IAAIA,QAAQ,CAACxF,QAAT,KAAsB;AAAE;AAApC,SAAqDwF,QAAQ,CAACtF,KAAT,IAAkBI,QAAQ,CAACK,MAAT,GAAkB,CAAzF,IAA8FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,IAAuB6E,QAAQ,CAACrF,GAAlI,EAAuI;AACnI,eAAOL,cAAc,CAACyF,qBAAf,CAAqClF,KAArC,EAA4CC,QAAQ,CAACE,UAArD,EAAiEgF,QAAjE,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AA1iBL;AAAA;AAAA,yBA2iBgBC,MA3iBhB,EA2iBwBpF,KA3iBxB,EA2iB+BqF,MA3iB/B,EA2iBuCC,eA3iBvC,EA2iBwDrF,QA3iBxD,EA2iBkE;AAC1D,UAAMF,cAAc,GAAGT,uBAAuB,CAAC8F,MAAM,CAACrF,cAAR,CAA9C;;AACA,UAAIkF,QAAQ,GAAGxF,cAAc,CAAC4B,uBAAf,CAAuCtB,cAAvC,EAAuDC,KAAvD,EAA8DC,QAA9D,CAAf;;AACA,UAAIkF,QAAQ,GAAG1F,cAAc,CAACsC,mBAAf,CAAmChC,cAAnC,EAAmDC,KAAnD,EAA0DC,QAA1D,CAAf;;AACA,UAAI,CAACqF,eAAL,EAAsB;AAClB;AACA,YAAItB,YAAJ;;AACA,YAAIC,UAAJ;;AACA,YAAIgB,QAAQ,IAAIA,QAAQ,CAACtF,QAAT,KAAsB;AAAE;AAApC,WAAqDsF,QAAQ,CAACpF,KAAT,IAAkBI,QAAQ,CAACK,MAAT,GAAkB,CAAzF,IAA8FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,IAAuB2E,QAAQ,CAACnF,GAAlI,EAAuI;AACnI;AACAkE,UAAAA,YAAW,GAAGiB,QAAQ,CAACpF,KAAT,GAAiB,CAA/B;AACAoE,UAAAA,UAAS,GAAGgB,QAAQ,CAACnF,GAAT,GAAe,CAA3B;AACH,SAJD,MAKK,IAAIqF,QAAQ,IAAIA,QAAQ,CAACxF,QAAT,KAAsB;AAAE;AAApC,WAAqDwF,QAAQ,CAACtF,KAAT,IAAkBI,QAAQ,CAACK,MAAT,GAAkB,CAAzF,IAA8FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,IAAuB6E,QAAQ,CAACrF,GAAlI,EAAuI;AACxI;AACAkE,UAAAA,YAAW,GAAGmB,QAAQ,CAACtF,KAAT,GAAiB,CAA/B;AACAoE,UAAAA,UAAS,GAAGkB,QAAQ,CAACrF,GAAT,GAAe,CAA3B;AACH,SAJI,MAKA;AACD,cAAImF,QAAJ,EAAc;AACVjB,YAAAA,YAAW,GAAGiB,QAAQ,CAACnF,GAAT,GAAe,CAA7B;AACH,WAFD,MAGK;AACDkE,YAAAA,YAAW,GAAG,CAAd;AACH;;AACD,cAAImB,QAAJ,EAAc;AACVlB,YAAAA,UAAS,GAAGkB,QAAQ,CAACtF,KAAT,GAAiB,CAA7B;AACH,WAFD,MAGK;AACDoE,YAAAA,UAAS,GAAGjE,KAAK,CAACmB,gBAAN,CAAuBlB,QAAQ,CAACE,UAAhC,CAAZ;AACH;AACJ;;AACD,eAAO,IAAIf,iBAAJ,CAAsB,IAAII,KAAJ,CAAUS,QAAQ,CAACE,UAAnB,EAA+B6D,YAA/B,EAA4C/D,QAAQ,CAACE,UAArD,EAAiE8D,UAAjE,CAAtB,EAAmG,CAAnG,EAAsG,IAAI1E,QAAJ,CAAaU,QAAQ,CAACE,UAAtB,EAAkC8D,UAAlC,CAAtG,EAAoJ,CAApJ,CAAP;AACH;;AACD,UAAID,WAAJ;AACA,UAAIC,SAAJ;;AACA,UAAIgB,QAAQ,IAAIA,QAAQ,CAACtF,QAAT,KAAsB;AAAE;AAApC,SAAqDsF,QAAQ,CAACpF,KAAT,GAAiBI,QAAQ,CAACK,MAAT,GAAkB,CAAxF,IAA6FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,GAAsB2E,QAAQ,CAACnF,GAAhI,EAAqI;AACjI;AACAkE,QAAAA,WAAW,GAAGiB,QAAQ,CAACpF,KAAT,GAAiB,CAA/B;AACAoE,QAAAA,SAAS,GAAGgB,QAAQ,CAACnF,GAAT,GAAe,CAA3B;AACH,OAJD,MAKK,IAAIqF,QAAQ,IAAIA,QAAQ,CAACxF,QAAT,KAAsB;AAAE;AAApC,SAAqDwF,QAAQ,CAACtF,KAAT,GAAiBI,QAAQ,CAACK,MAAT,GAAkB,CAAxF,IAA6FL,QAAQ,CAACK,MAAT,GAAkB,CAAlB,GAAsB6E,QAAQ,CAACrF,GAAhI,EAAqI;AACtI;AACAkE,QAAAA,WAAW,GAAGmB,QAAQ,CAACtF,KAAT,GAAiB,CAA/B;AACAoE,QAAAA,SAAS,GAAGkB,QAAQ,CAACrF,GAAT,GAAe,CAA3B;AACH,OAJI,MAKA;AACDkE,QAAAA,WAAW,GAAG/D,QAAQ,CAACK,MAAvB;AACA2D,QAAAA,SAAS,GAAGhE,QAAQ,CAACK,MAArB;AACH;;AACD,UAAIH,UAAU,GAAGF,QAAQ,CAACE,UAA1B;AACA,UAAIG,MAAJ;;AACA,UAAI+E,MAAM,CAACE,cAAP,CAAsBC,gBAAtB,CAAuCvF,QAAvC,CAAJ,EAAsD;AAClDK,QAAAA,MAAM,GAAG+E,MAAM,CAACE,cAAP,CAAsBtB,SAA/B;AACH,OAFD,MAGK,IAAIhE,QAAQ,CAACwF,eAAT,CAAyBJ,MAAM,CAACE,cAAP,CAAsBG,gBAAtB,EAAzB,CAAJ,EAAwE;AACzEpF,QAAAA,MAAM,GAAG0D,WAAT;AACA,YAAI2B,gBAAgB,GAAG,IAAIpG,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAvB;;AACA,YAAI+E,MAAM,CAACE,cAAP,CAAsBC,gBAAtB,CAAuCG,gBAAvC,CAAJ,EAA8D;AAC1DrF,UAAAA,MAAM,GAAG+E,MAAM,CAACE,cAAP,CAAsBtB,SAA/B;AACH;AACJ,OANI,MAOA;AACD3D,QAAAA,MAAM,GAAG2D,SAAT;;AACA,YAAI0B,iBAAgB,GAAG,IAAIpG,QAAJ,CAAaY,UAAb,EAAyBG,MAAzB,CAAvB;;AACA,YAAI+E,MAAM,CAACE,cAAP,CAAsBC,gBAAtB,CAAuCG,iBAAvC,CAAJ,EAA8D;AAC1DrF,UAAAA,MAAM,GAAG+E,MAAM,CAACE,cAAP,CAAsBvB,WAA/B;AACH;AACJ;;AACD,aAAOqB,MAAM,CAACO,IAAP,CAAY,IAAZ,EAAkBzF,UAAlB,EAA8BG,MAA9B,EAAsC,CAAtC,CAAP;AACH;AAjnBL;;AAAA;AAAA;AAmnBA,WAAauF,kBAAb;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA,uCAC8B3D,GAD9B,EACmC;AAC3B,UAAM4D,UAAU,GAAGC,cAAc,CAAC,CAC9BtG,cAAc,CAACuG,cAAf,CAA8B9D,GAA9B,EAAmC;AAAE;AAArC,OAD8B,EAE9BzC,cAAc,CAACuG,cAAf,CAA8B9D,GAA9B,EAAmC;AAAE;AAArC,OAF8B,EAG9BzC,cAAc,CAACwG,mBAAf,CAAmC/D,GAAG,CAAClC,KAAvC,EAA8CkC,GAAG,CAACC,SAAlD,CAH8B,CAAD,CAAjC;AAKA2D,MAAAA,UAAU,CAACI,IAAX,CAAgB1G,KAAK,CAAC2G,sBAAtB;AACA,aAAOL,UAAU,CAAC,CAAD,CAAjB;AACH;AATL;AAAA;AAAA,wCAU+B5D,GAV/B,EAUoC;AAC5B,UAAM4D,UAAU,GAAGC,cAAc,CAAC,CAC9BtG,cAAc,CAAC2G,eAAf,CAA+BlE,GAA/B,EAAoC;AAAE;AAAtC,OAD8B,EAE9BzC,cAAc,CAAC2G,eAAf,CAA+BlE,GAA/B,EAAoC;AAAE;AAAtC,OAF8B,EAG9BzC,cAAc,CAAC4G,oBAAf,CAAoCnE,GAAG,CAAClC,KAAxC,EAA+CkC,GAAG,CAACC,SAAnD,CAH8B,CAAD,CAAjC;AAKA2D,MAAAA,UAAU,CAACI,IAAX,CAAgB1G,KAAK,CAAC8G,wBAAtB;AACA,aAAOR,UAAU,CAAC,CAAD,CAAjB;AACH;AAlBL;AAAA;AAAA,qCAmB4B/F,cAnB5B,EAmB4CC,KAnB5C,EAmBmDC,QAnBnD,EAmB6D;AACrD,UAAM6F,UAAU,GAAGC,cAAc,CAAC,CAC9BtG,cAAc,CAAC8G,YAAf,CAA4BxG,cAA5B,EAA4CC,KAA5C,EAAmDC,QAAnD,EAA6D;AAAE;AAA/D,OAD8B,EAE9BR,cAAc,CAAC8G,YAAf,CAA4BxG,cAA5B,EAA4CC,KAA5C,EAAmDC,QAAnD,EAA6D;AAAE;AAA/D,OAF8B,EAG9BR,cAAc,CAAC6E,iBAAf,CAAiCtE,KAAjC,EAAwCC,QAAxC,CAH8B,CAAD,CAAjC;AAKA6F,MAAAA,UAAU,CAACI,IAAX,CAAgB3G,QAAQ,CAACiH,OAAzB;AACA,aAAOV,UAAU,CAAC,CAAD,CAAjB;AACH;AA3BL;AAAA;AAAA,sCA4B6B/F,cA5B7B,EA4B6CC,KA5B7C,EA4BoDC,QA5BpD,EA4B8D;AACtD,UAAM6F,UAAU,GAAGC,cAAc,CAAC,CAC9BtG,cAAc,CAACgH,aAAf,CAA6B1G,cAA7B,EAA6CC,KAA7C,EAAoDC,QAApD,EAA8D;AAAE;AAAhE,OAD8B,EAE9BR,cAAc,CAACgH,aAAf,CAA6B1G,cAA7B,EAA6CC,KAA7C,EAAoDC,QAApD,EAA8D;AAAE;AAAhE,OAF8B,EAG9BR,cAAc,CAACoF,kBAAf,CAAkC7E,KAAlC,EAAyCC,QAAzC,CAH8B,CAAD,CAAjC;AAKA6F,MAAAA,UAAU,CAACI,IAAX,CAAgB3G,QAAQ,CAACiH,OAAzB;AACA,aAAOV,UAAU,CAAC,CAAD,CAAjB;AACH;AApCL;;AAAA;AAAA,EAAwCrG,cAAxC;;AAsCA,SAASsG,cAAT,CAAwBW,GAAxB,EAA6B;AACzB,SAAOA,GAAG,CAACC,MAAJ,CAAW,UAAAC,EAAE;AAAA,WAAIC,OAAO,CAACD,EAAD,CAAX;AAAA,GAAb,CAAP;AACH","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { SingleCursorState } from './cursorCommon.js';\r\nimport { DeleteOperations } from './cursorDeleteOperations.js';\r\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nexport class WordOperations {\r\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\r\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\r\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\r\n    }\r\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\r\n        let lineContent = model.getLineContent(position.lineNumber);\r\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\r\n    }\r\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\r\n        let wordType = 0 /* None */;\r\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 0 /* Regular */) {\r\n                if (wordType === 2 /* Separator */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n                wordType = 1 /* Regular */;\r\n            }\r\n            else if (chClass === 2 /* WordSeparator */) {\r\n                if (wordType === 1 /* Regular */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n                wordType = 2 /* Separator */;\r\n            }\r\n            else if (chClass === 1 /* Whitespace */) {\r\n                if (wordType !== 0 /* None */) {\r\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\r\n                }\r\n            }\r\n        }\r\n        if (wordType !== 0 /* None */) {\r\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\r\n        }\r\n        return null;\r\n    }\r\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\r\n        let len = lineContent.length;\r\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 1 /* Whitespace */) {\r\n                return chIndex;\r\n            }\r\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\r\n                return chIndex;\r\n            }\r\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\r\n                return chIndex;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    static _findNextWordOnLine(wordSeparators, model, position) {\r\n        let lineContent = model.getLineContent(position.lineNumber);\r\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\r\n    }\r\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\r\n        let wordType = 0 /* None */;\r\n        let len = lineContent.length;\r\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 0 /* Regular */) {\r\n                if (wordType === 2 /* Separator */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n                wordType = 1 /* Regular */;\r\n            }\r\n            else if (chClass === 2 /* WordSeparator */) {\r\n                if (wordType === 1 /* Regular */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n                wordType = 2 /* Separator */;\r\n            }\r\n            else if (chClass === 1 /* Whitespace */) {\r\n                if (wordType !== 0 /* None */) {\r\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\r\n                }\r\n            }\r\n        }\r\n        if (wordType !== 0 /* None */) {\r\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\r\n        }\r\n        return null;\r\n    }\r\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\r\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\r\n            let chCode = lineContent.charCodeAt(chIndex);\r\n            let chClass = wordSeparators.get(chCode);\r\n            if (chClass === 1 /* Whitespace */) {\r\n                return chIndex + 1;\r\n            }\r\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\r\n                return chIndex + 1;\r\n            }\r\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\r\n                return chIndex + 1;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        if (column === 1) {\r\n            if (lineNumber > 1) {\r\n                lineNumber = lineNumber - 1;\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\r\n        if (wordNavigationType === 0 /* WordStart */) {\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        if (wordNavigationType === 1 /* WordStartFast */) {\r\n            if (prevWordOnLine\r\n                && prevWordOnLine.wordType === 2 /* Separator */\r\n                && prevWordOnLine.end - prevWordOnLine.start === 1\r\n                && prevWordOnLine.nextCharClass === 0 /* Regular */) {\r\n                // Skip over a word made up of one single separator and followed by a regular character\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        if (wordNavigationType === 3 /* WordAccessibility */) {\r\n            while (prevWordOnLine\r\n                && prevWordOnLine.wordType === 2 /* Separator */) {\r\n                // Skip over words made up of only separators\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\r\n        }\r\n        // We are stopping at the ending of words\r\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\r\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n        }\r\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\r\n    }\r\n    static _moveWordPartLeft(model, position) {\r\n        const lineNumber = position.lineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (position.column === 1) {\r\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\r\n        }\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        for (let column = position.column - 1; column > 1; column--) {\r\n            const left = lineContent.charCodeAt(column - 2);\r\n            const right = lineContent.charCodeAt(column - 1);\r\n            if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\r\n                // snake_case_variables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // camelCaseVariables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // thisIsACamelCaseWithOneLetterWords\r\n                if (column + 1 < maxColumn) {\r\n                    const rightRight = lineContent.charCodeAt(column);\r\n                    if (strings.isLowerAsciiLetter(rightRight)) {\r\n                        return new Position(lineNumber, column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Position(lineNumber, 1);\r\n    }\r\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        let movedDown = false;\r\n        if (column === model.getLineMaxColumn(lineNumber)) {\r\n            if (lineNumber < model.getLineCount()) {\r\n                movedDown = true;\r\n                lineNumber = lineNumber + 1;\r\n                column = 1;\r\n            }\r\n        }\r\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\r\n        if (wordNavigationType === 2 /* WordEnd */) {\r\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\r\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\r\n                    // Skip over a word made up of one single separator and followed by a regular character\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n                }\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        else if (wordNavigationType === 3 /* WordAccessibility */) {\r\n            if (movedDown) {\r\n                // If we move to the next line, pretend that the cursor is right before the first character.\r\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\r\n                // we need to start before.\r\n                column = 0;\r\n            }\r\n            while (nextWordOnLine\r\n                && (nextWordOnLine.wordType === 2 /* Separator */\r\n                    || nextWordOnLine.start + 1 <= column)) {\r\n                // Skip over a word made up of one single separator\r\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        else {\r\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                column = model.getLineMaxColumn(lineNumber);\r\n            }\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    static _moveWordPartRight(model, position) {\r\n        const lineNumber = position.lineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (position.column === maxColumn) {\r\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\r\n        }\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        for (let column = position.column + 1; column < maxColumn; column++) {\r\n            const left = lineContent.charCodeAt(column - 2);\r\n            const right = lineContent.charCodeAt(column - 1);\r\n            if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\r\n                // snake_case_variables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // camelCaseVariables\r\n                return new Position(lineNumber, column);\r\n            }\r\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\r\n                // thisIsACamelCaseWithOneLetterWords\r\n                if (column + 1 < maxColumn) {\r\n                    const rightRight = lineContent.charCodeAt(column);\r\n                    if (strings.isLowerAsciiLetter(rightRight)) {\r\n                        return new Position(lineNumber, column);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Position(lineNumber, maxColumn);\r\n    }\r\n    static _deleteWordLeftWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const startIndex = position.column - 2;\r\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\r\n        if (lastNonWhitespace + 1 < startIndex) {\r\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\r\n        }\r\n        return null;\r\n    }\r\n    static deleteWordLeft(ctx, wordNavigationType) {\r\n        const wordSeparators = ctx.wordSeparators;\r\n        const model = ctx.model;\r\n        const selection = ctx.selection;\r\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection])) {\r\n            const position = ctx.selection.getPosition();\r\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        if (lineNumber === 1 && column === 1) {\r\n            // Ignore deleting at beginning of file\r\n            return null;\r\n        }\r\n        if (whitespaceHeuristics) {\r\n            let r = this._deleteWordLeftWhitespace(model, position);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (wordNavigationType === 0 /* WordStart */) {\r\n            if (prevWordOnLine) {\r\n                column = prevWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                if (column > 1) {\r\n                    column = 1;\r\n                }\r\n                else {\r\n                    lineNumber--;\r\n                    column = model.getLineMaxColumn(lineNumber);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\r\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\r\n            }\r\n            if (prevWordOnLine) {\r\n                column = prevWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                if (column > 1) {\r\n                    column = 1;\r\n                }\r\n                else {\r\n                    lineNumber--;\r\n                    column = model.getLineMaxColumn(lineNumber);\r\n                }\r\n            }\r\n        }\r\n        return new Range(lineNumber, column, position.lineNumber, position.column);\r\n    }\r\n    static deleteInsideWord(wordSeparators, model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let r = this._deleteInsideWordWhitespace(model, position);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\r\n    }\r\n    static _charAtIsWhitespace(str, index) {\r\n        const charCode = str.charCodeAt(index);\r\n        return (charCode === 32 /* Space */ || charCode === 9 /* Tab */);\r\n    }\r\n    static _deleteInsideWordWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const lineContentLength = lineContent.length;\r\n        if (lineContentLength === 0) {\r\n            // empty line\r\n            return null;\r\n        }\r\n        let leftIndex = Math.max(position.column - 2, 0);\r\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\r\n            // touches a non-whitespace character to the left\r\n            return null;\r\n        }\r\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\r\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\r\n            // touches a non-whitespace character to the right\r\n            return null;\r\n        }\r\n        // walk over whitespace to the left\r\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\r\n            leftIndex--;\r\n        }\r\n        // walk over whitespace to the right\r\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\r\n            rightIndex++;\r\n        }\r\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\r\n    }\r\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const lineLength = lineContent.length;\r\n        if (lineLength === 0) {\r\n            // empty line\r\n            if (position.lineNumber > 1) {\r\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\r\n            }\r\n            else {\r\n                if (position.lineNumber < model.getLineCount()) {\r\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\r\n                }\r\n                else {\r\n                    // empty model\r\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\r\n                }\r\n            }\r\n        }\r\n        const touchesWord = (word) => {\r\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\r\n        };\r\n        const createRangeWithPosition = (startColumn, endColumn) => {\r\n            startColumn = Math.min(startColumn, position.column);\r\n            endColumn = Math.max(endColumn, position.column);\r\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\r\n        };\r\n        const deleteWordAndAdjacentWhitespace = (word) => {\r\n            let startColumn = word.start + 1;\r\n            let endColumn = word.end + 1;\r\n            let expandedToTheRight = false;\r\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\r\n                expandedToTheRight = true;\r\n                endColumn++;\r\n            }\r\n            if (!expandedToTheRight) {\r\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\r\n                    startColumn--;\r\n                }\r\n            }\r\n            return createRangeWithPosition(startColumn, endColumn);\r\n        };\r\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\r\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\r\n        }\r\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\r\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\r\n        }\r\n        if (prevWordOnLine && nextWordOnLine) {\r\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\r\n        }\r\n        if (prevWordOnLine) {\r\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\r\n        }\r\n        if (nextWordOnLine) {\r\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\r\n        }\r\n        return createRangeWithPosition(1, lineLength + 1);\r\n    }\r\n    static _deleteWordPartLeft(model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const pos = selection.getPosition();\r\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\r\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\r\n    }\r\n    static _findFirstNonWhitespaceChar(str, startIndex) {\r\n        let len = str.length;\r\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\r\n            let ch = str.charAt(chIndex);\r\n            if (ch !== ' ' && ch !== '\\t') {\r\n                return chIndex;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    static _deleteWordRightWhitespace(model, position) {\r\n        const lineContent = model.getLineContent(position.lineNumber);\r\n        const startIndex = position.column - 1;\r\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\r\n        if (startIndex + 1 < firstNonWhitespace) {\r\n            // bingo\r\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\r\n        }\r\n        return null;\r\n    }\r\n    static deleteWordRight(ctx, wordNavigationType) {\r\n        const wordSeparators = ctx.wordSeparators;\r\n        const model = ctx.model;\r\n        const selection = ctx.selection;\r\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\r\n        let lineNumber = position.lineNumber;\r\n        let column = position.column;\r\n        const lineCount = model.getLineCount();\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        if (lineNumber === lineCount && column === maxColumn) {\r\n            // Ignore deleting at end of file\r\n            return null;\r\n        }\r\n        if (whitespaceHeuristics) {\r\n            let r = this._deleteWordRightWhitespace(model, position);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (wordNavigationType === 2 /* WordEnd */) {\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.end + 1;\r\n            }\r\n            else {\r\n                if (column < maxColumn || lineNumber === lineCount) {\r\n                    column = maxColumn;\r\n                }\r\n                else {\r\n                    lineNumber++;\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\r\n                    if (nextWordOnLine) {\r\n                        column = nextWordOnLine.start + 1;\r\n                    }\r\n                    else {\r\n                        column = model.getLineMaxColumn(lineNumber);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\r\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\r\n            }\r\n            if (nextWordOnLine) {\r\n                column = nextWordOnLine.start + 1;\r\n            }\r\n            else {\r\n                if (column < maxColumn || lineNumber === lineCount) {\r\n                    column = maxColumn;\r\n                }\r\n                else {\r\n                    lineNumber++;\r\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\r\n                    if (nextWordOnLine) {\r\n                        column = nextWordOnLine.start + 1;\r\n                    }\r\n                    else {\r\n                        column = model.getLineMaxColumn(lineNumber);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Range(lineNumber, column, position.lineNumber, position.column);\r\n    }\r\n    static _deleteWordPartRight(model, selection) {\r\n        if (!selection.isEmpty()) {\r\n            return selection;\r\n        }\r\n        const pos = selection.getPosition();\r\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\r\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\r\n    }\r\n    static _createWordAtPosition(model, lineNumber, word) {\r\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\r\n        return {\r\n            word: model.getValueInRange(range),\r\n            startColumn: range.startColumn,\r\n            endColumn: range.endColumn\r\n        };\r\n    }\r\n    static getWordAtPosition(model, _wordSeparators, position) {\r\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\r\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\r\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\r\n        }\r\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\r\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\r\n        }\r\n        return null;\r\n    }\r\n    static word(config, model, cursor, inSelectionMode, position) {\r\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\r\n        let prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\r\n        let nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\r\n        if (!inSelectionMode) {\r\n            // Entering word selection for the first time\r\n            let startColumn;\r\n            let endColumn;\r\n            if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\r\n                // isTouchingPrevWord\r\n                startColumn = prevWord.start + 1;\r\n                endColumn = prevWord.end + 1;\r\n            }\r\n            else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\r\n                // isTouchingNextWord\r\n                startColumn = nextWord.start + 1;\r\n                endColumn = nextWord.end + 1;\r\n            }\r\n            else {\r\n                if (prevWord) {\r\n                    startColumn = prevWord.end + 1;\r\n                }\r\n                else {\r\n                    startColumn = 1;\r\n                }\r\n                if (nextWord) {\r\n                    endColumn = nextWord.start + 1;\r\n                }\r\n                else {\r\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\r\n                }\r\n            }\r\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\r\n        }\r\n        let startColumn;\r\n        let endColumn;\r\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\r\n            // isInsidePrevWord\r\n            startColumn = prevWord.start + 1;\r\n            endColumn = prevWord.end + 1;\r\n        }\r\n        else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\r\n            // isInsideNextWord\r\n            startColumn = nextWord.start + 1;\r\n            endColumn = nextWord.end + 1;\r\n        }\r\n        else {\r\n            startColumn = position.column;\r\n            endColumn = position.column;\r\n        }\r\n        let lineNumber = position.lineNumber;\r\n        let column;\r\n        if (cursor.selectionStart.containsPosition(position)) {\r\n            column = cursor.selectionStart.endColumn;\r\n        }\r\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\r\n            column = startColumn;\r\n            let possiblePosition = new Position(lineNumber, column);\r\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\r\n                column = cursor.selectionStart.endColumn;\r\n            }\r\n        }\r\n        else {\r\n            column = endColumn;\r\n            let possiblePosition = new Position(lineNumber, column);\r\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\r\n                column = cursor.selectionStart.startColumn;\r\n            }\r\n        }\r\n        return cursor.move(true, lineNumber, column, 0);\r\n    }\r\n}\r\nexport class WordPartOperations extends WordOperations {\r\n    static deleteWordPartLeft(ctx) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.deleteWordLeft(ctx, 0 /* WordStart */),\r\n            WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */),\r\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\r\n        ]);\r\n        candidates.sort(Range.compareRangesUsingEnds);\r\n        return candidates[2];\r\n    }\r\n    static deleteWordPartRight(ctx) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.deleteWordRight(ctx, 0 /* WordStart */),\r\n            WordOperations.deleteWordRight(ctx, 2 /* WordEnd */),\r\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\r\n        ]);\r\n        candidates.sort(Range.compareRangesUsingStarts);\r\n        return candidates[0];\r\n    }\r\n    static moveWordPartLeft(wordSeparators, model, position) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */),\r\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */),\r\n            WordOperations._moveWordPartLeft(model, position)\r\n        ]);\r\n        candidates.sort(Position.compare);\r\n        return candidates[2];\r\n    }\r\n    static moveWordPartRight(wordSeparators, model, position) {\r\n        const candidates = enforceDefined([\r\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */),\r\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */),\r\n            WordOperations._moveWordPartRight(model, position)\r\n        ]);\r\n        candidates.sort(Position.compare);\r\n        return candidates[0];\r\n    }\r\n}\r\nfunction enforceDefined(arr) {\r\n    return arr.filter(el => Boolean(el));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}