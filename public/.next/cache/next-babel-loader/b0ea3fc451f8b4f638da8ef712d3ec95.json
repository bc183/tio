{"ast":null,"code":"import _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { IndentAction } from '../modes/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nexport var TypeOperations = /*#__PURE__*/function () {\n  function TypeOperations() {\n    _classCallCheck(this, TypeOperations);\n  }\n\n  _createClass(TypeOperations, null, [{\n    key: \"indent\",\n    value: function indent(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ShiftCommand(selections[i], {\n          isUnshift: false,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        });\n      }\n\n      return commands;\n    }\n  }, {\n    key: \"outdent\",\n    value: function outdent(config, model, selections) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ShiftCommand(selections[i], {\n          isUnshift: true,\n          tabSize: config.tabSize,\n          indentSize: config.indentSize,\n          insertSpaces: config.insertSpaces,\n          useTabStops: config.useTabStops,\n          autoIndent: config.autoIndent\n        });\n      }\n\n      return commands;\n    }\n  }, {\n    key: \"shiftIndent\",\n    value: function shiftIndent(config, indentation, count) {\n      count = count || 1;\n      return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n  }, {\n    key: \"unshiftIndent\",\n    value: function unshiftIndent(config, indentation, count) {\n      count = count || 1;\n      return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n  }, {\n    key: \"_distributedPaste\",\n    value: function _distributedPaste(config, model, selections, text) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ReplaceCommand(selections[i], text[i]);\n      }\n\n      return new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_simplePaste\",\n    value: function _simplePaste(config, model, selections, text, pasteOnNewLine) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n\n        if (pasteOnNewLine && !selection.isEmpty()) {\n          pasteOnNewLine = false;\n        }\n\n        if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n          pasteOnNewLine = false;\n        }\n\n        if (pasteOnNewLine) {\n          // Paste entire line at the beginning of line\n          var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n          commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n        } else {\n          commands[i] = new ReplaceCommand(selection, text);\n        }\n      }\n\n      return new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_distributePasteToCursors\",\n    value: function _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n      if (pasteOnNewLine) {\n        return null;\n      }\n\n      if (selections.length === 1) {\n        return null;\n      }\n\n      if (multicursorText && multicursorText.length === selections.length) {\n        return multicursorText;\n      }\n\n      if (config.multiCursorPaste === 'spread') {\n        // Try to spread the pasted text in case the line count matches the cursor count\n        // Remove trailing \\n if present\n        if (text.charCodeAt(text.length - 1) === 10\n        /* LineFeed */\n        ) {\n            text = text.substr(0, text.length - 1);\n          } // Remove trailing \\r if present\n\n\n        if (text.charCodeAt(text.length - 1) === 13\n        /* CarriageReturn */\n        ) {\n            text = text.substr(0, text.length - 1);\n          }\n\n        var lines = strings.splitLines(text);\n\n        if (lines.length === selections.length) {\n          return lines;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n      var distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n\n      if (distributedPaste) {\n        selections = selections.sort(Range.compareRangesUsingStarts);\n        return this._distributedPaste(config, model, selections, distributedPaste);\n      } else {\n        return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n      }\n    }\n  }, {\n    key: \"_goodIndentForLine\",\n    value: function _goodIndentForLine(config, model, lineNumber) {\n      var action = null;\n      var indentation = '';\n      var expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n\n      if (expectedIndentAction) {\n        action = expectedIndentAction.action;\n        indentation = expectedIndentAction.indentation;\n      } else if (lineNumber > 1) {\n        var lastLineNumber;\n\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n          var lineText = model.getLineContent(lastLineNumber);\n          var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n\n          if (nonWhitespaceIdx >= 0) {\n            break;\n          }\n        }\n\n        if (lastLineNumber < 1) {\n          // No previous line with content found\n          return null;\n        }\n\n        var maxColumn = model.getLineMaxColumn(lastLineNumber);\n        var expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n\n        if (expectedEnterAction) {\n          indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n        }\n      }\n\n      if (action) {\n        if (action === IndentAction.Indent) {\n          indentation = TypeOperations.shiftIndent(config, indentation);\n        }\n\n        if (action === IndentAction.Outdent) {\n          indentation = TypeOperations.unshiftIndent(config, indentation);\n        }\n\n        indentation = config.normalizeIndentation(indentation);\n      }\n\n      if (!indentation) {\n        return null;\n      }\n\n      return indentation;\n    }\n  }, {\n    key: \"_replaceJumpToNextIndent\",\n    value: function _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n      var typeText = '';\n      var position = selection.getStartPosition();\n\n      if (config.insertSpaces) {\n        var visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n        var indentSize = config.indentSize;\n        var spacesCnt = indentSize - visibleColumnFromColumn % indentSize;\n\n        for (var i = 0; i < spacesCnt; i++) {\n          typeText += ' ';\n        }\n      } else {\n        typeText = '\\t';\n      }\n\n      return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n  }, {\n    key: \"tab\",\n    value: function tab(config, model, selections) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (selection.isEmpty()) {\n          var lineText = model.getLineContent(selection.startLineNumber);\n\n          if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n            var goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n\n            goodIndent = goodIndent || '\\t';\n            var possibleTypeText = config.normalizeIndentation(goodIndent);\n\n            if (!lineText.startsWith(possibleTypeText)) {\n              commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n              continue;\n            }\n          }\n\n          commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n        } else {\n          if (selection.startLineNumber === selection.endLineNumber) {\n            var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n\n            if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n              // This is a single line selection that is not the entire line\n              commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n              continue;\n            }\n          }\n\n          commands[i] = new ShiftCommand(selection, {\n            isUnshift: false,\n            tabSize: config.tabSize,\n            indentSize: config.indentSize,\n            insertSpaces: config.insertSpaces,\n            useTabStops: config.useTabStops,\n            autoIndent: config.autoIndent\n          });\n        }\n      }\n\n      return commands;\n    }\n  }, {\n    key: \"replacePreviousChar\",\n    value: function replacePreviousChar(prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (!selection.isEmpty()) {\n          // looks like https://github.com/microsoft/vscode/issues/2773\n          // where a cursor operation occurred before a canceled composition\n          // => ignore composition\n          commands[i] = null;\n          continue;\n        }\n\n        var pos = selection.getPosition();\n        var startColumn = Math.max(1, pos.column - replaceCharCnt);\n        var range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\n        var oldText = model.getValueInRange(range);\n\n        if (oldText === txt) {\n          // => ignore composition that doesn't do anything\n          commands[i] = null;\n          continue;\n        }\n\n        commands[i] = new ReplaceCommand(range, txt);\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: prevEditOperationType !== 1\n        /* Typing */\n        ,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_typeCommand\",\n    value: function _typeCommand(range, text, keepPosition) {\n      if (keepPosition) {\n        return new ReplaceCommandWithoutChangingPosition(range, text, true);\n      } else {\n        return new ReplaceCommand(range, text, true);\n      }\n    }\n  }, {\n    key: \"_enter\",\n    value: function _enter(config, model, keepPosition, range) {\n      if (config.autoIndent === 0\n      /* None */\n      ) {\n          return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n\n      if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1\n      /* Keep */\n      ) {\n          var _lineText = model.getLineContent(range.startLineNumber);\n\n          var _indentation = strings.getLeadingWhitespace(_lineText).substring(0, range.startColumn - 1);\n\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(_indentation), keepPosition);\n        }\n\n      var r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n\n      if (r) {\n        if (r.indentAction === IndentAction.None) {\n          // Nothing special\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n        } else if (r.indentAction === IndentAction.Indent) {\n          // Indent once\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n        } else if (r.indentAction === IndentAction.IndentOutdent) {\n          // Ultra special\n          var normalIndent = config.normalizeIndentation(r.indentation);\n          var increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n          var typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n\n          if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n          } else {\n            return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n          }\n        } else if (r.indentAction === IndentAction.Outdent) {\n          var actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n          return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n        }\n      }\n\n      var lineText = model.getLineContent(range.startLineNumber);\n      var indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n\n      if (config.autoIndent >= 4\n      /* Full */\n      ) {\n          var ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n            unshiftIndent: function unshiftIndent(indent) {\n              return TypeOperations.unshiftIndent(config, indent);\n            },\n            shiftIndent: function shiftIndent(indent) {\n              return TypeOperations.shiftIndent(config, indent);\n            },\n            normalizeIndentation: function normalizeIndentation(indent) {\n              return config.normalizeIndentation(indent);\n            }\n          });\n\n          if (ir) {\n            var oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\n            var oldEndColumn = range.endColumn;\n            var newLineContent = model.getLineContent(range.endLineNumber);\n            var firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n\n            if (firstNonWhitespace >= 0) {\n              range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n            } else {\n              range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n            }\n\n            if (keepPosition) {\n              return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n            } else {\n              var offset = 0;\n\n              if (oldEndColumn <= firstNonWhitespace + 1) {\n                if (!config.insertSpaces) {\n                  oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                }\n\n                offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n              }\n\n              return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n            }\n          }\n        }\n\n      return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n  }, {\n    key: \"_isAutoIndentType\",\n    value: function _isAutoIndentType(config, model, selections) {\n      if (config.autoIndent < 4\n      /* Full */\n      ) {\n          return false;\n        }\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_runAutoIndentType\",\n    value: function _runAutoIndentType(config, model, range, ch) {\n      var currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n      var actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n        shiftIndent: function shiftIndent(indentation) {\n          return TypeOperations.shiftIndent(config, indentation);\n        },\n        unshiftIndent: function unshiftIndent(indentation) {\n          return TypeOperations.unshiftIndent(config, indentation);\n        }\n      });\n\n      if (actualIndentation === null) {\n        return null;\n      }\n\n      if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n        var firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n\n        if (firstNonWhitespace === 0) {\n          return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n        } else {\n          return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_isAutoClosingOvertype\",\n    value: function _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n      if (config.autoClosingOvertype === 'never') {\n        return false;\n      }\n\n      if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n        return false;\n      }\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (!selection.isEmpty()) {\n          return false;\n        }\n\n        var position = selection.getPosition();\n        var lineText = model.getLineContent(position.lineNumber);\n        var afterCharacter = lineText.charAt(position.column - 1);\n\n        if (afterCharacter !== ch) {\n          return false;\n        } // Do not over-type quotes after a backslash\n\n\n        var chIsQuote = isQuote(ch);\n        var beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0\n        /* Null */\n        ;\n\n        if (beforeCharacter === 92\n        /* Backslash */\n        && chIsQuote) {\n          return false;\n        } // Must over-type a closing character typed by the editor\n\n\n        if (config.autoClosingOvertype === 'auto') {\n          var found = false;\n\n          for (var j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n            var autoClosedCharacter = autoClosedCharacters[j];\n\n            if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_runAutoClosingOvertype\",\n    value: function _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n        var typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n        commands[i] = new ReplaceCommand(typeSelection, ch);\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: prevEditOperationType !== 1\n        /* Typing */\n        ,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_isBeforeClosingBrace\",\n    value: function _isBeforeClosingBrace(config, lineAfter) {\n      // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n      var nextChar = lineAfter.charAt(0);\n      var potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n      var potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n      var isBeforeStartingBrace = potentialStartingBraces.some(function (x) {\n        return lineAfter.startsWith(x.open);\n      });\n      var isBeforeClosingBrace = potentialClosingBraces.some(function (x) {\n        return lineAfter.startsWith(x.close);\n      });\n      return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n  }, {\n    key: \"_findAutoClosingPairOpen\",\n    value: function _findAutoClosingPairOpen(config, model, positions, ch) {\n      var autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n\n      if (!autoClosingPairCandidates) {\n        return null;\n      } // Determine which auto-closing pair it is\n\n\n      var autoClosingPair = null;\n\n      var _iterator = _createForOfIteratorHelper(autoClosingPairCandidates),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var autoClosingPairCandidate = _step.value;\n\n          if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\n            var candidateIsMatch = true;\n\n            var _iterator2 = _createForOfIteratorHelper(positions),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var position = _step2.value;\n                var relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\n\n                if (relevantText + ch !== autoClosingPairCandidate.open) {\n                  candidateIsMatch = false;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            if (candidateIsMatch) {\n              autoClosingPair = autoClosingPairCandidate;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return autoClosingPair;\n    }\n  }, {\n    key: \"_findSubAutoClosingPairClose\",\n    value: function _findSubAutoClosingPairClose(config, autoClosingPair) {\n      if (autoClosingPair.open.length <= 1) {\n        return '';\n      }\n\n      var lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1); // get candidates with the same last character as close\n\n      var subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n      var subPairMatch = null;\n\n      var _iterator3 = _createForOfIteratorHelper(subPairCandidates),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var x = _step3.value;\n\n          if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\n            if (!subPairMatch || x.open.length > subPairMatch.open.length) {\n              subPairMatch = x;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (subPairMatch) {\n        return subPairMatch.close;\n      } else {\n        return '';\n      }\n    }\n  }, {\n    key: \"_getAutoClosingPairClose\",\n    value: function _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\n      var chIsQuote = isQuote(ch);\n      var autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\n\n      if (autoCloseConfig === 'never') {\n        return null;\n      }\n\n      var autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(function (s) {\n        return s.getPosition();\n      }), ch);\n\n      if (!autoClosingPair) {\n        return null;\n      }\n\n      var subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\n\n      var isSubAutoClosingPairPresent = true;\n      var shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (!selection.isEmpty()) {\n          return null;\n        }\n\n        var position = selection.getPosition();\n        var lineText = model.getLineContent(position.lineNumber);\n        var lineAfter = lineText.substring(position.column - 1);\n\n        if (!lineAfter.startsWith(subAutoClosingPairClose)) {\n          isSubAutoClosingPairPresent = false;\n        } // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n\n\n        if (lineText.length > position.column - 1) {\n          var characterAfter = lineText.charAt(position.column - 1);\n\n          var isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n\n          if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n            return null;\n          }\n        }\n\n        if (!model.isCheapToTokenize(position.lineNumber)) {\n          // Do not force tokenization\n          return null;\n        } // Do not auto-close ' or \" after a word character\n\n\n        if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\n          var wordSeparators = getMapForWordSeparators(config.wordSeparators);\n\n          if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0\n          /* Regular */\n          ) {\n              return null;\n            }\n\n          if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0\n          /* Regular */\n          ) {\n              return null;\n            }\n        }\n\n        model.forceTokenization(position.lineNumber);\n        var lineTokens = model.getLineTokens(position.lineNumber);\n        var shouldAutoClosePair = false;\n\n        try {\n          shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\n        } catch (e) {\n          onUnexpectedError(e);\n        }\n\n        if (!shouldAutoClosePair) {\n          return null;\n        }\n      }\n\n      if (isSubAutoClosingPairPresent) {\n        return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\n      } else {\n        return autoClosingPair.close;\n      }\n    }\n  }, {\n    key: \"_runAutoClosingOpenCharType\",\n    value: function _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"_shouldSurroundChar\",\n    value: function _shouldSurroundChar(config, ch) {\n      if (isQuote(ch)) {\n        return config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined';\n      } else {\n        // Character is a bracket\n        return config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined';\n      }\n    }\n  }, {\n    key: \"_isSurroundSelectionType\",\n    value: function _isSurroundSelectionType(config, model, selections, ch) {\n      if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n        return false;\n      }\n\n      var isTypingAQuoteCharacter = isQuote(ch);\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (selection.isEmpty()) {\n          return false;\n        }\n\n        var selectionContainsOnlyWhitespace = true;\n\n        for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n          var lineText = model.getLineContent(lineNumber);\n          var startIndex = lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0;\n          var endIndex = lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length;\n          var selectedText = lineText.substring(startIndex, endIndex);\n\n          if (/[^ \\t]/.test(selectedText)) {\n            // this selected text contains something other than whitespace\n            selectionContainsOnlyWhitespace = false;\n            break;\n          }\n        }\n\n        if (selectionContainsOnlyWhitespace) {\n          return false;\n        }\n\n        if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n          var selectionText = model.getValueInRange(selection);\n\n          if (isQuote(selectionText)) {\n            // Typing a quote character on top of another quote character\n            // => disable surround selection type\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_runSurroundSelectionType\",\n    value: function _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var closeCharacter = config.surroundingPairs[ch];\n        commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n      }\n\n      return new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }, {\n    key: \"_isTypeInterceptorElectricChar\",\n    value: function _isTypeInterceptorElectricChar(config, model, selections) {\n      if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_typeInterceptorElectricChar\",\n    value: function _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n      if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n        return null;\n      }\n\n      var position = selection.getPosition();\n      model.forceTokenization(position.lineNumber);\n      var lineTokens = model.getLineTokens(position.lineNumber);\n      var electricAction;\n\n      try {\n        electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\n      } catch (e) {\n        onUnexpectedError(e);\n        return null;\n      }\n\n      if (!electricAction) {\n        return null;\n      }\n\n      if (electricAction.matchOpenBracket) {\n        var endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n        var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\n          lineNumber: position.lineNumber,\n          column: endColumn\n        });\n\n        if (match) {\n          if (match.startLineNumber === position.lineNumber) {\n            // matched something on the same line => no change in indentation\n            return null;\n          }\n\n          var matchLine = model.getLineContent(match.startLineNumber);\n          var matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n          var newIndentation = config.normalizeIndentation(matchLineIndentation);\n          var lineText = model.getLineContent(position.lineNumber);\n          var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n          var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n          var typeText = newIndentation + prefix + ch;\n          var typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n          var command = new ReplaceCommand(typeSelection, typeText);\n          return new EditOperationResult(1\n          /* Typing */\n          , [command], {\n            shouldPushStackElementBefore: false,\n            shouldPushStackElementAfter: true\n          });\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * This is very similar with typing, but the character is already in the text buffer!\r\n     */\n\n  }, {\n    key: \"compositionEndWithInterceptors\",\n    value: function compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n      if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n        // no content was typed\n        return null;\n      }\n\n      var ch = null; // extract last typed character\n\n      var _iterator4 = _createForOfIteratorHelper(selections),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var selection = _step4.value;\n\n          if (!selection.isEmpty()) {\n            return null;\n          }\n\n          var position = selection.getPosition();\n          var currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n\n          if (ch === null) {\n            ch = currentChar;\n          } else if (ch !== currentChar) {\n            return null;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (!ch) {\n        return null;\n      }\n\n      if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n        // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n        var commands = selections.map(function (s) {\n          return new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false);\n        });\n        return new EditOperationResult(1\n        /* Typing */\n        , commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n\n      var autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n\n      if (autoClosingPairClose !== null) {\n        return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"typeWithInterceptors\",\n    value: function typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n      if (!isDoingComposition && ch === '\\n') {\n        var _commands = [];\n\n        for (var i = 0, len = selections.length; i < len; i++) {\n          _commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n        }\n\n        return new EditOperationResult(1\n        /* Typing */\n        , _commands, {\n          shouldPushStackElementBefore: true,\n          shouldPushStackElementAfter: false\n        });\n      }\n\n      if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n        var _commands2 = [];\n        var autoIndentFails = false;\n\n        for (var _i = 0, _len = selections.length; _i < _len; _i++) {\n          _commands2[_i] = this._runAutoIndentType(config, model, selections[_i], ch);\n\n          if (!_commands2[_i]) {\n            autoIndentFails = true;\n            break;\n          }\n        }\n\n        if (!autoIndentFails) {\n          return new EditOperationResult(1\n          /* Typing */\n          , _commands2, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n          });\n        }\n      }\n\n      if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n        return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n      }\n\n      if (!isDoingComposition) {\n        var autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n\n        if (autoClosingPairClose) {\n          return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n      }\n\n      if (this._isSurroundSelectionType(config, model, selections, ch)) {\n        return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n      } // Electric characters make sense only when dealing with a single cursor,\n      // as multiple cursors typing brackets for example would interfer with bracket matching\n\n\n      if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n        var r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n\n        if (r) {\n          return r;\n        }\n      } // A simple character type\n\n\n      var commands = [];\n\n      for (var _i2 = 0, _len2 = selections.length; _i2 < _len2; _i2++) {\n        commands[_i2] = new ReplaceCommand(selections[_i2], ch);\n      }\n\n      var shouldPushStackElementBefore = prevEditOperationType !== 1\n      /* Typing */\n      ;\n\n      if (ch === ' ') {\n        shouldPushStackElementBefore = true;\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: shouldPushStackElementBefore,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"typeWithoutInterceptors\",\n    value: function typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = new ReplaceCommand(selections[i], str);\n      }\n\n      return new EditOperationResult(1\n      /* Typing */\n      , commands, {\n        shouldPushStackElementBefore: prevEditOperationType !== 1\n        /* Typing */\n        ,\n        shouldPushStackElementAfter: false\n      });\n    }\n  }, {\n    key: \"lineInsertBefore\",\n    value: function lineInsertBefore(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var lineNumber = selections[i].positionLineNumber;\n\n        if (lineNumber === 1) {\n          commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n        } else {\n          lineNumber--;\n          var column = model.getLineMaxColumn(lineNumber);\n          commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n      }\n\n      return commands;\n    }\n  }, {\n    key: \"lineInsertAfter\",\n    value: function lineInsertAfter(config, model, selections) {\n      if (model === null || selections === null) {\n        return [];\n      }\n\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var lineNumber = selections[i].positionLineNumber;\n        var column = model.getLineMaxColumn(lineNumber);\n        commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n      }\n\n      return commands;\n    }\n  }, {\n    key: \"lineBreakInsert\",\n    value: function lineBreakInsert(config, model, selections) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        commands[i] = this._enter(config, model, true, selections[i]);\n      }\n\n      return commands;\n    }\n  }]);\n\n  return TypeOperations;\n}();\nexport var TypeWithAutoClosingCommand = /*#__PURE__*/function (_ReplaceCommandWithOf) {\n  _inherits(TypeWithAutoClosingCommand, _ReplaceCommandWithOf);\n\n  var _super = _createSuper(TypeWithAutoClosingCommand);\n\n  function TypeWithAutoClosingCommand(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n    var _this;\n\n    _classCallCheck(this, TypeWithAutoClosingCommand);\n\n    _this = _super.call(this, selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n    _this._openCharacter = openCharacter;\n    _this._closeCharacter = closeCharacter;\n    _this.closeCharacterRange = null;\n    _this.enclosingRange = null;\n    return _this;\n  }\n\n  _createClass(TypeWithAutoClosingCommand, [{\n    key: \"computeCursorState\",\n    value: function computeCursorState(model, helper) {\n      var inverseEditOperations = helper.getInverseEditOperations();\n      var range = inverseEditOperations[0].range;\n      this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n      this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n      return _get(_getPrototypeOf(TypeWithAutoClosingCommand.prototype), \"computeCursorState\", this).call(this, model, helper);\n    }\n  }]);\n\n  return TypeWithAutoClosingCommand;\n}(ReplaceCommandWithOffsetCursorState);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorTypeOperations.js"],"names":["onUnexpectedError","strings","ReplaceCommand","ReplaceCommandWithOffsetCursorState","ReplaceCommandWithoutChangingPosition","ReplaceCommandThatPreservesSelection","ShiftCommand","SurroundSelectionCommand","CursorColumns","EditOperationResult","isQuote","getMapForWordSeparators","Range","Selection","IndentAction","LanguageConfigurationRegistry","TypeOperations","config","model","selections","commands","i","len","length","isUnshift","tabSize","indentSize","insertSpaces","useTabStops","autoIndent","indentation","count","shiftIndent","unshiftIndent","text","shouldPushStackElementBefore","shouldPushStackElementAfter","pasteOnNewLine","selection","position","getPosition","isEmpty","indexOf","typeSelection","lineNumber","multicursorText","multiCursorPaste","charCodeAt","substr","lines","splitLines","distributedPaste","_distributePasteToCursors","sort","compareRangesUsingStarts","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","lastLineNumber","lineText","getLineContent","nonWhitespaceIdx","lastNonWhitespaceIndex","maxColumn","getLineMaxColumn","expectedEnterAction","getEnterAction","appendText","Indent","Outdent","normalizeIndentation","insertsAutoWhitespace","typeText","getStartPosition","visibleColumnFromColumn","visibleColumnFromColumn2","spacesCnt","startLineNumber","test","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","endLineNumber","lineMaxColumn","startColumn","endColumn","prevEditOperationType","txt","replaceCharCnt","pos","Math","max","column","range","oldText","getValueInRange","keepPosition","_typeCommand","getLeadingWhitespace","substring","r","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","getEndPosition","oldEndColumn","newLineContent","firstNonWhitespace","firstNonWhitespaceIndex","setEndPosition","afterEnter","offset","ceil","min","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","getLineFirstNonWhitespaceColumn","autoClosedCharacters","autoClosingOvertype","autoClosingPairs","autoClosingPairsCloseSingleChar","has","afterCharacter","charAt","chIsQuote","beforeCharacter","found","j","lenJ","autoClosedCharacter","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","get","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","some","x","open","isBeforeClosingBrace","close","positions","autoClosingPairCandidates","autoClosingPairsOpenByEnd","autoClosingPair","autoClosingPairCandidate","candidateIsMatch","relevantText","lastChar","subPairCandidates","autoClosingPairsCloseByEnd","subPairMatch","includes","endsWith","insertOpenCharacter","autoCloseConfig","autoClosingQuotes","autoClosingBrackets","_findAutoClosingPairOpen","map","s","subAutoClosingPairClose","_findSubAutoClosingPairClose","isSubAutoClosingPairPresent","shouldAutoCloseBefore","quote","bracket","characterAfter","isBeforeCloseBrace","_isBeforeClosingBrace","wordSeparators","forceTokenization","lineTokens","getLineTokens","shouldAutoClosePair","e","autoClosingPairClose","TypeWithAutoClosingCommand","autoSurround","_shouldSurroundChar","surroundingPairs","hasOwnProperty","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","electricChars","electricAction","onElectricCharacter","matchOpenBracket","lastIndexOf","match","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","prefix","command","selectionsWhenCompositionStarted","selectionsArrEqual","currentChar","_isAutoClosingOvertype","positionLineNumber","positionColumn","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","str","openCharacter","_openCharacter","_closeCharacter","closeCharacterRange","enclosingRange","helper","inverseEditOperations","getInverseEditOperations"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\r\nimport { ShiftCommand } from '../commands/shiftCommand.js';\r\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\r\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\r\nimport { getMapForWordSeparators } from './wordCharacterClassifier.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { IndentAction } from '../modes/languageConfiguration.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nexport class TypeOperations {\r\n    static indent(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ShiftCommand(selections[i], {\r\n                isUnshift: false,\r\n                tabSize: config.tabSize,\r\n                indentSize: config.indentSize,\r\n                insertSpaces: config.insertSpaces,\r\n                useTabStops: config.useTabStops,\r\n                autoIndent: config.autoIndent\r\n            });\r\n        }\r\n        return commands;\r\n    }\r\n    static outdent(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ShiftCommand(selections[i], {\r\n                isUnshift: true,\r\n                tabSize: config.tabSize,\r\n                indentSize: config.indentSize,\r\n                insertSpaces: config.insertSpaces,\r\n                useTabStops: config.useTabStops,\r\n                autoIndent: config.autoIndent\r\n            });\r\n        }\r\n        return commands;\r\n    }\r\n    static shiftIndent(config, indentation, count) {\r\n        count = count || 1;\r\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\r\n    }\r\n    static unshiftIndent(config, indentation, count) {\r\n        count = count || 1;\r\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\r\n    }\r\n    static _distributedPaste(config, model, selections, text) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            let position = selection.getPosition();\r\n            if (pasteOnNewLine && !selection.isEmpty()) {\r\n                pasteOnNewLine = false;\r\n            }\r\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\r\n                pasteOnNewLine = false;\r\n            }\r\n            if (pasteOnNewLine) {\r\n                // Paste entire line at the beginning of line\r\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\r\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\r\n            }\r\n            else {\r\n                commands[i] = new ReplaceCommand(selection, text);\r\n            }\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\r\n        if (pasteOnNewLine) {\r\n            return null;\r\n        }\r\n        if (selections.length === 1) {\r\n            return null;\r\n        }\r\n        if (multicursorText && multicursorText.length === selections.length) {\r\n            return multicursorText;\r\n        }\r\n        if (config.multiCursorPaste === 'spread') {\r\n            // Try to spread the pasted text in case the line count matches the cursor count\r\n            // Remove trailing \\n if present\r\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\r\n                text = text.substr(0, text.length - 1);\r\n            }\r\n            // Remove trailing \\r if present\r\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\r\n                text = text.substr(0, text.length - 1);\r\n            }\r\n            let lines = strings.splitLines(text);\r\n            if (lines.length === selections.length) {\r\n                return lines;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\r\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\r\n        if (distributedPaste) {\r\n            selections = selections.sort(Range.compareRangesUsingStarts);\r\n            return this._distributedPaste(config, model, selections, distributedPaste);\r\n        }\r\n        else {\r\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\r\n        }\r\n    }\r\n    static _goodIndentForLine(config, model, lineNumber) {\r\n        let action = null;\r\n        let indentation = '';\r\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\r\n        if (expectedIndentAction) {\r\n            action = expectedIndentAction.action;\r\n            indentation = expectedIndentAction.indentation;\r\n        }\r\n        else if (lineNumber > 1) {\r\n            let lastLineNumber;\r\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\r\n                const lineText = model.getLineContent(lastLineNumber);\r\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\r\n                if (nonWhitespaceIdx >= 0) {\r\n                    break;\r\n                }\r\n            }\r\n            if (lastLineNumber < 1) {\r\n                // No previous line with content found\r\n                return null;\r\n            }\r\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\r\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\r\n            if (expectedEnterAction) {\r\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\r\n            }\r\n        }\r\n        if (action) {\r\n            if (action === IndentAction.Indent) {\r\n                indentation = TypeOperations.shiftIndent(config, indentation);\r\n            }\r\n            if (action === IndentAction.Outdent) {\r\n                indentation = TypeOperations.unshiftIndent(config, indentation);\r\n            }\r\n            indentation = config.normalizeIndentation(indentation);\r\n        }\r\n        if (!indentation) {\r\n            return null;\r\n        }\r\n        return indentation;\r\n    }\r\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\r\n        let typeText = '';\r\n        let position = selection.getStartPosition();\r\n        if (config.insertSpaces) {\r\n            let visibleColumnFromColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\r\n            let indentSize = config.indentSize;\r\n            let spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\r\n            for (let i = 0; i < spacesCnt; i++) {\r\n                typeText += ' ';\r\n            }\r\n        }\r\n        else {\r\n            typeText = '\\t';\r\n        }\r\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\r\n    }\r\n    static tab(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (selection.isEmpty()) {\r\n                let lineText = model.getLineContent(selection.startLineNumber);\r\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\r\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\r\n                    goodIndent = goodIndent || '\\t';\r\n                    let possibleTypeText = config.normalizeIndentation(goodIndent);\r\n                    if (!lineText.startsWith(possibleTypeText)) {\r\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\r\n                        continue;\r\n                    }\r\n                }\r\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\r\n            }\r\n            else {\r\n                if (selection.startLineNumber === selection.endLineNumber) {\r\n                    let lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\r\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\r\n                        // This is a single line selection that is not the entire line\r\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\r\n                        continue;\r\n                    }\r\n                }\r\n                commands[i] = new ShiftCommand(selection, {\r\n                    isUnshift: false,\r\n                    tabSize: config.tabSize,\r\n                    indentSize: config.indentSize,\r\n                    insertSpaces: config.insertSpaces,\r\n                    useTabStops: config.useTabStops,\r\n                    autoIndent: config.autoIndent\r\n                });\r\n            }\r\n        }\r\n        return commands;\r\n    }\r\n    static replacePreviousChar(prevEditOperationType, config, model, selections, txt, replaceCharCnt) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                // looks like https://github.com/microsoft/vscode/issues/2773\r\n                // where a cursor operation occurred before a canceled composition\r\n                // => ignore composition\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            const pos = selection.getPosition();\r\n            const startColumn = Math.max(1, pos.column - replaceCharCnt);\r\n            const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);\r\n            const oldText = model.getValueInRange(range);\r\n            if (oldText === txt) {\r\n                // => ignore composition that doesn't do anything\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            commands[i] = new ReplaceCommand(range, txt);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _typeCommand(range, text, keepPosition) {\r\n        if (keepPosition) {\r\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\r\n        }\r\n        else {\r\n            return new ReplaceCommand(range, text, true);\r\n        }\r\n    }\r\n    static _enter(config, model, keepPosition, range) {\r\n        if (config.autoIndent === 0 /* None */) {\r\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\r\n        }\r\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\r\n            let lineText = model.getLineContent(range.startLineNumber);\r\n            let indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\r\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\r\n        }\r\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\r\n        if (r) {\r\n            if (r.indentAction === IndentAction.None) {\r\n                // Nothing special\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\r\n            }\r\n            else if (r.indentAction === IndentAction.Indent) {\r\n                // Indent once\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\r\n            }\r\n            else if (r.indentAction === IndentAction.IndentOutdent) {\r\n                // Ultra special\r\n                const normalIndent = config.normalizeIndentation(r.indentation);\r\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\r\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\r\n                if (keepPosition) {\r\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\r\n                }\r\n                else {\r\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\r\n                }\r\n            }\r\n            else if (r.indentAction === IndentAction.Outdent) {\r\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\r\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\r\n            }\r\n        }\r\n        const lineText = model.getLineContent(range.startLineNumber);\r\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\r\n        if (config.autoIndent >= 4 /* Full */) {\r\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\r\n                unshiftIndent: (indent) => {\r\n                    return TypeOperations.unshiftIndent(config, indent);\r\n                },\r\n                shiftIndent: (indent) => {\r\n                    return TypeOperations.shiftIndent(config, indent);\r\n                },\r\n                normalizeIndentation: (indent) => {\r\n                    return config.normalizeIndentation(indent);\r\n                }\r\n            });\r\n            if (ir) {\r\n                let oldEndViewColumn = CursorColumns.visibleColumnFromColumn2(config, model, range.getEndPosition());\r\n                const oldEndColumn = range.endColumn;\r\n                const newLineContent = model.getLineContent(range.endLineNumber);\r\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\r\n                if (firstNonWhitespace >= 0) {\r\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\r\n                }\r\n                else {\r\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\r\n                }\r\n                if (keepPosition) {\r\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\r\n                }\r\n                else {\r\n                    let offset = 0;\r\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\r\n                        if (!config.insertSpaces) {\r\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\r\n                        }\r\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\r\n                    }\r\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\r\n                }\r\n            }\r\n        }\r\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\r\n    }\r\n    static _isAutoIndentType(config, model, selections) {\r\n        if (config.autoIndent < 4 /* Full */) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runAutoIndentType(config, model, range, ch) {\r\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\r\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\r\n            shiftIndent: (indentation) => {\r\n                return TypeOperations.shiftIndent(config, indentation);\r\n            },\r\n            unshiftIndent: (indentation) => {\r\n                return TypeOperations.unshiftIndent(config, indentation);\r\n            },\r\n        });\r\n        if (actualIndentation === null) {\r\n            return null;\r\n        }\r\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\r\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\r\n            if (firstNonWhitespace === 0) {\r\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\r\n            }\r\n            else {\r\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\r\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\r\n        if (config.autoClosingOvertype === 'never') {\r\n            return false;\r\n        }\r\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                return false;\r\n            }\r\n            const position = selection.getPosition();\r\n            const lineText = model.getLineContent(position.lineNumber);\r\n            const afterCharacter = lineText.charAt(position.column - 1);\r\n            if (afterCharacter !== ch) {\r\n                return false;\r\n            }\r\n            // Do not over-type quotes after a backslash\r\n            const chIsQuote = isQuote(ch);\r\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\r\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\r\n                return false;\r\n            }\r\n            // Must over-type a closing character typed by the editor\r\n            if (config.autoClosingOvertype === 'auto') {\r\n                let found = false;\r\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\r\n                    const autoClosedCharacter = autoClosedCharacters[j];\r\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            const position = selection.getPosition();\r\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\r\n            commands[i] = new ReplaceCommand(typeSelection, ch);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _isBeforeClosingBrace(config, lineAfter) {\r\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\r\n        const nextChar = lineAfter.charAt(0);\r\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\r\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\r\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\r\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\r\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\r\n    }\r\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\r\n        const autoClosingPairCandidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\r\n        if (!autoClosingPairCandidates) {\r\n            return null;\r\n        }\r\n        // Determine which auto-closing pair it is\r\n        let autoClosingPair = null;\r\n        for (const autoClosingPairCandidate of autoClosingPairCandidates) {\r\n            if (autoClosingPair === null || autoClosingPairCandidate.open.length > autoClosingPair.open.length) {\r\n                let candidateIsMatch = true;\r\n                for (const position of positions) {\r\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - autoClosingPairCandidate.open.length + 1, position.lineNumber, position.column));\r\n                    if (relevantText + ch !== autoClosingPairCandidate.open) {\r\n                        candidateIsMatch = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (candidateIsMatch) {\r\n                    autoClosingPair = autoClosingPairCandidate;\r\n                }\r\n            }\r\n        }\r\n        return autoClosingPair;\r\n    }\r\n    static _findSubAutoClosingPairClose(config, autoClosingPair) {\r\n        if (autoClosingPair.open.length <= 1) {\r\n            return '';\r\n        }\r\n        const lastChar = autoClosingPair.close.charAt(autoClosingPair.close.length - 1);\r\n        // get candidates with the same last character as close\r\n        const subPairCandidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\r\n        let subPairMatch = null;\r\n        for (const x of subPairCandidates) {\r\n            if (x.open !== autoClosingPair.open && autoClosingPair.open.includes(x.open) && autoClosingPair.close.endsWith(x.close)) {\r\n                if (!subPairMatch || x.open.length > subPairMatch.open.length) {\r\n                    subPairMatch = x;\r\n                }\r\n            }\r\n        }\r\n        if (subPairMatch) {\r\n            return subPairMatch.close;\r\n        }\r\n        else {\r\n            return '';\r\n        }\r\n    }\r\n    static _getAutoClosingPairClose(config, model, selections, ch, insertOpenCharacter) {\r\n        const chIsQuote = isQuote(ch);\r\n        const autoCloseConfig = chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets;\r\n        if (autoCloseConfig === 'never') {\r\n            return null;\r\n        }\r\n        const autoClosingPair = this._findAutoClosingPairOpen(config, model, selections.map(s => s.getPosition()), ch);\r\n        if (!autoClosingPair) {\r\n            return null;\r\n        }\r\n        const subAutoClosingPairClose = this._findSubAutoClosingPairClose(config, autoClosingPair);\r\n        let isSubAutoClosingPairPresent = true;\r\n        const shouldAutoCloseBefore = chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket;\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (!selection.isEmpty()) {\r\n                return null;\r\n            }\r\n            const position = selection.getPosition();\r\n            const lineText = model.getLineContent(position.lineNumber);\r\n            const lineAfter = lineText.substring(position.column - 1);\r\n            if (!lineAfter.startsWith(subAutoClosingPairClose)) {\r\n                isSubAutoClosingPairPresent = false;\r\n            }\r\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\r\n            if (lineText.length > position.column - 1) {\r\n                const characterAfter = lineText.charAt(position.column - 1);\r\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\r\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\r\n                    return null;\r\n                }\r\n            }\r\n            if (!model.isCheapToTokenize(position.lineNumber)) {\r\n                // Do not force tokenization\r\n                return null;\r\n            }\r\n            // Do not auto-close ' or \" after a word character\r\n            if (autoClosingPair.open.length === 1 && chIsQuote && autoCloseConfig !== 'always') {\r\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\r\n                if (insertOpenCharacter && position.column > 1 && wordSeparators.get(lineText.charCodeAt(position.column - 2)) === 0 /* Regular */) {\r\n                    return null;\r\n                }\r\n                if (!insertOpenCharacter && position.column > 2 && wordSeparators.get(lineText.charCodeAt(position.column - 3)) === 0 /* Regular */) {\r\n                    return null;\r\n                }\r\n            }\r\n            model.forceTokenization(position.lineNumber);\r\n            const lineTokens = model.getLineTokens(position.lineNumber);\r\n            let shouldAutoClosePair = false;\r\n            try {\r\n                shouldAutoClosePair = LanguageConfigurationRegistry.shouldAutoClosePair(autoClosingPair, lineTokens, insertOpenCharacter ? position.column : position.column - 1);\r\n            }\r\n            catch (e) {\r\n                onUnexpectedError(e);\r\n            }\r\n            if (!shouldAutoClosePair) {\r\n                return null;\r\n            }\r\n        }\r\n        if (isSubAutoClosingPairPresent) {\r\n            return autoClosingPair.close.substring(0, autoClosingPair.close.length - subAutoClosingPairClose.length);\r\n        }\r\n        else {\r\n            return autoClosingPair.close;\r\n        }\r\n    }\r\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, insertOpenCharacter, autoClosingPairClose) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, insertOpenCharacter, autoClosingPairClose);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static _shouldSurroundChar(config, ch) {\r\n        if (isQuote(ch)) {\r\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\r\n        }\r\n        else {\r\n            // Character is a bracket\r\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\r\n        }\r\n    }\r\n    static _isSurroundSelectionType(config, model, selections, ch) {\r\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\r\n            return false;\r\n        }\r\n        const isTypingAQuoteCharacter = isQuote(ch);\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (selection.isEmpty()) {\r\n                return false;\r\n            }\r\n            let selectionContainsOnlyWhitespace = true;\r\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\r\n                const lineText = model.getLineContent(lineNumber);\r\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\r\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\r\n                const selectedText = lineText.substring(startIndex, endIndex);\r\n                if (/[^ \\t]/.test(selectedText)) {\r\n                    // this selected text contains something other than whitespace\r\n                    selectionContainsOnlyWhitespace = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (selectionContainsOnlyWhitespace) {\r\n                return false;\r\n            }\r\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\r\n                const selectionText = model.getValueInRange(selection);\r\n                if (isQuote(selectionText)) {\r\n                    // Typing a quote character on top of another quote character\r\n                    // => disable surround selection type\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            const closeCharacter = config.surroundingPairs[ch];\r\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n    static _isTypeInterceptorElectricChar(config, model, selections) {\r\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\r\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\r\n            return null;\r\n        }\r\n        let position = selection.getPosition();\r\n        model.forceTokenization(position.lineNumber);\r\n        let lineTokens = model.getLineTokens(position.lineNumber);\r\n        let electricAction;\r\n        try {\r\n            electricAction = LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n            return null;\r\n        }\r\n        if (!electricAction) {\r\n            return null;\r\n        }\r\n        if (electricAction.matchOpenBracket) {\r\n            let endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\r\n            let match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {\r\n                lineNumber: position.lineNumber,\r\n                column: endColumn\r\n            });\r\n            if (match) {\r\n                if (match.startLineNumber === position.lineNumber) {\r\n                    // matched something on the same line => no change in indentation\r\n                    return null;\r\n                }\r\n                let matchLine = model.getLineContent(match.startLineNumber);\r\n                let matchLineIndentation = strings.getLeadingWhitespace(matchLine);\r\n                let newIndentation = config.normalizeIndentation(matchLineIndentation);\r\n                let lineText = model.getLineContent(position.lineNumber);\r\n                let lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\r\n                let prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\r\n                let typeText = newIndentation + prefix + ch;\r\n                let typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\r\n                const command = new ReplaceCommand(typeSelection, typeText);\r\n                return new EditOperationResult(1 /* Typing */, [command], {\r\n                    shouldPushStackElementBefore: false,\r\n                    shouldPushStackElementAfter: true\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * This is very similar with typing, but the character is already in the text buffer!\r\n     */\r\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\r\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\r\n            // no content was typed\r\n            return null;\r\n        }\r\n        let ch = null;\r\n        // extract last typed character\r\n        for (const selection of selections) {\r\n            if (!selection.isEmpty()) {\r\n                return null;\r\n            }\r\n            const position = selection.getPosition();\r\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\r\n            if (ch === null) {\r\n                ch = currentChar;\r\n            }\r\n            else if (ch !== currentChar) {\r\n                return null;\r\n            }\r\n        }\r\n        if (!ch) {\r\n            return null;\r\n        }\r\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\r\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\r\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\r\n            return new EditOperationResult(1 /* Typing */, commands, {\r\n                shouldPushStackElementBefore: true,\r\n                shouldPushStackElementAfter: false\r\n            });\r\n        }\r\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\r\n        if (autoClosingPairClose !== null) {\r\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\r\n        }\r\n        return null;\r\n    }\r\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\r\n        if (!isDoingComposition && ch === '\\n') {\r\n            let commands = [];\r\n            for (let i = 0, len = selections.length; i < len; i++) {\r\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\r\n            }\r\n            return new EditOperationResult(1 /* Typing */, commands, {\r\n                shouldPushStackElementBefore: true,\r\n                shouldPushStackElementAfter: false,\r\n            });\r\n        }\r\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\r\n            let commands = [];\r\n            let autoIndentFails = false;\r\n            for (let i = 0, len = selections.length; i < len; i++) {\r\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\r\n                if (!commands[i]) {\r\n                    autoIndentFails = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!autoIndentFails) {\r\n                return new EditOperationResult(1 /* Typing */, commands, {\r\n                    shouldPushStackElementBefore: true,\r\n                    shouldPushStackElementAfter: false,\r\n                });\r\n            }\r\n        }\r\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\r\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\r\n        }\r\n        if (!isDoingComposition) {\r\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\r\n            if (autoClosingPairClose) {\r\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\r\n            }\r\n        }\r\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\r\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\r\n        }\r\n        // Electric characters make sense only when dealing with a single cursor,\r\n        // as multiple cursors typing brackets for example would interfer with bracket matching\r\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\r\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        // A simple character type\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], ch);\r\n        }\r\n        let shouldPushStackElementBefore = (prevEditOperationType !== 1 /* Typing */);\r\n        if (ch === ' ') {\r\n            shouldPushStackElementBefore = true;\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: shouldPushStackElementBefore,\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = new ReplaceCommand(selections[i], str);\r\n        }\r\n        return new EditOperationResult(1 /* Typing */, commands, {\r\n            shouldPushStackElementBefore: (prevEditOperationType !== 1 /* Typing */),\r\n            shouldPushStackElementAfter: false\r\n        });\r\n    }\r\n    static lineInsertBefore(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            let lineNumber = selections[i].positionLineNumber;\r\n            if (lineNumber === 1) {\r\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\r\n            }\r\n            else {\r\n                lineNumber--;\r\n                let column = model.getLineMaxColumn(lineNumber);\r\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\r\n            }\r\n        }\r\n        return commands;\r\n    }\r\n    static lineInsertAfter(config, model, selections) {\r\n        if (model === null || selections === null) {\r\n            return [];\r\n        }\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const lineNumber = selections[i].positionLineNumber;\r\n            let column = model.getLineMaxColumn(lineNumber);\r\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\r\n        }\r\n        return commands;\r\n    }\r\n    static lineBreakInsert(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            commands[i] = this._enter(config, model, true, selections[i]);\r\n        }\r\n        return commands;\r\n    }\r\n}\r\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\r\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\r\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\r\n        this._openCharacter = openCharacter;\r\n        this._closeCharacter = closeCharacter;\r\n        this.closeCharacterRange = null;\r\n        this.enclosingRange = null;\r\n    }\r\n    computeCursorState(model, helper) {\r\n        let inverseEditOperations = helper.getInverseEditOperations();\r\n        let range = inverseEditOperations[0].range;\r\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\r\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\r\n        return super.computeCursorState(model, helper);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}