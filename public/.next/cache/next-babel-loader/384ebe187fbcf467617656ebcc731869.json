{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\n\nvar FloatHorizontalRange = /*#__PURE__*/function () {\n  function FloatHorizontalRange(left, width) {\n    _classCallCheck(this, FloatHorizontalRange);\n\n    this.left = left;\n    this.width = width;\n  }\n\n  _createClass(FloatHorizontalRange, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"[\".concat(this.left, \",\").concat(this.width, \"]\");\n    }\n  }], [{\n    key: \"compare\",\n    value: function compare(a, b) {\n      return a.left - b.left;\n    }\n  }]);\n\n  return FloatHorizontalRange;\n}();\n\nexport var RangeUtil = /*#__PURE__*/function () {\n  function RangeUtil() {\n    _classCallCheck(this, RangeUtil);\n  }\n\n  _createClass(RangeUtil, null, [{\n    key: \"_createRange\",\n    value: function _createRange() {\n      if (!this._handyReadyRange) {\n        this._handyReadyRange = document.createRange();\n      }\n\n      return this._handyReadyRange;\n    }\n  }, {\n    key: \"_detachRange\",\n    value: function _detachRange(range, endNode) {\n      // Move range out of the span node, IE doesn't like having many ranges in\n      // the same spot and will act badly for lines containing dashes ('-')\n      range.selectNodeContents(endNode);\n    }\n  }, {\n    key: \"_readClientRects\",\n    value: function _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\n      var range = this._createRange();\n\n      try {\n        range.setStart(startElement, startOffset);\n        range.setEnd(endElement, endOffset);\n        return range.getClientRects();\n      } catch (e) {\n        // This is life ...\n        return null;\n      } finally {\n        this._detachRange(range, endNode);\n      }\n    }\n  }, {\n    key: \"_mergeAdjacentRanges\",\n    value: function _mergeAdjacentRanges(ranges) {\n      if (ranges.length === 1) {\n        // There is nothing to merge\n        return [new HorizontalRange(ranges[0].left, ranges[0].width)];\n      }\n\n      ranges.sort(FloatHorizontalRange.compare);\n      var result = [],\n          resultLen = 0;\n      var prevLeft = ranges[0].left;\n      var prevWidth = ranges[0].width;\n\n      for (var i = 1, len = ranges.length; i < len; i++) {\n        var range = ranges[i];\n        var myLeft = range.left;\n        var myWidth = range.width;\n\n        if (prevLeft + prevWidth + 0.9\n        /* account for browser's rounding errors*/\n        >= myLeft) {\n          prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\n        } else {\n          result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n          prevLeft = myLeft;\n          prevWidth = myWidth;\n        }\n      }\n\n      result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\n      return result;\n    }\n  }, {\n    key: \"_createHorizontalRangesFromClientRects\",\n    value: function _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {\n      if (!clientRects || clientRects.length === 0) {\n        return null;\n      } // We go through FloatHorizontalRange because it has been observed in bi-di text\n      // that the clientRects are not coming in sorted from the browser\n\n\n      var result = [];\n\n      for (var i = 0, len = clientRects.length; i < len; i++) {\n        var clientRect = clientRects[i];\n        result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\n      }\n\n      return this._mergeAdjacentRanges(result);\n    }\n  }, {\n    key: \"readHorizontalRanges\",\n    value: function readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\n      // Panic check\n      var min = 0;\n      var max = domNode.children.length - 1;\n\n      if (min > max) {\n        return null;\n      }\n\n      startChildIndex = Math.min(max, Math.max(min, startChildIndex));\n      endChildIndex = Math.min(max, Math.max(min, endChildIndex));\n\n      if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0) {\n        // We must find the position at the beginning of a <span>\n        // To cover cases of empty <span>s, aboid using a range and use the <span>'s bounding box\n        var _clientRects = domNode.children[startChildIndex].getClientRects();\n\n        return this._createHorizontalRangesFromClientRects(_clientRects, clientRectDeltaLeft);\n      } // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\n      // Chrome is buggy and doesn't handle 0 offsets well sometimes.\n\n\n      if (startChildIndex !== endChildIndex) {\n        if (endChildIndex > 0 && endOffset === 0) {\n          endChildIndex--;\n          endOffset = 1073741824\n          /* MAX_SAFE_SMALL_INTEGER */\n          ;\n        }\n      }\n\n      var startElement = domNode.children[startChildIndex].firstChild;\n      var endElement = domNode.children[endChildIndex].firstChild;\n\n      if (!startElement || !endElement) {\n        // When having an empty <span> (without any text content), try to move to the previous <span>\n        if (!startElement && startOffset === 0 && startChildIndex > 0) {\n          startElement = domNode.children[startChildIndex - 1].firstChild;\n          startOffset = 1073741824\n          /* MAX_SAFE_SMALL_INTEGER */\n          ;\n        }\n\n        if (!endElement && endOffset === 0 && endChildIndex > 0) {\n          endElement = domNode.children[endChildIndex - 1].firstChild;\n          endOffset = 1073741824\n          /* MAX_SAFE_SMALL_INTEGER */\n          ;\n        }\n      }\n\n      if (!startElement || !endElement) {\n        return null;\n      }\n\n      startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\n      endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\n\n      var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\n\n      return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\n    }\n  }]);\n\n  return RangeUtil;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/viewParts/lines/rangeUtil.js"],"names":["HorizontalRange","FloatHorizontalRange","left","width","a","b","RangeUtil","_handyReadyRange","document","createRange","range","endNode","selectNodeContents","startElement","startOffset","endElement","endOffset","_createRange","setStart","setEnd","getClientRects","e","_detachRange","ranges","length","sort","compare","result","resultLen","prevLeft","prevWidth","i","len","myLeft","myWidth","Math","max","clientRects","clientRectDeltaLeft","clientRect","_mergeAdjacentRanges","domNode","startChildIndex","endChildIndex","min","children","_createHorizontalRangesFromClientRects","firstChild","textContent","_readClientRects"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { HorizontalRange } from '../../../common/view/renderingContext.js';\r\nclass FloatHorizontalRange {\r\n    constructor(left, width) {\r\n        this.left = left;\r\n        this.width = width;\r\n    }\r\n    toString() {\r\n        return `[${this.left},${this.width}]`;\r\n    }\r\n    static compare(a, b) {\r\n        return a.left - b.left;\r\n    }\r\n}\r\nexport class RangeUtil {\r\n    static _createRange() {\r\n        if (!this._handyReadyRange) {\r\n            this._handyReadyRange = document.createRange();\r\n        }\r\n        return this._handyReadyRange;\r\n    }\r\n    static _detachRange(range, endNode) {\r\n        // Move range out of the span node, IE doesn't like having many ranges in\r\n        // the same spot and will act badly for lines containing dashes ('-')\r\n        range.selectNodeContents(endNode);\r\n    }\r\n    static _readClientRects(startElement, startOffset, endElement, endOffset, endNode) {\r\n        const range = this._createRange();\r\n        try {\r\n            range.setStart(startElement, startOffset);\r\n            range.setEnd(endElement, endOffset);\r\n            return range.getClientRects();\r\n        }\r\n        catch (e) {\r\n            // This is life ...\r\n            return null;\r\n        }\r\n        finally {\r\n            this._detachRange(range, endNode);\r\n        }\r\n    }\r\n    static _mergeAdjacentRanges(ranges) {\r\n        if (ranges.length === 1) {\r\n            // There is nothing to merge\r\n            return [new HorizontalRange(ranges[0].left, ranges[0].width)];\r\n        }\r\n        ranges.sort(FloatHorizontalRange.compare);\r\n        let result = [], resultLen = 0;\r\n        let prevLeft = ranges[0].left;\r\n        let prevWidth = ranges[0].width;\r\n        for (let i = 1, len = ranges.length; i < len; i++) {\r\n            const range = ranges[i];\r\n            const myLeft = range.left;\r\n            const myWidth = range.width;\r\n            if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {\r\n                prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);\r\n            }\r\n            else {\r\n                result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\r\n                prevLeft = myLeft;\r\n                prevWidth = myWidth;\r\n            }\r\n        }\r\n        result[resultLen++] = new HorizontalRange(prevLeft, prevWidth);\r\n        return result;\r\n    }\r\n    static _createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft) {\r\n        if (!clientRects || clientRects.length === 0) {\r\n            return null;\r\n        }\r\n        // We go through FloatHorizontalRange because it has been observed in bi-di text\r\n        // that the clientRects are not coming in sorted from the browser\r\n        const result = [];\r\n        for (let i = 0, len = clientRects.length; i < len; i++) {\r\n            const clientRect = clientRects[i];\r\n            result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);\r\n        }\r\n        return this._mergeAdjacentRanges(result);\r\n    }\r\n    static readHorizontalRanges(domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {\r\n        // Panic check\r\n        const min = 0;\r\n        const max = domNode.children.length - 1;\r\n        if (min > max) {\r\n            return null;\r\n        }\r\n        startChildIndex = Math.min(max, Math.max(min, startChildIndex));\r\n        endChildIndex = Math.min(max, Math.max(min, endChildIndex));\r\n        if (startChildIndex === endChildIndex && startOffset === endOffset && startOffset === 0) {\r\n            // We must find the position at the beginning of a <span>\r\n            // To cover cases of empty <span>s, aboid using a range and use the <span>'s bounding box\r\n            const clientRects = domNode.children[startChildIndex].getClientRects();\r\n            return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\r\n        }\r\n        // If crossing over to a span only to select offset 0, then use the previous span's maximum offset\r\n        // Chrome is buggy and doesn't handle 0 offsets well sometimes.\r\n        if (startChildIndex !== endChildIndex) {\r\n            if (endChildIndex > 0 && endOffset === 0) {\r\n                endChildIndex--;\r\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n        }\r\n        let startElement = domNode.children[startChildIndex].firstChild;\r\n        let endElement = domNode.children[endChildIndex].firstChild;\r\n        if (!startElement || !endElement) {\r\n            // When having an empty <span> (without any text content), try to move to the previous <span>\r\n            if (!startElement && startOffset === 0 && startChildIndex > 0) {\r\n                startElement = domNode.children[startChildIndex - 1].firstChild;\r\n                startOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n            if (!endElement && endOffset === 0 && endChildIndex > 0) {\r\n                endElement = domNode.children[endChildIndex - 1].firstChild;\r\n                endOffset = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            }\r\n        }\r\n        if (!startElement || !endElement) {\r\n            return null;\r\n        }\r\n        startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));\r\n        endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));\r\n        const clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);\r\n        return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}