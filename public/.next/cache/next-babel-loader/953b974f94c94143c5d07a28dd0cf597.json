{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar _a;\n\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Configuration } from '../config/configuration.js';\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\nvar ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', {\n  createHTML: function createHTML(value) {\n    return value;\n  }\n});\nexport var DOMLineBreaksComputerFactory = /*#__PURE__*/function () {\n  _createClass(DOMLineBreaksComputerFactory, null, [{\n    key: \"create\",\n    value: function create() {\n      return new DOMLineBreaksComputerFactory();\n    }\n  }]);\n\n  function DOMLineBreaksComputerFactory() {\n    _classCallCheck(this, DOMLineBreaksComputerFactory);\n  }\n\n  _createClass(DOMLineBreaksComputerFactory, [{\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n      tabSize = tabSize | 0; //@perf\n\n      wrappingColumn = +wrappingColumn; //@perf\n\n      var requests = [];\n      return {\n        addRequest: function addRequest(lineText, previousLineBreakData) {\n          requests.push(lineText);\n        },\n        finalize: function finalize() {\n          return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\n        }\n      };\n    }\n  }]);\n\n  return DOMLineBreaksComputerFactory;\n}();\n\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\n  var _a;\n\n  if (firstLineBreakColumn === -1) {\n    var _result = [];\n\n    for (var i = 0, len = requests.length; i < len; i++) {\n      _result[i] = null;\n    }\n\n    return _result;\n  }\n\n  var overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth); // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\n  // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\n\n  if (wrappingIndent === 2\n  /* Indent */\n  || wrappingIndent === 3\n  /* DeepIndent */\n  ) {\n      wrappingIndent = 1\n      /* Same */\n      ;\n    }\n\n  var containerDomNode = document.createElement('div');\n  Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\n  var sb = createStringBuilder(10000);\n  var firstNonWhitespaceIndices = [];\n  var wrappedTextIndentLengths = [];\n  var renderLineContents = [];\n  var allCharOffsets = [];\n  var allVisibleColumns = [];\n\n  for (var _i = 0; _i < requests.length; _i++) {\n    var lineContent = requests[_i];\n    var firstNonWhitespaceIndex = 0;\n    var wrappedTextIndentLength = 0;\n    var width = overallWidth;\n\n    if (wrappingIndent !== 0\n    /* None */\n    ) {\n        firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n\n        if (firstNonWhitespaceIndex === -1) {\n          // all whitespace line\n          firstNonWhitespaceIndex = 0;\n        } else {\n          // Track existing indent\n          for (var _i2 = 0; _i2 < firstNonWhitespaceIndex; _i2++) {\n            var charWidth = lineContent.charCodeAt(_i2) === 9\n            /* Tab */\n            ? tabSize - wrappedTextIndentLength % tabSize : 1;\n            wrappedTextIndentLength += charWidth;\n          }\n\n          var indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength); // Force sticking to beginning of line if no character would fit except for the indentation\n\n          if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\n            firstNonWhitespaceIndex = 0;\n            wrappedTextIndentLength = 0;\n          } else {\n            width = overallWidth - indentWidth;\n          }\n        }\n      }\n\n    var renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\n    var tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\n    firstNonWhitespaceIndices[_i] = firstNonWhitespaceIndex;\n    wrappedTextIndentLengths[_i] = wrappedTextIndentLength;\n    renderLineContents[_i] = renderLineContent;\n    allCharOffsets[_i] = tmp[0];\n    allVisibleColumns[_i] = tmp[1];\n  }\n\n  var html = sb.build();\n  var trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\n  containerDomNode.innerHTML = trustedhtml;\n  containerDomNode.style.position = 'absolute';\n  containerDomNode.style.top = '10000';\n  containerDomNode.style.wordWrap = 'break-word';\n  document.body.appendChild(containerDomNode);\n  var range = document.createRange();\n  var lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\n  var result = [];\n\n  for (var _i3 = 0; _i3 < requests.length; _i3++) {\n    var lineDomNode = lineDomNodes[_i3];\n    var breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[_i3], allCharOffsets[_i3]);\n\n    if (breakOffsets === null) {\n      result[_i3] = null;\n      continue;\n    }\n\n    var _firstNonWhitespaceIndex = firstNonWhitespaceIndices[_i3];\n    var _wrappedTextIndentLength = wrappedTextIndentLengths[_i3];\n    var visibleColumns = allVisibleColumns[_i3];\n    var breakOffsetsVisibleColumn = [];\n\n    for (var j = 0, _len = breakOffsets.length; j < _len; j++) {\n      breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\n    }\n\n    if (_firstNonWhitespaceIndex !== 0) {\n      // All break offsets are relative to the renderLineContent, make them absolute again\n      for (var _j = 0, _len2 = breakOffsets.length; _j < _len2; _j++) {\n        breakOffsets[_j] += _firstNonWhitespaceIndex;\n      }\n    }\n\n    result[_i3] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, _wrappedTextIndentLength);\n  }\n\n  document.body.removeChild(containerDomNode);\n  return result;\n}\n\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\n  sb.appendASCIIString('<div style=\"width:');\n  sb.appendASCIIString(String(width));\n  sb.appendASCIIString('px;\">'); // if (containsRTL) {\n  // \tsb.appendASCIIString('\" dir=\"ltr');\n  // }\n\n  var len = lineContent.length;\n  var visibleColumn = initialVisibleColumn;\n  var charOffset = 0;\n  var charOffsets = [];\n  var visibleColumns = [];\n  var nextCharCode = 0 < len ? lineContent.charCodeAt(0) : 0\n  /* Null */\n  ;\n  sb.appendASCIIString('<span>');\n\n  for (var charIndex = 0; charIndex < len; charIndex++) {\n    if (charIndex !== 0 && charIndex % 16384\n    /* SPAN_MODULO_LIMIT */\n    === 0) {\n      sb.appendASCIIString('</span><span>');\n    }\n\n    charOffsets[charIndex] = charOffset;\n    visibleColumns[charIndex] = visibleColumn;\n    var charCode = nextCharCode;\n    nextCharCode = charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0\n    /* Null */\n    ;\n    var producedCharacters = 1;\n    var charWidth = 1;\n\n    switch (charCode) {\n      case 9\n      /* Tab */\n      :\n        producedCharacters = tabSize - visibleColumn % tabSize;\n        charWidth = producedCharacters;\n\n        for (var space = 1; space <= producedCharacters; space++) {\n          if (space < producedCharacters) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n            sb.appendASCII(32\n            /* Space */\n            );\n          }\n        }\n\n        break;\n\n      case 32\n      /* Space */\n      :\n        if (nextCharCode === 32\n        /* Space */\n        ) {\n            sb.write1(0xA0); // &nbsp;\n          } else {\n          sb.appendASCII(32\n          /* Space */\n          );\n        }\n\n        break;\n\n      case 60\n      /* LessThan */\n      :\n        sb.appendASCIIString('&lt;');\n        break;\n\n      case 62\n      /* GreaterThan */\n      :\n        sb.appendASCIIString('&gt;');\n        break;\n\n      case 38\n      /* Ampersand */\n      :\n        sb.appendASCIIString('&amp;');\n        break;\n\n      case 0\n      /* Null */\n      :\n        sb.appendASCIIString('&#00;');\n        break;\n\n      case 65279\n      /* UTF8_BOM */\n      :\n      case 8232\n      /* LINE_SEPARATOR */\n      :\n      case 8233\n      /* PARAGRAPH_SEPARATOR */\n      :\n      case 133\n      /* NEXT_LINE */\n      :\n        sb.write1(0xFFFD);\n        break;\n\n      default:\n        if (strings.isFullWidthCharacter(charCode)) {\n          charWidth++;\n        } // if (renderControlCharacters && charCode < 32) {\n        // \tsb.write1(9216 + charCode);\n        // } else {\n\n\n        sb.write1(charCode);\n      // }\n    }\n\n    charOffset += producedCharacters;\n    visibleColumn += charWidth;\n  }\n\n  sb.appendASCIIString('</span>');\n  charOffsets[lineContent.length] = charOffset;\n  visibleColumns[lineContent.length] = visibleColumn;\n  sb.appendASCIIString('</div>');\n  return [charOffsets, visibleColumns];\n}\n\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\n  if (lineContent.length <= 1) {\n    return null;\n  }\n\n  var spans = Array.prototype.slice.call(lineDomNode.children, 0);\n  var breakOffsets = [];\n\n  try {\n    discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\n  } catch (err) {\n    console.log(err);\n    return null;\n  }\n\n  if (breakOffsets.length === 0) {\n    return null;\n  }\n\n  breakOffsets.push(lineContent.length);\n  return breakOffsets;\n}\n\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\n  if (low === high) {\n    return;\n  }\n\n  lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\n  highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\n\n  if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\n    // same line\n    return;\n  } // there is at least one line break between these two offsets\n\n\n  if (low + 1 === high) {\n    // the two characters are adjacent, so the line break must be exactly between them\n    result.push(high);\n    return;\n  }\n\n  var mid = low + (high - low) / 2 | 0;\n  var midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\n  discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\n  discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\n}\n\nfunction readClientRect(range, spans, startOffset, endOffset) {\n  range.setStart(spans[startOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, startOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  range.setEnd(spans[endOffset / 16384\n  /* SPAN_MODULO_LIMIT */\n  | 0].firstChild, endOffset % 16384\n  /* SPAN_MODULO_LIMIT */\n  );\n  return range.getClientRects();\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/view/domLineBreaksComputer.js"],"names":["_a","createStringBuilder","strings","Configuration","LineBreakData","ttPolicy","window","trustedTypes","createPolicy","createHTML","value","DOMLineBreaksComputerFactory","fontInfo","tabSize","wrappingColumn","wrappingIndent","requests","addRequest","lineText","previousLineBreakData","push","finalize","createLineBreaks","firstLineBreakColumn","result","i","len","length","overallWidth","Math","round","typicalHalfwidthCharacterWidth","containerDomNode","document","createElement","applyFontInfoSlow","sb","firstNonWhitespaceIndices","wrappedTextIndentLengths","renderLineContents","allCharOffsets","allVisibleColumns","lineContent","firstNonWhitespaceIndex","wrappedTextIndentLength","width","charWidth","charCodeAt","indentWidth","ceil","spaceWidth","typicalFullwidthCharacterWidth","renderLineContent","substr","tmp","renderLine","html","build","trustedhtml","innerHTML","style","position","top","wordWrap","body","appendChild","range","createRange","lineDomNodes","Array","prototype","slice","call","children","lineDomNode","breakOffsets","readLineBreaks","visibleColumns","breakOffsetsVisibleColumn","j","removeChild","initialVisibleColumn","appendASCIIString","String","visibleColumn","charOffset","charOffsets","nextCharCode","charIndex","charCode","producedCharacters","space","write1","appendASCII","isFullWidthCharacter","spans","discoverBreaks","err","console","log","low","lowRects","high","highRects","readClientRect","abs","mid","midRects","startOffset","endOffset","setStart","firstChild","setEnd","getClientRects"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a;\r\nimport { createStringBuilder } from '../../common/core/stringBuilder.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Configuration } from '../config/configuration.js';\r\nimport { LineBreakData } from '../../common/viewModel/viewModel.js';\r\nconst ttPolicy = (_a = window.trustedTypes) === null || _a === void 0 ? void 0 : _a.createPolicy('domLineBreaksComputer', { createHTML: value => value });\r\nexport class DOMLineBreaksComputerFactory {\r\n    static create() {\r\n        return new DOMLineBreaksComputerFactory();\r\n    }\r\n    constructor() {\r\n    }\r\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\r\n        tabSize = tabSize | 0; //@perf\r\n        wrappingColumn = +wrappingColumn; //@perf\r\n        let requests = [];\r\n        return {\r\n            addRequest: (lineText, previousLineBreakData) => {\r\n                requests.push(lineText);\r\n            },\r\n            finalize: () => {\r\n                return createLineBreaks(requests, fontInfo, tabSize, wrappingColumn, wrappingIndent);\r\n            }\r\n        };\r\n    }\r\n}\r\nfunction createLineBreaks(requests, fontInfo, tabSize, firstLineBreakColumn, wrappingIndent) {\r\n    var _a;\r\n    if (firstLineBreakColumn === -1) {\r\n        const result = [];\r\n        for (let i = 0, len = requests.length; i < len; i++) {\r\n            result[i] = null;\r\n        }\r\n        return result;\r\n    }\r\n    const overallWidth = Math.round(firstLineBreakColumn * fontInfo.typicalHalfwidthCharacterWidth);\r\n    // Cannot respect WrappingIndent.Indent and WrappingIndent.DeepIndent because that would require\r\n    // two dom layouts, in order to first set the width of the first line, and then set the width of the wrapped lines\r\n    if (wrappingIndent === 2 /* Indent */ || wrappingIndent === 3 /* DeepIndent */) {\r\n        wrappingIndent = 1 /* Same */;\r\n    }\r\n    const containerDomNode = document.createElement('div');\r\n    Configuration.applyFontInfoSlow(containerDomNode, fontInfo);\r\n    const sb = createStringBuilder(10000);\r\n    const firstNonWhitespaceIndices = [];\r\n    const wrappedTextIndentLengths = [];\r\n    const renderLineContents = [];\r\n    const allCharOffsets = [];\r\n    const allVisibleColumns = [];\r\n    for (let i = 0; i < requests.length; i++) {\r\n        const lineContent = requests[i];\r\n        let firstNonWhitespaceIndex = 0;\r\n        let wrappedTextIndentLength = 0;\r\n        let width = overallWidth;\r\n        if (wrappingIndent !== 0 /* None */) {\r\n            firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n            if (firstNonWhitespaceIndex === -1) {\r\n                // all whitespace line\r\n                firstNonWhitespaceIndex = 0;\r\n            }\r\n            else {\r\n                // Track existing indent\r\n                for (let i = 0; i < firstNonWhitespaceIndex; i++) {\r\n                    const charWidth = (lineContent.charCodeAt(i) === 9 /* Tab */\r\n                        ? (tabSize - (wrappedTextIndentLength % tabSize))\r\n                        : 1);\r\n                    wrappedTextIndentLength += charWidth;\r\n                }\r\n                const indentWidth = Math.ceil(fontInfo.spaceWidth * wrappedTextIndentLength);\r\n                // Force sticking to beginning of line if no character would fit except for the indentation\r\n                if (indentWidth + fontInfo.typicalFullwidthCharacterWidth > overallWidth) {\r\n                    firstNonWhitespaceIndex = 0;\r\n                    wrappedTextIndentLength = 0;\r\n                }\r\n                else {\r\n                    width = overallWidth - indentWidth;\r\n                }\r\n            }\r\n        }\r\n        const renderLineContent = lineContent.substr(firstNonWhitespaceIndex);\r\n        const tmp = renderLine(renderLineContent, wrappedTextIndentLength, tabSize, width, sb);\r\n        firstNonWhitespaceIndices[i] = firstNonWhitespaceIndex;\r\n        wrappedTextIndentLengths[i] = wrappedTextIndentLength;\r\n        renderLineContents[i] = renderLineContent;\r\n        allCharOffsets[i] = tmp[0];\r\n        allVisibleColumns[i] = tmp[1];\r\n    }\r\n    const html = sb.build();\r\n    const trustedhtml = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(html)) !== null && _a !== void 0 ? _a : html;\r\n    containerDomNode.innerHTML = trustedhtml;\r\n    containerDomNode.style.position = 'absolute';\r\n    containerDomNode.style.top = '10000';\r\n    containerDomNode.style.wordWrap = 'break-word';\r\n    document.body.appendChild(containerDomNode);\r\n    let range = document.createRange();\r\n    const lineDomNodes = Array.prototype.slice.call(containerDomNode.children, 0);\r\n    let result = [];\r\n    for (let i = 0; i < requests.length; i++) {\r\n        const lineDomNode = lineDomNodes[i];\r\n        const breakOffsets = readLineBreaks(range, lineDomNode, renderLineContents[i], allCharOffsets[i]);\r\n        if (breakOffsets === null) {\r\n            result[i] = null;\r\n            continue;\r\n        }\r\n        const firstNonWhitespaceIndex = firstNonWhitespaceIndices[i];\r\n        const wrappedTextIndentLength = wrappedTextIndentLengths[i];\r\n        const visibleColumns = allVisibleColumns[i];\r\n        const breakOffsetsVisibleColumn = [];\r\n        for (let j = 0, len = breakOffsets.length; j < len; j++) {\r\n            breakOffsetsVisibleColumn[j] = visibleColumns[breakOffsets[j]];\r\n        }\r\n        if (firstNonWhitespaceIndex !== 0) {\r\n            // All break offsets are relative to the renderLineContent, make them absolute again\r\n            for (let j = 0, len = breakOffsets.length; j < len; j++) {\r\n                breakOffsets[j] += firstNonWhitespaceIndex;\r\n            }\r\n        }\r\n        result[i] = new LineBreakData(breakOffsets, breakOffsetsVisibleColumn, wrappedTextIndentLength);\r\n    }\r\n    document.body.removeChild(containerDomNode);\r\n    return result;\r\n}\r\nfunction renderLine(lineContent, initialVisibleColumn, tabSize, width, sb) {\r\n    sb.appendASCIIString('<div style=\"width:');\r\n    sb.appendASCIIString(String(width));\r\n    sb.appendASCIIString('px;\">');\r\n    // if (containsRTL) {\r\n    // \tsb.appendASCIIString('\" dir=\"ltr');\r\n    // }\r\n    const len = lineContent.length;\r\n    let visibleColumn = initialVisibleColumn;\r\n    let charOffset = 0;\r\n    let charOffsets = [];\r\n    let visibleColumns = [];\r\n    let nextCharCode = (0 < len ? lineContent.charCodeAt(0) : 0 /* Null */);\r\n    sb.appendASCIIString('<span>');\r\n    for (let charIndex = 0; charIndex < len; charIndex++) {\r\n        if (charIndex !== 0 && charIndex % 16384 /* SPAN_MODULO_LIMIT */ === 0) {\r\n            sb.appendASCIIString('</span><span>');\r\n        }\r\n        charOffsets[charIndex] = charOffset;\r\n        visibleColumns[charIndex] = visibleColumn;\r\n        const charCode = nextCharCode;\r\n        nextCharCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\r\n        let producedCharacters = 1;\r\n        let charWidth = 1;\r\n        switch (charCode) {\r\n            case 9 /* Tab */:\r\n                producedCharacters = (tabSize - (visibleColumn % tabSize));\r\n                charWidth = producedCharacters;\r\n                for (let space = 1; space <= producedCharacters; space++) {\r\n                    if (space < producedCharacters) {\r\n                        sb.write1(0xA0); // &nbsp;\r\n                    }\r\n                    else {\r\n                        sb.appendASCII(32 /* Space */);\r\n                    }\r\n                }\r\n                break;\r\n            case 32 /* Space */:\r\n                if (nextCharCode === 32 /* Space */) {\r\n                    sb.write1(0xA0); // &nbsp;\r\n                }\r\n                else {\r\n                    sb.appendASCII(32 /* Space */);\r\n                }\r\n                break;\r\n            case 60 /* LessThan */:\r\n                sb.appendASCIIString('&lt;');\r\n                break;\r\n            case 62 /* GreaterThan */:\r\n                sb.appendASCIIString('&gt;');\r\n                break;\r\n            case 38 /* Ampersand */:\r\n                sb.appendASCIIString('&amp;');\r\n                break;\r\n            case 0 /* Null */:\r\n                sb.appendASCIIString('&#00;');\r\n                break;\r\n            case 65279 /* UTF8_BOM */:\r\n            case 8232 /* LINE_SEPARATOR */:\r\n            case 8233 /* PARAGRAPH_SEPARATOR */:\r\n            case 133 /* NEXT_LINE */:\r\n                sb.write1(0xFFFD);\r\n                break;\r\n            default:\r\n                if (strings.isFullWidthCharacter(charCode)) {\r\n                    charWidth++;\r\n                }\r\n                // if (renderControlCharacters && charCode < 32) {\r\n                // \tsb.write1(9216 + charCode);\r\n                // } else {\r\n                sb.write1(charCode);\r\n            // }\r\n        }\r\n        charOffset += producedCharacters;\r\n        visibleColumn += charWidth;\r\n    }\r\n    sb.appendASCIIString('</span>');\r\n    charOffsets[lineContent.length] = charOffset;\r\n    visibleColumns[lineContent.length] = visibleColumn;\r\n    sb.appendASCIIString('</div>');\r\n    return [charOffsets, visibleColumns];\r\n}\r\nfunction readLineBreaks(range, lineDomNode, lineContent, charOffsets) {\r\n    if (lineContent.length <= 1) {\r\n        return null;\r\n    }\r\n    const spans = Array.prototype.slice.call(lineDomNode.children, 0);\r\n    const breakOffsets = [];\r\n    try {\r\n        discoverBreaks(range, spans, charOffsets, 0, null, lineContent.length - 1, null, breakOffsets);\r\n    }\r\n    catch (err) {\r\n        console.log(err);\r\n        return null;\r\n    }\r\n    if (breakOffsets.length === 0) {\r\n        return null;\r\n    }\r\n    breakOffsets.push(lineContent.length);\r\n    return breakOffsets;\r\n}\r\nfunction discoverBreaks(range, spans, charOffsets, low, lowRects, high, highRects, result) {\r\n    if (low === high) {\r\n        return;\r\n    }\r\n    lowRects = lowRects || readClientRect(range, spans, charOffsets[low], charOffsets[low + 1]);\r\n    highRects = highRects || readClientRect(range, spans, charOffsets[high], charOffsets[high + 1]);\r\n    if (Math.abs(lowRects[0].top - highRects[0].top) <= 0.1) {\r\n        // same line\r\n        return;\r\n    }\r\n    // there is at least one line break between these two offsets\r\n    if (low + 1 === high) {\r\n        // the two characters are adjacent, so the line break must be exactly between them\r\n        result.push(high);\r\n        return;\r\n    }\r\n    const mid = low + ((high - low) / 2) | 0;\r\n    const midRects = readClientRect(range, spans, charOffsets[mid], charOffsets[mid + 1]);\r\n    discoverBreaks(range, spans, charOffsets, low, lowRects, mid, midRects, result);\r\n    discoverBreaks(range, spans, charOffsets, mid, midRects, high, highRects, result);\r\n}\r\nfunction readClientRect(range, spans, startOffset, endOffset) {\r\n    range.setStart(spans[(startOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, startOffset % 16384 /* SPAN_MODULO_LIMIT */);\r\n    range.setEnd(spans[(endOffset / 16384 /* SPAN_MODULO_LIMIT */) | 0].firstChild, endOffset % 16384 /* SPAN_MODULO_LIMIT */);\r\n    return range.getClientRects();\r\n}\r\n"]},"metadata":{},"sourceType":"module"}