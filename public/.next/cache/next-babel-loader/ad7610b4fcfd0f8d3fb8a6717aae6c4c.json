{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport var PieceTreeTextBufferFactory = /*#__PURE__*/function () {\n  function PieceTreeTextBufferFactory(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n    _classCallCheck(this, PieceTreeTextBufferFactory);\n\n    this._chunks = _chunks;\n    this._bom = _bom;\n    this._cr = _cr;\n    this._lf = _lf;\n    this._crlf = _crlf;\n    this._containsRTL = _containsRTL;\n    this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n    this._isBasicASCII = _isBasicASCII;\n    this._normalizeEOL = _normalizeEOL;\n  }\n\n  _createClass(PieceTreeTextBufferFactory, [{\n    key: \"_getEOL\",\n    value: function _getEOL(defaultEOL) {\n      var totalEOLCount = this._cr + this._lf + this._crlf;\n      var totalCRCount = this._cr + this._crlf;\n\n      if (totalEOLCount === 0) {\n        // This is an empty file or a file with precisely one line\n        return defaultEOL === 1\n        /* LF */\n        ? '\\n' : '\\r\\n';\n      }\n\n      if (totalCRCount > totalEOLCount / 2) {\n        // More than half of the file contains \\r\\n ending lines\n        return '\\r\\n';\n      } // At least one line more ends in \\n\n\n\n      return '\\n';\n    }\n  }, {\n    key: \"create\",\n    value: function create(defaultEOL) {\n      var eol = this._getEOL(defaultEOL);\n\n      var chunks = this._chunks;\n\n      if (this._normalizeEOL && (eol === '\\r\\n' && (this._cr > 0 || this._lf > 0) || eol === '\\n' && (this._cr > 0 || this._crlf > 0))) {\n        // Normalize pieces\n        for (var i = 0, len = chunks.length; i < len; i++) {\n          var str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n          var newLineStart = createLineStartsFast(str);\n          chunks[i] = new StringBuffer(str, newLineStart);\n        }\n      }\n\n      var textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n      return {\n        textBuffer: textBuffer,\n        disposable: textBuffer\n      };\n    }\n  }]);\n\n  return PieceTreeTextBufferFactory;\n}();\nexport var PieceTreeTextBufferBuilder = /*#__PURE__*/function () {\n  function PieceTreeTextBufferBuilder() {\n    _classCallCheck(this, PieceTreeTextBufferBuilder);\n\n    this.chunks = [];\n    this.BOM = '';\n    this._hasPreviousChar = false;\n    this._previousChar = 0;\n    this._tmpLineStarts = [];\n    this.cr = 0;\n    this.lf = 0;\n    this.crlf = 0;\n    this.containsRTL = false;\n    this.containsUnusualLineTerminators = false;\n    this.isBasicASCII = true;\n  }\n\n  _createClass(PieceTreeTextBufferBuilder, [{\n    key: \"acceptChunk\",\n    value: function acceptChunk(chunk) {\n      if (chunk.length === 0) {\n        return;\n      }\n\n      if (this.chunks.length === 0) {\n        if (strings.startsWithUTF8BOM(chunk)) {\n          this.BOM = strings.UTF8_BOM_CHARACTER;\n          chunk = chunk.substr(1);\n        }\n      }\n\n      var lastChar = chunk.charCodeAt(chunk.length - 1);\n\n      if (lastChar === 13\n      /* CarriageReturn */\n      || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n        // last character is \\r or a high surrogate => keep it back\n        this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n\n        this._hasPreviousChar = true;\n        this._previousChar = lastChar;\n      } else {\n        this._acceptChunk1(chunk, false);\n\n        this._hasPreviousChar = false;\n        this._previousChar = lastChar;\n      }\n    }\n  }, {\n    key: \"_acceptChunk1\",\n    value: function _acceptChunk1(chunk, allowEmptyStrings) {\n      if (!allowEmptyStrings && chunk.length === 0) {\n        // Nothing to do\n        return;\n      }\n\n      if (this._hasPreviousChar) {\n        this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n      } else {\n        this._acceptChunk2(chunk);\n      }\n    }\n  }, {\n    key: \"_acceptChunk2\",\n    value: function _acceptChunk2(chunk) {\n      var lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n      this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n      this.cr += lineStarts.cr;\n      this.lf += lineStarts.lf;\n      this.crlf += lineStarts.crlf;\n\n      if (this.isBasicASCII) {\n        this.isBasicASCII = lineStarts.isBasicASCII;\n      }\n\n      if (!this.isBasicASCII && !this.containsRTL) {\n        // No need to check if it is basic ASCII\n        this.containsRTL = strings.containsRTL(chunk);\n      }\n\n      if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n        // No need to check if it is basic ASCII\n        this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var normalizeEOL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this._finish();\n\n      return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n  }, {\n    key: \"_finish\",\n    value: function _finish() {\n      if (this.chunks.length === 0) {\n        this._acceptChunk1('', true);\n      }\n\n      if (this._hasPreviousChar) {\n        this._hasPreviousChar = false; // recreate last chunk\n\n        var lastChunk = this.chunks[this.chunks.length - 1];\n        lastChunk.buffer += String.fromCharCode(this._previousChar);\n        var newLineStarts = createLineStartsFast(lastChunk.buffer);\n        lastChunk.lineStarts = newLineStarts;\n\n        if (this._previousChar === 13\n        /* CarriageReturn */\n        ) {\n            this.cr++;\n          }\n      }\n    }\n  }]);\n\n  return PieceTreeTextBufferBuilder;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js"],"names":["strings","StringBuffer","createLineStarts","createLineStartsFast","PieceTreeTextBuffer","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","eol","_getEOL","chunks","i","len","length","str","buffer","replace","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","BOM","_hasPreviousChar","_previousChar","_tmpLineStarts","cr","lf","crlf","containsRTL","containsUnusualLineTerminators","isBasicASCII","chunk","startsWithUTF8BOM","UTF8_BOM_CHARACTER","substr","lastChar","charCodeAt","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","lineStarts","push","normalizeEOL","_finish","lastChunk","newLineStarts"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../../base/common/strings.js';\r\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\r\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\r\nexport class PieceTreeTextBufferFactory {\r\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\r\n        this._chunks = _chunks;\r\n        this._bom = _bom;\r\n        this._cr = _cr;\r\n        this._lf = _lf;\r\n        this._crlf = _crlf;\r\n        this._containsRTL = _containsRTL;\r\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\r\n        this._isBasicASCII = _isBasicASCII;\r\n        this._normalizeEOL = _normalizeEOL;\r\n    }\r\n    _getEOL(defaultEOL) {\r\n        const totalEOLCount = this._cr + this._lf + this._crlf;\r\n        const totalCRCount = this._cr + this._crlf;\r\n        if (totalEOLCount === 0) {\r\n            // This is an empty file or a file with precisely one line\r\n            return (defaultEOL === 1 /* LF */ ? '\\n' : '\\r\\n');\r\n        }\r\n        if (totalCRCount > totalEOLCount / 2) {\r\n            // More than half of the file contains \\r\\n ending lines\r\n            return '\\r\\n';\r\n        }\r\n        // At least one line more ends in \\n\r\n        return '\\n';\r\n    }\r\n    create(defaultEOL) {\r\n        const eol = this._getEOL(defaultEOL);\r\n        let chunks = this._chunks;\r\n        if (this._normalizeEOL &&\r\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\r\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\r\n            // Normalize pieces\r\n            for (let i = 0, len = chunks.length; i < len; i++) {\r\n                let str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\r\n                let newLineStart = createLineStartsFast(str);\r\n                chunks[i] = new StringBuffer(str, newLineStart);\r\n            }\r\n        }\r\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\r\n        return { textBuffer: textBuffer, disposable: textBuffer };\r\n    }\r\n}\r\nexport class PieceTreeTextBufferBuilder {\r\n    constructor() {\r\n        this.chunks = [];\r\n        this.BOM = '';\r\n        this._hasPreviousChar = false;\r\n        this._previousChar = 0;\r\n        this._tmpLineStarts = [];\r\n        this.cr = 0;\r\n        this.lf = 0;\r\n        this.crlf = 0;\r\n        this.containsRTL = false;\r\n        this.containsUnusualLineTerminators = false;\r\n        this.isBasicASCII = true;\r\n    }\r\n    acceptChunk(chunk) {\r\n        if (chunk.length === 0) {\r\n            return;\r\n        }\r\n        if (this.chunks.length === 0) {\r\n            if (strings.startsWithUTF8BOM(chunk)) {\r\n                this.BOM = strings.UTF8_BOM_CHARACTER;\r\n                chunk = chunk.substr(1);\r\n            }\r\n        }\r\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\r\n        if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n            // last character is \\r or a high surrogate => keep it back\r\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\r\n            this._hasPreviousChar = true;\r\n            this._previousChar = lastChar;\r\n        }\r\n        else {\r\n            this._acceptChunk1(chunk, false);\r\n            this._hasPreviousChar = false;\r\n            this._previousChar = lastChar;\r\n        }\r\n    }\r\n    _acceptChunk1(chunk, allowEmptyStrings) {\r\n        if (!allowEmptyStrings && chunk.length === 0) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\r\n        }\r\n        else {\r\n            this._acceptChunk2(chunk);\r\n        }\r\n    }\r\n    _acceptChunk2(chunk) {\r\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\r\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\r\n        this.cr += lineStarts.cr;\r\n        this.lf += lineStarts.lf;\r\n        this.crlf += lineStarts.crlf;\r\n        if (this.isBasicASCII) {\r\n            this.isBasicASCII = lineStarts.isBasicASCII;\r\n        }\r\n        if (!this.isBasicASCII && !this.containsRTL) {\r\n            // No need to check if it is basic ASCII\r\n            this.containsRTL = strings.containsRTL(chunk);\r\n        }\r\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\r\n            // No need to check if it is basic ASCII\r\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\r\n        }\r\n    }\r\n    finish(normalizeEOL = true) {\r\n        this._finish();\r\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\r\n    }\r\n    _finish() {\r\n        if (this.chunks.length === 0) {\r\n            this._acceptChunk1('', true);\r\n        }\r\n        if (this._hasPreviousChar) {\r\n            this._hasPreviousChar = false;\r\n            // recreate last chunk\r\n            let lastChunk = this.chunks[this.chunks.length - 1];\r\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\r\n            let newLineStarts = createLineStartsFast(lastChunk.buffer);\r\n            lastChunk.lineStarts = newLineStarts;\r\n            if (this._previousChar === 13 /* CarriageReturn */) {\r\n                this.cr++;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}