{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch } from '../model.js';\nvar LIMIT_FIND_COUNT = 999;\nexport var SearchParams = /*#__PURE__*/function () {\n  function SearchParams(searchString, isRegex, matchCase, wordSeparators) {\n    _classCallCheck(this, SearchParams);\n\n    this.searchString = searchString;\n    this.isRegex = isRegex;\n    this.matchCase = matchCase;\n    this.wordSeparators = wordSeparators;\n  }\n\n  _createClass(SearchParams, [{\n    key: \"parseSearchRequest\",\n    value: function parseSearchRequest() {\n      if (this.searchString === '') {\n        return null;\n      } // Try to create a RegExp out of the params\n\n\n      var multiline;\n\n      if (this.isRegex) {\n        multiline = isMultilineRegexSource(this.searchString);\n      } else {\n        multiline = this.searchString.indexOf('\\n') >= 0;\n      }\n\n      var regex = null;\n\n      try {\n        regex = strings.createRegExp(this.searchString, this.isRegex, {\n          matchCase: this.matchCase,\n          wholeWord: false,\n          multiline: multiline,\n          global: true,\n          unicode: true\n        });\n      } catch (err) {\n        return null;\n      }\n\n      if (!regex) {\n        return null;\n      }\n\n      var canUseSimpleSearch = !this.isRegex && !multiline;\n\n      if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n        // casing might make a difference\n        canUseSimpleSearch = this.matchCase;\n      }\n\n      return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n  }]);\n\n  return SearchParams;\n}();\nexport function isMultilineRegexSource(searchString) {\n  if (!searchString || searchString.length === 0) {\n    return false;\n  }\n\n  for (var i = 0, len = searchString.length; i < len; i++) {\n    var chCode = searchString.charCodeAt(i);\n\n    if (chCode === 92\n    /* Backslash */\n    ) {\n        // move to next char\n        i++;\n\n        if (i >= len) {\n          // string ends with a \\\n          break;\n        }\n\n        var nextChCode = searchString.charCodeAt(i);\n\n        if (nextChCode === 110\n        /* n */\n        || nextChCode === 114\n        /* r */\n        || nextChCode === 87\n        /* W */\n        || nextChCode === 119\n        /* w */\n        ) {\n            return true;\n          }\n      }\n  }\n\n  return false;\n}\nexport var SearchData = function SearchData(regex, wordSeparators, simpleSearch) {\n  _classCallCheck(this, SearchData);\n\n  this.regex = regex;\n  this.wordSeparators = wordSeparators;\n  this.simpleSearch = simpleSearch;\n};\nexport function createFindMatch(range, rawMatches, captureMatches) {\n  if (!captureMatches) {\n    return new FindMatch(range, null);\n  }\n\n  var matches = [];\n\n  for (var i = 0, len = rawMatches.length; i < len; i++) {\n    matches[i] = rawMatches[i];\n  }\n\n  return new FindMatch(range, matches);\n}\n\nvar LineFeedCounter = /*#__PURE__*/function () {\n  function LineFeedCounter(text) {\n    _classCallCheck(this, LineFeedCounter);\n\n    var lineFeedsOffsets = [];\n    var lineFeedsOffsetsLen = 0;\n\n    for (var i = 0, textLen = text.length; i < textLen; i++) {\n      if (text.charCodeAt(i) === 10\n      /* LineFeed */\n      ) {\n          lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n        }\n    }\n\n    this._lineFeedsOffsets = lineFeedsOffsets;\n  }\n\n  _createClass(LineFeedCounter, [{\n    key: \"findLineFeedCountBeforeOffset\",\n    value: function findLineFeedCountBeforeOffset(offset) {\n      var lineFeedsOffsets = this._lineFeedsOffsets;\n      var min = 0;\n      var max = lineFeedsOffsets.length - 1;\n\n      if (max === -1) {\n        // no line feeds\n        return 0;\n      }\n\n      if (offset <= lineFeedsOffsets[0]) {\n        // before first line feed\n        return 0;\n      }\n\n      while (min < max) {\n        var mid = min + ((max - min) / 2 >> 0);\n\n        if (lineFeedsOffsets[mid] >= offset) {\n          max = mid - 1;\n        } else {\n          if (lineFeedsOffsets[mid + 1] >= offset) {\n            // bingo!\n            min = mid;\n            max = mid;\n          } else {\n            min = mid + 1;\n          }\n        }\n      }\n\n      return min + 1;\n    }\n  }]);\n\n  return LineFeedCounter;\n}();\n\nexport var TextModelSearch = /*#__PURE__*/function () {\n  function TextModelSearch() {\n    _classCallCheck(this, TextModelSearch);\n  }\n\n  _createClass(TextModelSearch, null, [{\n    key: \"findMatches\",\n    value: function findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n      var searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return [];\n      }\n\n      if (searchData.regex.multiline) {\n        return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n      }\n\n      return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\n\n  }, {\n    key: \"_getMultilineMatchRange\",\n    value: function _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n      var startOffset;\n      var lineFeedCountBeforeMatch = 0;\n\n      if (lfCounter) {\n        lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n        startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch\n        /* add as many \\r as there were \\n */\n        ;\n      } else {\n        startOffset = deltaOffset + matchIndex;\n      }\n\n      var endOffset;\n\n      if (lfCounter) {\n        var lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n        var lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n        endOffset = startOffset + match0.length + lineFeedCountInMatch\n        /* add as many \\r as there were \\n */\n        ;\n      } else {\n        endOffset = startOffset + match0.length;\n      }\n\n      var startPosition = model.getPositionAt(startOffset);\n      var endPosition = model.getPositionAt(endOffset);\n      return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n  }, {\n    key: \"_doFindMatchesMultiline\",\n    value: function _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n      var deltaOffset = model.getOffsetAt(searchRange.getStartPosition()); // We always execute multiline search over the lines joined with \\n\n      // This makes it that \\n will match the EOL for both CRLF and LF models\n      // We compensate for offset errors in `_getMultilineMatchRange`\n\n      var text = model.getValueInRange(searchRange, 1\n      /* LF */\n      );\n      var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n      var result = [];\n      var counter = 0;\n      var m;\n      searcher.reset(0);\n\n      while (m = searcher.next(text)) {\n        result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n\n        if (counter >= limitResultCount) {\n          return result;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_doFindMatchesLineByLine\",\n    value: function _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n      var result = [];\n      var resultLen = 0; // Early case for a search range that starts & stops on the same line number\n\n      if (searchRange.startLineNumber === searchRange.endLineNumber) {\n        var _text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n\n        resultLen = this._findMatchesInLine(searchData, _text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      } // Collect results from first line\n\n\n      var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n      resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount); // Collect results from middle lines\n\n      for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n        resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n      } // Collect results from last line\n\n\n      if (resultLen < limitResultCount) {\n        var _text2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n\n        resultLen = this._findMatchesInLine(searchData, _text2, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_findMatchesInLine\",\n    value: function _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n      var wordSeparators = searchData.wordSeparators;\n\n      if (!captureMatches && searchData.simpleSearch) {\n        var searchString = searchData.simpleSearch;\n        var searchStringLen = searchString.length;\n        var textLength = text.length;\n        var lastMatchIndex = -searchStringLen;\n\n        while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n          if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n            result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n            if (resultLen >= limitResultCount) {\n              return resultLen;\n            }\n          }\n        }\n\n        return resultLen;\n      }\n\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      var m; // Reset regex to search from the beginning\n\n      searcher.reset(0);\n\n      do {\n        m = searcher.next(text);\n\n        if (m) {\n          result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n\n      return resultLen;\n    }\n  }, {\n    key: \"findNextMatch\",\n    value: function findNextMatch(model, searchParams, searchStart, captureMatches) {\n      var searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return null;\n      }\n\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n      if (searchData.regex.multiline) {\n        return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n      }\n\n      return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n  }, {\n    key: \"_doFindNextMatchMultiline\",\n    value: function _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n      var searchTextStart = new Position(searchStart.lineNumber, 1);\n      var deltaOffset = model.getOffsetAt(searchTextStart);\n      var lineCount = model.getLineCount(); // We always execute multiline search over the lines joined with \\n\n      // This makes it that \\n will match the EOL for both CRLF and LF models\n      // We compensate for offset errors in `_getMultilineMatchRange`\n\n      var text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1\n      /* LF */\n      );\n      var lfCounter = model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null;\n      searcher.reset(searchStart.column - 1);\n      var m = searcher.next(text);\n\n      if (m) {\n        return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n      }\n\n      if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n        // Try again from the top\n        return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_doFindNextMatchLineByLine\",\n    value: function _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n      var lineCount = model.getLineCount();\n      var startLineNumber = searchStart.lineNumber; // Look in first line\n\n      var text = model.getLineContent(startLineNumber);\n\n      var r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n\n      if (r) {\n        return r;\n      }\n\n      for (var i = 1; i <= lineCount; i++) {\n        var lineIndex = (startLineNumber + i - 1) % lineCount;\n\n        var _text3 = model.getLineContent(lineIndex + 1);\n\n        var _r = this._findFirstMatchInLine(searcher, _text3, lineIndex + 1, 1, captureMatches);\n\n        if (_r) {\n          return _r;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_findFirstMatchInLine\",\n    value: function _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n      // Set regex to search from column\n      searcher.reset(fromColumn - 1);\n      var m = searcher.next(text);\n\n      if (m) {\n        return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findPreviousMatch\",\n    value: function findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n      var searchData = searchParams.parseSearchRequest();\n\n      if (!searchData) {\n        return null;\n      }\n\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n\n      if (searchData.regex.multiline) {\n        return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n      }\n\n      return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n  }, {\n    key: \"_doFindPreviousMatchMultiline\",\n    value: function _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n      var matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n\n      if (matches.length > 0) {\n        return matches[matches.length - 1];\n      }\n\n      var lineCount = model.getLineCount();\n\n      if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n        // Try again with all content\n        return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_doFindPreviousMatchLineByLine\",\n    value: function _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n      var lineCount = model.getLineCount();\n      var startLineNumber = searchStart.lineNumber; // Look in first line\n\n      var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n\n      var r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n\n      if (r) {\n        return r;\n      }\n\n      for (var i = 1; i <= lineCount; i++) {\n        var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n\n        var _text4 = model.getLineContent(lineIndex + 1);\n\n        var _r2 = this._findLastMatchInLine(searcher, _text4, lineIndex + 1, captureMatches);\n\n        if (_r2) {\n          return _r2;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_findLastMatchInLine\",\n    value: function _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n      var bestResult = null;\n      var m;\n      searcher.reset(0);\n\n      while (m = searcher.next(text)) {\n        bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n      }\n\n      return bestResult;\n    }\n  }]);\n\n  return TextModelSearch;\n}();\n\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex === 0) {\n    // Match starts at start of string\n    return true;\n  }\n\n  var charBefore = text.charCodeAt(matchStartIndex - 1);\n\n  if (wordSeparators.get(charBefore) !== 0\n  /* Regular */\n  ) {\n      // The character before the match is a word separator\n      return true;\n    }\n\n  if (charBefore === 13\n  /* CarriageReturn */\n  || charBefore === 10\n  /* LineFeed */\n  ) {\n      // The character before the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var firstCharInMatch = text.charCodeAt(matchStartIndex);\n\n    if (wordSeparators.get(firstCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The first character inside the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  if (matchStartIndex + matchLength === textLength) {\n    // Match ends at end of string\n    return true;\n  }\n\n  var charAfter = text.charCodeAt(matchStartIndex + matchLength);\n\n  if (wordSeparators.get(charAfter) !== 0\n  /* Regular */\n  ) {\n      // The character after the match is a word separator\n      return true;\n    }\n\n  if (charAfter === 13\n  /* CarriageReturn */\n  || charAfter === 10\n  /* LineFeed */\n  ) {\n      // The character after the match is line break or carriage return.\n      return true;\n    }\n\n  if (matchLength > 0) {\n    var lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n\n    if (wordSeparators.get(lastCharInMatch) !== 0\n    /* Regular */\n    ) {\n        // The last character in the match is a word separator\n        return true;\n      }\n  }\n\n  return false;\n}\n\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n  return leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength);\n}\nexport var Searcher = /*#__PURE__*/function () {\n  function Searcher(wordSeparators, searchRegex) {\n    _classCallCheck(this, Searcher);\n\n    this._wordSeparators = wordSeparators;\n    this._searchRegex = searchRegex;\n    this._prevMatchStartIndex = -1;\n    this._prevMatchLength = 0;\n  }\n\n  _createClass(Searcher, [{\n    key: \"reset\",\n    value: function reset(lastIndex) {\n      this._searchRegex.lastIndex = lastIndex;\n      this._prevMatchStartIndex = -1;\n      this._prevMatchLength = 0;\n    }\n  }, {\n    key: \"next\",\n    value: function next(text) {\n      var textLength = text.length;\n      var m;\n\n      do {\n        if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n          // Reached the end of the line\n          return null;\n        }\n\n        m = this._searchRegex.exec(text);\n\n        if (!m) {\n          return null;\n        }\n\n        var matchStartIndex = m.index;\n        var matchLength = m[0].length;\n\n        if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n          if (matchLength === 0) {\n            // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n            // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n            if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n              this._searchRegex.lastIndex += 2;\n            } else {\n              this._searchRegex.lastIndex += 1;\n            }\n\n            continue;\n          } // Exit early if the regex matches the same range twice\n\n\n          return null;\n        }\n\n        this._prevMatchStartIndex = matchStartIndex;\n        this._prevMatchLength = matchLength;\n\n        if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n          return m;\n        }\n      } while (m);\n\n      return null;\n    }\n  }]);\n\n  return Searcher;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js"],"names":["strings","getMapForWordSeparators","Position","Range","FindMatch","LIMIT_FIND_COUNT","SearchParams","searchString","isRegex","matchCase","wordSeparators","multiline","isMultilineRegexSource","indexOf","regex","createRegExp","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","length","i","len","chCode","charCodeAt","nextChCode","simpleSearch","createFindMatch","range","rawMatches","captureMatches","matches","LineFeedCounter","text","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","offset","min","max","mid","TextModelSearch","model","searchParams","searchRange","limitResultCount","searchData","parseSearchRequest","_doFindMatchesMultiline","Searcher","_doFindMatchesLineByLine","deltaOffset","lfCounter","matchIndex","match0","startOffset","lineFeedCountBeforeMatch","findLineFeedCountBeforeOffset","endOffset","lineFeedCountBeforeEndOfMatch","lineFeedCountInMatch","startPosition","getPositionAt","endPosition","lineNumber","column","searcher","getOffsetAt","getStartPosition","getValueInRange","getEOL","result","counter","m","reset","next","_getMultilineMatchRange","index","resultLen","startLineNumber","endLineNumber","getLineContent","substring","startColumn","endColumn","_findMatchesInLine","searchStringLen","textLength","lastMatchIndex","isValidMatch","searchStart","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","lineCount","getLineCount","getLineMaxColumn","r","_findFirstMatchInLine","lineIndex","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","leftIsWordBounday","matchStartIndex","matchLength","charBefore","get","firstCharInMatch","rightIsWordBounday","charAfter","lastCharInMatch","searchRegex","_wordSeparators","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","getNextCodePoint"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { getMapForWordSeparators } from '../controller/wordCharacterClassifier.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { FindMatch } from '../model.js';\r\nconst LIMIT_FIND_COUNT = 999;\r\nexport class SearchParams {\r\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\r\n        this.searchString = searchString;\r\n        this.isRegex = isRegex;\r\n        this.matchCase = matchCase;\r\n        this.wordSeparators = wordSeparators;\r\n    }\r\n    parseSearchRequest() {\r\n        if (this.searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        let multiline;\r\n        if (this.isRegex) {\r\n            multiline = isMultilineRegexSource(this.searchString);\r\n        }\r\n        else {\r\n            multiline = (this.searchString.indexOf('\\n') >= 0);\r\n        }\r\n        let regex = null;\r\n        try {\r\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\r\n                matchCase: this.matchCase,\r\n                wholeWord: false,\r\n                multiline: multiline,\r\n                global: true,\r\n                unicode: true\r\n            });\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        if (!regex) {\r\n            return null;\r\n        }\r\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\r\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\r\n            // casing might make a difference\r\n            canUseSimpleSearch = this.matchCase;\r\n        }\r\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\r\n    }\r\n}\r\nexport function isMultilineRegexSource(searchString) {\r\n    if (!searchString || searchString.length === 0) {\r\n        return false;\r\n    }\r\n    for (let i = 0, len = searchString.length; i < len; i++) {\r\n        const chCode = searchString.charCodeAt(i);\r\n        if (chCode === 92 /* Backslash */) {\r\n            // move to next char\r\n            i++;\r\n            if (i >= len) {\r\n                // string ends with a \\\r\n                break;\r\n            }\r\n            const nextChCode = searchString.charCodeAt(i);\r\n            if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */ || nextChCode === 87 /* W */ || nextChCode === 119 /* w */) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport class SearchData {\r\n    constructor(regex, wordSeparators, simpleSearch) {\r\n        this.regex = regex;\r\n        this.wordSeparators = wordSeparators;\r\n        this.simpleSearch = simpleSearch;\r\n    }\r\n}\r\nexport function createFindMatch(range, rawMatches, captureMatches) {\r\n    if (!captureMatches) {\r\n        return new FindMatch(range, null);\r\n    }\r\n    let matches = [];\r\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\r\n        matches[i] = rawMatches[i];\r\n    }\r\n    return new FindMatch(range, matches);\r\n}\r\nclass LineFeedCounter {\r\n    constructor(text) {\r\n        let lineFeedsOffsets = [];\r\n        let lineFeedsOffsetsLen = 0;\r\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\r\n            if (text.charCodeAt(i) === 10 /* LineFeed */) {\r\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\r\n            }\r\n        }\r\n        this._lineFeedsOffsets = lineFeedsOffsets;\r\n    }\r\n    findLineFeedCountBeforeOffset(offset) {\r\n        const lineFeedsOffsets = this._lineFeedsOffsets;\r\n        let min = 0;\r\n        let max = lineFeedsOffsets.length - 1;\r\n        if (max === -1) {\r\n            // no line feeds\r\n            return 0;\r\n        }\r\n        if (offset <= lineFeedsOffsets[0]) {\r\n            // before first line feed\r\n            return 0;\r\n        }\r\n        while (min < max) {\r\n            const mid = min + ((max - min) / 2 >> 0);\r\n            if (lineFeedsOffsets[mid] >= offset) {\r\n                max = mid - 1;\r\n            }\r\n            else {\r\n                if (lineFeedsOffsets[mid + 1] >= offset) {\r\n                    // bingo!\r\n                    min = mid;\r\n                    max = mid;\r\n                }\r\n                else {\r\n                    min = mid + 1;\r\n                }\r\n            }\r\n        }\r\n        return min + 1;\r\n    }\r\n}\r\nexport class TextModelSearch {\r\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return [];\r\n        }\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\r\n        }\r\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    /**\r\n     * Multiline search always executes on the lines concatenated with \\n.\r\n     * We must therefore compensate for the count of \\n in case the model is CRLF\r\n     */\r\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\r\n        let startOffset;\r\n        let lineFeedCountBeforeMatch = 0;\r\n        if (lfCounter) {\r\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\r\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            startOffset = deltaOffset + matchIndex;\r\n        }\r\n        let endOffset;\r\n        if (lfCounter) {\r\n            let lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\r\n            let lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\r\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\r\n        }\r\n        else {\r\n            endOffset = startOffset + match0.length;\r\n        }\r\n        const startPosition = model.getPositionAt(startOffset);\r\n        const endPosition = model.getPositionAt(endOffset);\r\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\r\n    }\r\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\r\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        const text = model.getValueInRange(searchRange, 1 /* LF */);\r\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        const result = [];\r\n        let counter = 0;\r\n        let m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n            if (counter >= limitResultCount) {\r\n                return result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\r\n        const result = [];\r\n        let resultLen = 0;\r\n        // Early case for a search range that starts & stops on the same line number\r\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\r\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        // Collect results from first line\r\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\r\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\r\n        // Collect results from middle lines\r\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\r\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        // Collect results from last line\r\n        if (resultLen < limitResultCount) {\r\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\r\n        }\r\n        return result;\r\n    }\r\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        const wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            const searchString = searchData.simpleSearch;\r\n            const searchStringLen = searchString.length;\r\n            const textLength = text.length;\r\n            let lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        let m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    }\r\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    }\r\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\r\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\r\n        const deltaOffset = model.getOffsetAt(searchTextStart);\r\n        const lineCount = model.getLineCount();\r\n        // We always execute multiline search over the lines joined with \\n\r\n        // This makes it that \\n will match the EOL for both CRLF and LF models\r\n        // We compensate for offset errors in `_getMultilineMatchRange`\r\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* LF */);\r\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\r\n        searcher.reset(searchStart.column - 1);\r\n        let m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\r\n        }\r\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\r\n            // Try again from the top\r\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\r\n        const lineCount = model.getLineCount();\r\n        const startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        const text = model.getLineContent(startLineNumber);\r\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (let i = 1; i <= lineCount; i++) {\r\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\r\n            const text = model.getLineContent(lineIndex + 1);\r\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\r\n        // Set regex to search from column\r\n        searcher.reset(fromColumn - 1);\r\n        const m = searcher.next(text);\r\n        if (m) {\r\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\r\n        const searchData = searchParams.parseSearchRequest();\r\n        if (!searchData) {\r\n            return null;\r\n        }\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        if (searchData.regex.multiline) {\r\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\r\n        }\r\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\r\n    }\r\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\r\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\r\n        if (matches.length > 0) {\r\n            return matches[matches.length - 1];\r\n        }\r\n        const lineCount = model.getLineCount();\r\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\r\n            // Try again with all content\r\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\r\n        }\r\n        return null;\r\n    }\r\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\r\n        const lineCount = model.getLineCount();\r\n        const startLineNumber = searchStart.lineNumber;\r\n        // Look in first line\r\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\r\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\r\n        if (r) {\r\n            return r;\r\n        }\r\n        for (let i = 1; i <= lineCount; i++) {\r\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\r\n            const text = model.getLineContent(lineIndex + 1);\r\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\r\n            if (r) {\r\n                return r;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\r\n        let bestResult = null;\r\n        let m;\r\n        searcher.reset(0);\r\n        while ((m = searcher.next(text))) {\r\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\r\n        }\r\n        return bestResult;\r\n    }\r\n}\r\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex === 0) {\r\n        // Match starts at start of string\r\n        return true;\r\n    }\r\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\r\n    if (wordSeparators.get(charBefore) !== 0 /* Regular */) {\r\n        // The character before the match is a word separator\r\n        return true;\r\n    }\r\n    if (charBefore === 13 /* CarriageReturn */ || charBefore === 10 /* LineFeed */) {\r\n        // The character before the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\r\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* Regular */) {\r\n            // The first character inside the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    if (matchStartIndex + matchLength === textLength) {\r\n        // Match ends at end of string\r\n        return true;\r\n    }\r\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\r\n    if (wordSeparators.get(charAfter) !== 0 /* Regular */) {\r\n        // The character after the match is a word separator\r\n        return true;\r\n    }\r\n    if (charAfter === 13 /* CarriageReturn */ || charAfter === 10 /* LineFeed */) {\r\n        // The character after the match is line break or carriage return.\r\n        return true;\r\n    }\r\n    if (matchLength > 0) {\r\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\r\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* Regular */) {\r\n            // The last character in the match is a word separator\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\r\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\r\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\r\n}\r\nexport class Searcher {\r\n    constructor(wordSeparators, searchRegex) {\r\n        this._wordSeparators = wordSeparators;\r\n        this._searchRegex = searchRegex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    reset(lastIndex) {\r\n        this._searchRegex.lastIndex = lastIndex;\r\n        this._prevMatchStartIndex = -1;\r\n        this._prevMatchLength = 0;\r\n    }\r\n    next(text) {\r\n        const textLength = text.length;\r\n        let m;\r\n        do {\r\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\r\n                // Reached the end of the line\r\n                return null;\r\n            }\r\n            m = this._searchRegex.exec(text);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            const matchStartIndex = m.index;\r\n            const matchLength = m[0].length;\r\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\r\n                if (matchLength === 0) {\r\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\r\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\r\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\r\n                        this._searchRegex.lastIndex += 2;\r\n                    }\r\n                    else {\r\n                        this._searchRegex.lastIndex += 1;\r\n                    }\r\n                    continue;\r\n                }\r\n                // Exit early if the regex matches the same range twice\r\n                return null;\r\n            }\r\n            this._prevMatchStartIndex = matchStartIndex;\r\n            this._prevMatchLength = matchLength;\r\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\r\n                return m;\r\n            }\r\n        } while (m);\r\n        return null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}