{"ast":null,"code":"import _defineProperty from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _encodeTable;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { isWindows } from './platform.js';\nimport * as paths from './path.js';\nvar _schemePattern = /^\\w[\\w\\d+.-]*$/;\nvar _singleSlashStart = /^\\//;\nvar _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret, _strict) {\n  // scheme, must be set\n  if (!ret.scheme && _strict) {\n    throw new Error(\"[UriError]: Scheme is missing: {scheme: \\\"\\\", authority: \\\"\".concat(ret.authority, \"\\\", path: \\\"\").concat(ret.path, \"\\\", query: \\\"\").concat(ret.query, \"\\\", fragment: \\\"\").concat(ret.fragment, \"\\\"}\"));\n  } // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n  // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\n\n  if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n    throw new Error('[UriError]: Scheme contains illegal characters.');\n  } // path, http://tools.ietf.org/html/rfc3986#section-3.3\n  // If a URI contains an authority component, then the path component\n  // must either be empty or begin with a slash (\"/\") character.  If a URI\n  // does not contain an authority component, then the path cannot begin\n  // with two slash characters (\"//\").\n\n\n  if (ret.path) {\n    if (ret.authority) {\n      if (!_singleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n      }\n    } else {\n      if (_doubleSlashStart.test(ret.path)) {\n        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n      }\n    }\n  }\n} // for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\n\n\nfunction _schemeFix(scheme, _strict) {\n  if (!scheme && !_strict) {\n    return 'file';\n  }\n\n  return scheme;\n} // implements a bit of https://tools.ietf.org/html/rfc3986#section-5\n\n\nfunction _referenceResolution(scheme, path) {\n  // the slash-character is our 'default base' as we don't\n  // support constructing URIs relative to other URIs. This\n  // also means that we alter and potentially break paths.\n  // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n  switch (scheme) {\n    case 'https':\n    case 'http':\n    case 'file':\n      if (!path) {\n        path = _slash;\n      } else if (path[0] !== _slash) {\n        path = _slash + path;\n      }\n\n      break;\n  }\n\n  return path;\n}\n\nvar _empty = '';\nvar _slash = '/';\nvar _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\r\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n * This class is a simple parser which creates the basic component parts\r\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n * and encoding.\r\n *\r\n * ```txt\r\n *       foo://example.com:8042/over/there?name=ferret#nose\r\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n *        |           |            |            |        |\r\n *     scheme     authority       path        query   fragment\r\n *        |   _____________________|__\r\n *       / \\ /                        \\\r\n *       urn:example:animal:ferret:nose\r\n * ```\r\n */\n\nexport var URI = /*#__PURE__*/function () {\n  /**\r\n   * @internal\r\n   */\n  function URI(schemeOrData, authority, path, query, fragment) {\n    var _strict = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, URI);\n\n    if (typeof schemeOrData === 'object') {\n      this.scheme = schemeOrData.scheme || _empty;\n      this.authority = schemeOrData.authority || _empty;\n      this.path = schemeOrData.path || _empty;\n      this.query = schemeOrData.query || _empty;\n      this.fragment = schemeOrData.fragment || _empty; // no validation because it's this URI\n      // that creates uri components.\n      // _validateUri(this);\n    } else {\n      this.scheme = _schemeFix(schemeOrData, _strict);\n      this.authority = authority || _empty;\n      this.path = _referenceResolution(this.scheme, path || _empty);\n      this.query = query || _empty;\n      this.fragment = fragment || _empty;\n\n      _validateUri(this, _strict);\n    }\n  }\n\n  _createClass(URI, [{\n    key: \"with\",\n    // ---- modify to new -------------------------\n    value: function _with(change) {\n      if (!change) {\n        return this;\n      }\n\n      var scheme = change.scheme,\n          authority = change.authority,\n          path = change.path,\n          query = change.query,\n          fragment = change.fragment;\n\n      if (scheme === undefined) {\n        scheme = this.scheme;\n      } else if (scheme === null) {\n        scheme = _empty;\n      }\n\n      if (authority === undefined) {\n        authority = this.authority;\n      } else if (authority === null) {\n        authority = _empty;\n      }\n\n      if (path === undefined) {\n        path = this.path;\n      } else if (path === null) {\n        path = _empty;\n      }\n\n      if (query === undefined) {\n        query = this.query;\n      } else if (query === null) {\n        query = _empty;\n      }\n\n      if (fragment === undefined) {\n        fragment = this.fragment;\n      } else if (fragment === null) {\n        fragment = _empty;\n      }\n\n      if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {\n        return this;\n      }\n\n      return new Uri(scheme, authority, path, query, fragment);\n    } // ---- parse & validate ------------------------\n\n    /**\r\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\r\n     * `file:///usr/home`, or `scheme:with/path`.\r\n     *\r\n     * @param value A string which represents an URI (see `URI#toString`).\r\n     */\n\n  }, {\n    key: \"toString\",\n    // ---- printing/externalize ---------------------------\n\n    /**\r\n     * Creates a string representation for this URI. It's guaranteed that calling\r\n     * `URI.parse` with the result of this function creates an URI which is equal\r\n     * to this URI.\r\n     *\r\n     * * The result shall *not* be used for display purposes but for externalization or transport.\r\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\r\n     * ignore the scheme-specific encoding rules.\r\n     *\r\n     * @param skipEncoding Do not encode the result, default is `false`\r\n     */\n    value: function toString() {\n      var skipEncoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return _asFormatted(this, skipEncoding);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this;\n    }\n  }, {\n    key: \"fsPath\",\n    // ---- filesystem path -----------------------\n\n    /**\r\n     * Returns a string representing the corresponding file system path of this URI.\r\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\r\n     * platform specific path separator.\r\n     *\r\n     * * Will *not* validate the path for invalid characters and semantics.\r\n     * * Will *not* look at the scheme of this URI.\r\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\r\n     *\r\n     *\r\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\r\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\r\n     *\r\n     * ```ts\r\n        const u = URI.parse('file://server/c$/folder/file.txt')\r\n        u.authority === 'server'\r\n        u.path === '/shares/c$/file.txt'\r\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\r\n    ```\r\n     *\r\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\r\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\r\n     * with URIs that represent files on disk (`file` scheme).\r\n     */\n    get: function get() {\n      // if (this.scheme !== 'file') {\n      // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n      // }\n      return uriToFsPath(this, false);\n    }\n  }], [{\n    key: \"isUri\",\n    value: function isUri(thing) {\n      if (thing instanceof URI) {\n        return true;\n      }\n\n      if (!thing) {\n        return false;\n      }\n\n      return typeof thing.authority === 'string' && typeof thing.fragment === 'string' && typeof thing.path === 'string' && typeof thing.query === 'string' && typeof thing.scheme === 'string' && typeof thing.fsPath === 'string' && typeof thing[\"with\"] === 'function' && typeof thing.toString === 'function';\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(value) {\n      var _strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var match = _regexp.exec(value);\n\n      if (!match) {\n        return new Uri(_empty, _empty, _empty, _empty, _empty);\n      }\n\n      return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\r\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\r\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\r\n     *\r\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\r\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\r\n     * `URI.parse('file://' + path)` because the path might contain characters that are\r\n     * interpreted (# and ?). See the following sample:\r\n     * ```ts\r\n    const good = URI.file('/coding/c#/project1');\r\n    good.scheme === 'file';\r\n    good.path === '/coding/c#/project1';\r\n    good.fragment === '';\r\n    const bad = URI.parse('file://' + '/coding/c#/project1');\r\n    bad.scheme === 'file';\r\n    bad.path === '/coding/c'; // path is now broken\r\n    bad.fragment === '/project1';\r\n    ```\r\n     *\r\n     * @param path A file system path (see `URI#fsPath`)\r\n     */\n\n  }, {\n    key: \"file\",\n    value: function file(path) {\n      var authority = _empty; // normalize to fwd-slashes on windows,\n      // on other systems bwd-slashes are valid\n      // filename character, eg /f\\oo/ba\\r.txt\n\n      if (isWindows) {\n        path = path.replace(/\\\\/g, _slash);\n      } // check for authority as used in UNC shares\n      // or use the path as given\n\n\n      if (path[0] === _slash && path[1] === _slash) {\n        var idx = path.indexOf(_slash, 2);\n\n        if (idx === -1) {\n          authority = path.substring(2);\n          path = _slash;\n        } else {\n          authority = path.substring(2, idx);\n          path = path.substring(idx) || _slash;\n        }\n      }\n\n      return new Uri('file', authority, path, _empty, _empty);\n    }\n  }, {\n    key: \"from\",\n    value: function from(components) {\n      return new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\n    }\n    /**\r\n     * Join a URI path with path fragments and normalizes the resulting path.\r\n     *\r\n     * @param uri The input URI.\r\n     * @param pathFragment The path fragment to add to the URI path.\r\n     * @returns The resulting URI.\r\n     */\n\n  }, {\n    key: \"joinPath\",\n    value: function joinPath(uri) {\n      if (!uri.path) {\n        throw new Error(\"[UriError]: cannot call joinPath on URI without path\");\n      }\n\n      var newPath;\n\n      for (var _len = arguments.length, pathFragment = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        pathFragment[_key - 1] = arguments[_key];\n      }\n\n      if (isWindows && uri.scheme === 'file') {\n        var _paths$win;\n\n        newPath = URI.file((_paths$win = paths.win32).join.apply(_paths$win, [uriToFsPath(uri, true)].concat(pathFragment))).path;\n      } else {\n        var _paths$posix;\n\n        newPath = (_paths$posix = paths.posix).join.apply(_paths$posix, [uri.path].concat(pathFragment));\n      }\n\n      return uri[\"with\"]({\n        path: newPath\n      });\n    }\n  }, {\n    key: \"revive\",\n    value: function revive(data) {\n      if (!data) {\n        return data;\n      } else if (data instanceof URI) {\n        return data;\n      } else {\n        var result = new Uri(data);\n        result._formatted = data.external;\n        result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\n        return result;\n      }\n    }\n  }]);\n\n  return URI;\n}();\n\nvar _pathSepMarker = isWindows ? 1 : undefined; // This class exists so that URI is compatibile with vscode.Uri (API).\n\n\nvar Uri = /*#__PURE__*/function (_URI) {\n  _inherits(Uri, _URI);\n\n  var _super = _createSuper(Uri);\n\n  function Uri() {\n    var _this;\n\n    _classCallCheck(this, Uri);\n\n    _this = _super.apply(this, arguments);\n    _this._formatted = null;\n    _this._fsPath = null;\n    return _this;\n  }\n\n  _createClass(Uri, [{\n    key: \"toString\",\n    value: function toString() {\n      var skipEncoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!skipEncoding) {\n        if (!this._formatted) {\n          this._formatted = _asFormatted(this, false);\n        }\n\n        return this._formatted;\n      } else {\n        // we don't cache that\n        return _asFormatted(this, true);\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var res = {\n        $mid: 1\n      }; // cached state\n\n      if (this._fsPath) {\n        res.fsPath = this._fsPath;\n        res._sep = _pathSepMarker;\n      }\n\n      if (this._formatted) {\n        res.external = this._formatted;\n      } // uri components\n\n\n      if (this.path) {\n        res.path = this.path;\n      }\n\n      if (this.scheme) {\n        res.scheme = this.scheme;\n      }\n\n      if (this.authority) {\n        res.authority = this.authority;\n      }\n\n      if (this.query) {\n        res.query = this.query;\n      }\n\n      if (this.fragment) {\n        res.fragment = this.fragment;\n      }\n\n      return res;\n    }\n  }, {\n    key: \"fsPath\",\n    get: function get() {\n      if (!this._fsPath) {\n        this._fsPath = uriToFsPath(this, false);\n      }\n\n      return this._fsPath;\n    }\n  }]);\n\n  return Uri;\n}(URI); // reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\n\n\nvar encodeTable = (_encodeTable = {}, _defineProperty(_encodeTable, 58\n/* Colon */\n, '%3A'), _defineProperty(_encodeTable, 47\n/* Slash */\n, '%2F'), _defineProperty(_encodeTable, 63\n/* QuestionMark */\n, '%3F'), _defineProperty(_encodeTable, 35\n/* Hash */\n, '%23'), _defineProperty(_encodeTable, 91\n/* OpenSquareBracket */\n, '%5B'), _defineProperty(_encodeTable, 93\n/* CloseSquareBracket */\n, '%5D'), _defineProperty(_encodeTable, 64\n/* AtSign */\n, '%40'), _defineProperty(_encodeTable, 33\n/* ExclamationMark */\n, '%21'), _defineProperty(_encodeTable, 36\n/* DollarSign */\n, '%24'), _defineProperty(_encodeTable, 38\n/* Ampersand */\n, '%26'), _defineProperty(_encodeTable, 39\n/* SingleQuote */\n, '%27'), _defineProperty(_encodeTable, 40\n/* OpenParen */\n, '%28'), _defineProperty(_encodeTable, 41\n/* CloseParen */\n, '%29'), _defineProperty(_encodeTable, 42\n/* Asterisk */\n, '%2A'), _defineProperty(_encodeTable, 43\n/* Plus */\n, '%2B'), _defineProperty(_encodeTable, 44\n/* Comma */\n, '%2C'), _defineProperty(_encodeTable, 59\n/* Semicolon */\n, '%3B'), _defineProperty(_encodeTable, 61\n/* Equals */\n, '%3D'), _defineProperty(_encodeTable, 32\n/* Space */\n, '%20'), _encodeTable);\n\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\n  var res = undefined;\n  var nativeEncodePos = -1;\n\n  for (var pos = 0; pos < uriComponent.length; pos++) {\n    var code = uriComponent.charCodeAt(pos); // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\n    if (code >= 97\n    /* a */\n    && code <= 122\n    /* z */\n    || code >= 65\n    /* A */\n    && code <= 90\n    /* Z */\n    || code >= 48\n    /* Digit0 */\n    && code <= 57\n    /* Digit9 */\n    || code === 45\n    /* Dash */\n    || code === 46\n    /* Period */\n    || code === 95\n    /* Underline */\n    || code === 126\n    /* Tilde */\n    || allowSlash && code === 47\n    /* Slash */\n    ) {\n      // check if we are delaying native encode\n      if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n        nativeEncodePos = -1;\n      } // check if we write into a new string (by default we try to return the param)\n\n\n      if (res !== undefined) {\n        res += uriComponent.charAt(pos);\n      }\n    } else {\n      // encoding needed, we need to allocate a new string\n      if (res === undefined) {\n        res = uriComponent.substr(0, pos);\n      } // check with default table first\n\n\n      var escaped = encodeTable[code];\n\n      if (escaped !== undefined) {\n        // check if we are delaying native encode\n        if (nativeEncodePos !== -1) {\n          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n          nativeEncodePos = -1;\n        } // append escaped variant to result\n\n\n        res += escaped;\n      } else if (nativeEncodePos === -1) {\n        // use native encode only when needed\n        nativeEncodePos = pos;\n      }\n    }\n  }\n\n  if (nativeEncodePos !== -1) {\n    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n  }\n\n  return res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path) {\n  var res = undefined;\n\n  for (var pos = 0; pos < path.length; pos++) {\n    var code = path.charCodeAt(pos);\n\n    if (code === 35\n    /* Hash */\n    || code === 63\n    /* QuestionMark */\n    ) {\n        if (res === undefined) {\n          res = path.substr(0, pos);\n        }\n\n        res += encodeTable[code];\n      } else {\n      if (res !== undefined) {\n        res += path[pos];\n      }\n    }\n  }\n\n  return res !== undefined ? res : path;\n}\n/**\r\n * Compute `fsPath` for the given uri\r\n */\n\n\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\n  var value;\n\n  if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n    // unc path: file://shares/c$/far/boo\n    value = \"//\".concat(uri.authority).concat(uri.path);\n  } else if (uri.path.charCodeAt(0) === 47\n  /* Slash */\n  && (uri.path.charCodeAt(1) >= 65\n  /* A */\n  && uri.path.charCodeAt(1) <= 90\n  /* Z */\n  || uri.path.charCodeAt(1) >= 97\n  /* a */\n  && uri.path.charCodeAt(1) <= 122\n  /* z */\n  ) && uri.path.charCodeAt(2) === 58\n  /* Colon */\n  ) {\n      if (!keepDriveLetterCasing) {\n        // windows drive letter: file:///c:/far/boo\n        value = uri.path[1].toLowerCase() + uri.path.substr(2);\n      } else {\n        value = uri.path.substr(1);\n      }\n    } else {\n    // other path\n    value = uri.path;\n  }\n\n  if (isWindows) {\n    value = value.replace(/\\//g, '\\\\');\n  }\n\n  return value;\n}\n/**\r\n * Create the external version of a uri\r\n */\n\nfunction _asFormatted(uri, skipEncoding) {\n  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;\n  var res = '';\n  var scheme = uri.scheme,\n      authority = uri.authority,\n      path = uri.path,\n      query = uri.query,\n      fragment = uri.fragment;\n\n  if (scheme) {\n    res += scheme;\n    res += ':';\n  }\n\n  if (authority || scheme === 'file') {\n    res += _slash;\n    res += _slash;\n  }\n\n  if (authority) {\n    var idx = authority.indexOf('@');\n\n    if (idx !== -1) {\n      // <user>@<auth>\n      var userinfo = authority.substr(0, idx);\n      authority = authority.substr(idx + 1);\n      idx = userinfo.indexOf(':');\n\n      if (idx === -1) {\n        res += encoder(userinfo, false);\n      } else {\n        // <user>:<pass>@<auth>\n        res += encoder(userinfo.substr(0, idx), false);\n        res += ':';\n        res += encoder(userinfo.substr(idx + 1), false);\n      }\n\n      res += '@';\n    }\n\n    authority = authority.toLowerCase();\n    idx = authority.indexOf(':');\n\n    if (idx === -1) {\n      res += encoder(authority, false);\n    } else {\n      // <auth>:<port>\n      res += encoder(authority.substr(0, idx), false);\n      res += authority.substr(idx);\n    }\n  }\n\n  if (path) {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (path.length >= 3 && path.charCodeAt(0) === 47\n    /* Slash */\n    && path.charCodeAt(2) === 58\n    /* Colon */\n    ) {\n        var code = path.charCodeAt(1);\n\n        if (code >= 65\n        /* A */\n        && code <= 90\n        /* Z */\n        ) {\n            path = \"/\".concat(String.fromCharCode(code + 32), \":\").concat(path.substr(3)); // \"/c:\".length === 3\n          }\n      } else if (path.length >= 2 && path.charCodeAt(1) === 58\n    /* Colon */\n    ) {\n        var _code = path.charCodeAt(0);\n\n        if (_code >= 65\n        /* A */\n        && _code <= 90\n        /* Z */\n        ) {\n            path = \"\".concat(String.fromCharCode(_code + 32), \":\").concat(path.substr(2)); // \"/c:\".length === 3\n          }\n      } // encode the rest of the path\n\n\n    res += encoder(path, true);\n  }\n\n  if (query) {\n    res += '?';\n    res += encoder(query, false);\n  }\n\n  if (fragment) {\n    res += '#';\n    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n  }\n\n  return res;\n} // --- decode\n\n\nfunction decodeURIComponentGraceful(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (_a) {\n    if (str.length > 3) {\n      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n    } else {\n      return str;\n    }\n  }\n}\n\nvar _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str) {\n  if (!str.match(_rEncodedAsHex)) {\n    return str;\n  }\n\n  return str.replace(_rEncodedAsHex, function (match) {\n    return decodeURIComponentGraceful(match);\n  });\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/uri.js"],"names":["isWindows","paths","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","ret","_strict","scheme","Error","authority","path","query","fragment","test","_schemeFix","_referenceResolution","_slash","_empty","_regexp","URI","schemeOrData","change","undefined","Uri","skipEncoding","_asFormatted","uriToFsPath","thing","fsPath","toString","value","match","exec","percentDecode","replace","idx","indexOf","substring","components","uri","newPath","pathFragment","file","win32","join","posix","data","result","_formatted","external","_fsPath","_sep","_pathSepMarker","arguments","res","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","length","code","charCodeAt","encodeURIComponent","charAt","substr","escaped","encodeURIComponentMinimal","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","decodeURIComponentGraceful","str","decodeURIComponent","_a","_rEncodedAsHex"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { isWindows } from './platform.js';\r\nimport * as paths from './path.js';\r\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\r\nconst _singleSlashStart = /^\\//;\r\nconst _doubleSlashStart = /^\\/\\//;\r\nfunction _validateUri(ret, _strict) {\r\n    // scheme, must be set\r\n    if (!ret.scheme && _strict) {\r\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\r\n    }\r\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\r\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\r\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\r\n        throw new Error('[UriError]: Scheme contains illegal characters.');\r\n    }\r\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\r\n    // If a URI contains an authority component, then the path component\r\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\r\n    // does not contain an authority component, then the path cannot begin\r\n    // with two slash characters (\"//\").\r\n    if (ret.path) {\r\n        if (ret.authority) {\r\n            if (!_singleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n            }\r\n        }\r\n        else {\r\n            if (_doubleSlashStart.test(ret.path)) {\r\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n            }\r\n        }\r\n    }\r\n}\r\n// for a while we allowed uris *without* schemes and this is the migration\r\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\r\n// back to the file-scheme. that should cause the least carnage and still be a\r\n// clear warning\r\nfunction _schemeFix(scheme, _strict) {\r\n    if (!scheme && !_strict) {\r\n        return 'file';\r\n    }\r\n    return scheme;\r\n}\r\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\r\nfunction _referenceResolution(scheme, path) {\r\n    // the slash-character is our 'default base' as we don't\r\n    // support constructing URIs relative to other URIs. This\r\n    // also means that we alter and potentially break paths.\r\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\r\n    switch (scheme) {\r\n        case 'https':\r\n        case 'http':\r\n        case 'file':\r\n            if (!path) {\r\n                path = _slash;\r\n            }\r\n            else if (path[0] !== _slash) {\r\n                path = _slash + path;\r\n            }\r\n            break;\r\n    }\r\n    return path;\r\n}\r\nconst _empty = '';\r\nconst _slash = '/';\r\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n/**\r\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n * This class is a simple parser which creates the basic component parts\r\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n * and encoding.\r\n *\r\n * ```txt\r\n *       foo://example.com:8042/over/there?name=ferret#nose\r\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n *        |           |            |            |        |\r\n *     scheme     authority       path        query   fragment\r\n *        |   _____________________|__\r\n *       / \\ /                        \\\r\n *       urn:example:animal:ferret:nose\r\n * ```\r\n */\r\nexport class URI {\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\r\n        if (typeof schemeOrData === 'object') {\r\n            this.scheme = schemeOrData.scheme || _empty;\r\n            this.authority = schemeOrData.authority || _empty;\r\n            this.path = schemeOrData.path || _empty;\r\n            this.query = schemeOrData.query || _empty;\r\n            this.fragment = schemeOrData.fragment || _empty;\r\n            // no validation because it's this URI\r\n            // that creates uri components.\r\n            // _validateUri(this);\r\n        }\r\n        else {\r\n            this.scheme = _schemeFix(schemeOrData, _strict);\r\n            this.authority = authority || _empty;\r\n            this.path = _referenceResolution(this.scheme, path || _empty);\r\n            this.query = query || _empty;\r\n            this.fragment = fragment || _empty;\r\n            _validateUri(this, _strict);\r\n        }\r\n    }\r\n    static isUri(thing) {\r\n        if (thing instanceof URI) {\r\n            return true;\r\n        }\r\n        if (!thing) {\r\n            return false;\r\n        }\r\n        return typeof thing.authority === 'string'\r\n            && typeof thing.fragment === 'string'\r\n            && typeof thing.path === 'string'\r\n            && typeof thing.query === 'string'\r\n            && typeof thing.scheme === 'string'\r\n            && typeof thing.fsPath === 'string'\r\n            && typeof thing.with === 'function'\r\n            && typeof thing.toString === 'function';\r\n    }\r\n    // ---- filesystem path -----------------------\r\n    /**\r\n     * Returns a string representing the corresponding file system path of this URI.\r\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\r\n     * platform specific path separator.\r\n     *\r\n     * * Will *not* validate the path for invalid characters and semantics.\r\n     * * Will *not* look at the scheme of this URI.\r\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\r\n     *\r\n     *\r\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\r\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\r\n     *\r\n     * ```ts\r\n        const u = URI.parse('file://server/c$/folder/file.txt')\r\n        u.authority === 'server'\r\n        u.path === '/shares/c$/file.txt'\r\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\r\n    ```\r\n     *\r\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\r\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\r\n     * with URIs that represent files on disk (`file` scheme).\r\n     */\r\n    get fsPath() {\r\n        // if (this.scheme !== 'file') {\r\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\r\n        // }\r\n        return uriToFsPath(this, false);\r\n    }\r\n    // ---- modify to new -------------------------\r\n    with(change) {\r\n        if (!change) {\r\n            return this;\r\n        }\r\n        let { scheme, authority, path, query, fragment } = change;\r\n        if (scheme === undefined) {\r\n            scheme = this.scheme;\r\n        }\r\n        else if (scheme === null) {\r\n            scheme = _empty;\r\n        }\r\n        if (authority === undefined) {\r\n            authority = this.authority;\r\n        }\r\n        else if (authority === null) {\r\n            authority = _empty;\r\n        }\r\n        if (path === undefined) {\r\n            path = this.path;\r\n        }\r\n        else if (path === null) {\r\n            path = _empty;\r\n        }\r\n        if (query === undefined) {\r\n            query = this.query;\r\n        }\r\n        else if (query === null) {\r\n            query = _empty;\r\n        }\r\n        if (fragment === undefined) {\r\n            fragment = this.fragment;\r\n        }\r\n        else if (fragment === null) {\r\n            fragment = _empty;\r\n        }\r\n        if (scheme === this.scheme\r\n            && authority === this.authority\r\n            && path === this.path\r\n            && query === this.query\r\n            && fragment === this.fragment) {\r\n            return this;\r\n        }\r\n        return new Uri(scheme, authority, path, query, fragment);\r\n    }\r\n    // ---- parse & validate ------------------------\r\n    /**\r\n     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,\r\n     * `file:///usr/home`, or `scheme:with/path`.\r\n     *\r\n     * @param value A string which represents an URI (see `URI#toString`).\r\n     */\r\n    static parse(value, _strict = false) {\r\n        const match = _regexp.exec(value);\r\n        if (!match) {\r\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\r\n        }\r\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\r\n    }\r\n    /**\r\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\r\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\r\n     *\r\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\r\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\r\n     * `URI.parse('file://' + path)` because the path might contain characters that are\r\n     * interpreted (# and ?). See the following sample:\r\n     * ```ts\r\n    const good = URI.file('/coding/c#/project1');\r\n    good.scheme === 'file';\r\n    good.path === '/coding/c#/project1';\r\n    good.fragment === '';\r\n    const bad = URI.parse('file://' + '/coding/c#/project1');\r\n    bad.scheme === 'file';\r\n    bad.path === '/coding/c'; // path is now broken\r\n    bad.fragment === '/project1';\r\n    ```\r\n     *\r\n     * @param path A file system path (see `URI#fsPath`)\r\n     */\r\n    static file(path) {\r\n        let authority = _empty;\r\n        // normalize to fwd-slashes on windows,\r\n        // on other systems bwd-slashes are valid\r\n        // filename character, eg /f\\oo/ba\\r.txt\r\n        if (isWindows) {\r\n            path = path.replace(/\\\\/g, _slash);\r\n        }\r\n        // check for authority as used in UNC shares\r\n        // or use the path as given\r\n        if (path[0] === _slash && path[1] === _slash) {\r\n            const idx = path.indexOf(_slash, 2);\r\n            if (idx === -1) {\r\n                authority = path.substring(2);\r\n                path = _slash;\r\n            }\r\n            else {\r\n                authority = path.substring(2, idx);\r\n                path = path.substring(idx) || _slash;\r\n            }\r\n        }\r\n        return new Uri('file', authority, path, _empty, _empty);\r\n    }\r\n    static from(components) {\r\n        return new Uri(components.scheme, components.authority, components.path, components.query, components.fragment);\r\n    }\r\n    /**\r\n     * Join a URI path with path fragments and normalizes the resulting path.\r\n     *\r\n     * @param uri The input URI.\r\n     * @param pathFragment The path fragment to add to the URI path.\r\n     * @returns The resulting URI.\r\n     */\r\n    static joinPath(uri, ...pathFragment) {\r\n        if (!uri.path) {\r\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\r\n        }\r\n        let newPath;\r\n        if (isWindows && uri.scheme === 'file') {\r\n            newPath = URI.file(paths.win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\r\n        }\r\n        else {\r\n            newPath = paths.posix.join(uri.path, ...pathFragment);\r\n        }\r\n        return uri.with({ path: newPath });\r\n    }\r\n    // ---- printing/externalize ---------------------------\r\n    /**\r\n     * Creates a string representation for this URI. It's guaranteed that calling\r\n     * `URI.parse` with the result of this function creates an URI which is equal\r\n     * to this URI.\r\n     *\r\n     * * The result shall *not* be used for display purposes but for externalization or transport.\r\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\r\n     * ignore the scheme-specific encoding rules.\r\n     *\r\n     * @param skipEncoding Do not encode the result, default is `false`\r\n     */\r\n    toString(skipEncoding = false) {\r\n        return _asFormatted(this, skipEncoding);\r\n    }\r\n    toJSON() {\r\n        return this;\r\n    }\r\n    static revive(data) {\r\n        if (!data) {\r\n            return data;\r\n        }\r\n        else if (data instanceof URI) {\r\n            return data;\r\n        }\r\n        else {\r\n            const result = new Uri(data);\r\n            result._formatted = data.external;\r\n            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;\r\n            return result;\r\n        }\r\n    }\r\n}\r\nconst _pathSepMarker = isWindows ? 1 : undefined;\r\n// This class exists so that URI is compatibile with vscode.Uri (API).\r\nclass Uri extends URI {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._formatted = null;\r\n        this._fsPath = null;\r\n    }\r\n    get fsPath() {\r\n        if (!this._fsPath) {\r\n            this._fsPath = uriToFsPath(this, false);\r\n        }\r\n        return this._fsPath;\r\n    }\r\n    toString(skipEncoding = false) {\r\n        if (!skipEncoding) {\r\n            if (!this._formatted) {\r\n                this._formatted = _asFormatted(this, false);\r\n            }\r\n            return this._formatted;\r\n        }\r\n        else {\r\n            // we don't cache that\r\n            return _asFormatted(this, true);\r\n        }\r\n    }\r\n    toJSON() {\r\n        const res = {\r\n            $mid: 1\r\n        };\r\n        // cached state\r\n        if (this._fsPath) {\r\n            res.fsPath = this._fsPath;\r\n            res._sep = _pathSepMarker;\r\n        }\r\n        if (this._formatted) {\r\n            res.external = this._formatted;\r\n        }\r\n        // uri components\r\n        if (this.path) {\r\n            res.path = this.path;\r\n        }\r\n        if (this.scheme) {\r\n            res.scheme = this.scheme;\r\n        }\r\n        if (this.authority) {\r\n            res.authority = this.authority;\r\n        }\r\n        if (this.query) {\r\n            res.query = this.query;\r\n        }\r\n        if (this.fragment) {\r\n            res.fragment = this.fragment;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\r\nconst encodeTable = {\r\n    [58 /* Colon */]: '%3A',\r\n    [47 /* Slash */]: '%2F',\r\n    [63 /* QuestionMark */]: '%3F',\r\n    [35 /* Hash */]: '%23',\r\n    [91 /* OpenSquareBracket */]: '%5B',\r\n    [93 /* CloseSquareBracket */]: '%5D',\r\n    [64 /* AtSign */]: '%40',\r\n    [33 /* ExclamationMark */]: '%21',\r\n    [36 /* DollarSign */]: '%24',\r\n    [38 /* Ampersand */]: '%26',\r\n    [39 /* SingleQuote */]: '%27',\r\n    [40 /* OpenParen */]: '%28',\r\n    [41 /* CloseParen */]: '%29',\r\n    [42 /* Asterisk */]: '%2A',\r\n    [43 /* Plus */]: '%2B',\r\n    [44 /* Comma */]: '%2C',\r\n    [59 /* Semicolon */]: '%3B',\r\n    [61 /* Equals */]: '%3D',\r\n    [32 /* Space */]: '%20',\r\n};\r\nfunction encodeURIComponentFast(uriComponent, allowSlash) {\r\n    let res = undefined;\r\n    let nativeEncodePos = -1;\r\n    for (let pos = 0; pos < uriComponent.length; pos++) {\r\n        const code = uriComponent.charCodeAt(pos);\r\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\r\n        if ((code >= 97 /* a */ && code <= 122 /* z */)\r\n            || (code >= 65 /* A */ && code <= 90 /* Z */)\r\n            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)\r\n            || code === 45 /* Dash */\r\n            || code === 46 /* Period */\r\n            || code === 95 /* Underline */\r\n            || code === 126 /* Tilde */\r\n            || (allowSlash && code === 47 /* Slash */)) {\r\n            // check if we are delaying native encode\r\n            if (nativeEncodePos !== -1) {\r\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                nativeEncodePos = -1;\r\n            }\r\n            // check if we write into a new string (by default we try to return the param)\r\n            if (res !== undefined) {\r\n                res += uriComponent.charAt(pos);\r\n            }\r\n        }\r\n        else {\r\n            // encoding needed, we need to allocate a new string\r\n            if (res === undefined) {\r\n                res = uriComponent.substr(0, pos);\r\n            }\r\n            // check with default table first\r\n            const escaped = encodeTable[code];\r\n            if (escaped !== undefined) {\r\n                // check if we are delaying native encode\r\n                if (nativeEncodePos !== -1) {\r\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\r\n                    nativeEncodePos = -1;\r\n                }\r\n                // append escaped variant to result\r\n                res += escaped;\r\n            }\r\n            else if (nativeEncodePos === -1) {\r\n                // use native encode only when needed\r\n                nativeEncodePos = pos;\r\n            }\r\n        }\r\n    }\r\n    if (nativeEncodePos !== -1) {\r\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\r\n    }\r\n    return res !== undefined ? res : uriComponent;\r\n}\r\nfunction encodeURIComponentMinimal(path) {\r\n    let res = undefined;\r\n    for (let pos = 0; pos < path.length; pos++) {\r\n        const code = path.charCodeAt(pos);\r\n        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {\r\n            if (res === undefined) {\r\n                res = path.substr(0, pos);\r\n            }\r\n            res += encodeTable[code];\r\n        }\r\n        else {\r\n            if (res !== undefined) {\r\n                res += path[pos];\r\n            }\r\n        }\r\n    }\r\n    return res !== undefined ? res : path;\r\n}\r\n/**\r\n * Compute `fsPath` for the given uri\r\n */\r\nexport function uriToFsPath(uri, keepDriveLetterCasing) {\r\n    let value;\r\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\r\n        // unc path: file://shares/c$/far/boo\r\n        value = `//${uri.authority}${uri.path}`;\r\n    }\r\n    else if (uri.path.charCodeAt(0) === 47 /* Slash */\r\n        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)\r\n        && uri.path.charCodeAt(2) === 58 /* Colon */) {\r\n        if (!keepDriveLetterCasing) {\r\n            // windows drive letter: file:///c:/far/boo\r\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\r\n        }\r\n        else {\r\n            value = uri.path.substr(1);\r\n        }\r\n    }\r\n    else {\r\n        // other path\r\n        value = uri.path;\r\n    }\r\n    if (isWindows) {\r\n        value = value.replace(/\\//g, '\\\\');\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Create the external version of a uri\r\n */\r\nfunction _asFormatted(uri, skipEncoding) {\r\n    const encoder = !skipEncoding\r\n        ? encodeURIComponentFast\r\n        : encodeURIComponentMinimal;\r\n    let res = '';\r\n    let { scheme, authority, path, query, fragment } = uri;\r\n    if (scheme) {\r\n        res += scheme;\r\n        res += ':';\r\n    }\r\n    if (authority || scheme === 'file') {\r\n        res += _slash;\r\n        res += _slash;\r\n    }\r\n    if (authority) {\r\n        let idx = authority.indexOf('@');\r\n        if (idx !== -1) {\r\n            // <user>@<auth>\r\n            const userinfo = authority.substr(0, idx);\r\n            authority = authority.substr(idx + 1);\r\n            idx = userinfo.indexOf(':');\r\n            if (idx === -1) {\r\n                res += encoder(userinfo, false);\r\n            }\r\n            else {\r\n                // <user>:<pass>@<auth>\r\n                res += encoder(userinfo.substr(0, idx), false);\r\n                res += ':';\r\n                res += encoder(userinfo.substr(idx + 1), false);\r\n            }\r\n            res += '@';\r\n        }\r\n        authority = authority.toLowerCase();\r\n        idx = authority.indexOf(':');\r\n        if (idx === -1) {\r\n            res += encoder(authority, false);\r\n        }\r\n        else {\r\n            // <auth>:<port>\r\n            res += encoder(authority.substr(0, idx), false);\r\n            res += authority.substr(idx);\r\n        }\r\n    }\r\n    if (path) {\r\n        // lower-case windows drive letters in /C:/fff or C:/fff\r\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {\r\n            const code = path.charCodeAt(1);\r\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\r\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {\r\n            const code = path.charCodeAt(0);\r\n            if (code >= 65 /* A */ && code <= 90 /* Z */) {\r\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\r\n            }\r\n        }\r\n        // encode the rest of the path\r\n        res += encoder(path, true);\r\n    }\r\n    if (query) {\r\n        res += '?';\r\n        res += encoder(query, false);\r\n    }\r\n    if (fragment) {\r\n        res += '#';\r\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\r\n    }\r\n    return res;\r\n}\r\n// --- decode\r\nfunction decodeURIComponentGraceful(str) {\r\n    try {\r\n        return decodeURIComponent(str);\r\n    }\r\n    catch (_a) {\r\n        if (str.length > 3) {\r\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\r\n        }\r\n        else {\r\n            return str;\r\n        }\r\n    }\r\n}\r\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\r\nfunction percentDecode(str) {\r\n    if (!str.match(_rEncodedAsHex)) {\r\n        return str;\r\n    }\r\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\r\n}\r\n"]},"metadata":{},"sourceType":"module"}