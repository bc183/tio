{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\n\nfunction reverseEndianness(arr) {\n  for (var i = 0, len = arr.length; i < len; i += 4) {\n    // flip bytes 0<->3 and 1<->2\n    var b0 = arr[i + 0];\n    var b1 = arr[i + 1];\n    var b2 = arr[i + 2];\n    var b3 = arr[i + 3];\n    arr[i + 0] = b3;\n    arr[i + 1] = b2;\n    arr[i + 2] = b1;\n    arr[i + 3] = b0;\n  }\n}\n\nfunction toLittleEndianBuffer(arr) {\n  var uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n\n  if (!platform.isLittleEndian()) {\n    // the byte order must be changed\n    reverseEndianness(uint8Arr);\n  }\n\n  return VSBuffer.wrap(uint8Arr);\n}\n\nexport function encodeSemanticTokensDto(semanticTokens) {\n  var dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n  var offset = 0;\n  dest[offset++] = semanticTokens.id;\n\n  if (semanticTokens.type === 'full') {\n    dest[offset++] = 1\n    /* Full */\n    ;\n    dest[offset++] = semanticTokens.data.length;\n    dest.set(semanticTokens.data, offset);\n    offset += semanticTokens.data.length;\n  } else {\n    dest[offset++] = 2\n    /* Delta */\n    ;\n    dest[offset++] = semanticTokens.deltas.length;\n\n    var _iterator = _createForOfIteratorHelper(semanticTokens.deltas),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var delta = _step.value;\n        dest[offset++] = delta.start;\n        dest[offset++] = delta.deleteCount;\n\n        if (delta.data) {\n          dest[offset++] = delta.data.length;\n          dest.set(delta.data, offset);\n          offset += delta.data.length;\n        } else {\n          dest[offset++] = 0;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return toLittleEndianBuffer(dest);\n}\n\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n  var result = 0;\n  result += +1 // id\n  + 1 // type\n  ;\n\n  if (semanticTokens.type === 'full') {\n    result += +1 // data length\n    + semanticTokens.data.length;\n  } else {\n    result += +1 // delta count\n    ;\n    result += (+1 // start\n    + 1 // deleteCount\n    + 1 // data length\n    ) * semanticTokens.deltas.length;\n\n    var _iterator2 = _createForOfIteratorHelper(semanticTokens.deltas),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var delta = _step2.value;\n\n        if (delta.data) {\n          result += delta.data.length;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"],"names":["VSBuffer","platform","reverseEndianness","arr","i","len","length","b0","b1","b2","b3","toLittleEndianBuffer","uint8Arr","Uint8Array","buffer","byteOffset","isLittleEndian","wrap","encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","encodeSemanticTokensDtoSize","offset","id","type","data","set","deltas","delta","start","deleteCount","result"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { VSBuffer } from '../../../base/common/buffer.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nfunction reverseEndianness(arr) {\r\n    for (let i = 0, len = arr.length; i < len; i += 4) {\r\n        // flip bytes 0<->3 and 1<->2\r\n        const b0 = arr[i + 0];\r\n        const b1 = arr[i + 1];\r\n        const b2 = arr[i + 2];\r\n        const b3 = arr[i + 3];\r\n        arr[i + 0] = b3;\r\n        arr[i + 1] = b2;\r\n        arr[i + 2] = b1;\r\n        arr[i + 3] = b0;\r\n    }\r\n}\r\nfunction toLittleEndianBuffer(arr) {\r\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\r\n    if (!platform.isLittleEndian()) {\r\n        // the byte order must be changed\r\n        reverseEndianness(uint8Arr);\r\n    }\r\n    return VSBuffer.wrap(uint8Arr);\r\n}\r\nexport function encodeSemanticTokensDto(semanticTokens) {\r\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\r\n    let offset = 0;\r\n    dest[offset++] = semanticTokens.id;\r\n    if (semanticTokens.type === 'full') {\r\n        dest[offset++] = 1 /* Full */;\r\n        dest[offset++] = semanticTokens.data.length;\r\n        dest.set(semanticTokens.data, offset);\r\n        offset += semanticTokens.data.length;\r\n    }\r\n    else {\r\n        dest[offset++] = 2 /* Delta */;\r\n        dest[offset++] = semanticTokens.deltas.length;\r\n        for (const delta of semanticTokens.deltas) {\r\n            dest[offset++] = delta.start;\r\n            dest[offset++] = delta.deleteCount;\r\n            if (delta.data) {\r\n                dest[offset++] = delta.data.length;\r\n                dest.set(delta.data, offset);\r\n                offset += delta.data.length;\r\n            }\r\n            else {\r\n                dest[offset++] = 0;\r\n            }\r\n        }\r\n    }\r\n    return toLittleEndianBuffer(dest);\r\n}\r\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\r\n    let result = 0;\r\n    result += (+1 // id\r\n        + 1 // type\r\n    );\r\n    if (semanticTokens.type === 'full') {\r\n        result += (+1 // data length\r\n            + semanticTokens.data.length);\r\n    }\r\n    else {\r\n        result += (+1 // delta count\r\n        );\r\n        result += (+1 // start\r\n            + 1 // deleteCount\r\n            + 1 // data length\r\n        ) * semanticTokens.deltas.length;\r\n        for (const delta of semanticTokens.deltas) {\r\n            if (delta.data) {\r\n                result += delta.data.length;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}