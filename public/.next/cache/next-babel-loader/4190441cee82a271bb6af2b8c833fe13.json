{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\nfunction _computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n  var diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n  return diffAlgo.ComputeDiff(pretty);\n}\n\nvar LineSequence = /*#__PURE__*/function () {\n  function LineSequence(lines) {\n    _classCallCheck(this, LineSequence);\n\n    var startColumns = [];\n    var endColumns = [];\n\n    for (var i = 0, length = lines.length; i < length; i++) {\n      startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n      endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n    }\n\n    this.lines = lines;\n    this._startColumns = startColumns;\n    this._endColumns = endColumns;\n  }\n\n  _createClass(LineSequence, [{\n    key: \"getElements\",\n    value: function getElements() {\n      var elements = [];\n\n      for (var i = 0, len = this.lines.length; i < len; i++) {\n        elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n      }\n\n      return elements;\n    }\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber(i) {\n      return i + 1;\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber(i) {\n      return i + 1;\n    }\n  }, {\n    key: \"createCharSequence\",\n    value: function createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n      var charCodes = [];\n      var lineNumbers = [];\n      var columns = [];\n      var len = 0;\n\n      for (var index = startIndex; index <= endIndex; index++) {\n        var lineContent = this.lines[index];\n        var startColumn = shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1;\n        var endColumn = shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1;\n\n        for (var col = startColumn; col < endColumn; col++) {\n          charCodes[len] = lineContent.charCodeAt(col - 1);\n          lineNumbers[len] = index + 1;\n          columns[len] = col;\n          len++;\n        }\n      }\n\n      return new CharSequence(charCodes, lineNumbers, columns);\n    }\n  }]);\n\n  return LineSequence;\n}();\n\nvar CharSequence = /*#__PURE__*/function () {\n  function CharSequence(charCodes, lineNumbers, columns) {\n    _classCallCheck(this, CharSequence);\n\n    this._charCodes = charCodes;\n    this._lineNumbers = lineNumbers;\n    this._columns = columns;\n  }\n\n  _createClass(CharSequence, [{\n    key: \"getElements\",\n    value: function getElements() {\n      return this._charCodes;\n    }\n  }, {\n    key: \"getStartLineNumber\",\n    value: function getStartLineNumber(i) {\n      return this._lineNumbers[i];\n    }\n  }, {\n    key: \"getStartColumn\",\n    value: function getStartColumn(i) {\n      return this._columns[i];\n    }\n  }, {\n    key: \"getEndLineNumber\",\n    value: function getEndLineNumber(i) {\n      return this._lineNumbers[i];\n    }\n  }, {\n    key: \"getEndColumn\",\n    value: function getEndColumn(i) {\n      return this._columns[i] + 1;\n    }\n  }]);\n\n  return CharSequence;\n}();\n\nvar CharChange = /*#__PURE__*/function () {\n  function CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n    _classCallCheck(this, CharChange);\n\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalStartColumn = originalStartColumn;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.originalEndColumn = originalEndColumn;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedStartColumn = modifiedStartColumn;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.modifiedEndColumn = modifiedEndColumn;\n  }\n\n  _createClass(CharChange, null, [{\n    key: \"createFromDiffChange\",\n    value: function createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n      var originalStartLineNumber;\n      var originalStartColumn;\n      var originalEndLineNumber;\n      var originalEndColumn;\n      var modifiedStartLineNumber;\n      var modifiedStartColumn;\n      var modifiedEndLineNumber;\n      var modifiedEndColumn;\n\n      if (diffChange.originalLength === 0) {\n        originalStartLineNumber = 0;\n        originalStartColumn = 0;\n        originalEndLineNumber = 0;\n        originalEndColumn = 0;\n      } else {\n        originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n      }\n\n      if (diffChange.modifiedLength === 0) {\n        modifiedStartLineNumber = 0;\n        modifiedStartColumn = 0;\n        modifiedEndLineNumber = 0;\n        modifiedEndColumn = 0;\n      } else {\n        modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      }\n\n      return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n  }]);\n\n  return CharChange;\n}();\n\nfunction postProcessCharChanges(rawChanges) {\n  if (rawChanges.length <= 1) {\n    return rawChanges;\n  }\n\n  var result = [rawChanges[0]];\n  var prevChange = result[0];\n\n  for (var i = 1, len = rawChanges.length; i < len; i++) {\n    var currChange = rawChanges[i];\n    var originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n    var modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength); // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\n    var matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n    if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n      // Merge the current change into the previous one\n      prevChange.originalLength = currChange.originalStart + currChange.originalLength - prevChange.originalStart;\n      prevChange.modifiedLength = currChange.modifiedStart + currChange.modifiedLength - prevChange.modifiedStart;\n    } else {\n      // Add the current change\n      result.push(currChange);\n      prevChange = currChange;\n    }\n  }\n\n  return result;\n}\n\nvar LineChange = /*#__PURE__*/function () {\n  function LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n    _classCallCheck(this, LineChange);\n\n    this.originalStartLineNumber = originalStartLineNumber;\n    this.originalEndLineNumber = originalEndLineNumber;\n    this.modifiedStartLineNumber = modifiedStartLineNumber;\n    this.modifiedEndLineNumber = modifiedEndLineNumber;\n    this.charChanges = charChanges;\n  }\n\n  _createClass(LineChange, null, [{\n    key: \"createFromDiffResult\",\n    value: function createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n      var originalStartLineNumber;\n      var originalEndLineNumber;\n      var modifiedStartLineNumber;\n      var modifiedEndLineNumber;\n      var charChanges = undefined;\n\n      if (diffChange.originalLength === 0) {\n        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n        originalEndLineNumber = 0;\n      } else {\n        originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n        originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n      }\n\n      if (diffChange.modifiedLength === 0) {\n        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n        modifiedEndLineNumber = 0;\n      } else {\n        modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n        modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n      }\n\n      if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n        // Compute character changes for diff chunks of at most 20 lines...\n        var originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n        var modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n        var rawChanges = _computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n\n        if (shouldPostProcessCharChanges) {\n          rawChanges = postProcessCharChanges(rawChanges);\n        }\n\n        charChanges = [];\n\n        for (var i = 0, length = rawChanges.length; i < length; i++) {\n          charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n        }\n      }\n\n      return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n  }]);\n\n  return LineChange;\n}();\n\nexport var DiffComputer = /*#__PURE__*/function () {\n  function DiffComputer(originalLines, modifiedLines, opts) {\n    _classCallCheck(this, DiffComputer);\n\n    this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n    this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n    this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n    this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n    this.originalLines = originalLines;\n    this.modifiedLines = modifiedLines;\n    this.original = new LineSequence(originalLines);\n    this.modified = new LineSequence(modifiedLines);\n    this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n    this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n  }\n\n  _createClass(DiffComputer, [{\n    key: \"computeDiff\",\n    value: function computeDiff() {\n      if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n        // empty original => fast path\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n          return {\n            quitEarly: false,\n            changes: []\n          };\n        }\n\n        return {\n          quitEarly: false,\n          changes: [{\n            originalStartLineNumber: 1,\n            originalEndLineNumber: 1,\n            modifiedStartLineNumber: 1,\n            modifiedEndLineNumber: this.modified.lines.length,\n            charChanges: [{\n              modifiedEndColumn: 0,\n              modifiedEndLineNumber: 0,\n              modifiedStartColumn: 0,\n              modifiedStartLineNumber: 0,\n              originalEndColumn: 0,\n              originalEndLineNumber: 0,\n              originalStartColumn: 0,\n              originalStartLineNumber: 0\n            }]\n          }]\n        };\n      }\n\n      if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n        // empty modified => fast path\n        return {\n          quitEarly: false,\n          changes: [{\n            originalStartLineNumber: 1,\n            originalEndLineNumber: this.original.lines.length,\n            modifiedStartLineNumber: 1,\n            modifiedEndLineNumber: 1,\n            charChanges: [{\n              modifiedEndColumn: 0,\n              modifiedEndLineNumber: 0,\n              modifiedStartColumn: 0,\n              modifiedStartLineNumber: 0,\n              originalEndColumn: 0,\n              originalEndLineNumber: 0,\n              originalStartColumn: 0,\n              originalStartLineNumber: 0\n            }]\n          }]\n        };\n      }\n\n      var diffResult = _computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n\n      var rawChanges = diffResult.changes;\n      var quitEarly = diffResult.quitEarly; // The diff is always computed with ignoring trim whitespace\n      // This ensures we get the prettiest diff\n\n      if (this.shouldIgnoreTrimWhitespace) {\n        var lineChanges = [];\n\n        for (var i = 0, length = rawChanges.length; i < length; i++) {\n          lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n        }\n\n        return {\n          quitEarly: quitEarly,\n          changes: lineChanges\n        };\n      } // Need to post-process and introduce changes where the trim whitespace is different\n      // Note that we are looping starting at -1 to also cover the lines before the first change\n\n\n      var result = [];\n      var originalLineIndex = 0;\n      var modifiedLineIndex = 0;\n\n      for (var _i = -1\n      /* !!!! */\n      , len = rawChanges.length; _i < len; _i++) {\n        var nextChange = _i + 1 < len ? rawChanges[_i + 1] : null;\n        var originalStop = nextChange ? nextChange.originalStart : this.originalLines.length;\n        var modifiedStop = nextChange ? nextChange.modifiedStart : this.modifiedLines.length;\n\n        while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n          var originalLine = this.originalLines[originalLineIndex];\n          var modifiedLine = this.modifiedLines[modifiedLineIndex];\n\n          if (originalLine !== modifiedLine) {\n            // These lines differ only in trim whitespace\n            // Check the leading whitespace\n            {\n              var originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n              var modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n\n              while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                var originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                var modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n\n                if (originalChar !== modifiedChar) {\n                  break;\n                }\n\n                originalStartColumn--;\n                modifiedStartColumn--;\n              }\n\n              if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n              }\n            } // Check the trailing whitespace\n\n            {\n              var originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n              var modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n              var originalMaxColumn = originalLine.length + 1;\n              var modifiedMaxColumn = modifiedLine.length + 1;\n\n              while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                var _originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n\n                var _modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n\n                if (_originalChar !== _modifiedChar) {\n                  break;\n                }\n\n                originalEndColumn++;\n                modifiedEndColumn++;\n              }\n\n              if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n              }\n            }\n          }\n\n          originalLineIndex++;\n          modifiedLineIndex++;\n        }\n\n        if (nextChange) {\n          // Emit the actual change\n          result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n          originalLineIndex += nextChange.originalLength;\n          modifiedLineIndex += nextChange.modifiedLength;\n        }\n      }\n\n      return {\n        quitEarly: quitEarly,\n        changes: result\n      };\n    }\n  }, {\n    key: \"_pushTrimWhitespaceCharChange\",\n    value: function _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n      if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n        // Merged into previous\n        return;\n      }\n\n      var charChanges = undefined;\n\n      if (this.shouldComputeCharChanges) {\n        charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n      }\n\n      result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n  }, {\n    key: \"_mergeTrimWhitespaceCharChange\",\n    value: function _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n      var len = result.length;\n\n      if (len === 0) {\n        return false;\n      }\n\n      var prevChange = result[len - 1];\n\n      if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n        // Don't merge with inserts/deletes\n        return false;\n      }\n\n      if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n        prevChange.originalEndLineNumber = originalLineNumber;\n        prevChange.modifiedEndLineNumber = modifiedLineNumber;\n\n        if (this.shouldComputeCharChanges && prevChange.charChanges) {\n          prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return DiffComputer;\n}();\n\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n  var r = strings.firstNonWhitespaceIndex(txt);\n\n  if (r === -1) {\n    return defaultValue;\n  }\n\n  return r + 1;\n}\n\nfunction getLastNonBlankColumn(txt, defaultValue) {\n  var r = strings.lastNonWhitespaceIndex(txt);\n\n  if (r === -1) {\n    return defaultValue;\n  }\n\n  return r + 2;\n}\n\nfunction createContinueProcessingPredicate(maximumRuntime) {\n  if (maximumRuntime === 0) {\n    return function () {\n      return true;\n    };\n  }\n\n  var startTime = Date.now();\n  return function () {\n    return Date.now() - startTime < maximumRuntime;\n  };\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js"],"names":["LcsDiff","strings","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","diffAlgo","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","length","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","len","substring","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","index","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","originalLength","getStartLineNumber","originalStart","getStartColumn","getEndLineNumber","getEndColumn","modifiedLength","modifiedStart","postProcessCharChanges","rawChanges","result","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","matchingLength","Math","min","push","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","undefined","createCharSequence","changes","createFromDiffChange","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","originalChar","modifiedChar","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","maximumRuntime","startTime","Date","now"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\r\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n    return diffAlgo.ComputeDiff(pretty);\r\n}\r\nclass LineSequence {\r\n    constructor(lines) {\r\n        const startColumns = [];\r\n        const endColumns = [];\r\n        for (let i = 0, length = lines.length; i < length; i++) {\r\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\r\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\r\n        }\r\n        this.lines = lines;\r\n        this._startColumns = startColumns;\r\n        this._endColumns = endColumns;\r\n    }\r\n    getElements() {\r\n        const elements = [];\r\n        for (let i = 0, len = this.lines.length; i < len; i++) {\r\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\r\n        }\r\n        return elements;\r\n    }\r\n    getStartLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    getEndLineNumber(i) {\r\n        return i + 1;\r\n    }\r\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\r\n        const charCodes = [];\r\n        const lineNumbers = [];\r\n        const columns = [];\r\n        let len = 0;\r\n        for (let index = startIndex; index <= endIndex; index++) {\r\n            const lineContent = this.lines[index];\r\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\r\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\r\n            for (let col = startColumn; col < endColumn; col++) {\r\n                charCodes[len] = lineContent.charCodeAt(col - 1);\r\n                lineNumbers[len] = index + 1;\r\n                columns[len] = col;\r\n                len++;\r\n            }\r\n        }\r\n        return new CharSequence(charCodes, lineNumbers, columns);\r\n    }\r\n}\r\nclass CharSequence {\r\n    constructor(charCodes, lineNumbers, columns) {\r\n        this._charCodes = charCodes;\r\n        this._lineNumbers = lineNumbers;\r\n        this._columns = columns;\r\n    }\r\n    getElements() {\r\n        return this._charCodes;\r\n    }\r\n    getStartLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getStartColumn(i) {\r\n        return this._columns[i];\r\n    }\r\n    getEndLineNumber(i) {\r\n        return this._lineNumbers[i];\r\n    }\r\n    getEndColumn(i) {\r\n        return this._columns[i] + 1;\r\n    }\r\n}\r\nclass CharChange {\r\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalStartColumn = originalStartColumn;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.originalEndColumn = originalEndColumn;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedStartColumn = modifiedStartColumn;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.modifiedEndColumn = modifiedEndColumn;\r\n    }\r\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n        let originalStartLineNumber;\r\n        let originalStartColumn;\r\n        let originalEndLineNumber;\r\n        let originalEndColumn;\r\n        let modifiedStartLineNumber;\r\n        let modifiedStartColumn;\r\n        let modifiedEndLineNumber;\r\n        let modifiedEndColumn;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = 0;\r\n            originalStartColumn = 0;\r\n            originalEndLineNumber = 0;\r\n            originalEndColumn = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = 0;\r\n            modifiedStartColumn = 0;\r\n            modifiedEndLineNumber = 0;\r\n            modifiedEndColumn = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\r\n    }\r\n}\r\nfunction postProcessCharChanges(rawChanges) {\r\n    if (rawChanges.length <= 1) {\r\n        return rawChanges;\r\n    }\r\n    const result = [rawChanges[0]];\r\n    let prevChange = result[0];\r\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\r\n        const currChange = rawChanges[i];\r\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n            // Merge the current change into the previous one\r\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n        }\r\n        else {\r\n            // Add the current change\r\n            result.push(currChange);\r\n            prevChange = currChange;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nclass LineChange {\r\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\r\n        this.originalStartLineNumber = originalStartLineNumber;\r\n        this.originalEndLineNumber = originalEndLineNumber;\r\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\r\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\r\n        this.charChanges = charChanges;\r\n    }\r\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\r\n        let originalStartLineNumber;\r\n        let originalEndLineNumber;\r\n        let modifiedStartLineNumber;\r\n        let modifiedEndLineNumber;\r\n        let charChanges = undefined;\r\n        if (diffChange.originalLength === 0) {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n            originalEndLineNumber = 0;\r\n        }\r\n        else {\r\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n        }\r\n        if (diffChange.modifiedLength === 0) {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n            modifiedEndLineNumber = 0;\r\n        }\r\n        else {\r\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n        }\r\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\r\n            // Compute character changes for diff chunks of at most 20 lines...\r\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\r\n            if (shouldPostProcessCharChanges) {\r\n                rawChanges = postProcessCharChanges(rawChanges);\r\n            }\r\n            charChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n            }\r\n        }\r\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\r\n    }\r\n}\r\nexport class DiffComputer {\r\n    constructor(originalLines, modifiedLines, opts) {\r\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\r\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\r\n        this.originalLines = originalLines;\r\n        this.modifiedLines = modifiedLines;\r\n        this.original = new LineSequence(originalLines);\r\n        this.modified = new LineSequence(modifiedLines);\r\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\r\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\r\n    }\r\n    computeDiff() {\r\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\r\n            // empty original => fast path\r\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n                return {\r\n                    quitEarly: false,\r\n                    changes: []\r\n                };\r\n            }\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: 1,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: this.modified.lines.length,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\r\n            // empty modified => fast path\r\n            return {\r\n                quitEarly: false,\r\n                changes: [{\r\n                        originalStartLineNumber: 1,\r\n                        originalEndLineNumber: this.original.lines.length,\r\n                        modifiedStartLineNumber: 1,\r\n                        modifiedEndLineNumber: 1,\r\n                        charChanges: [{\r\n                                modifiedEndColumn: 0,\r\n                                modifiedEndLineNumber: 0,\r\n                                modifiedStartColumn: 0,\r\n                                modifiedStartLineNumber: 0,\r\n                                originalEndColumn: 0,\r\n                                originalEndLineNumber: 0,\r\n                                originalStartColumn: 0,\r\n                                originalStartLineNumber: 0\r\n                            }]\r\n                    }]\r\n            };\r\n        }\r\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\r\n        const rawChanges = diffResult.changes;\r\n        const quitEarly = diffResult.quitEarly;\r\n        // The diff is always computed with ignoring trim whitespace\r\n        // This ensures we get the prettiest diff\r\n        if (this.shouldIgnoreTrimWhitespace) {\r\n            const lineChanges = [];\r\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n            }\r\n            return {\r\n                quitEarly: quitEarly,\r\n                changes: lineChanges\r\n            };\r\n        }\r\n        // Need to post-process and introduce changes where the trim whitespace is different\r\n        // Note that we are looping starting at -1 to also cover the lines before the first change\r\n        const result = [];\r\n        let originalLineIndex = 0;\r\n        let modifiedLineIndex = 0;\r\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\r\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\r\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\r\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\r\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\r\n                const originalLine = this.originalLines[originalLineIndex];\r\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\r\n                if (originalLine !== modifiedLine) {\r\n                    // These lines differ only in trim whitespace\r\n                    // Check the leading whitespace\r\n                    {\r\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\r\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\r\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\r\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\r\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalStartColumn--;\r\n                            modifiedStartColumn--;\r\n                        }\r\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\r\n                        }\r\n                    }\r\n                    // Check the trailing whitespace\r\n                    {\r\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\r\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\r\n                        const originalMaxColumn = originalLine.length + 1;\r\n                        const modifiedMaxColumn = modifiedLine.length + 1;\r\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\r\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\r\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\r\n                            if (originalChar !== modifiedChar) {\r\n                                break;\r\n                            }\r\n                            originalEndColumn++;\r\n                            modifiedEndColumn++;\r\n                        }\r\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\r\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\r\n                        }\r\n                    }\r\n                }\r\n                originalLineIndex++;\r\n                modifiedLineIndex++;\r\n            }\r\n            if (nextChange) {\r\n                // Emit the actual change\r\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\r\n                originalLineIndex += nextChange.originalLength;\r\n                modifiedLineIndex += nextChange.modifiedLength;\r\n            }\r\n        }\r\n        return {\r\n            quitEarly: quitEarly,\r\n            changes: result\r\n        };\r\n    }\r\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\r\n            // Merged into previous\r\n            return;\r\n        }\r\n        let charChanges = undefined;\r\n        if (this.shouldComputeCharChanges) {\r\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\r\n        }\r\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\r\n    }\r\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\r\n        const len = result.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const prevChange = result[len - 1];\r\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\r\n            // Don't merge with inserts/deletes\r\n            return false;\r\n        }\r\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\r\n            prevChange.originalEndLineNumber = originalLineNumber;\r\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\r\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\r\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction getFirstNonBlankColumn(txt, defaultValue) {\r\n    const r = strings.firstNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 1;\r\n}\r\nfunction getLastNonBlankColumn(txt, defaultValue) {\r\n    const r = strings.lastNonWhitespaceIndex(txt);\r\n    if (r === -1) {\r\n        return defaultValue;\r\n    }\r\n    return r + 2;\r\n}\r\nfunction createContinueProcessingPredicate(maximumRuntime) {\r\n    if (maximumRuntime === 0) {\r\n        return () => true;\r\n    }\r\n    const startTime = Date.now();\r\n    return () => {\r\n        return Date.now() - startTime < maximumRuntime;\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}