{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { CancellationTokenSource } from './cancellation.js';\nimport * as errors from './errors.js';\nimport { toDisposable } from './lifecycle.js';\nexport function isThenable(obj) {\n  return obj && typeof obj.then === 'function';\n}\nexport function createCancelablePromise(callback) {\n  var source = new CancellationTokenSource();\n  var thenable = callback(source.token);\n  var promise = new Promise(function (resolve, reject) {\n    source.token.onCancellationRequested(function () {\n      reject(errors.canceled());\n    });\n    Promise.resolve(thenable).then(function (value) {\n      source.dispose();\n      resolve(value);\n    }, function (err) {\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new ( /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n\n    _createClass(_class, [{\n      key: \"cancel\",\n      value: function cancel() {\n        source.cancel();\n      }\n    }, {\n      key: \"then\",\n      value: function then(resolve, reject) {\n        return promise.then(resolve, reject);\n      }\n    }, {\n      key: \"catch\",\n      value: function _catch(reject) {\n        return this.then(undefined, reject);\n      }\n    }, {\n      key: \"finally\",\n      value: function _finally(onfinally) {\n        return promise[\"finally\"](onfinally);\n      }\n    }]);\n\n    return _class;\n  }())();\n}\nexport function raceCancellation(promise, token, defaultValue) {\n  return Promise.race([promise, new Promise(function (resolve) {\n    return token.onCancellationRequested(function () {\n      return resolve(defaultValue);\n    });\n  })]);\n}\n/**\r\n * A helper to delay (debounce) execution of a task that is being requested often.\r\n *\r\n * Following the throttler, now imagine the mail man wants to optimize the number of\r\n * trips proactively. The trip itself can be long, so he decides not to make the trip\r\n * as soon as a letter is submitted. Instead he waits a while, in case more\r\n * letters are submitted. After said waiting period, if no letters were submitted, he\r\n * decides to make the trip. Imagine that N more letters were submitted after the first\r\n * one, all within a short period of time between each other. Even though N+1\r\n * submissions occurred, only 1 delivery was made.\r\n *\r\n * The delayer offers this behavior via the trigger() method, into which both the task\r\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\r\n * the example:\r\n *\r\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\r\n * \t\tconst letters = [];\r\n *\r\n * \t\tfunction letterReceived(l) {\r\n * \t\t\tletters.push(l);\r\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\r\n * \t\t}\r\n */\n\nexport var Delayer = /*#__PURE__*/function () {\n  function Delayer(defaultDelay) {\n    _classCallCheck(this, Delayer);\n\n    this.defaultDelay = defaultDelay;\n    this.timeout = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n\n  _createClass(Delayer, [{\n    key: \"trigger\",\n    value: function trigger(task) {\n      var _this = this;\n\n      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultDelay;\n      this.task = task;\n      this.cancelTimeout();\n\n      if (!this.completionPromise) {\n        this.completionPromise = new Promise(function (resolve, reject) {\n          _this.doResolve = resolve;\n          _this.doReject = reject;\n        }).then(function () {\n          _this.completionPromise = null;\n          _this.doResolve = null;\n\n          if (_this.task) {\n            var _task = _this.task;\n            _this.task = null;\n            return _task();\n          }\n\n          return undefined;\n        });\n      }\n\n      this.timeout = setTimeout(function () {\n        _this.timeout = null;\n\n        if (_this.doResolve) {\n          _this.doResolve(null);\n        }\n      }, delay);\n      return this.completionPromise;\n    }\n  }, {\n    key: \"isTriggered\",\n    value: function isTriggered() {\n      return this.timeout !== null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.cancelTimeout();\n\n      if (this.completionPromise) {\n        if (this.doReject) {\n          this.doReject(errors.canceled());\n        }\n\n        this.completionPromise = null;\n      }\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      if (this.timeout !== null) {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.cancelTimeout();\n    }\n  }]);\n\n  return Delayer;\n}();\nexport function timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(function (token) {\n      return timeout(millis, token);\n    });\n  }\n\n  return new Promise(function (resolve, reject) {\n    var handle = setTimeout(resolve, millis);\n    token.onCancellationRequested(function () {\n      clearTimeout(handle);\n      reject(errors.canceled());\n    });\n  });\n}\nexport function disposableTimeout(handler) {\n  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var timer = setTimeout(handler, timeout);\n  return toDisposable(function () {\n    return clearTimeout(timer);\n  });\n}\nexport function first(promiseFactories) {\n  var shouldStop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (t) {\n    return !!t;\n  };\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var index = 0;\n  var len = promiseFactories.length;\n\n  var loop = function loop() {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n\n    var factory = promiseFactories[index++];\n    var promise = Promise.resolve(factory());\n    return promise.then(function (result) {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n\n      return loop();\n    });\n  };\n\n  return loop();\n}\nexport var TimeoutTimer = /*#__PURE__*/function () {\n  function TimeoutTimer(runner, timeout) {\n    _classCallCheck(this, TimeoutTimer);\n\n    this._token = -1;\n\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n\n  _createClass(TimeoutTimer, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.cancel();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this._token !== -1) {\n        clearTimeout(this._token);\n        this._token = -1;\n      }\n    }\n  }, {\n    key: \"cancelAndSet\",\n    value: function cancelAndSet(runner, timeout) {\n      var _this2 = this;\n\n      this.cancel();\n      this._token = setTimeout(function () {\n        _this2._token = -1;\n        runner();\n      }, timeout);\n    }\n  }, {\n    key: \"setIfNotSet\",\n    value: function setIfNotSet(runner, timeout) {\n      var _this3 = this;\n\n      if (this._token !== -1) {\n        // timer is already set\n        return;\n      }\n\n      this._token = setTimeout(function () {\n        _this3._token = -1;\n        runner();\n      }, timeout);\n    }\n  }]);\n\n  return TimeoutTimer;\n}();\nexport var IntervalTimer = /*#__PURE__*/function () {\n  function IntervalTimer() {\n    _classCallCheck(this, IntervalTimer);\n\n    this._token = -1;\n  }\n\n  _createClass(IntervalTimer, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.cancel();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this._token !== -1) {\n        clearInterval(this._token);\n        this._token = -1;\n      }\n    }\n  }, {\n    key: \"cancelAndSet\",\n    value: function cancelAndSet(runner, interval) {\n      this.cancel();\n      this._token = setInterval(function () {\n        runner();\n      }, interval);\n    }\n  }]);\n\n  return IntervalTimer;\n}();\nexport var RunOnceScheduler = /*#__PURE__*/function () {\n  function RunOnceScheduler(runner, delay) {\n    _classCallCheck(this, RunOnceScheduler);\n\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  /**\r\n   * Dispose RunOnceScheduler\r\n   */\n\n\n  _createClass(RunOnceScheduler, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.cancel();\n      this.runner = null;\n    }\n    /**\r\n     * Cancel current scheduled runner (if any).\r\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.isScheduled()) {\n        clearTimeout(this.timeoutToken);\n        this.timeoutToken = -1;\n      }\n    }\n    /**\r\n     * Cancel previous runner (if any) & schedule a new runner.\r\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule() {\n      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.cancel();\n      this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n  }, {\n    key: \"isScheduled\",\n\n    /**\r\n     * Returns true if scheduled.\r\n     */\n    value: function isScheduled() {\n      return this.timeoutToken !== -1;\n    }\n  }, {\n    key: \"onTimeout\",\n    value: function onTimeout() {\n      this.timeoutToken = -1;\n\n      if (this.runner) {\n        this.doRun();\n      }\n    }\n  }, {\n    key: \"doRun\",\n    value: function doRun() {\n      if (this.runner) {\n        this.runner();\n      }\n    }\n  }, {\n    key: \"delay\",\n    get: function get() {\n      return this.timeout;\n    },\n    set: function set(value) {\n      this.timeout = value;\n    }\n  }]);\n\n  return RunOnceScheduler;\n}();\n/**\r\n * Execute the callback the next time the browser is idle\r\n */\n\nexport var runWhenIdle;\n\n(function () {\n  if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n    var dummyIdle = Object.freeze({\n      didTimeout: true,\n      timeRemaining: function timeRemaining() {\n        return 15;\n      }\n    });\n\n    runWhenIdle = function runWhenIdle(runner) {\n      var handle = setTimeout(function () {\n        return runner(dummyIdle);\n      });\n      var disposed = false;\n      return {\n        dispose: function dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          clearTimeout(handle);\n        }\n      };\n    };\n  } else {\n    runWhenIdle = function runWhenIdle(runner, timeout) {\n      var handle = requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout: timeout\n      } : undefined);\n      var disposed = false;\n      return {\n        dispose: function dispose() {\n          if (disposed) {\n            return;\n          }\n\n          disposed = true;\n          cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n})();\n/**\r\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\r\n * here: https://philipwalton.com/articles/idle-until-urgent/\r\n */\n\n\nexport var IdleValue = /*#__PURE__*/function () {\n  function IdleValue(executor) {\n    var _this4 = this;\n\n    _classCallCheck(this, IdleValue);\n\n    this._didRun = false;\n\n    this._executor = function () {\n      try {\n        _this4._value = executor();\n      } catch (err) {\n        _this4._error = err;\n      } finally {\n        _this4._didRun = true;\n      }\n    };\n\n    this._handle = runWhenIdle(function () {\n      return _this4._executor();\n    });\n  }\n\n  _createClass(IdleValue, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._handle.dispose();\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      if (!this._didRun) {\n        this._handle.dispose();\n\n        this._executor();\n      }\n\n      if (this._error) {\n        throw this._error;\n      }\n\n      return this._value;\n    }\n  }]);\n\n  return IdleValue;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/async.js"],"names":["CancellationTokenSource","errors","toDisposable","isThenable","obj","then","createCancelablePromise","callback","source","thenable","token","promise","Promise","resolve","reject","onCancellationRequested","canceled","value","dispose","err","cancel","undefined","onfinally","raceCancellation","defaultValue","race","Delayer","defaultDelay","timeout","completionPromise","doResolve","doReject","task","delay","cancelTimeout","setTimeout","clearTimeout","millis","handle","disposableTimeout","handler","timer","first","promiseFactories","shouldStop","t","index","len","length","loop","factory","result","TimeoutTimer","runner","_token","setIfNotSet","IntervalTimer","clearInterval","interval","setInterval","RunOnceScheduler","timeoutToken","timeoutHandler","onTimeout","bind","isScheduled","doRun","runWhenIdle","requestIdleCallback","cancelIdleCallback","dummyIdle","Object","freeze","didTimeout","timeRemaining","disposed","IdleValue","executor","_didRun","_executor","_value","_error","_handle"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { CancellationTokenSource } from './cancellation.js';\r\nimport * as errors from './errors.js';\r\nimport { toDisposable } from './lifecycle.js';\r\nexport function isThenable(obj) {\r\n    return obj && typeof obj.then === 'function';\r\n}\r\nexport function createCancelablePromise(callback) {\r\n    const source = new CancellationTokenSource();\r\n    const thenable = callback(source.token);\r\n    const promise = new Promise((resolve, reject) => {\r\n        source.token.onCancellationRequested(() => {\r\n            reject(errors.canceled());\r\n        });\r\n        Promise.resolve(thenable).then(value => {\r\n            source.dispose();\r\n            resolve(value);\r\n        }, err => {\r\n            source.dispose();\r\n            reject(err);\r\n        });\r\n    });\r\n    return new class {\r\n        cancel() {\r\n            source.cancel();\r\n        }\r\n        then(resolve, reject) {\r\n            return promise.then(resolve, reject);\r\n        }\r\n        catch(reject) {\r\n            return this.then(undefined, reject);\r\n        }\r\n        finally(onfinally) {\r\n            return promise.finally(onfinally);\r\n        }\r\n    };\r\n}\r\nexport function raceCancellation(promise, token, defaultValue) {\r\n    return Promise.race([promise, new Promise(resolve => token.onCancellationRequested(() => resolve(defaultValue)))]);\r\n}\r\n/**\r\n * A helper to delay (debounce) execution of a task that is being requested often.\r\n *\r\n * Following the throttler, now imagine the mail man wants to optimize the number of\r\n * trips proactively. The trip itself can be long, so he decides not to make the trip\r\n * as soon as a letter is submitted. Instead he waits a while, in case more\r\n * letters are submitted. After said waiting period, if no letters were submitted, he\r\n * decides to make the trip. Imagine that N more letters were submitted after the first\r\n * one, all within a short period of time between each other. Even though N+1\r\n * submissions occurred, only 1 delivery was made.\r\n *\r\n * The delayer offers this behavior via the trigger() method, into which both the task\r\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\r\n * the example:\r\n *\r\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\r\n * \t\tconst letters = [];\r\n *\r\n * \t\tfunction letterReceived(l) {\r\n * \t\t\tletters.push(l);\r\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\r\n * \t\t}\r\n */\r\nexport class Delayer {\r\n    constructor(defaultDelay) {\r\n        this.defaultDelay = defaultDelay;\r\n        this.timeout = null;\r\n        this.completionPromise = null;\r\n        this.doResolve = null;\r\n        this.doReject = null;\r\n        this.task = null;\r\n    }\r\n    trigger(task, delay = this.defaultDelay) {\r\n        this.task = task;\r\n        this.cancelTimeout();\r\n        if (!this.completionPromise) {\r\n            this.completionPromise = new Promise((resolve, reject) => {\r\n                this.doResolve = resolve;\r\n                this.doReject = reject;\r\n            }).then(() => {\r\n                this.completionPromise = null;\r\n                this.doResolve = null;\r\n                if (this.task) {\r\n                    const task = this.task;\r\n                    this.task = null;\r\n                    return task();\r\n                }\r\n                return undefined;\r\n            });\r\n        }\r\n        this.timeout = setTimeout(() => {\r\n            this.timeout = null;\r\n            if (this.doResolve) {\r\n                this.doResolve(null);\r\n            }\r\n        }, delay);\r\n        return this.completionPromise;\r\n    }\r\n    isTriggered() {\r\n        return this.timeout !== null;\r\n    }\r\n    cancel() {\r\n        this.cancelTimeout();\r\n        if (this.completionPromise) {\r\n            if (this.doReject) {\r\n                this.doReject(errors.canceled());\r\n            }\r\n            this.completionPromise = null;\r\n        }\r\n    }\r\n    cancelTimeout() {\r\n        if (this.timeout !== null) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = null;\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancelTimeout();\r\n    }\r\n}\r\nexport function timeout(millis, token) {\r\n    if (!token) {\r\n        return createCancelablePromise(token => timeout(millis, token));\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        const handle = setTimeout(resolve, millis);\r\n        token.onCancellationRequested(() => {\r\n            clearTimeout(handle);\r\n            reject(errors.canceled());\r\n        });\r\n    });\r\n}\r\nexport function disposableTimeout(handler, timeout = 0) {\r\n    const timer = setTimeout(handler, timeout);\r\n    return toDisposable(() => clearTimeout(timer));\r\n}\r\nexport function first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\r\n    let index = 0;\r\n    const len = promiseFactories.length;\r\n    const loop = () => {\r\n        if (index >= len) {\r\n            return Promise.resolve(defaultValue);\r\n        }\r\n        const factory = promiseFactories[index++];\r\n        const promise = Promise.resolve(factory());\r\n        return promise.then(result => {\r\n            if (shouldStop(result)) {\r\n                return Promise.resolve(result);\r\n            }\r\n            return loop();\r\n        });\r\n    };\r\n    return loop();\r\n}\r\nexport class TimeoutTimer {\r\n    constructor(runner, timeout) {\r\n        this._token = -1;\r\n        if (typeof runner === 'function' && typeof timeout === 'number') {\r\n            this.setIfNotSet(runner, timeout);\r\n        }\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n    cancel() {\r\n        if (this._token !== -1) {\r\n            clearTimeout(this._token);\r\n            this._token = -1;\r\n        }\r\n    }\r\n    cancelAndSet(runner, timeout) {\r\n        this.cancel();\r\n        this._token = setTimeout(() => {\r\n            this._token = -1;\r\n            runner();\r\n        }, timeout);\r\n    }\r\n    setIfNotSet(runner, timeout) {\r\n        if (this._token !== -1) {\r\n            // timer is already set\r\n            return;\r\n        }\r\n        this._token = setTimeout(() => {\r\n            this._token = -1;\r\n            runner();\r\n        }, timeout);\r\n    }\r\n}\r\nexport class IntervalTimer {\r\n    constructor() {\r\n        this._token = -1;\r\n    }\r\n    dispose() {\r\n        this.cancel();\r\n    }\r\n    cancel() {\r\n        if (this._token !== -1) {\r\n            clearInterval(this._token);\r\n            this._token = -1;\r\n        }\r\n    }\r\n    cancelAndSet(runner, interval) {\r\n        this.cancel();\r\n        this._token = setInterval(() => {\r\n            runner();\r\n        }, interval);\r\n    }\r\n}\r\nexport class RunOnceScheduler {\r\n    constructor(runner, delay) {\r\n        this.timeoutToken = -1;\r\n        this.runner = runner;\r\n        this.timeout = delay;\r\n        this.timeoutHandler = this.onTimeout.bind(this);\r\n    }\r\n    /**\r\n     * Dispose RunOnceScheduler\r\n     */\r\n    dispose() {\r\n        this.cancel();\r\n        this.runner = null;\r\n    }\r\n    /**\r\n     * Cancel current scheduled runner (if any).\r\n     */\r\n    cancel() {\r\n        if (this.isScheduled()) {\r\n            clearTimeout(this.timeoutToken);\r\n            this.timeoutToken = -1;\r\n        }\r\n    }\r\n    /**\r\n     * Cancel previous runner (if any) & schedule a new runner.\r\n     */\r\n    schedule(delay = this.timeout) {\r\n        this.cancel();\r\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\r\n    }\r\n    get delay() {\r\n        return this.timeout;\r\n    }\r\n    set delay(value) {\r\n        this.timeout = value;\r\n    }\r\n    /**\r\n     * Returns true if scheduled.\r\n     */\r\n    isScheduled() {\r\n        return this.timeoutToken !== -1;\r\n    }\r\n    onTimeout() {\r\n        this.timeoutToken = -1;\r\n        if (this.runner) {\r\n            this.doRun();\r\n        }\r\n    }\r\n    doRun() {\r\n        if (this.runner) {\r\n            this.runner();\r\n        }\r\n    }\r\n}\r\n/**\r\n * Execute the callback the next time the browser is idle\r\n */\r\nexport let runWhenIdle;\r\n(function () {\r\n    if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\r\n        const dummyIdle = Object.freeze({\r\n            didTimeout: true,\r\n            timeRemaining() { return 15; }\r\n        });\r\n        runWhenIdle = (runner) => {\r\n            const handle = setTimeout(() => runner(dummyIdle));\r\n            let disposed = false;\r\n            return {\r\n                dispose() {\r\n                    if (disposed) {\r\n                        return;\r\n                    }\r\n                    disposed = true;\r\n                    clearTimeout(handle);\r\n                }\r\n            };\r\n        };\r\n    }\r\n    else {\r\n        runWhenIdle = (runner, timeout) => {\r\n            const handle = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\r\n            let disposed = false;\r\n            return {\r\n                dispose() {\r\n                    if (disposed) {\r\n                        return;\r\n                    }\r\n                    disposed = true;\r\n                    cancelIdleCallback(handle);\r\n                }\r\n            };\r\n        };\r\n    }\r\n})();\r\n/**\r\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\r\n * here: https://philipwalton.com/articles/idle-until-urgent/\r\n */\r\nexport class IdleValue {\r\n    constructor(executor) {\r\n        this._didRun = false;\r\n        this._executor = () => {\r\n            try {\r\n                this._value = executor();\r\n            }\r\n            catch (err) {\r\n                this._error = err;\r\n            }\r\n            finally {\r\n                this._didRun = true;\r\n            }\r\n        };\r\n        this._handle = runWhenIdle(() => this._executor());\r\n    }\r\n    dispose() {\r\n        this._handle.dispose();\r\n    }\r\n    get value() {\r\n        if (!this._didRun) {\r\n            this._handle.dispose();\r\n            this._executor();\r\n        }\r\n        if (this._error) {\r\n            throw this._error;\r\n        }\r\n        return this._value;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}