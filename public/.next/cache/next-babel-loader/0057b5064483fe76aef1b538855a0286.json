{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { TokenMetadata } from '../modes.js';\nexport function countEOL(text) {\n  var eolCount = 0;\n  var firstLineLength = 0;\n  var lastLineStart = 0;\n  var eol = 0\n  /* Unknown */\n  ;\n\n  for (var i = 0, len = text.length; i < len; i++) {\n    var chr = text.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n\n        if (i + 1 < len && text.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            eol |= 2\n            /* CRLF */\n            ;\n            i++; // skip \\n\n          } else {\n          // \\r... case\n          eol |= 3\n          /* Invalid */\n          ;\n        }\n\n        lastLineStart = i + 1;\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        // \\n... case\n        eol |= 1\n        /* LF */\n        ;\n\n        if (eolCount === 0) {\n          firstLineLength = i;\n        }\n\n        eolCount++;\n        lastLineStart = i + 1;\n      }\n  }\n\n  if (eolCount === 0) {\n    firstLineLength = text.length;\n  }\n\n  return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n\nfunction getDefaultMetadata(topLevelLanguageId) {\n  return (topLevelLanguageId << 0\n  /* LANGUAGEID_OFFSET */\n  | 0\n  /* Other */\n  << 8\n  /* TOKEN_TYPE_OFFSET */\n  | 0\n  /* None */\n  << 11\n  /* FONT_STYLE_OFFSET */\n  | 1\n  /* DefaultForeground */\n  << 14\n  /* FOREGROUND_OFFSET */\n  | 2\n  /* DefaultBackground */\n  << 23\n  /* BACKGROUND_OFFSET */\n  ) >>> 0;\n}\n\nvar EMPTY_LINE_TOKENS = new Uint32Array(0).buffer;\nexport var MultilineTokensBuilder = /*#__PURE__*/function () {\n  function MultilineTokensBuilder() {\n    _classCallCheck(this, MultilineTokensBuilder);\n\n    this.tokens = [];\n  }\n\n  _createClass(MultilineTokensBuilder, [{\n    key: \"add\",\n    value: function add(lineNumber, lineTokens) {\n      if (this.tokens.length > 0) {\n        var last = this.tokens[this.tokens.length - 1];\n        var lastLineNumber = last.startLineNumber + last.tokens.length - 1;\n\n        if (lastLineNumber + 1 === lineNumber) {\n          // append\n          last.tokens.push(lineTokens);\n          return;\n        }\n      }\n\n      this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\n    }\n  }]);\n\n  return MultilineTokensBuilder;\n}();\nexport var SparseEncodedTokens = /*#__PURE__*/function () {\n  function SparseEncodedTokens(tokens) {\n    _classCallCheck(this, SparseEncodedTokens);\n\n    this._tokens = tokens;\n    this._tokenCount = tokens.length / 4;\n  }\n\n  _createClass(SparseEncodedTokens, [{\n    key: \"toString\",\n    value: function toString(startLineNumber) {\n      var pieces = [];\n\n      for (var i = 0; i < this._tokenCount; i++) {\n        pieces.push(\"(\".concat(this._getDeltaLine(i) + startLineNumber, \",\").concat(this._getStartCharacter(i), \"-\").concat(this._getEndCharacter(i), \")\"));\n      }\n\n      return \"[\".concat(pieces.join(','), \"]\");\n    }\n  }, {\n    key: \"getMaxDeltaLine\",\n    value: function getMaxDeltaLine() {\n      var tokenCount = this._getTokenCount();\n\n      if (tokenCount === 0) {\n        return -1;\n      }\n\n      return this._getDeltaLine(tokenCount - 1);\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var tokenCount = this._getTokenCount();\n\n      if (tokenCount === 0) {\n        return null;\n      }\n\n      var startChar = this._getStartCharacter(0);\n\n      var maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n\n      var endChar = this._getEndCharacter(tokenCount - 1);\n\n      return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n  }, {\n    key: \"_getTokenCount\",\n    value: function _getTokenCount() {\n      return this._tokenCount;\n    }\n  }, {\n    key: \"_getDeltaLine\",\n    value: function _getDeltaLine(tokenIndex) {\n      return this._tokens[4 * tokenIndex];\n    }\n  }, {\n    key: \"_getStartCharacter\",\n    value: function _getStartCharacter(tokenIndex) {\n      return this._tokens[4 * tokenIndex + 1];\n    }\n  }, {\n    key: \"_getEndCharacter\",\n    value: function _getEndCharacter(tokenIndex) {\n      return this._tokens[4 * tokenIndex + 2];\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._getTokenCount() === 0;\n    }\n  }, {\n    key: \"getLineTokens\",\n    value: function getLineTokens(deltaLine) {\n      var low = 0;\n      var high = this._getTokenCount() - 1;\n\n      while (low < high) {\n        var mid = low + Math.floor((high - low) / 2);\n\n        var midDeltaLine = this._getDeltaLine(mid);\n\n        if (midDeltaLine < deltaLine) {\n          low = mid + 1;\n        } else if (midDeltaLine > deltaLine) {\n          high = mid - 1;\n        } else {\n          var min = mid;\n\n          while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n            min--;\n          }\n\n          var max = mid;\n\n          while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n            max++;\n          }\n\n          return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\n        }\n      }\n\n      if (this._getDeltaLine(low) === deltaLine) {\n        return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._tokenCount = 0;\n    }\n  }, {\n    key: \"removeTokens\",\n    value: function removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n      var tokens = this._tokens;\n      var tokenCount = this._tokenCount;\n      var newTokenCount = 0;\n      var hasDeletedTokens = false;\n      var firstDeltaLine = 0;\n\n      for (var i = 0; i < tokenCount; i++) {\n        var srcOffset = 4 * i;\n        var tokenDeltaLine = tokens[srcOffset];\n        var tokenStartCharacter = tokens[srcOffset + 1];\n        var tokenEndCharacter = tokens[srcOffset + 2];\n        var tokenMetadata = tokens[srcOffset + 3];\n\n        if ((tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) && (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar)) {\n          hasDeletedTokens = true;\n        } else {\n          if (newTokenCount === 0) {\n            firstDeltaLine = tokenDeltaLine;\n          }\n\n          if (hasDeletedTokens) {\n            // must move the token to the left\n            var destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n          }\n\n          newTokenCount++;\n        }\n      }\n\n      this._tokenCount = newTokenCount;\n      return firstDeltaLine;\n    }\n  }, {\n    key: \"split\",\n    value: function split(startDeltaLine, startChar, endDeltaLine, endChar) {\n      var tokens = this._tokens;\n      var tokenCount = this._tokenCount;\n      var aTokens = [];\n      var bTokens = [];\n      var destTokens = aTokens;\n      var destOffset = 0;\n      var destFirstDeltaLine = 0;\n\n      for (var i = 0; i < tokenCount; i++) {\n        var srcOffset = 4 * i;\n        var tokenDeltaLine = tokens[srcOffset];\n        var tokenStartCharacter = tokens[srcOffset + 1];\n        var tokenEndCharacter = tokens[srcOffset + 2];\n        var tokenMetadata = tokens[srcOffset + 3];\n\n        if (tokenDeltaLine > startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar) {\n          if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar) {\n            // this token is touching the range\n            continue;\n          } else {\n            // this token is after the range\n            if (destTokens !== bTokens) {\n              // this token is the first token after the range\n              destTokens = bTokens;\n              destOffset = 0;\n              destFirstDeltaLine = tokenDeltaLine;\n            }\n          }\n        }\n\n        destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n        destTokens[destOffset++] = tokenStartCharacter;\n        destTokens[destOffset++] = tokenEndCharacter;\n        destTokens[destOffset++] = tokenMetadata;\n      }\n\n      return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n  }, {\n    key: \"acceptDeleteRange\",\n    value: function acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n      // This is a bit complex, here are the cases I used to think about this:\n      //\n      // 1. The token starts before the deletion range\n      // 1a. The token is completely before the deletion range\n      //               -----------\n      //                          xxxxxxxxxxx\n      // 1b. The token starts before, the deletion range ends after the token\n      //               -----------\n      //                      xxxxxxxxxxx\n      // 1c. The token starts before, the deletion range ends precisely with the token\n      //               ---------------\n      //                      xxxxxxxx\n      // 1d. The token starts before, the deletion range is inside the token\n      //               ---------------\n      //                    xxxxx\n      //\n      // 2. The token starts at the same position with the deletion range\n      // 2a. The token starts at the same position, and ends inside the deletion range\n      //               -------\n      //               xxxxxxxxxxx\n      // 2b. The token starts at the same position, and ends at the same position as the deletion range\n      //               ----------\n      //               xxxxxxxxxx\n      // 2c. The token starts at the same position, and ends after the deletion range\n      //               -------------\n      //               xxxxxxx\n      //\n      // 3. The token starts inside the deletion range\n      // 3a. The token is inside the deletion range\n      //                -------\n      //             xxxxxxxxxxxxx\n      // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n      //                ----------\n      //             xxxxxxxxxxxxx\n      // 3c. The token starts inside the deletion range, and ends after the deletion range\n      //                ------------\n      //             xxxxxxxxxxx\n      //\n      // 4. The token starts after the deletion range\n      //                  -----------\n      //          xxxxxxxx\n      //\n      var tokens = this._tokens;\n      var tokenCount = this._tokenCount;\n      var deletedLineCount = endDeltaLine - startDeltaLine;\n      var newTokenCount = 0;\n      var hasDeletedTokens = false;\n\n      for (var i = 0; i < tokenCount; i++) {\n        var srcOffset = 4 * i;\n        var tokenDeltaLine = tokens[srcOffset];\n        var tokenStartCharacter = tokens[srcOffset + 1];\n        var tokenEndCharacter = tokens[srcOffset + 2];\n        var tokenMetadata = tokens[srcOffset + 3];\n\n        if (tokenDeltaLine < startDeltaLine || tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter) {\n          // 1a. The token is completely before the deletion range\n          // => nothing to do\n          newTokenCount++;\n          continue;\n        } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n          // 1b, 1c, 1d\n          // => the token survives, but it needs to shrink\n          if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n            // 1d. The token starts before, the deletion range is inside the token\n            // => the token shrinks by the deletion character count\n            tokenEndCharacter -= endCharacter - startCharacter;\n          } else {\n            // 1b. The token starts before, the deletion range ends after the token\n            // 1c. The token starts before, the deletion range ends precisely with the token\n            // => the token shrinks its ending to the deletion start\n            tokenEndCharacter = startCharacter;\n          }\n        } else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n          // 2a, 2b, 2c\n          if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n            // 2c. The token starts at the same position, and ends after the deletion range\n            // => the token shrinks by the deletion character count\n            tokenEndCharacter -= endCharacter - startCharacter;\n          } else {\n            // 2a. The token starts at the same position, and ends inside the deletion range\n            // 2b. The token starts at the same position, and ends at the same position as the deletion range\n            // => the token is deleted\n            hasDeletedTokens = true;\n            continue;\n          }\n        } else if (tokenDeltaLine < endDeltaLine || tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter) {\n          // 3a, 3b, 3c\n          if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n            // 3c. The token starts inside the deletion range, and ends after the deletion range\n            // => the token moves left and shrinks\n            if (tokenDeltaLine === startDeltaLine) {\n              // the deletion started on the same line as the token\n              // => the token moves left and shrinks\n              tokenStartCharacter = startCharacter;\n              tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n            } else {\n              // the deletion started on a line above the token\n              // => the token moves to the beginning of the line\n              tokenStartCharacter = 0;\n              tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n            }\n          } else {\n            // 3a. The token is inside the deletion range\n            // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n            // => the token is deleted\n            hasDeletedTokens = true;\n            continue;\n          }\n        } else if (tokenDeltaLine > endDeltaLine) {\n          // 4. (partial) The token starts after the deletion range, on a line below...\n          if (deletedLineCount === 0 && !hasDeletedTokens) {\n            // early stop, there is no need to walk all the tokens and do nothing...\n            newTokenCount = tokenCount;\n            break;\n          }\n\n          tokenDeltaLine -= deletedLineCount;\n        } else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n          // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n          if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n            tokenStartCharacter += horizontalShiftForFirstLineTokens;\n            tokenEndCharacter += horizontalShiftForFirstLineTokens;\n          }\n\n          tokenDeltaLine -= deletedLineCount;\n          tokenStartCharacter -= endCharacter - startCharacter;\n          tokenEndCharacter -= endCharacter - startCharacter;\n        } else {\n          throw new Error(\"Not possible!\");\n        }\n\n        var destOffset = 4 * newTokenCount;\n        tokens[destOffset] = tokenDeltaLine;\n        tokens[destOffset + 1] = tokenStartCharacter;\n        tokens[destOffset + 2] = tokenEndCharacter;\n        tokens[destOffset + 3] = tokenMetadata;\n        newTokenCount++;\n      }\n\n      this._tokenCount = newTokenCount;\n    }\n  }, {\n    key: \"acceptInsertText\",\n    value: function acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n      // Here are the cases I used to think about this:\n      //\n      // 1. The token is completely before the insertion point\n      //            -----------   |\n      // 2. The token ends precisely at the insertion point\n      //            -----------|\n      // 3. The token contains the insertion point\n      //            -----|------\n      // 4. The token starts precisely at the insertion point\n      //            |-----------\n      // 5. The token is completely after the insertion point\n      //            |   -----------\n      //\n      var isInsertingPreciselyOneWordCharacter = eolCount === 0 && firstLineLength === 1 && (firstCharCode >= 48\n      /* Digit0 */\n      && firstCharCode <= 57\n      /* Digit9 */\n      || firstCharCode >= 65\n      /* A */\n      && firstCharCode <= 90\n      /* Z */\n      || firstCharCode >= 97\n      /* a */\n      && firstCharCode <= 122\n      /* z */\n      );\n      var tokens = this._tokens;\n      var tokenCount = this._tokenCount;\n\n      for (var i = 0; i < tokenCount; i++) {\n        var offset = 4 * i;\n        var tokenDeltaLine = tokens[offset];\n        var tokenStartCharacter = tokens[offset + 1];\n        var tokenEndCharacter = tokens[offset + 2];\n\n        if (tokenDeltaLine < deltaLine || tokenDeltaLine === deltaLine && tokenEndCharacter < character) {\n          // 1. The token is completely before the insertion point\n          // => nothing to do\n          continue;\n        } else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n          // 2. The token ends precisely at the insertion point\n          // => expand the end character only if inserting precisely one character that is a word character\n          if (isInsertingPreciselyOneWordCharacter) {\n            tokenEndCharacter += 1;\n          } else {\n            continue;\n          }\n        } else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n          // 3. The token contains the insertion point\n          if (eolCount === 0) {\n            // => just expand the end character\n            tokenEndCharacter += firstLineLength;\n          } else {\n            // => cut off the token\n            tokenEndCharacter = character;\n          }\n        } else {\n          // 4. or 5.\n          if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n            // 4. The token starts precisely at the insertion point\n            // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n            // => otherwise behave as in case 5.\n            if (isInsertingPreciselyOneWordCharacter) {\n              continue;\n            }\n          } // => the token must move and keep its size constant\n\n\n          if (tokenDeltaLine === deltaLine) {\n            tokenDeltaLine += eolCount; // this token is on the line where the insertion is taking place\n\n            if (eolCount === 0) {\n              tokenStartCharacter += firstLineLength;\n              tokenEndCharacter += firstLineLength;\n            } else {\n              var tokenLength = tokenEndCharacter - tokenStartCharacter;\n              tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n              tokenEndCharacter = tokenStartCharacter + tokenLength;\n            }\n          } else {\n            tokenDeltaLine += eolCount;\n          }\n        }\n\n        tokens[offset] = tokenDeltaLine;\n        tokens[offset + 1] = tokenStartCharacter;\n        tokens[offset + 2] = tokenEndCharacter;\n      }\n    }\n  }]);\n\n  return SparseEncodedTokens;\n}();\nexport var LineTokens2 = /*#__PURE__*/function () {\n  function LineTokens2(tokens) {\n    _classCallCheck(this, LineTokens2);\n\n    this._tokens = tokens;\n  }\n\n  _createClass(LineTokens2, [{\n    key: \"getCount\",\n    value: function getCount() {\n      return this._tokens.length / 4;\n    }\n  }, {\n    key: \"getStartCharacter\",\n    value: function getStartCharacter(tokenIndex) {\n      return this._tokens[4 * tokenIndex + 1];\n    }\n  }, {\n    key: \"getEndCharacter\",\n    value: function getEndCharacter(tokenIndex) {\n      return this._tokens[4 * tokenIndex + 2];\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(tokenIndex) {\n      return this._tokens[4 * tokenIndex + 3];\n    }\n  }]);\n\n  return LineTokens2;\n}();\nexport var MultilineTokens2 = /*#__PURE__*/function () {\n  function MultilineTokens2(startLineNumber, tokens) {\n    _classCallCheck(this, MultilineTokens2);\n\n    this.startLineNumber = startLineNumber;\n    this.tokens = tokens;\n    this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n  }\n\n  _createClass(MultilineTokens2, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.tokens.toString(this.startLineNumber);\n    }\n  }, {\n    key: \"_updateEndLineNumber\",\n    value: function _updateEndLineNumber() {\n      this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.tokens.isEmpty();\n    }\n  }, {\n    key: \"getLineTokens\",\n    value: function getLineTokens(lineNumber) {\n      if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\n        return this.tokens.getLineTokens(lineNumber - this.startLineNumber);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      var deltaRange = this.tokens.getRange();\n\n      if (!deltaRange) {\n        return deltaRange;\n      }\n\n      return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n  }, {\n    key: \"removeTokens\",\n    value: function removeTokens(range) {\n      var startLineIndex = range.startLineNumber - this.startLineNumber;\n      var endLineIndex = range.endLineNumber - this.startLineNumber;\n      this.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n\n      this._updateEndLineNumber();\n    }\n  }, {\n    key: \"split\",\n    value: function split(range) {\n      // split tokens to two:\n      // a) all the tokens before `range`\n      // b) all the tokens after `range`\n      var startLineIndex = range.startLineNumber - this.startLineNumber;\n      var endLineIndex = range.endLineNumber - this.startLineNumber;\n\n      var _this$tokens$split = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1),\n          _this$tokens$split2 = _slicedToArray(_this$tokens$split, 3),\n          a = _this$tokens$split2[0],\n          b = _this$tokens$split2[1],\n          bDeltaLine = _this$tokens$split2[2];\n\n      return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\n    }\n  }, {\n    key: \"applyEdit\",\n    value: function applyEdit(range, text) {\n      var _countEOL = countEOL(text),\n          _countEOL2 = _slicedToArray(_countEOL, 3),\n          eolCount = _countEOL2[0],\n          firstLineLength = _countEOL2[1],\n          lastLineLength = _countEOL2[2];\n\n      this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0\n      /* Null */\n      );\n    }\n  }, {\n    key: \"acceptEdit\",\n    value: function acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n      this._acceptDeleteRange(range);\n\n      this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n\n      this._updateEndLineNumber();\n    }\n  }, {\n    key: \"_acceptDeleteRange\",\n    value: function _acceptDeleteRange(range) {\n      if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n        // Nothing to delete\n        return;\n      }\n\n      var firstLineIndex = range.startLineNumber - this.startLineNumber;\n      var lastLineIndex = range.endLineNumber - this.startLineNumber;\n\n      if (lastLineIndex < 0) {\n        // this deletion occurs entirely before this block, so we only need to adjust line numbers\n        var deletedLinesCount = lastLineIndex - firstLineIndex;\n        this.startLineNumber -= deletedLinesCount;\n        return;\n      }\n\n      var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n      if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n        // this deletion occurs entirely after this block, so there is nothing to do\n        return;\n      }\n\n      if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n        // this deletion completely encompasses this block\n        this.startLineNumber = 0;\n        this.tokens.clear();\n        return;\n      }\n\n      if (firstLineIndex < 0) {\n        var deletedBefore = -firstLineIndex;\n        this.startLineNumber -= deletedBefore;\n        this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n      } else {\n        this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n      }\n    }\n  }, {\n    key: \"_acceptInsertText\",\n    value: function _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n      if (eolCount === 0 && firstLineLength === 0) {\n        // Nothing to insert\n        return;\n      }\n\n      var lineIndex = position.lineNumber - this.startLineNumber;\n\n      if (lineIndex < 0) {\n        // this insertion occurs before this block, so we only need to adjust line numbers\n        this.startLineNumber += eolCount;\n        return;\n      }\n\n      var tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\n\n      if (lineIndex >= tokenMaxDeltaLine + 1) {\n        // this insertion occurs after this block, so there is nothing to do\n        return;\n      }\n\n      this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n  }]);\n\n  return MultilineTokens2;\n}();\nexport var MultilineTokens = function MultilineTokens(startLineNumber, tokens) {\n  _classCallCheck(this, MultilineTokens);\n\n  this.startLineNumber = startLineNumber;\n  this.tokens = tokens;\n};\n\nfunction toUint32Array(arr) {\n  if (arr instanceof Uint32Array) {\n    return arr;\n  } else {\n    return new Uint32Array(arr);\n  }\n}\n\nexport var TokensStore2 = /*#__PURE__*/function () {\n  function TokensStore2() {\n    _classCallCheck(this, TokensStore2);\n\n    this._pieces = [];\n    this._isComplete = false;\n  }\n\n  _createClass(TokensStore2, [{\n    key: \"flush\",\n    value: function flush() {\n      this._pieces = [];\n      this._isComplete = false;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._pieces.length === 0;\n    }\n  }, {\n    key: \"set\",\n    value: function set(pieces, isComplete) {\n      this._pieces = pieces || [];\n      this._isComplete = isComplete;\n    }\n  }, {\n    key: \"setPartial\",\n    value: function setPartial(_range, pieces) {\n      // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n      var range = _range;\n\n      if (pieces.length > 0) {\n        var _firstRange = pieces[0].getRange();\n\n        var _lastRange = pieces[pieces.length - 1].getRange();\n\n        if (!_firstRange || !_lastRange) {\n          return _range;\n        }\n\n        range = _range.plusRange(_firstRange).plusRange(_lastRange);\n      }\n\n      var insertPosition = null;\n\n      for (var i = 0, len = this._pieces.length; i < len; i++) {\n        var piece = this._pieces[i];\n\n        if (piece.endLineNumber < range.startLineNumber) {\n          // this piece is before the range\n          continue;\n        }\n\n        if (piece.startLineNumber > range.endLineNumber) {\n          // this piece is after the range, so mark the spot before this piece\n          // as a good insertion position and stop looping\n          insertPosition = insertPosition || {\n            index: i\n          };\n          break;\n        } // this piece might intersect with the range\n\n\n        piece.removeTokens(range);\n\n        if (piece.isEmpty()) {\n          // remove the piece if it became empty\n          this._pieces.splice(i, 1);\n\n          i--;\n          len--;\n          continue;\n        }\n\n        if (piece.endLineNumber < range.startLineNumber) {\n          // after removal, this piece is before the range\n          continue;\n        }\n\n        if (piece.startLineNumber > range.endLineNumber) {\n          // after removal, this piece is after the range\n          insertPosition = insertPosition || {\n            index: i\n          };\n          continue;\n        } // after removal, this piece contains the range\n\n\n        var _piece$split = piece.split(range),\n            _piece$split2 = _slicedToArray(_piece$split, 2),\n            a = _piece$split2[0],\n            b = _piece$split2[1];\n\n        if (a.isEmpty()) {\n          // this piece is actually after the range\n          insertPosition = insertPosition || {\n            index: i\n          };\n          continue;\n        }\n\n        if (b.isEmpty()) {\n          // this piece is actually before the range\n          continue;\n        }\n\n        this._pieces.splice(i, 1, a, b);\n\n        i++;\n        len++;\n        insertPosition = insertPosition || {\n          index: i\n        };\n      }\n\n      insertPosition = insertPosition || {\n        index: this._pieces.length\n      };\n\n      if (pieces.length > 0) {\n        this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n      } // console.log(`I HAVE ${this._pieces.length} pieces`);\n      // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n\n\n      return range;\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return this._isComplete;\n    }\n  }, {\n    key: \"addSemanticTokens\",\n    value: function addSemanticTokens(lineNumber, aTokens) {\n      var pieces = this._pieces;\n\n      if (pieces.length === 0) {\n        return aTokens;\n      }\n\n      var pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\n\n      var bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n\n      if (!bTokens) {\n        return aTokens;\n      }\n\n      var aLen = aTokens.getCount();\n      var bLen = bTokens.getCount();\n      var aIndex = 0;\n      var result = [],\n          resultLen = 0;\n      var lastEndOffset = 0;\n\n      var emitToken = function emitToken(endOffset, metadata) {\n        if (endOffset === lastEndOffset) {\n          return;\n        }\n\n        lastEndOffset = endOffset;\n        result[resultLen++] = endOffset;\n        result[resultLen++] = metadata;\n      };\n\n      for (var bIndex = 0; bIndex < bLen; bIndex++) {\n        var bStartCharacter = bTokens.getStartCharacter(bIndex);\n        var bEndCharacter = bTokens.getEndCharacter(bIndex);\n        var bMetadata = bTokens.getMetadata(bIndex);\n        var bMask = ((bMetadata & 1\n        /* SEMANTIC_USE_ITALIC */\n        ? 2048\n        /* ITALIC_MASK */\n        : 0) | (bMetadata & 2\n        /* SEMANTIC_USE_BOLD */\n        ? 4096\n        /* BOLD_MASK */\n        : 0) | (bMetadata & 4\n        /* SEMANTIC_USE_UNDERLINE */\n        ? 8192\n        /* UNDERLINE_MASK */\n        : 0) | (bMetadata & 8\n        /* SEMANTIC_USE_FOREGROUND */\n        ? 8372224\n        /* FOREGROUND_MASK */\n        : 0) | (bMetadata & 16\n        /* SEMANTIC_USE_BACKGROUND */\n        ? 4286578688\n        /* BACKGROUND_MASK */\n        : 0)) >>> 0;\n        var aMask = ~bMask >>> 0; // push any token from `a` that is before `b`\n\n        while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n          aIndex++;\n        } // push the token from `a` if it intersects the token from `b`\n\n\n        if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n          emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n        } // skip any tokens from `a` that are contained inside `b`\n\n\n        while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n          emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n          aIndex++;\n        }\n\n        if (aIndex < aLen) {\n          emitToken(bEndCharacter, aTokens.getMetadata(aIndex) & aMask | bMetadata & bMask);\n\n          if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n            // `a` ends exactly at the same spot as `b`!\n            aIndex++;\n          }\n        } else {\n          var aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1); // push the token from `b`\n\n          emitToken(bEndCharacter, aTokens.getMetadata(aMergeIndex) & aMask | bMetadata & bMask);\n        }\n      } // push the remaining tokens from `a`\n\n\n      while (aIndex < aLen) {\n        emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n        aIndex++;\n      }\n\n      return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\n    }\n  }, {\n    key: \"acceptEdit\",\n    //#region Editing\n    value: function acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n      var _iterator = _createForOfIteratorHelper(this._pieces),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var piece = _step.value;\n          piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }], [{\n    key: \"_findFirstPieceWithLine\",\n    value: function _findFirstPieceWithLine(pieces, lineNumber) {\n      var low = 0;\n      var high = pieces.length - 1;\n\n      while (low < high) {\n        var mid = low + Math.floor((high - low) / 2);\n\n        if (pieces[mid].endLineNumber < lineNumber) {\n          low = mid + 1;\n        } else if (pieces[mid].startLineNumber > lineNumber) {\n          high = mid - 1;\n        } else {\n          while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n            mid--;\n          }\n\n          return mid;\n        }\n      }\n\n      return low;\n    }\n  }]);\n\n  return TokensStore2;\n}();\nexport var TokensStore = /*#__PURE__*/function () {\n  function TokensStore() {\n    _classCallCheck(this, TokensStore);\n\n    this._lineTokens = [];\n    this._len = 0;\n  }\n\n  _createClass(TokensStore, [{\n    key: \"flush\",\n    value: function flush() {\n      this._lineTokens = [];\n      this._len = 0;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(topLevelLanguageId, lineIndex, lineText) {\n      var rawLineTokens = null;\n\n      if (lineIndex < this._len) {\n        rawLineTokens = this._lineTokens[lineIndex];\n      }\n\n      if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n        return new LineTokens(toUint32Array(rawLineTokens), lineText);\n      }\n\n      var lineTokens = new Uint32Array(2);\n      lineTokens[0] = lineText.length;\n      lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\n      return new LineTokens(lineTokens, lineText);\n    }\n  }, {\n    key: \"_ensureLine\",\n    value: function _ensureLine(lineIndex) {\n      while (lineIndex >= this._len) {\n        this._lineTokens[this._len] = null;\n        this._len++;\n      }\n    }\n  }, {\n    key: \"_deleteLines\",\n    value: function _deleteLines(start, deleteCount) {\n      if (deleteCount === 0) {\n        return;\n      }\n\n      if (start + deleteCount > this._len) {\n        deleteCount = this._len - start;\n      }\n\n      this._lineTokens.splice(start, deleteCount);\n\n      this._len -= deleteCount;\n    }\n  }, {\n    key: \"_insertLines\",\n    value: function _insertLines(insertIndex, insertCount) {\n      if (insertCount === 0) {\n        return;\n      }\n\n      var lineTokens = [];\n\n      for (var i = 0; i < insertCount; i++) {\n        lineTokens[i] = null;\n      }\n\n      this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n      this._len += insertCount;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n      var tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\n\n      this._ensureLine(lineIndex);\n\n      var oldTokens = this._lineTokens[lineIndex];\n      this._lineTokens[lineIndex] = tokens;\n\n      if (checkEquality) {\n        return !TokensStore._equals(oldTokens, tokens);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"acceptEdit\",\n    //#region Editing\n    value: function acceptEdit(range, eolCount, firstLineLength) {\n      this._acceptDeleteRange(range);\n\n      this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n  }, {\n    key: \"_acceptDeleteRange\",\n    value: function _acceptDeleteRange(range) {\n      var firstLineIndex = range.startLineNumber - 1;\n\n      if (firstLineIndex >= this._len) {\n        return;\n      }\n\n      if (range.startLineNumber === range.endLineNumber) {\n        if (range.startColumn === range.endColumn) {\n          // Nothing to delete\n          return;\n        }\n\n        this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n        return;\n      }\n\n      this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n      var lastLineIndex = range.endLineNumber - 1;\n      var lastLineTokens = null;\n\n      if (lastLineIndex < this._len) {\n        lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n      } // Take remaining text on last line and append it to remaining text on first line\n\n\n      this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens); // Delete middle lines\n\n      this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }, {\n    key: \"_acceptInsertText\",\n    value: function _acceptInsertText(position, eolCount, firstLineLength) {\n      if (eolCount === 0 && firstLineLength === 0) {\n        // Nothing to insert\n        return;\n      }\n\n      var lineIndex = position.lineNumber - 1;\n\n      if (lineIndex >= this._len) {\n        return;\n      }\n\n      if (eolCount === 0) {\n        // Inserting text on one line\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        return;\n      }\n\n      this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n      this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n\n      this._insertLines(position.lineNumber, eolCount);\n    }\n  }], [{\n    key: \"_massageTokens\",\n    value: function _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n      var tokens = _tokens ? toUint32Array(_tokens) : null;\n\n      if (lineTextLength === 0) {\n        var hasDifferentLanguageId = false;\n\n        if (tokens && tokens.length > 1) {\n          hasDifferentLanguageId = TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId;\n        }\n\n        if (!hasDifferentLanguageId) {\n          return EMPTY_LINE_TOKENS;\n        }\n      }\n\n      if (!tokens || tokens.length === 0) {\n        var _tokens2 = new Uint32Array(2);\n\n        _tokens2[0] = lineTextLength;\n        _tokens2[1] = getDefaultMetadata(topLevelLanguageId);\n        return _tokens2.buffer;\n      } // Ensure the last token covers the end of the text\n\n\n      tokens[tokens.length - 2] = lineTextLength;\n\n      if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n        // Store directly the ArrayBuffer pointer to save an object\n        return tokens.buffer;\n      }\n\n      return tokens;\n    }\n  }, {\n    key: \"_equals\",\n    value: function _equals(_a, _b) {\n      if (!_a || !_b) {\n        return !_a && !_b;\n      }\n\n      var a = toUint32Array(_a);\n      var b = toUint32Array(_b);\n\n      if (a.length !== b.length) {\n        return false;\n      }\n\n      for (var i = 0, len = a.length; i < len; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_deleteBeginning\",\n    value: function _deleteBeginning(lineTokens, toChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n\n      return TokensStore._delete(lineTokens, 0, toChIndex);\n    }\n  }, {\n    key: \"_deleteEnding\",\n    value: function _deleteEnding(lineTokens, fromChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n\n      var tokens = toUint32Array(lineTokens);\n      var lineTextLength = tokens[tokens.length - 2];\n      return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete(lineTokens, fromChIndex, toChIndex) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n        return lineTokens;\n      }\n\n      var tokens = toUint32Array(lineTokens);\n      var tokensCount = tokens.length >>> 1; // special case: deleting everything\n\n      if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n        return EMPTY_LINE_TOKENS;\n      }\n\n      var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n      var fromTokenStartOffset = fromTokenIndex > 0 ? tokens[fromTokenIndex - 1 << 1] : 0;\n      var fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n      if (toChIndex < fromTokenEndOffset) {\n        // the delete range is inside a single token\n        var _delta = toChIndex - fromChIndex;\n\n        for (var i = fromTokenIndex; i < tokensCount; i++) {\n          tokens[i << 1] -= _delta;\n        }\n\n        return lineTokens;\n      }\n\n      var dest;\n      var lastEnd;\n\n      if (fromTokenStartOffset !== fromChIndex) {\n        tokens[fromTokenIndex << 1] = fromChIndex;\n        dest = fromTokenIndex + 1 << 1;\n        lastEnd = fromChIndex;\n      } else {\n        dest = fromTokenIndex << 1;\n        lastEnd = fromTokenStartOffset;\n      }\n\n      var delta = toChIndex - fromChIndex;\n\n      for (var tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n        var tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\n        if (tokenEndOffset > lastEnd) {\n          tokens[dest++] = tokenEndOffset;\n          tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n          lastEnd = tokenEndOffset;\n        }\n      }\n\n      if (dest === tokens.length) {\n        // nothing to trim\n        return lineTokens;\n      }\n\n      var tmp = new Uint32Array(dest);\n      tmp.set(tokens.subarray(0, dest), 0);\n      return tmp.buffer;\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(lineTokens, _otherTokens) {\n      if (_otherTokens === EMPTY_LINE_TOKENS) {\n        return lineTokens;\n      }\n\n      if (lineTokens === EMPTY_LINE_TOKENS) {\n        return _otherTokens;\n      }\n\n      if (lineTokens === null) {\n        return lineTokens;\n      }\n\n      if (_otherTokens === null) {\n        // cannot determine combined line length...\n        return null;\n      }\n\n      var myTokens = toUint32Array(lineTokens);\n      var otherTokens = toUint32Array(_otherTokens);\n      var otherTokensCount = otherTokens.length >>> 1;\n      var result = new Uint32Array(myTokens.length + otherTokens.length);\n      result.set(myTokens, 0);\n      var dest = myTokens.length;\n      var delta = myTokens[myTokens.length - 2];\n\n      for (var i = 0; i < otherTokensCount; i++) {\n        result[dest++] = otherTokens[i << 1] + delta;\n        result[dest++] = otherTokens[(i << 1) + 1];\n      }\n\n      return result.buffer;\n    }\n  }, {\n    key: \"_insert\",\n    value: function _insert(lineTokens, chIndex, textLength) {\n      if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n        // nothing to do\n        return lineTokens;\n      }\n\n      var tokens = toUint32Array(lineTokens);\n      var tokensCount = tokens.length >>> 1;\n      var fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\n      if (fromTokenIndex > 0) {\n        var fromTokenStartOffset = tokens[fromTokenIndex - 1 << 1];\n\n        if (fromTokenStartOffset === chIndex) {\n          fromTokenIndex--;\n        }\n      }\n\n      for (var tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n        tokens[tokenIndex << 1] += textLength;\n      }\n\n      return lineTokens;\n    }\n  }]);\n\n  return TokensStore;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/tokensStore.js"],"names":["arrays","LineTokens","Position","Range","TokenMetadata","countEOL","text","eolCount","firstLineLength","lastLineStart","eol","i","len","length","chr","charCodeAt","getDefaultMetadata","topLevelLanguageId","EMPTY_LINE_TOKENS","Uint32Array","buffer","MultilineTokensBuilder","tokens","lineNumber","lineTokens","last","lastLineNumber","startLineNumber","push","MultilineTokens","SparseEncodedTokens","_tokens","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","tokenIndex","deltaLine","low","high","mid","Math","floor","midDeltaLine","min","max","LineTokens2","subarray","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","tokenMetadata","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","lastLineLength","firstCharCode","isInsertingPreciselyOneWordCharacter","offset","tokenLength","MultilineTokens2","endLineNumber","getMaxDeltaLine","toString","isEmpty","getLineTokens","deltaRange","getRange","startColumn","endColumn","range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","split","a","b","bDeltaLine","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","position","lineIndex","acceptInsertText","column","toUint32Array","arr","TokensStore2","_pieces","_isComplete","isComplete","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","splice","arrayInsert","pieceIndex","_findFirstPieceWithLine","aLen","getCount","bLen","aIndex","result","resultLen","lastEndOffset","emitToken","endOffset","metadata","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","getEndOffset","getStartOffset","aMergeIndex","getLineContent","TokensStore","_lineTokens","_len","lineText","rawLineTokens","start","deleteCount","insertIndex","insertCount","lineTextLength","checkEquality","_massageTokens","_ensureLine","oldTokens","_equals","_delete","_deleteEnding","lastLineTokens","_deleteBeginning","_append","_deleteLines","_insert","_insertLines","hasDifferentLanguageId","getLanguageId","byteOffset","byteLength","_a","_b","toChIndex","fromChIndex","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tokenEndOffset","tmp","set","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,MAAZ,MAAwB,gCAAxB;AACA,SAASC,UAAT,QAA2B,uBAA3B;AACA,SAASC,QAAT,QAAyB,qBAAzB;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,aAAT,QAA8B,aAA9B;AACA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwB;AAC3B,MAAIC,QAAQ,GAAG,CAAf;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,GAAG,GAAG;AAAE;AAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGN,IAAI,CAACO,MAA3B,EAAmCF,CAAC,GAAGC,GAAvC,EAA4CD,CAAC,EAA7C,EAAiD;AAC7C,QAAMG,GAAG,GAAGR,IAAI,CAACS,UAAL,CAAgBJ,CAAhB,CAAZ;;AACA,QAAIG,GAAG,KAAK;AAAG;AAAf,MAAqC;AACjC,YAAIP,QAAQ,KAAK,CAAjB,EAAoB;AAChBC,UAAAA,eAAe,GAAGG,CAAlB;AACH;;AACDJ,QAAAA,QAAQ;;AACR,YAAII,CAAC,GAAG,CAAJ,GAAQC,GAAR,IAAeN,IAAI,CAACS,UAAL,CAAgBJ,CAAC,GAAG,CAApB,MAA2B;AAAG;AAAjD,UAAiE;AAC7D;AACAD,YAAAA,GAAG,IAAI;AAAE;AAAT;AACAC,YAAAA,CAAC,GAH4D,CAGxD;AACR,WAJD,MAKK;AACD;AACAD,UAAAA,GAAG,IAAI;AAAE;AAAT;AACH;;AACDD,QAAAA,aAAa,GAAGE,CAAC,GAAG,CAApB;AACH,OAfD,MAgBK,IAAIG,GAAG,KAAK;AAAG;AAAf,MAA+B;AAChC;AACAJ,QAAAA,GAAG,IAAI;AAAE;AAAT;;AACA,YAAIH,QAAQ,KAAK,CAAjB,EAAoB;AAChBC,UAAAA,eAAe,GAAGG,CAAlB;AACH;;AACDJ,QAAAA,QAAQ;AACRE,QAAAA,aAAa,GAAGE,CAAC,GAAG,CAApB;AACH;AACJ;;AACD,MAAIJ,QAAQ,KAAK,CAAjB,EAAoB;AAChBC,IAAAA,eAAe,GAAGF,IAAI,CAACO,MAAvB;AACH;;AACD,SAAO,CAACN,QAAD,EAAWC,eAAX,EAA4BF,IAAI,CAACO,MAAL,GAAcJ,aAA1C,EAAyDC,GAAzD,CAAP;AACH;;AACD,SAASM,kBAAT,CAA4BC,kBAA5B,EAAgD;AAC5C,SAAO,CAAEA,kBAAkB,IAAI;AAAE;AAAzB,IACD;AAAE;AAAF,KAAiB;AAAE;AADlB,IAED;AAAE;AAAF,KAAgB;AAAG;AAFlB,IAGD;AAAE;AAAF,KAA6B;AAAG;AAH/B,IAID;AAAE;AAAF,KAA6B;AAAG;AAJhC,QAI8D,CAJrE;AAKH;;AACD,IAAMC,iBAAiB,GAAI,IAAIC,WAAJ,CAAgB,CAAhB,CAAD,CAAqBC,MAA/C;AACA,WAAaC,sBAAb;AACI,oCAAc;AAAA;;AACV,SAAKC,MAAL,GAAc,EAAd;AACH;;AAHL;AAAA;AAAA,wBAIQC,UAJR,EAIoBC,UAJpB,EAIgC;AACxB,UAAI,KAAKF,MAAL,CAAYT,MAAZ,GAAqB,CAAzB,EAA4B;AACxB,YAAMY,IAAI,GAAG,KAAKH,MAAL,CAAY,KAAKA,MAAL,CAAYT,MAAZ,GAAqB,CAAjC,CAAb;AACA,YAAMa,cAAc,GAAGD,IAAI,CAACE,eAAL,GAAuBF,IAAI,CAACH,MAAL,CAAYT,MAAnC,GAA4C,CAAnE;;AACA,YAAIa,cAAc,GAAG,CAAjB,KAAuBH,UAA3B,EAAuC;AACnC;AACAE,UAAAA,IAAI,CAACH,MAAL,CAAYM,IAAZ,CAAiBJ,UAAjB;AACA;AACH;AACJ;;AACD,WAAKF,MAAL,CAAYM,IAAZ,CAAiB,IAAIC,eAAJ,CAAoBN,UAApB,EAAgC,CAACC,UAAD,CAAhC,CAAjB;AACH;AAfL;;AAAA;AAAA;AAiBA,WAAaM,mBAAb;AACI,+BAAYR,MAAZ,EAAoB;AAAA;;AAChB,SAAKS,OAAL,GAAeT,MAAf;AACA,SAAKU,WAAL,GAAmBV,MAAM,CAACT,MAAP,GAAgB,CAAnC;AACH;;AAJL;AAAA;AAAA,6BAKac,eALb,EAK8B;AACtB,UAAIM,MAAM,GAAG,EAAb;;AACA,WAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKqB,WAAzB,EAAsCrB,CAAC,EAAvC,EAA2C;AACvCsB,QAAAA,MAAM,CAACL,IAAP,YAAgB,KAAKM,aAAL,CAAmBvB,CAAnB,IAAwBgB,eAAxC,cAA2D,KAAKQ,kBAAL,CAAwBxB,CAAxB,CAA3D,cAAyF,KAAKyB,gBAAL,CAAsBzB,CAAtB,CAAzF;AACH;;AACD,wBAAWsB,MAAM,CAACI,IAAP,CAAY,GAAZ,CAAX;AACH;AAXL;AAAA;AAAA,sCAYsB;AACd,UAAMC,UAAU,GAAG,KAAKC,cAAL,EAAnB;;AACA,UAAID,UAAU,KAAK,CAAnB,EAAsB;AAClB,eAAO,CAAC,CAAR;AACH;;AACD,aAAO,KAAKJ,aAAL,CAAmBI,UAAU,GAAG,CAAhC,CAAP;AACH;AAlBL;AAAA;AAAA,+BAmBe;AACP,UAAMA,UAAU,GAAG,KAAKC,cAAL,EAAnB;;AACA,UAAID,UAAU,KAAK,CAAnB,EAAsB;AAClB,eAAO,IAAP;AACH;;AACD,UAAME,SAAS,GAAG,KAAKL,kBAAL,CAAwB,CAAxB,CAAlB;;AACA,UAAMM,YAAY,GAAG,KAAKP,aAAL,CAAmBI,UAAU,GAAG,CAAhC,CAArB;;AACA,UAAMI,OAAO,GAAG,KAAKN,gBAAL,CAAsBE,UAAU,GAAG,CAAnC,CAAhB;;AACA,aAAO,IAAInC,KAAJ,CAAU,CAAV,EAAaqC,SAAS,GAAG,CAAzB,EAA4BC,YAA5B,EAA0CC,OAAO,GAAG,CAApD,CAAP;AACH;AA5BL;AAAA;AAAA,qCA6BqB;AACb,aAAO,KAAKV,WAAZ;AACH;AA/BL;AAAA;AAAA,kCAgCkBW,UAhClB,EAgC8B;AACtB,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAjB,CAAP;AACH;AAlCL;AAAA;AAAA,uCAmCuBA,UAnCvB,EAmCmC;AAC3B,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAJ,GAAiB,CAA9B,CAAP;AACH;AArCL;AAAA;AAAA,qCAsCqBA,UAtCrB,EAsCiC;AACzB,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAJ,GAAiB,CAA9B,CAAP;AACH;AAxCL;AAAA;AAAA,8BAyCc;AACN,aAAQ,KAAKJ,cAAL,OAA0B,CAAlC;AACH;AA3CL;AAAA;AAAA,kCA4CkBK,SA5ClB,EA4C6B;AACrB,UAAIC,GAAG,GAAG,CAAV;AACA,UAAIC,IAAI,GAAG,KAAKP,cAAL,KAAwB,CAAnC;;AACA,aAAOM,GAAG,GAAGC,IAAb,EAAmB;AACf,YAAMC,GAAG,GAAGF,GAAG,GAAGG,IAAI,CAACC,KAAL,CAAW,CAACH,IAAI,GAAGD,GAAR,IAAe,CAA1B,CAAlB;;AACA,YAAMK,YAAY,GAAG,KAAKhB,aAAL,CAAmBa,GAAnB,CAArB;;AACA,YAAIG,YAAY,GAAGN,SAAnB,EAA8B;AAC1BC,UAAAA,GAAG,GAAGE,GAAG,GAAG,CAAZ;AACH,SAFD,MAGK,IAAIG,YAAY,GAAGN,SAAnB,EAA8B;AAC/BE,UAAAA,IAAI,GAAGC,GAAG,GAAG,CAAb;AACH,SAFI,MAGA;AACD,cAAII,GAAG,GAAGJ,GAAV;;AACA,iBAAOI,GAAG,GAAGN,GAAN,IAAa,KAAKX,aAAL,CAAmBiB,GAAG,GAAG,CAAzB,MAAgCP,SAApD,EAA+D;AAC3DO,YAAAA,GAAG;AACN;;AACD,cAAIC,GAAG,GAAGL,GAAV;;AACA,iBAAOK,GAAG,GAAGN,IAAN,IAAc,KAAKZ,aAAL,CAAmBkB,GAAG,GAAG,CAAzB,MAAgCR,SAArD,EAAgE;AAC5DQ,YAAAA,GAAG;AACN;;AACD,iBAAO,IAAIC,WAAJ,CAAgB,KAAKtB,OAAL,CAAauB,QAAb,CAAsB,IAAIH,GAA1B,EAA+B,IAAIC,GAAJ,GAAU,CAAzC,CAAhB,CAAP;AACH;AACJ;;AACD,UAAI,KAAKlB,aAAL,CAAmBW,GAAnB,MAA4BD,SAAhC,EAA2C;AACvC,eAAO,IAAIS,WAAJ,CAAgB,KAAKtB,OAAL,CAAauB,QAAb,CAAsB,IAAIT,GAA1B,EAA+B,IAAIA,GAAJ,GAAU,CAAzC,CAAhB,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AAxEL;AAAA;AAAA,4BAyEY;AACJ,WAAKb,WAAL,GAAmB,CAAnB;AACH;AA3EL;AAAA;AAAA,iCA4EiBuB,cA5EjB,EA4EiCf,SA5EjC,EA4E4CgB,YA5E5C,EA4E0Dd,OA5E1D,EA4EmE;AAC3D,UAAMpB,MAAM,GAAG,KAAKS,OAApB;AACA,UAAMO,UAAU,GAAG,KAAKN,WAAxB;AACA,UAAIyB,aAAa,GAAG,CAApB;AACA,UAAIC,gBAAgB,GAAG,KAAvB;AACA,UAAIC,cAAc,GAAG,CAArB;;AACA,WAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,UAApB,EAAgC3B,CAAC,EAAjC,EAAqC;AACjC,YAAMiD,SAAS,GAAG,IAAIjD,CAAtB;AACA,YAAMkD,cAAc,GAAGvC,MAAM,CAACsC,SAAD,CAA7B;AACA,YAAME,mBAAmB,GAAGxC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAAlC;AACA,YAAMG,iBAAiB,GAAGzC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAAhC;AACA,YAAMI,aAAa,GAAG1C,MAAM,CAACsC,SAAS,GAAG,CAAb,CAA5B;;AACA,YAAI,CAACC,cAAc,GAAGN,cAAjB,IAAoCM,cAAc,KAAKN,cAAnB,IAAqCQ,iBAAiB,IAAIvB,SAA/F,MACIqB,cAAc,GAAGL,YAAjB,IAAkCK,cAAc,KAAKL,YAAnB,IAAmCM,mBAAmB,IAAIpB,OADhG,CAAJ,EAC+G;AAC3GgB,UAAAA,gBAAgB,GAAG,IAAnB;AACH,SAHD,MAIK;AACD,cAAID,aAAa,KAAK,CAAtB,EAAyB;AACrBE,YAAAA,cAAc,GAAGE,cAAjB;AACH;;AACD,cAAIH,gBAAJ,EAAsB;AAClB;AACA,gBAAMO,UAAU,GAAG,IAAIR,aAAvB;AACAnC,YAAAA,MAAM,CAAC2C,UAAD,CAAN,GAAqBJ,cAAc,GAAGF,cAAtC;AACArC,YAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBH,mBAAzB;AACAxC,YAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBF,iBAAzB;AACAzC,YAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBD,aAAzB;AACH;;AACDP,UAAAA,aAAa;AAChB;AACJ;;AACD,WAAKzB,WAAL,GAAmByB,aAAnB;AACA,aAAOE,cAAP;AACH;AA7GL;AAAA;AAAA,0BA8GUJ,cA9GV,EA8G0Bf,SA9G1B,EA8GqCgB,YA9GrC,EA8GmDd,OA9GnD,EA8G4D;AACpD,UAAMpB,MAAM,GAAG,KAAKS,OAApB;AACA,UAAMO,UAAU,GAAG,KAAKN,WAAxB;AACA,UAAIkC,OAAO,GAAG,EAAd;AACA,UAAIC,OAAO,GAAG,EAAd;AACA,UAAIC,UAAU,GAAGF,OAAjB;AACA,UAAID,UAAU,GAAG,CAAjB;AACA,UAAII,kBAAkB,GAAG,CAAzB;;AACA,WAAK,IAAI1D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,UAApB,EAAgC3B,CAAC,EAAjC,EAAqC;AACjC,YAAMiD,SAAS,GAAG,IAAIjD,CAAtB;AACA,YAAMkD,cAAc,GAAGvC,MAAM,CAACsC,SAAD,CAA7B;AACA,YAAME,mBAAmB,GAAGxC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAAlC;AACA,YAAMG,iBAAiB,GAAGzC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAAhC;AACA,YAAMI,aAAa,GAAG1C,MAAM,CAACsC,SAAS,GAAG,CAAb,CAA5B;;AACA,YAAKC,cAAc,GAAGN,cAAjB,IAAoCM,cAAc,KAAKN,cAAnB,IAAqCQ,iBAAiB,IAAIvB,SAAnG,EAAgH;AAC5G,cAAKqB,cAAc,GAAGL,YAAjB,IAAkCK,cAAc,KAAKL,YAAnB,IAAmCM,mBAAmB,IAAIpB,OAAjG,EAA4G;AACxG;AACA;AACH,WAHD,MAIK;AACD;AACA,gBAAI0B,UAAU,KAAKD,OAAnB,EAA4B;AACxB;AACAC,cAAAA,UAAU,GAAGD,OAAb;AACAF,cAAAA,UAAU,GAAG,CAAb;AACAI,cAAAA,kBAAkB,GAAGR,cAArB;AACH;AACJ;AACJ;;AACDO,QAAAA,UAAU,CAACH,UAAU,EAAX,CAAV,GAA2BJ,cAAc,GAAGQ,kBAA5C;AACAD,QAAAA,UAAU,CAACH,UAAU,EAAX,CAAV,GAA2BH,mBAA3B;AACAM,QAAAA,UAAU,CAACH,UAAU,EAAX,CAAV,GAA2BF,iBAA3B;AACAK,QAAAA,UAAU,CAACH,UAAU,EAAX,CAAV,GAA2BD,aAA3B;AACH;;AACD,aAAO,CAAC,IAAIlC,mBAAJ,CAAwB,IAAIX,WAAJ,CAAgB+C,OAAhB,CAAxB,CAAD,EAAoD,IAAIpC,mBAAJ,CAAwB,IAAIX,WAAJ,CAAgBgD,OAAhB,CAAxB,CAApD,EAAuGE,kBAAvG,CAAP;AACH;AAjJL;AAAA;AAAA,sCAkJsBC,iCAlJtB,EAkJyDf,cAlJzD,EAkJyEgB,cAlJzE,EAkJyFf,YAlJzF,EAkJuGgB,YAlJvG,EAkJqH;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMlD,MAAM,GAAG,KAAKS,OAApB;AACA,UAAMO,UAAU,GAAG,KAAKN,WAAxB;AACA,UAAMyC,gBAAgB,GAAIjB,YAAY,GAAGD,cAAzC;AACA,UAAIE,aAAa,GAAG,CAApB;AACA,UAAIC,gBAAgB,GAAG,KAAvB;;AACA,WAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,UAApB,EAAgC3B,CAAC,EAAjC,EAAqC;AACjC,YAAMiD,SAAS,GAAG,IAAIjD,CAAtB;AACA,YAAIkD,cAAc,GAAGvC,MAAM,CAACsC,SAAD,CAA3B;AACA,YAAIE,mBAAmB,GAAGxC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAAhC;AACA,YAAIG,iBAAiB,GAAGzC,MAAM,CAACsC,SAAS,GAAG,CAAb,CAA9B;AACA,YAAMI,aAAa,GAAG1C,MAAM,CAACsC,SAAS,GAAG,CAAb,CAA5B;;AACA,YAAIC,cAAc,GAAGN,cAAjB,IAAoCM,cAAc,KAAKN,cAAnB,IAAqCQ,iBAAiB,IAAIQ,cAAlG,EAAmH;AAC/G;AACA;AACAd,UAAAA,aAAa;AACb;AACH,SALD,MAMK,IAAII,cAAc,KAAKN,cAAnB,IAAqCO,mBAAmB,GAAGS,cAA/D,EAA+E;AAChF;AACA;AACA,cAAIV,cAAc,KAAKL,YAAnB,IAAmCO,iBAAiB,GAAGS,YAA3D,EAAyE;AACrE;AACA;AACAT,YAAAA,iBAAiB,IAAKS,YAAY,GAAGD,cAArC;AACH,WAJD,MAKK;AACD;AACA;AACA;AACAR,YAAAA,iBAAiB,GAAGQ,cAApB;AACH;AACJ,SAdI,MAeA,IAAIV,cAAc,KAAKN,cAAnB,IAAqCO,mBAAmB,KAAKS,cAAjE,EAAiF;AAClF;AACA,cAAIV,cAAc,KAAKL,YAAnB,IAAmCO,iBAAiB,GAAGS,YAA3D,EAAyE;AACrE;AACA;AACAT,YAAAA,iBAAiB,IAAKS,YAAY,GAAGD,cAArC;AACH,WAJD,MAKK;AACD;AACA;AACA;AACAb,YAAAA,gBAAgB,GAAG,IAAnB;AACA;AACH;AACJ,SAdI,MAeA,IAAIG,cAAc,GAAGL,YAAjB,IAAkCK,cAAc,KAAKL,YAAnB,IAAmCM,mBAAmB,GAAGU,YAA/F,EAA8G;AAC/G;AACA,cAAIX,cAAc,KAAKL,YAAnB,IAAmCO,iBAAiB,GAAGS,YAA3D,EAAyE;AACrE;AACA;AACA,gBAAIX,cAAc,KAAKN,cAAvB,EAAuC;AACnC;AACA;AACAO,cAAAA,mBAAmB,GAAGS,cAAtB;AACAR,cAAAA,iBAAiB,GAAGD,mBAAmB,IAAIC,iBAAiB,GAAGS,YAAxB,CAAvC;AACH,aALD,MAMK;AACD;AACA;AACAV,cAAAA,mBAAmB,GAAG,CAAtB;AACAC,cAAAA,iBAAiB,GAAGD,mBAAmB,IAAIC,iBAAiB,GAAGS,YAAxB,CAAvC;AACH;AACJ,WAfD,MAgBK;AACD;AACA;AACA;AACAd,YAAAA,gBAAgB,GAAG,IAAnB;AACA;AACH;AACJ,SAzBI,MA0BA,IAAIG,cAAc,GAAGL,YAArB,EAAmC;AACpC;AACA,cAAIiB,gBAAgB,KAAK,CAArB,IAA0B,CAACf,gBAA/B,EAAiD;AAC7C;AACAD,YAAAA,aAAa,GAAGnB,UAAhB;AACA;AACH;;AACDuB,UAAAA,cAAc,IAAIY,gBAAlB;AACH,SARI,MASA,IAAIZ,cAAc,KAAKL,YAAnB,IAAmCM,mBAAmB,IAAIU,YAA9D,EAA4E;AAC7E;AACA,cAAIF,iCAAiC,IAAIT,cAAc,KAAK,CAA5D,EAA+D;AAC3DC,YAAAA,mBAAmB,IAAIQ,iCAAvB;AACAP,YAAAA,iBAAiB,IAAIO,iCAArB;AACH;;AACDT,UAAAA,cAAc,IAAIY,gBAAlB;AACAX,UAAAA,mBAAmB,IAAKU,YAAY,GAAGD,cAAvC;AACAR,UAAAA,iBAAiB,IAAKS,YAAY,GAAGD,cAArC;AACH,SATI,MAUA;AACD,gBAAM,IAAIG,KAAJ,iBAAN;AACH;;AACD,YAAMT,UAAU,GAAG,IAAIR,aAAvB;AACAnC,QAAAA,MAAM,CAAC2C,UAAD,CAAN,GAAqBJ,cAArB;AACAvC,QAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBH,mBAAzB;AACAxC,QAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBF,iBAAzB;AACAzC,QAAAA,MAAM,CAAC2C,UAAU,GAAG,CAAd,CAAN,GAAyBD,aAAzB;AACAP,QAAAA,aAAa;AAChB;;AACD,WAAKzB,WAAL,GAAmByB,aAAnB;AACH;AApSL;AAAA;AAAA,qCAqSqBb,SArSrB,EAqSgC+B,SArShC,EAqS2CpE,QArS3C,EAqSqDC,eArSrD,EAqSsEoE,cArStE,EAqSsFC,aArStF,EAqSqG;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,oCAAoC,GAAIvE,QAAQ,KAAK,CAAb,IACvCC,eAAe,KAAK,CADmB,KAErCqE,aAAa,IAAI;AAAG;AAApB,SAAoCA,aAAa,IAAI;AAAG;AAAzD,SACIA,aAAa,IAAI;AAAG;AAApB,SAA+BA,aAAa,IAAI;AAAG;AADvD,SAEIA,aAAa,IAAI;AAAG;AAApB,SAA+BA,aAAa,IAAI;AAAI;AAJlB,OAA9C;AAKA,UAAMvD,MAAM,GAAG,KAAKS,OAApB;AACA,UAAMO,UAAU,GAAG,KAAKN,WAAxB;;AACA,WAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,UAApB,EAAgC3B,CAAC,EAAjC,EAAqC;AACjC,YAAMoE,MAAM,GAAG,IAAIpE,CAAnB;AACA,YAAIkD,cAAc,GAAGvC,MAAM,CAACyD,MAAD,CAA3B;AACA,YAAIjB,mBAAmB,GAAGxC,MAAM,CAACyD,MAAM,GAAG,CAAV,CAAhC;AACA,YAAIhB,iBAAiB,GAAGzC,MAAM,CAACyD,MAAM,GAAG,CAAV,CAA9B;;AACA,YAAIlB,cAAc,GAAGjB,SAAjB,IAA+BiB,cAAc,KAAKjB,SAAnB,IAAgCmB,iBAAiB,GAAGY,SAAvF,EAAmG;AAC/F;AACA;AACA;AACH,SAJD,MAKK,IAAId,cAAc,KAAKjB,SAAnB,IAAgCmB,iBAAiB,KAAKY,SAA1D,EAAqE;AACtE;AACA;AACA,cAAIG,oCAAJ,EAA0C;AACtCf,YAAAA,iBAAiB,IAAI,CAArB;AACH,WAFD,MAGK;AACD;AACH;AACJ,SATI,MAUA,IAAIF,cAAc,KAAKjB,SAAnB,IAAgCkB,mBAAmB,GAAGa,SAAtD,IAAmEA,SAAS,GAAGZ,iBAAnF,EAAsG;AACvG;AACA,cAAIxD,QAAQ,KAAK,CAAjB,EAAoB;AAChB;AACAwD,YAAAA,iBAAiB,IAAIvD,eAArB;AACH,WAHD,MAIK;AACD;AACAuD,YAAAA,iBAAiB,GAAGY,SAApB;AACH;AACJ,SAVI,MAWA;AACD;AACA,cAAId,cAAc,KAAKjB,SAAnB,IAAgCkB,mBAAmB,KAAKa,SAA5D,EAAuE;AACnE;AACA;AACA;AACA,gBAAIG,oCAAJ,EAA0C;AACtC;AACH;AACJ,WATA,CAUD;;;AACA,cAAIjB,cAAc,KAAKjB,SAAvB,EAAkC;AAC9BiB,YAAAA,cAAc,IAAItD,QAAlB,CAD8B,CAE9B;;AACA,gBAAIA,QAAQ,KAAK,CAAjB,EAAoB;AAChBuD,cAAAA,mBAAmB,IAAItD,eAAvB;AACAuD,cAAAA,iBAAiB,IAAIvD,eAArB;AACH,aAHD,MAIK;AACD,kBAAMwE,WAAW,GAAGjB,iBAAiB,GAAGD,mBAAxC;AACAA,cAAAA,mBAAmB,GAAGc,cAAc,IAAId,mBAAmB,GAAGa,SAA1B,CAApC;AACAZ,cAAAA,iBAAiB,GAAGD,mBAAmB,GAAGkB,WAA1C;AACH;AACJ,WAZD,MAaK;AACDnB,YAAAA,cAAc,IAAItD,QAAlB;AACH;AACJ;;AACDe,QAAAA,MAAM,CAACyD,MAAD,CAAN,GAAiBlB,cAAjB;AACAvC,QAAAA,MAAM,CAACyD,MAAM,GAAG,CAAV,CAAN,GAAqBjB,mBAArB;AACAxC,QAAAA,MAAM,CAACyD,MAAM,GAAG,CAAV,CAAN,GAAqBhB,iBAArB;AACH;AACJ;AAzXL;;AAAA;AAAA;AA2XA,WAAaV,WAAb;AACI,uBAAY/B,MAAZ,EAAoB;AAAA;;AAChB,SAAKS,OAAL,GAAeT,MAAf;AACH;;AAHL;AAAA;AAAA,+BAIe;AACP,aAAO,KAAKS,OAAL,CAAalB,MAAb,GAAsB,CAA7B;AACH;AANL;AAAA;AAAA,sCAOsB8B,UAPtB,EAOkC;AAC1B,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAJ,GAAiB,CAA9B,CAAP;AACH;AATL;AAAA;AAAA,oCAUoBA,UAVpB,EAUgC;AACxB,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAJ,GAAiB,CAA9B,CAAP;AACH;AAZL;AAAA;AAAA,gCAagBA,UAbhB,EAa4B;AACpB,aAAO,KAAKZ,OAAL,CAAa,IAAIY,UAAJ,GAAiB,CAA9B,CAAP;AACH;AAfL;;AAAA;AAAA;AAiBA,WAAasC,gBAAb;AACI,4BAAYtD,eAAZ,EAA6BL,MAA7B,EAAqC;AAAA;;AACjC,SAAKK,eAAL,GAAuBA,eAAvB;AACA,SAAKL,MAAL,GAAcA,MAAd;AACA,SAAK4D,aAAL,GAAqB,KAAKvD,eAAL,GAAuB,KAAKL,MAAL,CAAY6D,eAAZ,EAA5C;AACH;;AALL;AAAA;AAAA,+BAMe;AACP,aAAO,KAAK7D,MAAL,CAAY8D,QAAZ,CAAqB,KAAKzD,eAA1B,CAAP;AACH;AARL;AAAA;AAAA,2CAS2B;AACnB,WAAKuD,aAAL,GAAqB,KAAKvD,eAAL,GAAuB,KAAKL,MAAL,CAAY6D,eAAZ,EAA5C;AACH;AAXL;AAAA;AAAA,8BAYc;AACN,aAAO,KAAK7D,MAAL,CAAY+D,OAAZ,EAAP;AACH;AAdL;AAAA;AAAA,kCAekB9D,UAflB,EAe8B;AACtB,UAAI,KAAKI,eAAL,IAAwBJ,UAAxB,IAAsCA,UAAU,IAAI,KAAK2D,aAA7D,EAA4E;AACxE,eAAO,KAAK5D,MAAL,CAAYgE,aAAZ,CAA0B/D,UAAU,GAAG,KAAKI,eAA5C,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AApBL;AAAA;AAAA,+BAqBe;AACP,UAAM4D,UAAU,GAAG,KAAKjE,MAAL,CAAYkE,QAAZ,EAAnB;;AACA,UAAI,CAACD,UAAL,EAAiB;AACb,eAAOA,UAAP;AACH;;AACD,aAAO,IAAIpF,KAAJ,CAAU,KAAKwB,eAAL,GAAuB4D,UAAU,CAAC5D,eAA5C,EAA6D4D,UAAU,CAACE,WAAxE,EAAqF,KAAK9D,eAAL,GAAuB4D,UAAU,CAACL,aAAvH,EAAsIK,UAAU,CAACG,SAAjJ,CAAP;AACH;AA3BL;AAAA;AAAA,iCA4BiBC,KA5BjB,EA4BwB;AAChB,UAAMC,cAAc,GAAGD,KAAK,CAAChE,eAAN,GAAwB,KAAKA,eAApD;AACA,UAAMkE,YAAY,GAAGF,KAAK,CAACT,aAAN,GAAsB,KAAKvD,eAAhD;AACA,WAAKA,eAAL,IAAwB,KAAKL,MAAL,CAAYwE,YAAZ,CAAyBF,cAAzB,EAAyCD,KAAK,CAACF,WAAN,GAAoB,CAA7D,EAAgEI,YAAhE,EAA8EF,KAAK,CAACD,SAAN,GAAkB,CAAhG,CAAxB;;AACA,WAAKK,oBAAL;AACH;AAjCL;AAAA;AAAA,0BAkCUJ,KAlCV,EAkCiB;AACT;AACA;AACA;AACA,UAAMC,cAAc,GAAGD,KAAK,CAAChE,eAAN,GAAwB,KAAKA,eAApD;AACA,UAAMkE,YAAY,GAAGF,KAAK,CAACT,aAAN,GAAsB,KAAKvD,eAAhD;;AALS,+BAMkB,KAAKL,MAAL,CAAY0E,KAAZ,CAAkBJ,cAAlB,EAAkCD,KAAK,CAACF,WAAN,GAAoB,CAAtD,EAAyDI,YAAzD,EAAuEF,KAAK,CAACD,SAAN,GAAkB,CAAzF,CANlB;AAAA;AAAA,UAMFO,CANE;AAAA,UAMCC,CAND;AAAA,UAMIC,UANJ;;AAOT,aAAO,CAAC,IAAIlB,gBAAJ,CAAqB,KAAKtD,eAA1B,EAA2CsE,CAA3C,CAAD,EAAgD,IAAIhB,gBAAJ,CAAqB,KAAKtD,eAAL,GAAuBwE,UAA5C,EAAwDD,CAAxD,CAAhD,CAAP;AACH;AA1CL;AAAA;AAAA,8BA2CcP,KA3Cd,EA2CqBrF,IA3CrB,EA2C2B;AAAA,sBACiCD,QAAQ,CAACC,IAAD,CADzC;AAAA;AAAA,UACZC,QADY;AAAA,UACFC,eADE;AAAA,UACeoE,cADf;;AAEnB,WAAKwB,UAAL,CAAgBT,KAAhB,EAAuBpF,QAAvB,EAAiCC,eAAjC,EAAkDoE,cAAlD,EAAkEtE,IAAI,CAACO,MAAL,GAAc,CAAd,GAAkBP,IAAI,CAACS,UAAL,CAAgB,CAAhB,CAAlB,GAAuC;AAAE;AAA3G;AACH;AA9CL;AAAA;AAAA,+BA+Ce4E,KA/Cf,EA+CsBpF,QA/CtB,EA+CgCC,eA/ChC,EA+CiDoE,cA/CjD,EA+CiEC,aA/CjE,EA+CgF;AACxE,WAAKwB,kBAAL,CAAwBV,KAAxB;;AACA,WAAKW,iBAAL,CAAuB,IAAIpG,QAAJ,CAAayF,KAAK,CAAChE,eAAnB,EAAoCgE,KAAK,CAACF,WAA1C,CAAvB,EAA+ElF,QAA/E,EAAyFC,eAAzF,EAA0GoE,cAA1G,EAA0HC,aAA1H;;AACA,WAAKkB,oBAAL;AACH;AAnDL;AAAA;AAAA,uCAoDuBJ,KApDvB,EAoD8B;AACtB,UAAIA,KAAK,CAAChE,eAAN,KAA0BgE,KAAK,CAACT,aAAhC,IAAiDS,KAAK,CAACF,WAAN,KAAsBE,KAAK,CAACD,SAAjF,EAA4F;AACxF;AACA;AACH;;AACD,UAAMa,cAAc,GAAGZ,KAAK,CAAChE,eAAN,GAAwB,KAAKA,eAApD;AACA,UAAM6E,aAAa,GAAGb,KAAK,CAACT,aAAN,GAAsB,KAAKvD,eAAjD;;AACA,UAAI6E,aAAa,GAAG,CAApB,EAAuB;AACnB;AACA,YAAMC,iBAAiB,GAAGD,aAAa,GAAGD,cAA1C;AACA,aAAK5E,eAAL,IAAwB8E,iBAAxB;AACA;AACH;;AACD,UAAMC,iBAAiB,GAAG,KAAKpF,MAAL,CAAY6D,eAAZ,EAA1B;;AACA,UAAIoB,cAAc,IAAIG,iBAAiB,GAAG,CAA1C,EAA6C;AACzC;AACA;AACH;;AACD,UAAIH,cAAc,GAAG,CAAjB,IAAsBC,aAAa,IAAIE,iBAAiB,GAAG,CAA/D,EAAkE;AAC9D;AACA,aAAK/E,eAAL,GAAuB,CAAvB;AACA,aAAKL,MAAL,CAAYqF,KAAZ;AACA;AACH;;AACD,UAAIJ,cAAc,GAAG,CAArB,EAAwB;AACpB,YAAMK,aAAa,GAAG,CAACL,cAAvB;AACA,aAAK5E,eAAL,IAAwBiF,aAAxB;AACA,aAAKtF,MAAL,CAAYuF,iBAAZ,CAA8BlB,KAAK,CAACF,WAAN,GAAoB,CAAlD,EAAqD,CAArD,EAAwD,CAAxD,EAA2De,aAA3D,EAA0Eb,KAAK,CAACD,SAAN,GAAkB,CAA5F;AACH,OAJD,MAKK;AACD,aAAKpE,MAAL,CAAYuF,iBAAZ,CAA8B,CAA9B,EAAiCN,cAAjC,EAAiDZ,KAAK,CAACF,WAAN,GAAoB,CAArE,EAAwEe,aAAxE,EAAuFb,KAAK,CAACD,SAAN,GAAkB,CAAzG;AACH;AACJ;AApFL;AAAA;AAAA,sCAqFsBoB,QArFtB,EAqFgCvG,QArFhC,EAqF0CC,eArF1C,EAqF2DoE,cArF3D,EAqF2EC,aArF3E,EAqF0F;AAClF,UAAItE,QAAQ,KAAK,CAAb,IAAkBC,eAAe,KAAK,CAA1C,EAA6C;AACzC;AACA;AACH;;AACD,UAAMuG,SAAS,GAAGD,QAAQ,CAACvF,UAAT,GAAsB,KAAKI,eAA7C;;AACA,UAAIoF,SAAS,GAAG,CAAhB,EAAmB;AACf;AACA,aAAKpF,eAAL,IAAwBpB,QAAxB;AACA;AACH;;AACD,UAAMmG,iBAAiB,GAAG,KAAKpF,MAAL,CAAY6D,eAAZ,EAA1B;;AACA,UAAI4B,SAAS,IAAIL,iBAAiB,GAAG,CAArC,EAAwC;AACpC;AACA;AACH;;AACD,WAAKpF,MAAL,CAAY0F,gBAAZ,CAA6BD,SAA7B,EAAwCD,QAAQ,CAACG,MAAT,GAAkB,CAA1D,EAA6D1G,QAA7D,EAAuEC,eAAvE,EAAwFoE,cAAxF,EAAwGC,aAAxG;AACH;AAtGL;;AAAA;AAAA;AAwGA,WAAahD,eAAb,GACI,yBAAYF,eAAZ,EAA6BL,MAA7B,EAAqC;AAAA;;AACjC,OAAKK,eAAL,GAAuBA,eAAvB;AACA,OAAKL,MAAL,GAAcA,MAAd;AACH,CAJL;;AAMA,SAAS4F,aAAT,CAAuBC,GAAvB,EAA4B;AACxB,MAAIA,GAAG,YAAYhG,WAAnB,EAAgC;AAC5B,WAAOgG,GAAP;AACH,GAFD,MAGK;AACD,WAAO,IAAIhG,WAAJ,CAAgBgG,GAAhB,CAAP;AACH;AACJ;;AACD,WAAaC,YAAb;AACI,0BAAc;AAAA;;AACV,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACH;;AAJL;AAAA;AAAA,4BAKY;AACJ,WAAKD,OAAL,GAAe,EAAf;AACA,WAAKC,WAAL,GAAmB,KAAnB;AACH;AARL;AAAA;AAAA,8BASc;AACN,aAAQ,KAAKD,OAAL,CAAaxG,MAAb,KAAwB,CAAhC;AACH;AAXL;AAAA;AAAA,wBAYQoB,MAZR,EAYgBsF,UAZhB,EAY4B;AACpB,WAAKF,OAAL,GAAepF,MAAM,IAAI,EAAzB;AACA,WAAKqF,WAAL,GAAmBC,UAAnB;AACH;AAfL;AAAA;AAAA,+BAgBeC,MAhBf,EAgBuBvF,MAhBvB,EAgB+B;AACvB;AACA,UAAI0D,KAAK,GAAG6B,MAAZ;;AACA,UAAIvF,MAAM,CAACpB,MAAP,GAAgB,CAApB,EAAuB;AACnB,YAAM4G,WAAW,GAAGxF,MAAM,CAAC,CAAD,CAAN,CAAUuD,QAAV,EAApB;;AACA,YAAMkC,UAAU,GAAGzF,MAAM,CAACA,MAAM,CAACpB,MAAP,GAAgB,CAAjB,CAAN,CAA0B2E,QAA1B,EAAnB;;AACA,YAAI,CAACiC,WAAD,IAAgB,CAACC,UAArB,EAAiC;AAC7B,iBAAOF,MAAP;AACH;;AACD7B,QAAAA,KAAK,GAAG6B,MAAM,CAACG,SAAP,CAAiBF,WAAjB,EAA8BE,SAA9B,CAAwCD,UAAxC,CAAR;AACH;;AACD,UAAIE,cAAc,GAAG,IAArB;;AACA,WAAK,IAAIjH,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAG,KAAKyG,OAAL,CAAaxG,MAAnC,EAA2CF,CAAC,GAAGC,GAA/C,EAAoDD,CAAC,EAArD,EAAyD;AACrD,YAAMkH,KAAK,GAAG,KAAKR,OAAL,CAAa1G,CAAb,CAAd;;AACA,YAAIkH,KAAK,CAAC3C,aAAN,GAAsBS,KAAK,CAAChE,eAAhC,EAAiD;AAC7C;AACA;AACH;;AACD,YAAIkG,KAAK,CAAClG,eAAN,GAAwBgE,KAAK,CAACT,aAAlC,EAAiD;AAC7C;AACA;AACA0C,UAAAA,cAAc,GAAGA,cAAc,IAAI;AAAEE,YAAAA,KAAK,EAAEnH;AAAT,WAAnC;AACA;AACH,SAXoD,CAYrD;;;AACAkH,QAAAA,KAAK,CAAC/B,YAAN,CAAmBH,KAAnB;;AACA,YAAIkC,KAAK,CAACxC,OAAN,EAAJ,EAAqB;AACjB;AACA,eAAKgC,OAAL,CAAaU,MAAb,CAAoBpH,CAApB,EAAuB,CAAvB;;AACAA,UAAAA,CAAC;AACDC,UAAAA,GAAG;AACH;AACH;;AACD,YAAIiH,KAAK,CAAC3C,aAAN,GAAsBS,KAAK,CAAChE,eAAhC,EAAiD;AAC7C;AACA;AACH;;AACD,YAAIkG,KAAK,CAAClG,eAAN,GAAwBgE,KAAK,CAACT,aAAlC,EAAiD;AAC7C;AACA0C,UAAAA,cAAc,GAAGA,cAAc,IAAI;AAAEE,YAAAA,KAAK,EAAEnH;AAAT,WAAnC;AACA;AACH,SA7BoD,CA8BrD;;;AA9BqD,2BA+BtCkH,KAAK,CAAC7B,KAAN,CAAYL,KAAZ,CA/BsC;AAAA;AAAA,YA+B9CM,CA/B8C;AAAA,YA+B3CC,CA/B2C;;AAgCrD,YAAID,CAAC,CAACZ,OAAF,EAAJ,EAAiB;AACb;AACAuC,UAAAA,cAAc,GAAGA,cAAc,IAAI;AAAEE,YAAAA,KAAK,EAAEnH;AAAT,WAAnC;AACA;AACH;;AACD,YAAIuF,CAAC,CAACb,OAAF,EAAJ,EAAiB;AACb;AACA;AACH;;AACD,aAAKgC,OAAL,CAAaU,MAAb,CAAoBpH,CAApB,EAAuB,CAAvB,EAA0BsF,CAA1B,EAA6BC,CAA7B;;AACAvF,QAAAA,CAAC;AACDC,QAAAA,GAAG;AACHgH,QAAAA,cAAc,GAAGA,cAAc,IAAI;AAAEE,UAAAA,KAAK,EAAEnH;AAAT,SAAnC;AACH;;AACDiH,MAAAA,cAAc,GAAGA,cAAc,IAAI;AAAEE,QAAAA,KAAK,EAAE,KAAKT,OAAL,CAAaxG;AAAtB,OAAnC;;AACA,UAAIoB,MAAM,CAACpB,MAAP,GAAgB,CAApB,EAAuB;AACnB,aAAKwG,OAAL,GAAerH,MAAM,CAACgI,WAAP,CAAmB,KAAKX,OAAxB,EAAiCO,cAAc,CAACE,KAAhD,EAAuD7F,MAAvD,CAAf;AACH,OA7DsB,CA8DvB;AACA;;;AACA,aAAO0D,KAAP;AACH;AAjFL;AAAA;AAAA,iCAkFiB;AACT,aAAO,KAAK2B,WAAZ;AACH;AApFL;AAAA;AAAA,sCAqFsB/F,UArFtB,EAqFkC2C,OArFlC,EAqF2C;AACnC,UAAMjC,MAAM,GAAG,KAAKoF,OAApB;;AACA,UAAIpF,MAAM,CAACpB,MAAP,KAAkB,CAAtB,EAAyB;AACrB,eAAOqD,OAAP;AACH;;AACD,UAAM+D,UAAU,GAAGb,YAAY,CAACc,uBAAb,CAAqCjG,MAArC,EAA6CV,UAA7C,CAAnB;;AACA,UAAM4C,OAAO,GAAGlC,MAAM,CAACgG,UAAD,CAAN,CAAmB3C,aAAnB,CAAiC/D,UAAjC,CAAhB;;AACA,UAAI,CAAC4C,OAAL,EAAc;AACV,eAAOD,OAAP;AACH;;AACD,UAAMiE,IAAI,GAAGjE,OAAO,CAACkE,QAAR,EAAb;AACA,UAAMC,IAAI,GAAGlE,OAAO,CAACiE,QAAR,EAAb;AACA,UAAIE,MAAM,GAAG,CAAb;AACA,UAAIC,MAAM,GAAG,EAAb;AAAA,UAAiBC,SAAS,GAAG,CAA7B;AACA,UAAIC,aAAa,GAAG,CAApB;;AACA,UAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,SAAD,EAAYC,QAAZ,EAAyB;AACvC,YAAID,SAAS,KAAKF,aAAlB,EAAiC;AAC7B;AACH;;AACDA,QAAAA,aAAa,GAAGE,SAAhB;AACAJ,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBG,SAAtB;AACAJ,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBI,QAAtB;AACH,OAPD;;AAQA,WAAK,IAAIC,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGR,IAA9B,EAAoCQ,MAAM,EAA1C,EAA8C;AAC1C,YAAMC,eAAe,GAAG3E,OAAO,CAAC4E,iBAAR,CAA0BF,MAA1B,CAAxB;AACA,YAAMG,aAAa,GAAG7E,OAAO,CAAC8E,eAAR,CAAwBJ,MAAxB,CAAtB;AACA,YAAMK,SAAS,GAAG/E,OAAO,CAACgF,WAAR,CAAoBN,MAApB,CAAlB;AACA,YAAMO,KAAK,GAAG,CAAC,CAAEF,SAAS,GAAG;AAAE;AAAf,UAA4C;AAAK;AAAjD,UAAqE,CAAtE,KACPA,SAAS,GAAG;AAAE;AAAf,UAA0C;AAAK;AAA/C,UAAiE,CADzD,KAEPA,SAAS,GAAG;AAAE;AAAf,UAA+C;AAAK;AAApD,UAA2E,CAFnE,KAGPA,SAAS,GAAG;AAAE;AAAf,UAAgD;AAAQ;AAAxD,UAAgF,CAHxE,KAIPA,SAAS,GAAG;AAAG;AAAhB,UAAiD;AAAW;AAA5D,UAAoF,CAJ5E,CAAD,MAIqF,CAJnG;AAKA,YAAMG,KAAK,GAAI,CAACD,KAAF,KAAa,CAA3B,CAT0C,CAU1C;;AACA,eAAOd,MAAM,GAAGH,IAAT,IAAiBjE,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,KAAgCQ,eAAxD,EAAyE;AACrEJ,UAAAA,SAAS,CAACxE,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,CAAD,EAA+BpE,OAAO,CAACiF,WAAR,CAAoBb,MAApB,CAA/B,CAAT;AACAA,UAAAA,MAAM;AACT,SAdyC,CAe1C;;;AACA,YAAIA,MAAM,GAAGH,IAAT,IAAiBjE,OAAO,CAACqF,cAAR,CAAuBjB,MAAvB,IAAiCQ,eAAtD,EAAuE;AACnEJ,UAAAA,SAAS,CAACI,eAAD,EAAkB5E,OAAO,CAACiF,WAAR,CAAoBb,MAApB,CAAlB,CAAT;AACH,SAlByC,CAmB1C;;;AACA,eAAOA,MAAM,GAAGH,IAAT,IAAiBjE,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,IAA+BU,aAAvD,EAAsE;AAClEN,UAAAA,SAAS,CAACxE,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,CAAD,EAAgCpE,OAAO,CAACiF,WAAR,CAAoBb,MAApB,IAA8Be,KAA/B,GAAyCH,SAAS,GAAGE,KAApF,CAAT;AACAd,UAAAA,MAAM;AACT;;AACD,YAAIA,MAAM,GAAGH,IAAb,EAAmB;AACfO,UAAAA,SAAS,CAACM,aAAD,EAAiB9E,OAAO,CAACiF,WAAR,CAAoBb,MAApB,IAA8Be,KAA/B,GAAyCH,SAAS,GAAGE,KAArE,CAAT;;AACA,cAAIlF,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,MAAiCU,aAArC,EAAoD;AAChD;AACAV,YAAAA,MAAM;AACT;AACJ,SAND,MAOK;AACD,cAAMkB,WAAW,GAAGxG,IAAI,CAACG,GAAL,CAASH,IAAI,CAACI,GAAL,CAAS,CAAT,EAAYkF,MAAM,GAAG,CAArB,CAAT,EAAkCH,IAAI,GAAG,CAAzC,CAApB,CADC,CAED;;AACAO,UAAAA,SAAS,CAACM,aAAD,EAAiB9E,OAAO,CAACiF,WAAR,CAAoBK,WAApB,IAAmCH,KAApC,GAA8CH,SAAS,GAAGE,KAA1E,CAAT;AACH;AACJ,OA3DkC,CA4DnC;;;AACA,aAAOd,MAAM,GAAGH,IAAhB,EAAsB;AAClBO,QAAAA,SAAS,CAACxE,OAAO,CAACoF,YAAR,CAAqBhB,MAArB,CAAD,EAA+BpE,OAAO,CAACiF,WAAR,CAAoBb,MAApB,CAA/B,CAAT;AACAA,QAAAA,MAAM;AACT;;AACD,aAAO,IAAIrI,UAAJ,CAAe,IAAIkB,WAAJ,CAAgBoH,MAAhB,CAAf,EAAwCrE,OAAO,CAACuF,cAAR,EAAxC,CAAP;AACH;AAvJL;AAAA;AA4KI;AA5KJ,+BA6Ke9D,KA7Kf,EA6KsBpF,QA7KtB,EA6KgCC,eA7KhC,EA6KiDoE,cA7KjD,EA6KiEC,aA7KjE,EA6KgF;AAAA,iDACpD,KAAKwC,OAD+C;AAAA;;AAAA;AACxE,4DAAkC;AAAA,cAAvBQ,KAAuB;AAC9BA,UAAAA,KAAK,CAACzB,UAAN,CAAiBT,KAAjB,EAAwBpF,QAAxB,EAAkCC,eAAlC,EAAmDoE,cAAnD,EAAmEC,aAAnE;AACH;AAHuE;AAAA;AAAA;AAAA;AAAA;AAI3E;AAjLL;AAAA;AAAA,4CAwJmC5C,MAxJnC,EAwJ2CV,UAxJ3C,EAwJuD;AAC/C,UAAIsB,GAAG,GAAG,CAAV;AACA,UAAIC,IAAI,GAAGb,MAAM,CAACpB,MAAP,GAAgB,CAA3B;;AACA,aAAOgC,GAAG,GAAGC,IAAb,EAAmB;AACf,YAAIC,GAAG,GAAGF,GAAG,GAAGG,IAAI,CAACC,KAAL,CAAW,CAACH,IAAI,GAAGD,GAAR,IAAe,CAA1B,CAAhB;;AACA,YAAIZ,MAAM,CAACc,GAAD,CAAN,CAAYmC,aAAZ,GAA4B3D,UAAhC,EAA4C;AACxCsB,UAAAA,GAAG,GAAGE,GAAG,GAAG,CAAZ;AACH,SAFD,MAGK,IAAId,MAAM,CAACc,GAAD,CAAN,CAAYpB,eAAZ,GAA8BJ,UAAlC,EAA8C;AAC/CuB,UAAAA,IAAI,GAAGC,GAAG,GAAG,CAAb;AACH,SAFI,MAGA;AACD,iBAAOA,GAAG,GAAGF,GAAN,IAAaZ,MAAM,CAACc,GAAG,GAAG,CAAP,CAAN,CAAgBpB,eAAhB,IAAmCJ,UAAhD,IAA8DA,UAAU,IAAIU,MAAM,CAACc,GAAG,GAAG,CAAP,CAAN,CAAgBmC,aAAnG,EAAkH;AAC9GnC,YAAAA,GAAG;AACN;;AACD,iBAAOA,GAAP;AACH;AACJ;;AACD,aAAOF,GAAP;AACH;AA3KL;;AAAA;AAAA;AAmLA,WAAa6G,WAAb;AACI,yBAAc;AAAA;;AACV,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,IAAL,GAAY,CAAZ;AACH;;AAJL;AAAA;AAAA,4BAKY;AACJ,WAAKD,WAAL,GAAmB,EAAnB;AACA,WAAKC,IAAL,GAAY,CAAZ;AACH;AARL;AAAA;AAAA,8BASc3I,kBATd,EASkC8F,SATlC,EAS6C8C,QAT7C,EASuD;AAC/C,UAAIC,aAAa,GAAG,IAApB;;AACA,UAAI/C,SAAS,GAAG,KAAK6C,IAArB,EAA2B;AACvBE,QAAAA,aAAa,GAAG,KAAKH,WAAL,CAAiB5C,SAAjB,CAAhB;AACH;;AACD,UAAI+C,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK5I,iBAAhD,EAAmE;AAC/D,eAAO,IAAIjB,UAAJ,CAAeiH,aAAa,CAAC4C,aAAD,CAA5B,EAA6CD,QAA7C,CAAP;AACH;;AACD,UAAIrI,UAAU,GAAG,IAAIL,WAAJ,CAAgB,CAAhB,CAAjB;AACAK,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBqI,QAAQ,CAAChJ,MAAzB;AACAW,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBR,kBAAkB,CAACC,kBAAD,CAAlC;AACA,aAAO,IAAIhB,UAAJ,CAAeuB,UAAf,EAA2BqI,QAA3B,CAAP;AACH;AArBL;AAAA;AAAA,gCA+CgB9C,SA/ChB,EA+C2B;AACnB,aAAOA,SAAS,IAAI,KAAK6C,IAAzB,EAA+B;AAC3B,aAAKD,WAAL,CAAiB,KAAKC,IAAtB,IAA8B,IAA9B;AACA,aAAKA,IAAL;AACH;AACJ;AApDL;AAAA;AAAA,iCAqDiBG,KArDjB,EAqDwBC,WArDxB,EAqDqC;AAC7B,UAAIA,WAAW,KAAK,CAApB,EAAuB;AACnB;AACH;;AACD,UAAID,KAAK,GAAGC,WAAR,GAAsB,KAAKJ,IAA/B,EAAqC;AACjCI,QAAAA,WAAW,GAAG,KAAKJ,IAAL,GAAYG,KAA1B;AACH;;AACD,WAAKJ,WAAL,CAAiB5B,MAAjB,CAAwBgC,KAAxB,EAA+BC,WAA/B;;AACA,WAAKJ,IAAL,IAAaI,WAAb;AACH;AA9DL;AAAA;AAAA,iCA+DiBC,WA/DjB,EA+D8BC,WA/D9B,EA+D2C;AACnC,UAAIA,WAAW,KAAK,CAApB,EAAuB;AACnB;AACH;;AACD,UAAI1I,UAAU,GAAG,EAAjB;;AACA,WAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuJ,WAApB,EAAiCvJ,CAAC,EAAlC,EAAsC;AAClCa,QAAAA,UAAU,CAACb,CAAD,CAAV,GAAgB,IAAhB;AACH;;AACD,WAAKgJ,WAAL,GAAmB3J,MAAM,CAACgI,WAAP,CAAmB,KAAK2B,WAAxB,EAAqCM,WAArC,EAAkDzI,UAAlD,CAAnB;AACA,WAAKoI,IAAL,IAAaM,WAAb;AACH;AAzEL;AAAA;AAAA,8BA0EcjJ,kBA1Ed,EA0EkC8F,SA1ElC,EA0E6CoD,cA1E7C,EA0E6DpI,OA1E7D,EA0EsEqI,aA1EtE,EA0EqF;AAC7E,UAAM9I,MAAM,GAAGoI,WAAW,CAACW,cAAZ,CAA2BpJ,kBAA3B,EAA+CkJ,cAA/C,EAA+DpI,OAA/D,CAAf;;AACA,WAAKuI,WAAL,CAAiBvD,SAAjB;;AACA,UAAMwD,SAAS,GAAG,KAAKZ,WAAL,CAAiB5C,SAAjB,CAAlB;AACA,WAAK4C,WAAL,CAAiB5C,SAAjB,IAA8BzF,MAA9B;;AACA,UAAI8I,aAAJ,EAAmB;AACf,eAAO,CAACV,WAAW,CAACc,OAAZ,CAAoBD,SAApB,EAA+BjJ,MAA/B,CAAR;AACH;;AACD,aAAO,KAAP;AACH;AAnFL;AAAA;AAoGI;AApGJ,+BAqGeqE,KArGf,EAqGsBpF,QArGtB,EAqGgCC,eArGhC,EAqGiD;AACzC,WAAK6F,kBAAL,CAAwBV,KAAxB;;AACA,WAAKW,iBAAL,CAAuB,IAAIpG,QAAJ,CAAayF,KAAK,CAAChE,eAAnB,EAAoCgE,KAAK,CAACF,WAA1C,CAAvB,EAA+ElF,QAA/E,EAAyFC,eAAzF;AACH;AAxGL;AAAA;AAAA,uCAyGuBmF,KAzGvB,EAyG8B;AACtB,UAAMY,cAAc,GAAGZ,KAAK,CAAChE,eAAN,GAAwB,CAA/C;;AACA,UAAI4E,cAAc,IAAI,KAAKqD,IAA3B,EAAiC;AAC7B;AACH;;AACD,UAAIjE,KAAK,CAAChE,eAAN,KAA0BgE,KAAK,CAACT,aAApC,EAAmD;AAC/C,YAAIS,KAAK,CAACF,WAAN,KAAsBE,KAAK,CAACD,SAAhC,EAA2C;AACvC;AACA;AACH;;AACD,aAAKiE,WAAL,CAAiBpD,cAAjB,IAAmCmD,WAAW,CAACe,OAAZ,CAAoB,KAAKd,WAAL,CAAiBpD,cAAjB,CAApB,EAAsDZ,KAAK,CAACF,WAAN,GAAoB,CAA1E,EAA6EE,KAAK,CAACD,SAAN,GAAkB,CAA/F,CAAnC;AACA;AACH;;AACD,WAAKiE,WAAL,CAAiBpD,cAAjB,IAAmCmD,WAAW,CAACgB,aAAZ,CAA0B,KAAKf,WAAL,CAAiBpD,cAAjB,CAA1B,EAA4DZ,KAAK,CAACF,WAAN,GAAoB,CAAhF,CAAnC;AACA,UAAMe,aAAa,GAAGb,KAAK,CAACT,aAAN,GAAsB,CAA5C;AACA,UAAIyF,cAAc,GAAG,IAArB;;AACA,UAAInE,aAAa,GAAG,KAAKoD,IAAzB,EAA+B;AAC3Be,QAAAA,cAAc,GAAGjB,WAAW,CAACkB,gBAAZ,CAA6B,KAAKjB,WAAL,CAAiBnD,aAAjB,CAA7B,EAA8Db,KAAK,CAACD,SAAN,GAAkB,CAAhF,CAAjB;AACH,OAlBqB,CAmBtB;;;AACA,WAAKiE,WAAL,CAAiBpD,cAAjB,IAAmCmD,WAAW,CAACmB,OAAZ,CAAoB,KAAKlB,WAAL,CAAiBpD,cAAjB,CAApB,EAAsDoE,cAAtD,CAAnC,CApBsB,CAqBtB;;AACA,WAAKG,YAAL,CAAkBnF,KAAK,CAAChE,eAAxB,EAAyCgE,KAAK,CAACT,aAAN,GAAsBS,KAAK,CAAChE,eAArE;AACH;AAhIL;AAAA;AAAA,sCAiIsBmF,QAjItB,EAiIgCvG,QAjIhC,EAiI0CC,eAjI1C,EAiI2D;AACnD,UAAID,QAAQ,KAAK,CAAb,IAAkBC,eAAe,KAAK,CAA1C,EAA6C;AACzC;AACA;AACH;;AACD,UAAMuG,SAAS,GAAGD,QAAQ,CAACvF,UAAT,GAAsB,CAAxC;;AACA,UAAIwF,SAAS,IAAI,KAAK6C,IAAtB,EAA4B;AACxB;AACH;;AACD,UAAIrJ,QAAQ,KAAK,CAAjB,EAAoB;AAChB;AACA,aAAKoJ,WAAL,CAAiB5C,SAAjB,IAA8B2C,WAAW,CAACqB,OAAZ,CAAoB,KAAKpB,WAAL,CAAiB5C,SAAjB,CAApB,EAAiDD,QAAQ,CAACG,MAAT,GAAkB,CAAnE,EAAsEzG,eAAtE,CAA9B;AACA;AACH;;AACD,WAAKmJ,WAAL,CAAiB5C,SAAjB,IAA8B2C,WAAW,CAACgB,aAAZ,CAA0B,KAAKf,WAAL,CAAiB5C,SAAjB,CAA1B,EAAuDD,QAAQ,CAACG,MAAT,GAAkB,CAAzE,CAA9B;AACA,WAAK0C,WAAL,CAAiB5C,SAAjB,IAA8B2C,WAAW,CAACqB,OAAZ,CAAoB,KAAKpB,WAAL,CAAiB5C,SAAjB,CAApB,EAAiDD,QAAQ,CAACG,MAAT,GAAkB,CAAnE,EAAsEzG,eAAtE,CAA9B;;AACA,WAAKwK,YAAL,CAAkBlE,QAAQ,CAACvF,UAA3B,EAAuChB,QAAvC;AACH;AAlJL;AAAA;AAAA,mCAsB0BU,kBAtB1B,EAsB8CkJ,cAtB9C,EAsB8DpI,OAtB9D,EAsBuE;AAC/D,UAAMT,MAAM,GAAGS,OAAO,GAAGmF,aAAa,CAACnF,OAAD,CAAhB,GAA4B,IAAlD;;AACA,UAAIoI,cAAc,KAAK,CAAvB,EAA0B;AACtB,YAAIc,sBAAsB,GAAG,KAA7B;;AACA,YAAI3J,MAAM,IAAIA,MAAM,CAACT,MAAP,GAAgB,CAA9B,EAAiC;AAC7BoK,UAAAA,sBAAsB,GAAI7K,aAAa,CAAC8K,aAAd,CAA4B5J,MAAM,CAAC,CAAD,CAAlC,MAA2CL,kBAArE;AACH;;AACD,YAAI,CAACgK,sBAAL,EAA6B;AACzB,iBAAO/J,iBAAP;AACH;AACJ;;AACD,UAAI,CAACI,MAAD,IAAWA,MAAM,CAACT,MAAP,KAAkB,CAAjC,EAAoC;AAChC,YAAMS,QAAM,GAAG,IAAIH,WAAJ,CAAgB,CAAhB,CAAf;;AACAG,QAAAA,QAAM,CAAC,CAAD,CAAN,GAAY6I,cAAZ;AACA7I,QAAAA,QAAM,CAAC,CAAD,CAAN,GAAYN,kBAAkB,CAACC,kBAAD,CAA9B;AACA,eAAOK,QAAM,CAACF,MAAd;AACH,OAhB8D,CAiB/D;;;AACAE,MAAAA,MAAM,CAACA,MAAM,CAACT,MAAP,GAAgB,CAAjB,CAAN,GAA4BsJ,cAA5B;;AACA,UAAI7I,MAAM,CAAC6J,UAAP,KAAsB,CAAtB,IAA2B7J,MAAM,CAAC8J,UAAP,KAAsB9J,MAAM,CAACF,MAAP,CAAcgK,UAAnE,EAA+E;AAC3E;AACA,eAAO9J,MAAM,CAACF,MAAd;AACH;;AACD,aAAOE,MAAP;AACH;AA9CL;AAAA;AAAA,4BAoFmB+J,EApFnB,EAoFuBC,EApFvB,EAoF2B;AACnB,UAAI,CAACD,EAAD,IAAO,CAACC,EAAZ,EAAgB;AACZ,eAAO,CAACD,EAAD,IAAO,CAACC,EAAf;AACH;;AACD,UAAMrF,CAAC,GAAGiB,aAAa,CAACmE,EAAD,CAAvB;AACA,UAAMnF,CAAC,GAAGgB,aAAa,CAACoE,EAAD,CAAvB;;AACA,UAAIrF,CAAC,CAACpF,MAAF,KAAaqF,CAAC,CAACrF,MAAnB,EAA2B;AACvB,eAAO,KAAP;AACH;;AACD,WAAK,IAAIF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGqF,CAAC,CAACpF,MAAxB,EAAgCF,CAAC,GAAGC,GAApC,EAAyCD,CAAC,EAA1C,EAA8C;AAC1C,YAAIsF,CAAC,CAACtF,CAAD,CAAD,KAASuF,CAAC,CAACvF,CAAD,CAAd,EAAmB;AACf,iBAAO,KAAP;AACH;AACJ;;AACD,aAAO,IAAP;AACH;AAnGL;AAAA;AAAA,qCAmJ4Ba,UAnJ5B,EAmJwC+J,SAnJxC,EAmJmD;AAC3C,UAAI/J,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKN,iBAA1C,EAA6D;AACzD,eAAOM,UAAP;AACH;;AACD,aAAOkI,WAAW,CAACe,OAAZ,CAAoBjJ,UAApB,EAAgC,CAAhC,EAAmC+J,SAAnC,CAAP;AACH;AAxJL;AAAA;AAAA,kCAyJyB/J,UAzJzB,EAyJqCgK,WAzJrC,EAyJkD;AAC1C,UAAIhK,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKN,iBAA1C,EAA6D;AACzD,eAAOM,UAAP;AACH;;AACD,UAAMF,MAAM,GAAG4F,aAAa,CAAC1F,UAAD,CAA5B;AACA,UAAM2I,cAAc,GAAG7I,MAAM,CAACA,MAAM,CAACT,MAAP,GAAgB,CAAjB,CAA7B;AACA,aAAO6I,WAAW,CAACe,OAAZ,CAAoBjJ,UAApB,EAAgCgK,WAAhC,EAA6CrB,cAA7C,CAAP;AACH;AAhKL;AAAA;AAAA,4BAiKmB3I,UAjKnB,EAiK+BgK,WAjK/B,EAiK4CD,SAjK5C,EAiKuD;AAC/C,UAAI/J,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKN,iBAAtC,IAA2DsK,WAAW,KAAKD,SAA/E,EAA0F;AACtF,eAAO/J,UAAP;AACH;;AACD,UAAMF,MAAM,GAAG4F,aAAa,CAAC1F,UAAD,CAA5B;AACA,UAAMiK,WAAW,GAAInK,MAAM,CAACT,MAAP,KAAkB,CAAvC,CAL+C,CAM/C;;AACA,UAAI2K,WAAW,KAAK,CAAhB,IAAqBlK,MAAM,CAACA,MAAM,CAACT,MAAP,GAAgB,CAAjB,CAAN,KAA8B0K,SAAvD,EAAkE;AAC9D,eAAOrK,iBAAP;AACH;;AACD,UAAMwK,cAAc,GAAGzL,UAAU,CAAC0L,sBAAX,CAAkCrK,MAAlC,EAA0CkK,WAA1C,CAAvB;AACA,UAAMI,oBAAoB,GAAIF,cAAc,GAAG,CAAjB,GAAqBpK,MAAM,CAAEoK,cAAc,GAAG,CAAlB,IAAwB,CAAzB,CAA3B,GAAyD,CAAvF;AACA,UAAMG,kBAAkB,GAAGvK,MAAM,CAACoK,cAAc,IAAI,CAAnB,CAAjC;;AACA,UAAIH,SAAS,GAAGM,kBAAhB,EAAoC;AAChC;AACA,YAAMC,MAAK,GAAIP,SAAS,GAAGC,WAA3B;;AACA,aAAK,IAAI7K,CAAC,GAAG+K,cAAb,EAA6B/K,CAAC,GAAG8K,WAAjC,EAA8C9K,CAAC,EAA/C,EAAmD;AAC/CW,UAAAA,MAAM,CAACX,CAAC,IAAI,CAAN,CAAN,IAAkBmL,MAAlB;AACH;;AACD,eAAOtK,UAAP;AACH;;AACD,UAAIuK,IAAJ;AACA,UAAIC,OAAJ;;AACA,UAAIJ,oBAAoB,KAAKJ,WAA7B,EAA0C;AACtClK,QAAAA,MAAM,CAACoK,cAAc,IAAI,CAAnB,CAAN,GAA8BF,WAA9B;AACAO,QAAAA,IAAI,GAAKL,cAAc,GAAG,CAAlB,IAAwB,CAAhC;AACAM,QAAAA,OAAO,GAAGR,WAAV;AACH,OAJD,MAKK;AACDO,QAAAA,IAAI,GAAIL,cAAc,IAAI,CAA1B;AACAM,QAAAA,OAAO,GAAGJ,oBAAV;AACH;;AACD,UAAME,KAAK,GAAIP,SAAS,GAAGC,WAA3B;;AACA,WAAK,IAAI7I,UAAU,GAAG+I,cAAc,GAAG,CAAvC,EAA0C/I,UAAU,GAAG8I,WAAvD,EAAoE9I,UAAU,EAA9E,EAAkF;AAC9E,YAAMsJ,cAAc,GAAG3K,MAAM,CAACqB,UAAU,IAAI,CAAf,CAAN,GAA0BmJ,KAAjD;;AACA,YAAIG,cAAc,GAAGD,OAArB,EAA8B;AAC1B1K,UAAAA,MAAM,CAACyK,IAAI,EAAL,CAAN,GAAiBE,cAAjB;AACA3K,UAAAA,MAAM,CAACyK,IAAI,EAAL,CAAN,GAAiBzK,MAAM,CAAC,CAACqB,UAAU,IAAI,CAAf,IAAoB,CAArB,CAAvB;AACAqJ,UAAAA,OAAO,GAAGC,cAAV;AACH;AACJ;;AACD,UAAIF,IAAI,KAAKzK,MAAM,CAACT,MAApB,EAA4B;AACxB;AACA,eAAOW,UAAP;AACH;;AACD,UAAI0K,GAAG,GAAG,IAAI/K,WAAJ,CAAgB4K,IAAhB,CAAV;AACAG,MAAAA,GAAG,CAACC,GAAJ,CAAQ7K,MAAM,CAACgC,QAAP,CAAgB,CAAhB,EAAmByI,IAAnB,CAAR,EAAkC,CAAlC;AACA,aAAOG,GAAG,CAAC9K,MAAX;AACH;AAjNL;AAAA;AAAA,4BAkNmBI,UAlNnB,EAkN+B4K,YAlN/B,EAkN6C;AACrC,UAAIA,YAAY,KAAKlL,iBAArB,EAAwC;AACpC,eAAOM,UAAP;AACH;;AACD,UAAIA,UAAU,KAAKN,iBAAnB,EAAsC;AAClC,eAAOkL,YAAP;AACH;;AACD,UAAI5K,UAAU,KAAK,IAAnB,EAAyB;AACrB,eAAOA,UAAP;AACH;;AACD,UAAI4K,YAAY,KAAK,IAArB,EAA2B;AACvB;AACA,eAAO,IAAP;AACH;;AACD,UAAMC,QAAQ,GAAGnF,aAAa,CAAC1F,UAAD,CAA9B;AACA,UAAM8K,WAAW,GAAGpF,aAAa,CAACkF,YAAD,CAAjC;AACA,UAAMG,gBAAgB,GAAID,WAAW,CAACzL,MAAZ,KAAuB,CAAjD;AACA,UAAI0H,MAAM,GAAG,IAAIpH,WAAJ,CAAgBkL,QAAQ,CAACxL,MAAT,GAAkByL,WAAW,CAACzL,MAA9C,CAAb;AACA0H,MAAAA,MAAM,CAAC4D,GAAP,CAAWE,QAAX,EAAqB,CAArB;AACA,UAAIN,IAAI,GAAGM,QAAQ,CAACxL,MAApB;AACA,UAAMiL,KAAK,GAAGO,QAAQ,CAACA,QAAQ,CAACxL,MAAT,GAAkB,CAAnB,CAAtB;;AACA,WAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4L,gBAApB,EAAsC5L,CAAC,EAAvC,EAA2C;AACvC4H,QAAAA,MAAM,CAACwD,IAAI,EAAL,CAAN,GAAiBO,WAAW,CAAE3L,CAAC,IAAI,CAAP,CAAX,GAAwBmL,KAAzC;AACAvD,QAAAA,MAAM,CAACwD,IAAI,EAAL,CAAN,GAAiBO,WAAW,CAAC,CAAC3L,CAAC,IAAI,CAAN,IAAW,CAAZ,CAA5B;AACH;;AACD,aAAO4H,MAAM,CAACnH,MAAd;AACH;AA5OL;AAAA;AAAA,4BA6OmBI,UA7OnB,EA6O+BgL,OA7O/B,EA6OwCC,UA7OxC,EA6OoD;AAC5C,UAAIjL,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKN,iBAA1C,EAA6D;AACzD;AACA,eAAOM,UAAP;AACH;;AACD,UAAMF,MAAM,GAAG4F,aAAa,CAAC1F,UAAD,CAA5B;AACA,UAAMiK,WAAW,GAAInK,MAAM,CAACT,MAAP,KAAkB,CAAvC;AACA,UAAI6K,cAAc,GAAGzL,UAAU,CAAC0L,sBAAX,CAAkCrK,MAAlC,EAA0CkL,OAA1C,CAArB;;AACA,UAAId,cAAc,GAAG,CAArB,EAAwB;AACpB,YAAME,oBAAoB,GAAGtK,MAAM,CAAEoK,cAAc,GAAG,CAAlB,IAAwB,CAAzB,CAAnC;;AACA,YAAIE,oBAAoB,KAAKY,OAA7B,EAAsC;AAClCd,UAAAA,cAAc;AACjB;AACJ;;AACD,WAAK,IAAI/I,UAAU,GAAG+I,cAAtB,EAAsC/I,UAAU,GAAG8I,WAAnD,EAAgE9I,UAAU,EAA1E,EAA8E;AAC1ErB,QAAAA,MAAM,CAACqB,UAAU,IAAI,CAAf,CAAN,IAA2B8J,UAA3B;AACH;;AACD,aAAOjL,UAAP;AACH;AA/PL;;AAAA;AAAA","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { TokenMetadata } from '../modes.js';\r\nexport function countEOL(text) {\r\n    let eolCount = 0;\r\n    let firstLineLength = 0;\r\n    let lastLineStart = 0;\r\n    let eol = 0 /* Unknown */;\r\n    for (let i = 0, len = text.length; i < len; i++) {\r\n        const chr = text.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                eol |= 2 /* CRLF */;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n                eol |= 3 /* Invalid */;\r\n            }\r\n            lastLineStart = i + 1;\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            // \\n... case\r\n            eol |= 1 /* LF */;\r\n            if (eolCount === 0) {\r\n                firstLineLength = i;\r\n            }\r\n            eolCount++;\r\n            lastLineStart = i + 1;\r\n        }\r\n    }\r\n    if (eolCount === 0) {\r\n        firstLineLength = text.length;\r\n    }\r\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\r\n}\r\nfunction getDefaultMetadata(topLevelLanguageId) {\r\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\r\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\r\n        | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)\r\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\r\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\r\n}\r\nconst EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\r\nexport class MultilineTokensBuilder {\r\n    constructor() {\r\n        this.tokens = [];\r\n    }\r\n    add(lineNumber, lineTokens) {\r\n        if (this.tokens.length > 0) {\r\n            const last = this.tokens[this.tokens.length - 1];\r\n            const lastLineNumber = last.startLineNumber + last.tokens.length - 1;\r\n            if (lastLineNumber + 1 === lineNumber) {\r\n                // append\r\n                last.tokens.push(lineTokens);\r\n                return;\r\n            }\r\n        }\r\n        this.tokens.push(new MultilineTokens(lineNumber, [lineTokens]));\r\n    }\r\n}\r\nexport class SparseEncodedTokens {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n        this._tokenCount = tokens.length / 4;\r\n    }\r\n    toString(startLineNumber) {\r\n        let pieces = [];\r\n        for (let i = 0; i < this._tokenCount; i++) {\r\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\r\n        }\r\n        return `[${pieces.join(',')}]`;\r\n    }\r\n    getMaxDeltaLine() {\r\n        const tokenCount = this._getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return -1;\r\n        }\r\n        return this._getDeltaLine(tokenCount - 1);\r\n    }\r\n    getRange() {\r\n        const tokenCount = this._getTokenCount();\r\n        if (tokenCount === 0) {\r\n            return null;\r\n        }\r\n        const startChar = this._getStartCharacter(0);\r\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\r\n        const endChar = this._getEndCharacter(tokenCount - 1);\r\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\r\n    }\r\n    _getTokenCount() {\r\n        return this._tokenCount;\r\n    }\r\n    _getDeltaLine(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex];\r\n    }\r\n    _getStartCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    }\r\n    _getEndCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    }\r\n    isEmpty() {\r\n        return (this._getTokenCount() === 0);\r\n    }\r\n    getLineTokens(deltaLine) {\r\n        let low = 0;\r\n        let high = this._getTokenCount() - 1;\r\n        while (low < high) {\r\n            const mid = low + Math.floor((high - low) / 2);\r\n            const midDeltaLine = this._getDeltaLine(mid);\r\n            if (midDeltaLine < deltaLine) {\r\n                low = mid + 1;\r\n            }\r\n            else if (midDeltaLine > deltaLine) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                let min = mid;\r\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\r\n                    min--;\r\n                }\r\n                let max = mid;\r\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\r\n                    max++;\r\n                }\r\n                return new LineTokens2(this._tokens.subarray(4 * min, 4 * max + 4));\r\n            }\r\n        }\r\n        if (this._getDeltaLine(low) === deltaLine) {\r\n            return new LineTokens2(this._tokens.subarray(4 * low, 4 * low + 4));\r\n        }\r\n        return null;\r\n    }\r\n    clear() {\r\n        this._tokenCount = 0;\r\n    }\r\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        let newTokenCount = 0;\r\n        let hasDeletedTokens = false;\r\n        let firstDeltaLine = 0;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            const tokenDeltaLine = tokens[srcOffset];\r\n            const tokenStartCharacter = tokens[srcOffset + 1];\r\n            const tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\r\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\r\n                hasDeletedTokens = true;\r\n            }\r\n            else {\r\n                if (newTokenCount === 0) {\r\n                    firstDeltaLine = tokenDeltaLine;\r\n                }\r\n                if (hasDeletedTokens) {\r\n                    // must move the token to the left\r\n                    const destOffset = 4 * newTokenCount;\r\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\r\n                    tokens[destOffset + 1] = tokenStartCharacter;\r\n                    tokens[destOffset + 2] = tokenEndCharacter;\r\n                    tokens[destOffset + 3] = tokenMetadata;\r\n                }\r\n                newTokenCount++;\r\n            }\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n        return firstDeltaLine;\r\n    }\r\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        let aTokens = [];\r\n        let bTokens = [];\r\n        let destTokens = aTokens;\r\n        let destOffset = 0;\r\n        let destFirstDeltaLine = 0;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            const tokenDeltaLine = tokens[srcOffset];\r\n            const tokenStartCharacter = tokens[srcOffset + 1];\r\n            const tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\r\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\r\n                    // this token is touching the range\r\n                    continue;\r\n                }\r\n                else {\r\n                    // this token is after the range\r\n                    if (destTokens !== bTokens) {\r\n                        // this token is the first token after the range\r\n                        destTokens = bTokens;\r\n                        destOffset = 0;\r\n                        destFirstDeltaLine = tokenDeltaLine;\r\n                    }\r\n                }\r\n            }\r\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\r\n            destTokens[destOffset++] = tokenStartCharacter;\r\n            destTokens[destOffset++] = tokenEndCharacter;\r\n            destTokens[destOffset++] = tokenMetadata;\r\n        }\r\n        return [new SparseEncodedTokens(new Uint32Array(aTokens)), new SparseEncodedTokens(new Uint32Array(bTokens)), destFirstDeltaLine];\r\n    }\r\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\r\n        // This is a bit complex, here are the cases I used to think about this:\r\n        //\r\n        // 1. The token starts before the deletion range\r\n        // 1a. The token is completely before the deletion range\r\n        //               -----------\r\n        //                          xxxxxxxxxxx\r\n        // 1b. The token starts before, the deletion range ends after the token\r\n        //               -----------\r\n        //                      xxxxxxxxxxx\r\n        // 1c. The token starts before, the deletion range ends precisely with the token\r\n        //               ---------------\r\n        //                      xxxxxxxx\r\n        // 1d. The token starts before, the deletion range is inside the token\r\n        //               ---------------\r\n        //                    xxxxx\r\n        //\r\n        // 2. The token starts at the same position with the deletion range\r\n        // 2a. The token starts at the same position, and ends inside the deletion range\r\n        //               -------\r\n        //               xxxxxxxxxxx\r\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n        //               ----------\r\n        //               xxxxxxxxxx\r\n        // 2c. The token starts at the same position, and ends after the deletion range\r\n        //               -------------\r\n        //               xxxxxxx\r\n        //\r\n        // 3. The token starts inside the deletion range\r\n        // 3a. The token is inside the deletion range\r\n        //                -------\r\n        //             xxxxxxxxxxxxx\r\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n        //                ----------\r\n        //             xxxxxxxxxxxxx\r\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n        //                ------------\r\n        //             xxxxxxxxxxx\r\n        //\r\n        // 4. The token starts after the deletion range\r\n        //                  -----------\r\n        //          xxxxxxxx\r\n        //\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\r\n        let newTokenCount = 0;\r\n        let hasDeletedTokens = false;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const srcOffset = 4 * i;\r\n            let tokenDeltaLine = tokens[srcOffset];\r\n            let tokenStartCharacter = tokens[srcOffset + 1];\r\n            let tokenEndCharacter = tokens[srcOffset + 2];\r\n            const tokenMetadata = tokens[srcOffset + 3];\r\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\r\n                // 1a. The token is completely before the deletion range\r\n                // => nothing to do\r\n                newTokenCount++;\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\r\n                // 1b, 1c, 1d\r\n                // => the token survives, but it needs to shrink\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 1d. The token starts before, the deletion range is inside the token\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 1b. The token starts before, the deletion range ends after the token\r\n                    // 1c. The token starts before, the deletion range ends precisely with the token\r\n                    // => the token shrinks its ending to the deletion start\r\n                    tokenEndCharacter = startCharacter;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\r\n                // 2a, 2b, 2c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 2c. The token starts at the same position, and ends after the deletion range\r\n                    // => the token shrinks by the deletion character count\r\n                    tokenEndCharacter -= (endCharacter - startCharacter);\r\n                }\r\n                else {\r\n                    // 2a. The token starts at the same position, and ends inside the deletion range\r\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\r\n                // 3a, 3b, 3c\r\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\r\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\r\n                    // => the token moves left and shrinks\r\n                    if (tokenDeltaLine === startDeltaLine) {\r\n                        // the deletion started on the same line as the token\r\n                        // => the token moves left and shrinks\r\n                        tokenStartCharacter = startCharacter;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                    else {\r\n                        // the deletion started on a line above the token\r\n                        // => the token moves to the beginning of the line\r\n                        tokenStartCharacter = 0;\r\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\r\n                    }\r\n                }\r\n                else {\r\n                    // 3a. The token is inside the deletion range\r\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\r\n                    // => the token is deleted\r\n                    hasDeletedTokens = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine > endDeltaLine) {\r\n                // 4. (partial) The token starts after the deletion range, on a line below...\r\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\r\n                    // early stop, there is no need to walk all the tokens and do nothing...\r\n                    newTokenCount = tokenCount;\r\n                    break;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n            }\r\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\r\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\r\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\r\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\r\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\r\n                }\r\n                tokenDeltaLine -= deletedLineCount;\r\n                tokenStartCharacter -= (endCharacter - startCharacter);\r\n                tokenEndCharacter -= (endCharacter - startCharacter);\r\n            }\r\n            else {\r\n                throw new Error(`Not possible!`);\r\n            }\r\n            const destOffset = 4 * newTokenCount;\r\n            tokens[destOffset] = tokenDeltaLine;\r\n            tokens[destOffset + 1] = tokenStartCharacter;\r\n            tokens[destOffset + 2] = tokenEndCharacter;\r\n            tokens[destOffset + 3] = tokenMetadata;\r\n            newTokenCount++;\r\n        }\r\n        this._tokenCount = newTokenCount;\r\n    }\r\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        // Here are the cases I used to think about this:\r\n        //\r\n        // 1. The token is completely before the insertion point\r\n        //            -----------   |\r\n        // 2. The token ends precisely at the insertion point\r\n        //            -----------|\r\n        // 3. The token contains the insertion point\r\n        //            -----|------\r\n        // 4. The token starts precisely at the insertion point\r\n        //            |-----------\r\n        // 5. The token is completely after the insertion point\r\n        //            |   -----------\r\n        //\r\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\r\n            && firstLineLength === 1\r\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\r\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\r\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\r\n        const tokens = this._tokens;\r\n        const tokenCount = this._tokenCount;\r\n        for (let i = 0; i < tokenCount; i++) {\r\n            const offset = 4 * i;\r\n            let tokenDeltaLine = tokens[offset];\r\n            let tokenStartCharacter = tokens[offset + 1];\r\n            let tokenEndCharacter = tokens[offset + 2];\r\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\r\n                // 1. The token is completely before the insertion point\r\n                // => nothing to do\r\n                continue;\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\r\n                // 2. The token ends precisely at the insertion point\r\n                // => expand the end character only if inserting precisely one character that is a word character\r\n                if (isInsertingPreciselyOneWordCharacter) {\r\n                    tokenEndCharacter += 1;\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\r\n                // 3. The token contains the insertion point\r\n                if (eolCount === 0) {\r\n                    // => just expand the end character\r\n                    tokenEndCharacter += firstLineLength;\r\n                }\r\n                else {\r\n                    // => cut off the token\r\n                    tokenEndCharacter = character;\r\n                }\r\n            }\r\n            else {\r\n                // 4. or 5.\r\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\r\n                    // 4. The token starts precisely at the insertion point\r\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\r\n                    // => otherwise behave as in case 5.\r\n                    if (isInsertingPreciselyOneWordCharacter) {\r\n                        continue;\r\n                    }\r\n                }\r\n                // => the token must move and keep its size constant\r\n                if (tokenDeltaLine === deltaLine) {\r\n                    tokenDeltaLine += eolCount;\r\n                    // this token is on the line where the insertion is taking place\r\n                    if (eolCount === 0) {\r\n                        tokenStartCharacter += firstLineLength;\r\n                        tokenEndCharacter += firstLineLength;\r\n                    }\r\n                    else {\r\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\r\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\r\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\r\n                    }\r\n                }\r\n                else {\r\n                    tokenDeltaLine += eolCount;\r\n                }\r\n            }\r\n            tokens[offset] = tokenDeltaLine;\r\n            tokens[offset + 1] = tokenStartCharacter;\r\n            tokens[offset + 2] = tokenEndCharacter;\r\n        }\r\n    }\r\n}\r\nexport class LineTokens2 {\r\n    constructor(tokens) {\r\n        this._tokens = tokens;\r\n    }\r\n    getCount() {\r\n        return this._tokens.length / 4;\r\n    }\r\n    getStartCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 1];\r\n    }\r\n    getEndCharacter(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 2];\r\n    }\r\n    getMetadata(tokenIndex) {\r\n        return this._tokens[4 * tokenIndex + 3];\r\n    }\r\n}\r\nexport class MultilineTokens2 {\r\n    constructor(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    toString() {\r\n        return this.tokens.toString(this.startLineNumber);\r\n    }\r\n    _updateEndLineNumber() {\r\n        this.endLineNumber = this.startLineNumber + this.tokens.getMaxDeltaLine();\r\n    }\r\n    isEmpty() {\r\n        return this.tokens.isEmpty();\r\n    }\r\n    getLineTokens(lineNumber) {\r\n        if (this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber) {\r\n            return this.tokens.getLineTokens(lineNumber - this.startLineNumber);\r\n        }\r\n        return null;\r\n    }\r\n    getRange() {\r\n        const deltaRange = this.tokens.getRange();\r\n        if (!deltaRange) {\r\n            return deltaRange;\r\n        }\r\n        return new Range(this.startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this.startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\r\n    }\r\n    removeTokens(range) {\r\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\r\n        this.startLineNumber += this.tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\r\n        this._updateEndLineNumber();\r\n    }\r\n    split(range) {\r\n        // split tokens to two:\r\n        // a) all the tokens before `range`\r\n        // b) all the tokens after `range`\r\n        const startLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const endLineIndex = range.endLineNumber - this.startLineNumber;\r\n        const [a, b, bDeltaLine] = this.tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\r\n        return [new MultilineTokens2(this.startLineNumber, a), new MultilineTokens2(this.startLineNumber + bDeltaLine, b)];\r\n    }\r\n    applyEdit(range, text) {\r\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\r\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\r\n    }\r\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        this._updateEndLineNumber();\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            // Nothing to delete\r\n            return;\r\n        }\r\n        const firstLineIndex = range.startLineNumber - this.startLineNumber;\r\n        const lastLineIndex = range.endLineNumber - this.startLineNumber;\r\n        if (lastLineIndex < 0) {\r\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\r\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\r\n            this.startLineNumber -= deletedLinesCount;\r\n            return;\r\n        }\r\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion occurs entirely after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this deletion completely encompasses this block\r\n            this.startLineNumber = 0;\r\n            this.tokens.clear();\r\n            return;\r\n        }\r\n        if (firstLineIndex < 0) {\r\n            const deletedBefore = -firstLineIndex;\r\n            this.startLineNumber -= deletedBefore;\r\n            this.tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\r\n        }\r\n        else {\r\n            this.tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\r\n        }\r\n    }\r\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        const lineIndex = position.lineNumber - this.startLineNumber;\r\n        if (lineIndex < 0) {\r\n            // this insertion occurs before this block, so we only need to adjust line numbers\r\n            this.startLineNumber += eolCount;\r\n            return;\r\n        }\r\n        const tokenMaxDeltaLine = this.tokens.getMaxDeltaLine();\r\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\r\n            // this insertion occurs after this block, so there is nothing to do\r\n            return;\r\n        }\r\n        this.tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n    }\r\n}\r\nexport class MultilineTokens {\r\n    constructor(startLineNumber, tokens) {\r\n        this.startLineNumber = startLineNumber;\r\n        this.tokens = tokens;\r\n    }\r\n}\r\nfunction toUint32Array(arr) {\r\n    if (arr instanceof Uint32Array) {\r\n        return arr;\r\n    }\r\n    else {\r\n        return new Uint32Array(arr);\r\n    }\r\n}\r\nexport class TokensStore2 {\r\n    constructor() {\r\n        this._pieces = [];\r\n        this._isComplete = false;\r\n    }\r\n    flush() {\r\n        this._pieces = [];\r\n        this._isComplete = false;\r\n    }\r\n    isEmpty() {\r\n        return (this._pieces.length === 0);\r\n    }\r\n    set(pieces, isComplete) {\r\n        this._pieces = pieces || [];\r\n        this._isComplete = isComplete;\r\n    }\r\n    setPartial(_range, pieces) {\r\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\r\n        let range = _range;\r\n        if (pieces.length > 0) {\r\n            const _firstRange = pieces[0].getRange();\r\n            const _lastRange = pieces[pieces.length - 1].getRange();\r\n            if (!_firstRange || !_lastRange) {\r\n                return _range;\r\n            }\r\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\r\n        }\r\n        let insertPosition = null;\r\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\r\n            const piece = this._pieces[i];\r\n            if (piece.endLineNumber < range.startLineNumber) {\r\n                // this piece is before the range\r\n                continue;\r\n            }\r\n            if (piece.startLineNumber > range.endLineNumber) {\r\n                // this piece is after the range, so mark the spot before this piece\r\n                // as a good insertion position and stop looping\r\n                insertPosition = insertPosition || { index: i };\r\n                break;\r\n            }\r\n            // this piece might intersect with the range\r\n            piece.removeTokens(range);\r\n            if (piece.isEmpty()) {\r\n                // remove the piece if it became empty\r\n                this._pieces.splice(i, 1);\r\n                i--;\r\n                len--;\r\n                continue;\r\n            }\r\n            if (piece.endLineNumber < range.startLineNumber) {\r\n                // after removal, this piece is before the range\r\n                continue;\r\n            }\r\n            if (piece.startLineNumber > range.endLineNumber) {\r\n                // after removal, this piece is after the range\r\n                insertPosition = insertPosition || { index: i };\r\n                continue;\r\n            }\r\n            // after removal, this piece contains the range\r\n            const [a, b] = piece.split(range);\r\n            if (a.isEmpty()) {\r\n                // this piece is actually after the range\r\n                insertPosition = insertPosition || { index: i };\r\n                continue;\r\n            }\r\n            if (b.isEmpty()) {\r\n                // this piece is actually before the range\r\n                continue;\r\n            }\r\n            this._pieces.splice(i, 1, a, b);\r\n            i++;\r\n            len++;\r\n            insertPosition = insertPosition || { index: i };\r\n        }\r\n        insertPosition = insertPosition || { index: this._pieces.length };\r\n        if (pieces.length > 0) {\r\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\r\n        }\r\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\r\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\r\n        return range;\r\n    }\r\n    isComplete() {\r\n        return this._isComplete;\r\n    }\r\n    addSemanticTokens(lineNumber, aTokens) {\r\n        const pieces = this._pieces;\r\n        if (pieces.length === 0) {\r\n            return aTokens;\r\n        }\r\n        const pieceIndex = TokensStore2._findFirstPieceWithLine(pieces, lineNumber);\r\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\r\n        if (!bTokens) {\r\n            return aTokens;\r\n        }\r\n        const aLen = aTokens.getCount();\r\n        const bLen = bTokens.getCount();\r\n        let aIndex = 0;\r\n        let result = [], resultLen = 0;\r\n        let lastEndOffset = 0;\r\n        const emitToken = (endOffset, metadata) => {\r\n            if (endOffset === lastEndOffset) {\r\n                return;\r\n            }\r\n            lastEndOffset = endOffset;\r\n            result[resultLen++] = endOffset;\r\n            result[resultLen++] = metadata;\r\n        };\r\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\r\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\r\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\r\n            const bMetadata = bTokens.getMetadata(bIndex);\r\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 2048 /* ITALIC_MASK */ : 0)\r\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 4096 /* BOLD_MASK */ : 0)\r\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 8192 /* UNDERLINE_MASK */ : 0)\r\n                | ((bMetadata & 8 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\r\n                | ((bMetadata & 16 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\r\n            const aMask = (~bMask) >>> 0;\r\n            // push any token from `a` that is before `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\r\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\r\n                aIndex++;\r\n            }\r\n            // push the token from `a` if it intersects the token from `b`\r\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\r\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\r\n            }\r\n            // skip any tokens from `a` that are contained inside `b`\r\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\r\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\r\n                aIndex++;\r\n            }\r\n            if (aIndex < aLen) {\r\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\r\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\r\n                    // `a` ends exactly at the same spot as `b`!\r\n                    aIndex++;\r\n                }\r\n            }\r\n            else {\r\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\r\n                // push the token from `b`\r\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\r\n            }\r\n        }\r\n        // push the remaining tokens from `a`\r\n        while (aIndex < aLen) {\r\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\r\n            aIndex++;\r\n        }\r\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent());\r\n    }\r\n    static _findFirstPieceWithLine(pieces, lineNumber) {\r\n        let low = 0;\r\n        let high = pieces.length - 1;\r\n        while (low < high) {\r\n            let mid = low + Math.floor((high - low) / 2);\r\n            if (pieces[mid].endLineNumber < lineNumber) {\r\n                low = mid + 1;\r\n            }\r\n            else if (pieces[mid].startLineNumber > lineNumber) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\r\n                    mid--;\r\n                }\r\n                return mid;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n    //#region Editing\r\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\r\n        for (const piece of this._pieces) {\r\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\r\n        }\r\n    }\r\n}\r\nexport class TokensStore {\r\n    constructor() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    flush() {\r\n        this._lineTokens = [];\r\n        this._len = 0;\r\n    }\r\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\r\n        let rawLineTokens = null;\r\n        if (lineIndex < this._len) {\r\n            rawLineTokens = this._lineTokens[lineIndex];\r\n        }\r\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\r\n            return new LineTokens(toUint32Array(rawLineTokens), lineText);\r\n        }\r\n        let lineTokens = new Uint32Array(2);\r\n        lineTokens[0] = lineText.length;\r\n        lineTokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n        return new LineTokens(lineTokens, lineText);\r\n    }\r\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\r\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\r\n        if (lineTextLength === 0) {\r\n            let hasDifferentLanguageId = false;\r\n            if (tokens && tokens.length > 1) {\r\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\r\n            }\r\n            if (!hasDifferentLanguageId) {\r\n                return EMPTY_LINE_TOKENS;\r\n            }\r\n        }\r\n        if (!tokens || tokens.length === 0) {\r\n            const tokens = new Uint32Array(2);\r\n            tokens[0] = lineTextLength;\r\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\r\n            return tokens.buffer;\r\n        }\r\n        // Ensure the last token covers the end of the text\r\n        tokens[tokens.length - 2] = lineTextLength;\r\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\r\n            // Store directly the ArrayBuffer pointer to save an object\r\n            return tokens.buffer;\r\n        }\r\n        return tokens;\r\n    }\r\n    _ensureLine(lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._lineTokens[this._len] = null;\r\n            this._len++;\r\n        }\r\n    }\r\n    _deleteLines(start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._lineTokens.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    }\r\n    _insertLines(insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        let lineTokens = [];\r\n        for (let i = 0; i < insertCount; i++) {\r\n            lineTokens[i] = null;\r\n        }\r\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\r\n        this._len += insertCount;\r\n    }\r\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\r\n        const tokens = TokensStore._massageTokens(topLevelLanguageId, lineTextLength, _tokens);\r\n        this._ensureLine(lineIndex);\r\n        const oldTokens = this._lineTokens[lineIndex];\r\n        this._lineTokens[lineIndex] = tokens;\r\n        if (checkEquality) {\r\n            return !TokensStore._equals(oldTokens, tokens);\r\n        }\r\n        return false;\r\n    }\r\n    static _equals(_a, _b) {\r\n        if (!_a || !_b) {\r\n            return !_a && !_b;\r\n        }\r\n        const a = toUint32Array(_a);\r\n        const b = toUint32Array(_b);\r\n        if (a.length !== b.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = a.length; i < len; i++) {\r\n            if (a[i] !== b[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    //#region Editing\r\n    acceptEdit(range, eolCount, firstLineLength) {\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        const firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (range.startLineNumber === range.endLineNumber) {\r\n            if (range.startColumn === range.endColumn) {\r\n                // Nothing to delete\r\n                return;\r\n            }\r\n            this._lineTokens[firstLineIndex] = TokensStore._delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\r\n            return;\r\n        }\r\n        this._lineTokens[firstLineIndex] = TokensStore._deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\r\n        const lastLineIndex = range.endLineNumber - 1;\r\n        let lastLineTokens = null;\r\n        if (lastLineIndex < this._len) {\r\n            lastLineTokens = TokensStore._deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\r\n        }\r\n        // Take remaining text on last line and append it to remaining text on first line\r\n        this._lineTokens[firstLineIndex] = TokensStore._append(this._lineTokens[firstLineIndex], lastLineTokens);\r\n        // Delete middle lines\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    }\r\n    _acceptInsertText(position, eolCount, firstLineLength) {\r\n        if (eolCount === 0 && firstLineLength === 0) {\r\n            // Nothing to insert\r\n            return;\r\n        }\r\n        const lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        if (eolCount === 0) {\r\n            // Inserting text on one line\r\n            this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n            return;\r\n        }\r\n        this._lineTokens[lineIndex] = TokensStore._deleteEnding(this._lineTokens[lineIndex], position.column - 1);\r\n        this._lineTokens[lineIndex] = TokensStore._insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    }\r\n    static _deleteBeginning(lineTokens, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        return TokensStore._delete(lineTokens, 0, toChIndex);\r\n    }\r\n    static _deleteEnding(lineTokens, fromChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const lineTextLength = tokens[tokens.length - 2];\r\n        return TokensStore._delete(lineTokens, fromChIndex, lineTextLength);\r\n    }\r\n    static _delete(lineTokens, fromChIndex, toChIndex) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const tokensCount = (tokens.length >>> 1);\r\n        // special case: deleting everything\r\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\r\n            return EMPTY_LINE_TOKENS;\r\n        }\r\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\r\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\r\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\r\n        if (toChIndex < fromTokenEndOffset) {\r\n            // the delete range is inside a single token\r\n            const delta = (toChIndex - fromChIndex);\r\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\r\n                tokens[i << 1] -= delta;\r\n            }\r\n            return lineTokens;\r\n        }\r\n        let dest;\r\n        let lastEnd;\r\n        if (fromTokenStartOffset !== fromChIndex) {\r\n            tokens[fromTokenIndex << 1] = fromChIndex;\r\n            dest = ((fromTokenIndex + 1) << 1);\r\n            lastEnd = fromChIndex;\r\n        }\r\n        else {\r\n            dest = (fromTokenIndex << 1);\r\n            lastEnd = fromTokenStartOffset;\r\n        }\r\n        const delta = (toChIndex - fromChIndex);\r\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\r\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\r\n            if (tokenEndOffset > lastEnd) {\r\n                tokens[dest++] = tokenEndOffset;\r\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\r\n                lastEnd = tokenEndOffset;\r\n            }\r\n        }\r\n        if (dest === tokens.length) {\r\n            // nothing to trim\r\n            return lineTokens;\r\n        }\r\n        let tmp = new Uint32Array(dest);\r\n        tmp.set(tokens.subarray(0, dest), 0);\r\n        return tmp.buffer;\r\n    }\r\n    static _append(lineTokens, _otherTokens) {\r\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\r\n            return lineTokens;\r\n        }\r\n        if (lineTokens === EMPTY_LINE_TOKENS) {\r\n            return _otherTokens;\r\n        }\r\n        if (lineTokens === null) {\r\n            return lineTokens;\r\n        }\r\n        if (_otherTokens === null) {\r\n            // cannot determine combined line length...\r\n            return null;\r\n        }\r\n        const myTokens = toUint32Array(lineTokens);\r\n        const otherTokens = toUint32Array(_otherTokens);\r\n        const otherTokensCount = (otherTokens.length >>> 1);\r\n        let result = new Uint32Array(myTokens.length + otherTokens.length);\r\n        result.set(myTokens, 0);\r\n        let dest = myTokens.length;\r\n        const delta = myTokens[myTokens.length - 2];\r\n        for (let i = 0; i < otherTokensCount; i++) {\r\n            result[dest++] = otherTokens[(i << 1)] + delta;\r\n            result[dest++] = otherTokens[(i << 1) + 1];\r\n        }\r\n        return result.buffer;\r\n    }\r\n    static _insert(lineTokens, chIndex, textLength) {\r\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\r\n            // nothing to do\r\n            return lineTokens;\r\n        }\r\n        const tokens = toUint32Array(lineTokens);\r\n        const tokensCount = (tokens.length >>> 1);\r\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\r\n        if (fromTokenIndex > 0) {\r\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\r\n            if (fromTokenStartOffset === chIndex) {\r\n                fromTokenIndex--;\r\n            }\r\n        }\r\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\r\n            tokens[tokenIndex << 1] += textLength;\r\n        }\r\n        return lineTokens;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}