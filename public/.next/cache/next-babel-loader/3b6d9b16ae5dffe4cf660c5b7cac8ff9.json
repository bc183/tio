{"ast":null,"code":"import _regeneratorRuntime from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as nls from '../../../nls.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport Severity from '../../../base/common/severity.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nvar DEBUG = false;\n\nfunction getResourceLabel(resource) {\n  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\n\nvar stackElementCounter = 0;\n\nvar ResourceStackElement = /*#__PURE__*/function () {\n  function ResourceStackElement(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n    _classCallCheck(this, ResourceStackElement);\n\n    this.id = ++stackElementCounter;\n    this.type = 0\n    /* Resource */\n    ;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this.resourceLabels = [this.resourceLabel];\n    this.strResources = [this.strResource];\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.isValid = true;\n  }\n\n  _createClass(ResourceStackElement, [{\n    key: \"setValid\",\n    value: function setValid(isValid) {\n      this.isValid = isValid;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[id:\".concat(this.id, \"] [group:\").concat(this.groupId, \"] [\").concat(this.isValid ? '  VALID' : 'INVALID', \"] \").concat(this.actual.constructor.name, \" - \").concat(this.actual);\n    }\n  }]);\n\n  return ResourceStackElement;\n}();\n\nvar ResourceReasonPair = function ResourceReasonPair(resourceLabel, reason) {\n  _classCallCheck(this, ResourceReasonPair);\n\n  this.resourceLabel = resourceLabel;\n  this.reason = reason;\n};\n\nvar RemovedResources = /*#__PURE__*/function () {\n  function RemovedResources() {\n    _classCallCheck(this, RemovedResources);\n\n    this.elements = new Map();\n  }\n\n  _createClass(RemovedResources, [{\n    key: \"createMessage\",\n    value: function createMessage() {\n      var externalRemoval = [];\n      var noParallelUniverses = [];\n\n      var _iterator = _createForOfIteratorHelper(this.elements),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              element = _step$value[1];\n\n          var dest = element.reason === 0\n          /* ExternalRemoval */\n          ? externalRemoval : noParallelUniverses;\n          dest.push(element.resourceLabel);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var messages = [];\n\n      if (externalRemoval.length > 0) {\n        messages.push(nls.localize({\n          key: 'externalRemoval',\n          comment: ['{0} is a list of filenames']\n        }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n      }\n\n      if (noParallelUniverses.length > 0) {\n        messages.push(nls.localize({\n          key: 'noParallelUniverses',\n          comment: ['{0} is a list of filenames']\n        }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n      }\n\n      return messages.join('\\n');\n    }\n  }, {\n    key: \"has\",\n    value: function has(strResource) {\n      return this.elements.has(strResource);\n    }\n  }, {\n    key: \"set\",\n    value: function set(strResource, value) {\n      this.elements.set(strResource, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(strResource) {\n      return this.elements[\"delete\"](strResource);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.elements.size;\n    }\n  }]);\n\n  return RemovedResources;\n}();\n\nvar WorkspaceStackElement = /*#__PURE__*/function () {\n  function WorkspaceStackElement(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n    _classCallCheck(this, WorkspaceStackElement);\n\n    this.id = ++stackElementCounter;\n    this.type = 1\n    /* Workspace */\n    ;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabels = resourceLabels;\n    this.strResources = strResources;\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.removedResources = null;\n    this.invalidatedResources = null;\n  }\n\n  _createClass(WorkspaceStackElement, [{\n    key: \"canSplit\",\n    value: function canSplit() {\n      return typeof this.actual.split === 'function';\n    }\n  }, {\n    key: \"removeResource\",\n    value: function removeResource(resourceLabel, strResource, reason) {\n      if (!this.removedResources) {\n        this.removedResources = new RemovedResources();\n      }\n\n      if (!this.removedResources.has(strResource)) {\n        this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n      }\n    }\n  }, {\n    key: \"setValid\",\n    value: function setValid(resourceLabel, strResource, isValid) {\n      if (isValid) {\n        if (this.invalidatedResources) {\n          this.invalidatedResources[\"delete\"](strResource);\n\n          if (this.invalidatedResources.size === 0) {\n            this.invalidatedResources = null;\n          }\n        }\n      } else {\n        if (!this.invalidatedResources) {\n          this.invalidatedResources = new RemovedResources();\n        }\n\n        if (!this.invalidatedResources.has(strResource)) {\n          this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0\n          /* ExternalRemoval */\n          ));\n        }\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"[id:\".concat(this.id, \"] [group:\").concat(this.groupId, \"] [\").concat(this.invalidatedResources ? 'INVALID' : '  VALID', \"] \").concat(this.actual.constructor.name, \" - \").concat(this.actual);\n    }\n  }]);\n\n  return WorkspaceStackElement;\n}();\n\nvar ResourceEditStack = /*#__PURE__*/function () {\n  function ResourceEditStack(resourceLabel, strResource) {\n    _classCallCheck(this, ResourceEditStack);\n\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this._past = [];\n    this._future = [];\n    this.locked = false;\n    this.versionId = 1;\n  }\n\n  _createClass(ResourceEditStack, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _iterator2 = _createForOfIteratorHelper(this._past),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var element = _step2.value;\n\n          if (element.type === 1\n          /* Workspace */\n          ) {\n              element.removeResource(this.resourceLabel, this.strResource, 0\n              /* ExternalRemoval */\n              );\n            }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this._future),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _element2 = _step3.value;\n\n          if (_element2.type === 1\n          /* Workspace */\n          ) {\n              _element2.removeResource(this.resourceLabel, this.strResource, 0\n              /* ExternalRemoval */\n              );\n            }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this.versionId++;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = [];\n      result.push(\"* \".concat(this.strResource, \":\"));\n\n      for (var i = 0; i < this._past.length; i++) {\n        result.push(\"   * [UNDO] \".concat(this._past[i]));\n      }\n\n      for (var _i = this._future.length - 1; _i >= 0; _i--) {\n        result.push(\"   * [REDO] \".concat(this._future[_i]));\n      }\n\n      return result.join('\\n');\n    }\n  }, {\n    key: \"flushAllElements\",\n    value: function flushAllElements() {\n      this._past = [];\n      this._future = [];\n      this.versionId++;\n    }\n  }, {\n    key: \"_setElementValidFlag\",\n    value: function _setElementValidFlag(element, isValid) {\n      if (element.type === 1\n      /* Workspace */\n      ) {\n          element.setValid(this.resourceLabel, this.strResource, isValid);\n        } else {\n        element.setValid(isValid);\n      }\n    }\n  }, {\n    key: \"setElementsValidFlag\",\n    value: function setElementsValidFlag(isValid, filter) {\n      var _iterator4 = _createForOfIteratorHelper(this._past),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var element = _step4.value;\n\n          if (filter(element.actual)) {\n            this._setElementValidFlag(element, isValid);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(this._future),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _element3 = _step5.value;\n\n          if (filter(_element3.actual)) {\n            this._setElementValidFlag(_element3, isValid);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"pushElement\",\n    value: function pushElement(element) {\n      // remove the future\n      var _iterator6 = _createForOfIteratorHelper(this._future),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var futureElement = _step6.value;\n\n          if (futureElement.type === 1\n          /* Workspace */\n          ) {\n              futureElement.removeResource(this.resourceLabel, this.strResource, 1\n              /* NoParallelUniverses */\n              );\n            }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      this._future = [];\n\n      this._past.push(element);\n\n      this.versionId++;\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(resource) {\n      var elements = [];\n\n      for (var i = 0, len = this._past.length; i < len; i++) {\n        elements.push(this._past[i].id);\n      }\n\n      for (var _i2 = this._future.length - 1; _i2 >= 0; _i2--) {\n        elements.push(this._future[_i2].id);\n      }\n\n      return new ResourceEditStackSnapshot(resource, elements);\n    }\n  }, {\n    key: \"restoreSnapshot\",\n    value: function restoreSnapshot(snapshot) {\n      var snapshotLength = snapshot.elements.length;\n      var isOK = true;\n      var snapshotIndex = 0;\n      var removePastAfter = -1;\n\n      for (var i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n        var element = this._past[i];\n\n        if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n          isOK = false;\n          removePastAfter = 0;\n        }\n\n        if (!isOK && element.type === 1\n        /* Workspace */\n        ) {\n            element.removeResource(this.resourceLabel, this.strResource, 0\n            /* ExternalRemoval */\n            );\n          }\n      }\n\n      var removeFutureBefore = -1;\n\n      for (var _i3 = this._future.length - 1; _i3 >= 0; _i3--, snapshotIndex++) {\n        var _element4 = this._future[_i3];\n\n        if (isOK && (snapshotIndex >= snapshotLength || _element4.id !== snapshot.elements[snapshotIndex])) {\n          isOK = false;\n          removeFutureBefore = _i3;\n        }\n\n        if (!isOK && _element4.type === 1\n        /* Workspace */\n        ) {\n            _element4.removeResource(this.resourceLabel, this.strResource, 0\n            /* ExternalRemoval */\n            );\n          }\n      }\n\n      if (removePastAfter !== -1) {\n        this._past = this._past.slice(0, removePastAfter);\n      }\n\n      if (removeFutureBefore !== -1) {\n        this._future = this._future.slice(removeFutureBefore + 1);\n      }\n\n      this.versionId++;\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements() {\n      var past = [];\n      var future = [];\n\n      var _iterator7 = _createForOfIteratorHelper(this._past),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var element = _step7.value;\n          past.push(element.actual);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(this._future),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _element5 = _step8.value;\n          future.push(_element5.actual);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return {\n        past: past,\n        future: future\n      };\n    }\n  }, {\n    key: \"getClosestPastElement\",\n    value: function getClosestPastElement() {\n      if (this._past.length === 0) {\n        return null;\n      }\n\n      return this._past[this._past.length - 1];\n    }\n  }, {\n    key: \"getSecondClosestPastElement\",\n    value: function getSecondClosestPastElement() {\n      if (this._past.length < 2) {\n        return null;\n      }\n\n      return this._past[this._past.length - 2];\n    }\n  }, {\n    key: \"getClosestFutureElement\",\n    value: function getClosestFutureElement() {\n      if (this._future.length === 0) {\n        return null;\n      }\n\n      return this._future[this._future.length - 1];\n    }\n  }, {\n    key: \"hasPastElements\",\n    value: function hasPastElements() {\n      return this._past.length > 0;\n    }\n  }, {\n    key: \"hasFutureElements\",\n    value: function hasFutureElements() {\n      return this._future.length > 0;\n    }\n  }, {\n    key: \"splitPastWorkspaceElement\",\n    value: function splitPastWorkspaceElement(toRemove, individualMap) {\n      for (var j = this._past.length - 1; j >= 0; j--) {\n        if (this._past[j] === toRemove) {\n          if (individualMap.has(this.strResource)) {\n            // gets replaced\n            this._past[j] = individualMap.get(this.strResource);\n          } else {\n            // gets deleted\n            this._past.splice(j, 1);\n          }\n\n          break;\n        }\n      }\n\n      this.versionId++;\n    }\n  }, {\n    key: \"splitFutureWorkspaceElement\",\n    value: function splitFutureWorkspaceElement(toRemove, individualMap) {\n      for (var j = this._future.length - 1; j >= 0; j--) {\n        if (this._future[j] === toRemove) {\n          if (individualMap.has(this.strResource)) {\n            // gets replaced\n            this._future[j] = individualMap.get(this.strResource);\n          } else {\n            // gets deleted\n            this._future.splice(j, 1);\n          }\n\n          break;\n        }\n      }\n\n      this.versionId++;\n    }\n  }, {\n    key: \"moveBackward\",\n    value: function moveBackward(element) {\n      this._past.pop();\n\n      this._future.push(element);\n\n      this.versionId++;\n    }\n  }, {\n    key: \"moveForward\",\n    value: function moveForward(element) {\n      this._future.pop();\n\n      this._past.push(element);\n\n      this.versionId++;\n    }\n  }]);\n\n  return ResourceEditStack;\n}();\n\nvar EditStackSnapshot = /*#__PURE__*/function () {\n  function EditStackSnapshot(editStacks) {\n    _classCallCheck(this, EditStackSnapshot);\n\n    this.editStacks = editStacks;\n    this._versionIds = [];\n\n    for (var i = 0, len = this.editStacks.length; i < len; i++) {\n      this._versionIds[i] = this.editStacks[i].versionId;\n    }\n  }\n\n  _createClass(EditStackSnapshot, [{\n    key: \"isValid\",\n    value: function isValid() {\n      for (var i = 0, len = this.editStacks.length; i < len; i++) {\n        if (this._versionIds[i] !== this.editStacks[i].versionId) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return EditStackSnapshot;\n}();\n\nvar missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\n\nvar UndoRedoService = /*#__PURE__*/function () {\n  function UndoRedoService(_dialogService, _notificationService) {\n    _classCallCheck(this, UndoRedoService);\n\n    this._dialogService = _dialogService;\n    this._notificationService = _notificationService;\n    this._editStacks = new Map();\n    this._uriComparisonKeyComputers = [];\n  }\n\n  _createClass(UndoRedoService, [{\n    key: \"getUriComparisonKey\",\n    value: function getUriComparisonKey(resource) {\n      var _iterator9 = _createForOfIteratorHelper(this._uriComparisonKeyComputers),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var uriComparisonKeyComputer = _step9.value;\n\n          if (uriComparisonKeyComputer[0] === resource.scheme) {\n            return uriComparisonKeyComputer[1].getComparisonKey(resource);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return resource.toString();\n    }\n  }, {\n    key: \"_print\",\n    value: function _print(label) {\n      console.log(\"------------------------------------\");\n      console.log(\"AFTER \".concat(label, \": \"));\n      var str = [];\n\n      var _iterator10 = _createForOfIteratorHelper(this._editStacks),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var element = _step10.value;\n          str.push(element[1].toString());\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      console.log(str.join('\\n'));\n    }\n  }, {\n    key: \"pushElement\",\n    value: function pushElement(element) {\n      var group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UndoRedoGroup.None;\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UndoRedoSource.None;\n\n      if (element.type === 0\n      /* Resource */\n      ) {\n          var resourceLabel = getResourceLabel(element.resource);\n          var strResource = this.getUriComparisonKey(element.resource);\n\n          this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        } else {\n        var seen = new Set();\n        var resourceLabels = [];\n        var strResources = [];\n\n        var _iterator11 = _createForOfIteratorHelper(element.resources),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var resource = _step11.value;\n\n            var _resourceLabel = getResourceLabel(resource);\n\n            var _strResource = this.getUriComparisonKey(resource);\n\n            if (seen.has(_strResource)) {\n              continue;\n            }\n\n            seen.add(_strResource);\n            resourceLabels.push(_resourceLabel);\n            strResources.push(_strResource);\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        if (resourceLabels.length === 1) {\n          this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n        } else {\n          this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n      }\n\n      if (DEBUG) {\n        this._print('pushElement');\n      }\n    }\n  }, {\n    key: \"_pushElement\",\n    value: function _pushElement(element) {\n      for (var i = 0, len = element.strResources.length; i < len; i++) {\n        var resourceLabel = element.resourceLabels[i];\n        var strResource = element.strResources[i];\n        var editStack = void 0;\n\n        if (this._editStacks.has(strResource)) {\n          editStack = this._editStacks.get(strResource);\n        } else {\n          editStack = new ResourceEditStack(resourceLabel, strResource);\n\n          this._editStacks.set(strResource, editStack);\n        }\n\n        editStack.pushElement(element);\n      }\n    }\n  }, {\n    key: \"getLastElement\",\n    value: function getLastElement(resource) {\n      var strResource = this.getUriComparisonKey(resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        if (editStack.hasFutureElements()) {\n          return null;\n        }\n\n        var closestPastElement = editStack.getClosestPastElement();\n        return closestPastElement ? closestPastElement.actual : null;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_splitPastWorkspaceElement\",\n    value: function _splitPastWorkspaceElement(toRemove, ignoreResources) {\n      var individualArr = toRemove.actual.split();\n      var individualMap = new Map();\n\n      var _iterator12 = _createForOfIteratorHelper(individualArr),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _element = _step12.value;\n          var resourceLabel = getResourceLabel(_element.resource);\n          var strResource = this.getUriComparisonKey(_element.resource);\n          var element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n          individualMap.set(element.strResource, element);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      var _iterator13 = _createForOfIteratorHelper(toRemove.strResources),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _strResource2 = _step13.value;\n\n          if (ignoreResources && ignoreResources.has(_strResource2)) {\n            continue;\n          }\n\n          var editStack = this._editStacks.get(_strResource2);\n\n          editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n  }, {\n    key: \"_splitFutureWorkspaceElement\",\n    value: function _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n      var individualArr = toRemove.actual.split();\n      var individualMap = new Map();\n\n      var _iterator14 = _createForOfIteratorHelper(individualArr),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _element = _step14.value;\n          var resourceLabel = getResourceLabel(_element.resource);\n          var strResource = this.getUriComparisonKey(_element.resource);\n          var element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n          individualMap.set(element.strResource, element);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      var _iterator15 = _createForOfIteratorHelper(toRemove.strResources),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _strResource3 = _step15.value;\n\n          if (ignoreResources && ignoreResources.has(_strResource3)) {\n            continue;\n          }\n\n          var editStack = this._editStacks.get(_strResource3);\n\n          editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n  }, {\n    key: \"removeElements\",\n    value: function removeElements(resource) {\n      var strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        editStack.dispose();\n\n        this._editStacks[\"delete\"](strResource);\n      }\n\n      if (DEBUG) {\n        this._print('removeElements');\n      }\n    }\n  }, {\n    key: \"setElementsValidFlag\",\n    value: function setElementsValidFlag(resource, isValid, filter) {\n      var strResource = this.getUriComparisonKey(resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        editStack.setElementsValidFlag(isValid, filter);\n      }\n\n      if (DEBUG) {\n        this._print('setElementsValidFlag');\n      }\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(resource) {\n      var strResource = this.getUriComparisonKey(resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        return editStack.createSnapshot(resource);\n      }\n\n      return new ResourceEditStackSnapshot(resource, []);\n    }\n  }, {\n    key: \"restoreSnapshot\",\n    value: function restoreSnapshot(snapshot) {\n      var strResource = this.getUriComparisonKey(snapshot.resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        editStack.restoreSnapshot(snapshot);\n\n        if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n          // the edit stack is now empty, just remove it entirely\n          editStack.dispose();\n\n          this._editStacks[\"delete\"](strResource);\n        }\n      }\n\n      if (DEBUG) {\n        this._print('restoreSnapshot');\n      }\n    }\n  }, {\n    key: \"getElements\",\n    value: function getElements(resource) {\n      var strResource = this.getUriComparisonKey(resource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        return editStack.getElements();\n      }\n\n      return {\n        past: [],\n        future: []\n      };\n    }\n  }, {\n    key: \"_findClosestUndoElementWithSource\",\n    value: function _findClosestUndoElementWithSource(sourceId) {\n      if (!sourceId) {\n        return [null, null];\n      } // find an element with the sourceId and with the highest sourceOrder ready to be undone\n\n\n      var matchedElement = null;\n      var matchedStrResource = null;\n\n      var _iterator16 = _createForOfIteratorHelper(this._editStacks),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var _step16$value = _slicedToArray(_step16.value, 2),\n              strResource = _step16$value[0],\n              editStack = _step16$value[1];\n\n          var candidate = editStack.getClosestPastElement();\n\n          if (!candidate) {\n            continue;\n          }\n\n          if (candidate.sourceId === sourceId) {\n            if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n              matchedElement = candidate;\n              matchedStrResource = strResource;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      return [matchedElement, matchedStrResource];\n    }\n  }, {\n    key: \"canUndo\",\n    value: function canUndo(resourceOrSource) {\n      if (resourceOrSource instanceof UndoRedoSource) {\n        var _this$_findClosestUnd = this._findClosestUndoElementWithSource(resourceOrSource.id),\n            _this$_findClosestUnd2 = _slicedToArray(_this$_findClosestUnd, 2),\n            matchedStrResource = _this$_findClosestUnd2[1];\n\n        return matchedStrResource ? true : false;\n      }\n\n      var strResource = this.getUriComparisonKey(resourceOrSource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        return editStack.hasPastElements();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(err, element) {\n      onUnexpectedError(err); // An error occured while undoing or redoing => drop the undo/redo stack for all affected resources\n\n      var _iterator17 = _createForOfIteratorHelper(element.strResources),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var strResource = _step17.value;\n          this.removeElements(strResource);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      this._notificationService.error(err);\n    }\n  }, {\n    key: \"_acquireLocks\",\n    value: function _acquireLocks(editStackSnapshot) {\n      // first, check if all locks can be acquired\n      var _iterator18 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var editStack = _step18.value;\n\n          if (editStack.locked) {\n            throw new Error('Cannot acquire edit stack lock');\n          }\n        } // can acquire all locks\n\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      var _iterator19 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var _editStack = _step19.value;\n          _editStack.locked = true;\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return function () {\n        // release all locks\n        var _iterator20 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n            _step20;\n\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var editStack = _step20.value;\n            editStack.locked = false;\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n      };\n    }\n  }, {\n    key: \"_safeInvokeWithLocks\",\n    value: function _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n      var _this = this;\n\n      var releaseLocks = this._acquireLocks(editStackSnapshot);\n\n      var result;\n\n      try {\n        result = invoke();\n      } catch (err) {\n        releaseLocks();\n        cleanup.dispose();\n        return this._onError(err, element);\n      }\n\n      if (result) {\n        // result is Promise<void>\n        return result.then(function () {\n          releaseLocks();\n          cleanup.dispose();\n          return continuation();\n        }, function (err) {\n          releaseLocks();\n          cleanup.dispose();\n          return _this._onError(err, element);\n        });\n      } else {\n        // result is void\n        releaseLocks();\n        cleanup.dispose();\n        return continuation();\n      }\n    }\n  }, {\n    key: \"_invokeWorkspacePrepare\",\n    value: function _invokeWorkspacePrepare(element) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(typeof element.actual.prepareUndoRedo === 'undefined')) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Disposable.None);\n\n              case 2:\n                result = element.actual.prepareUndoRedo();\n\n                if (!(typeof result === 'undefined')) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Disposable.None);\n\n              case 5:\n                return _context.abrupt(\"return\", result);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"_invokeResourcePrepare\",\n    value: function _invokeResourcePrepare(element, callback) {\n      if (element.actual.type !== 1\n      /* Workspace */\n      || typeof element.actual.prepareUndoRedo === 'undefined') {\n        // no preparation needed\n        return callback(Disposable.None);\n      }\n\n      var r = element.actual.prepareUndoRedo();\n\n      if (!r) {\n        // nothing to clean up\n        return callback(Disposable.None);\n      }\n\n      if (isDisposable(r)) {\n        return callback(r);\n      }\n\n      return r.then(function (disposable) {\n        return callback(disposable);\n      });\n    }\n  }, {\n    key: \"_getAffectedEditStacks\",\n    value: function _getAffectedEditStacks(element) {\n      var affectedEditStacks = [];\n\n      var _iterator21 = _createForOfIteratorHelper(element.strResources),\n          _step21;\n\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var strResource = _step21.value;\n          affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      return new EditStackSnapshot(affectedEditStacks);\n    }\n  }, {\n    key: \"_tryToSplitAndUndo\",\n    value: function _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n      if (element.canSplit()) {\n        this._splitPastWorkspaceElement(element, ignoreResources);\n\n        this._notificationService.info(message);\n\n        return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n      } else {\n        // Cannot safely split this workspace element => flush all undo/redo stacks\n        var _iterator22 = _createForOfIteratorHelper(element.strResources),\n            _step22;\n\n        try {\n          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n            var _strResource4 = _step22.value;\n            this.removeElements(_strResource4);\n          }\n        } catch (err) {\n          _iterator22.e(err);\n        } finally {\n          _iterator22.f();\n        }\n\n        this._notificationService.info(message);\n\n        return new WorkspaceVerificationError();\n      }\n    }\n  }, {\n    key: \"_checkWorkspaceUndo\",\n    value: function _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n      if (element.removedResources) {\n        return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({\n          key: 'cannotWorkspaceUndo',\n          comment: ['{0} is a label for an operation. {1} is another message.']\n        }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n      }\n\n      if (checkInvalidatedResources && element.invalidatedResources) {\n        return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({\n          key: 'cannotWorkspaceUndo',\n          comment: ['{0} is a label for an operation. {1} is another message.']\n        }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n      } // this must be the last past element in all the impacted resources!\n\n\n      var cannotUndoDueToResources = [];\n\n      var _iterator23 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var editStack = _step23.value;\n\n          if (editStack.getClosestPastElement() !== element) {\n            cannotUndoDueToResources.push(editStack.resourceLabel);\n          }\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      if (cannotUndoDueToResources.length > 0) {\n        return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceUndoDueToChanges',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n      }\n\n      var cannotLockDueToResources = [];\n\n      var _iterator24 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var _editStack2 = _step24.value;\n\n          if (_editStack2.locked) {\n            cannotLockDueToResources.push(_editStack2.resourceLabel);\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      if (cannotLockDueToResources.length > 0) {\n        return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceUndoDueToInProgressUndoRedo',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n      } // check if new stack elements were added in the meantime...\n\n\n      if (!editStackSnapshot.isValid()) {\n        return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_workspaceUndo\",\n    value: function _workspaceUndo(strResource, element, undoConfirmed) {\n      var affectedEditStacks = this._getAffectedEditStacks(element);\n\n      var verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks,\n      /*invalidated resources will be checked after the prepare call*/\n      false);\n\n      if (verificationError) {\n        return verificationError.returnValue;\n      }\n\n      return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n  }, {\n    key: \"_isPartOfUndoGroup\",\n    value: function _isPartOfUndoGroup(element) {\n      if (!element.groupId) {\n        return false;\n      } // check that there is at least another element with the same groupId ready to be undone\n\n\n      var _iterator25 = _createForOfIteratorHelper(this._editStacks),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var _step25$value = _slicedToArray(_step25.value, 2),\n              editStack = _step25$value[1];\n\n          var pastElement = editStack.getClosestPastElement();\n\n          if (!pastElement) {\n            continue;\n          }\n\n          if (pastElement === element) {\n            var secondPastElement = editStack.getSecondClosestPastElement();\n\n            if (secondPastElement && secondPastElement.groupId === element.groupId) {\n              // there is another element with the same group id in the same stack!\n              return true;\n            }\n          }\n\n          if (pastElement.groupId === element.groupId) {\n            // there is another element with the same group id in another stack!\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_confirmAndExecuteWorkspaceUndo\",\n    value: function _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var result, verificationError1, cleanup, verificationError2, _iterator26, _step26, editStack;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(element.canSplit() && !this._isPartOfUndoGroup(element))) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [nls.localize({\n                  key: 'ok',\n                  comment: ['{0} denotes a number that is > 1']\n                }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length), nls.localize('nok', \"Undo this File\"), nls.localize('cancel', \"Cancel\")], {\n                  cancelId: 2\n                });\n\n              case 3:\n                result = _context2.sent;\n\n                if (!(result.choice === 2)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 6:\n                if (!(result.choice === 1)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                // choice: undo this file\n                this._splitPastWorkspaceElement(element, null);\n\n                return _context2.abrupt(\"return\", this._undo(strResource, 0, true));\n\n              case 9:\n                // choice: undo in all files\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n                verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot,\n                /*invalidated resources will be checked after the prepare call*/\n                false);\n\n                if (!verificationError1) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", verificationError1.returnValue);\n\n              case 12:\n                undoConfirmed = true;\n\n              case 13:\n                _context2.prev = 13;\n                _context2.next = 16;\n                return this._invokeWorkspacePrepare(element);\n\n              case 16:\n                cleanup = _context2.sent;\n                _context2.next = 22;\n                break;\n\n              case 19:\n                _context2.prev = 19;\n                _context2.t0 = _context2[\"catch\"](13);\n                return _context2.abrupt(\"return\", this._onError(_context2.t0, element));\n\n              case 22:\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n                verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot,\n                /*now also check that there are no more invalidated resources*/\n                true);\n\n                if (!verificationError2) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                cleanup.dispose();\n                return _context2.abrupt(\"return\", verificationError2.returnValue);\n\n              case 26:\n                _iterator26 = _createForOfIteratorHelper(editStackSnapshot.editStacks);\n\n                try {\n                  for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                    editStack = _step26.value;\n                    editStack.moveBackward(element);\n                  }\n                } catch (err) {\n                  _iterator26.e(err);\n                } finally {\n                  _iterator26.f();\n                }\n\n                return _context2.abrupt(\"return\", this._safeInvokeWithLocks(element, function () {\n                  return element.actual.undo();\n                }, editStackSnapshot, cleanup, function () {\n                  return _this2._continueUndoInGroup(element.groupId, undoConfirmed);\n                }));\n\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[13, 19]]);\n      }));\n    }\n  }, {\n    key: \"_resourceUndo\",\n    value: function _resourceUndo(editStack, element, undoConfirmed) {\n      var _this3 = this;\n\n      if (!element.isValid) {\n        // invalid element => immediately flush edit stack!\n        editStack.flushAllElements();\n        return;\n      }\n\n      if (editStack.locked) {\n        var message = nls.localize({\n          key: 'cannotResourceUndoDueToInProgressUndoRedo',\n          comment: ['{0} is a label for an operation.']\n        }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n\n        this._notificationService.info(message);\n\n        return;\n      }\n\n      return this._invokeResourcePrepare(element, function (cleanup) {\n        editStack.moveBackward(element);\n        return _this3._safeInvokeWithLocks(element, function () {\n          return element.actual.undo();\n        }, new EditStackSnapshot([editStack]), cleanup, function () {\n          return _this3._continueUndoInGroup(element.groupId, undoConfirmed);\n        });\n      });\n    }\n  }, {\n    key: \"_findClosestUndoElementInGroup\",\n    value: function _findClosestUndoElementInGroup(groupId) {\n      if (!groupId) {\n        return [null, null];\n      } // find another element with the same groupId and with the highest groupOrder ready to be undone\n\n\n      var matchedElement = null;\n      var matchedStrResource = null;\n\n      var _iterator27 = _createForOfIteratorHelper(this._editStacks),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var _step27$value = _slicedToArray(_step27.value, 2),\n              strResource = _step27$value[0],\n              editStack = _step27$value[1];\n\n          var candidate = editStack.getClosestPastElement();\n\n          if (!candidate) {\n            continue;\n          }\n\n          if (candidate.groupId === groupId) {\n            if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n              matchedElement = candidate;\n              matchedStrResource = strResource;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return [matchedElement, matchedStrResource];\n    }\n  }, {\n    key: \"_continueUndoInGroup\",\n    value: function _continueUndoInGroup(groupId, undoConfirmed) {\n      if (!groupId) {\n        return;\n      }\n\n      var _this$_findClosestUnd3 = this._findClosestUndoElementInGroup(groupId),\n          _this$_findClosestUnd4 = _slicedToArray(_this$_findClosestUnd3, 2),\n          matchedStrResource = _this$_findClosestUnd4[1];\n\n      if (matchedStrResource) {\n        return this._undo(matchedStrResource, 0, undoConfirmed);\n      }\n    }\n  }, {\n    key: \"undo\",\n    value: function undo(resourceOrSource) {\n      if (resourceOrSource instanceof UndoRedoSource) {\n        var _this$_findClosestUnd5 = this._findClosestUndoElementWithSource(resourceOrSource.id),\n            _this$_findClosestUnd6 = _slicedToArray(_this$_findClosestUnd5, 2),\n            matchedStrResource = _this$_findClosestUnd6[1];\n\n        return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n      }\n\n      if (typeof resourceOrSource === 'string') {\n        return this._undo(resourceOrSource, 0, false);\n      }\n\n      return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n  }, {\n    key: \"_undo\",\n    value: function _undo(strResource) {\n      var sourceId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var undoConfirmed = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (!this._editStacks.has(strResource)) {\n        return;\n      }\n\n      var editStack = this._editStacks.get(strResource);\n\n      var element = editStack.getClosestPastElement();\n\n      if (!element) {\n        return;\n      }\n\n      if (element.groupId) {\n        // this element is a part of a group, we need to make sure undoing in a group is in order\n        var _this$_findClosestUnd7 = this._findClosestUndoElementInGroup(element.groupId),\n            _this$_findClosestUnd8 = _slicedToArray(_this$_findClosestUnd7, 2),\n            matchedElement = _this$_findClosestUnd8[0],\n            matchedStrResource = _this$_findClosestUnd8[1];\n\n        if (element !== matchedElement && matchedStrResource) {\n          // there is an element in the same group that should be undone before this one\n          return this._undo(matchedStrResource, sourceId, undoConfirmed);\n        }\n      }\n\n      var shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;\n\n      if (shouldPromptForConfirmation && !undoConfirmed) {\n        // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n        return this._confirmAndContinueUndo(strResource, sourceId, element);\n      }\n\n      try {\n        if (element.type === 1\n        /* Workspace */\n        ) {\n            return this._workspaceUndo(strResource, element, undoConfirmed);\n          } else {\n          return this._resourceUndo(editStack, element, undoConfirmed);\n        }\n      } finally {\n        if (DEBUG) {\n          this._print('undo');\n        }\n      }\n    }\n  }, {\n    key: \"_confirmAndContinueUndo\",\n    value: function _confirmAndContinueUndo(strResource, sourceId, element) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [nls.localize('confirmDifferentSource.ok', \"Undo\"), nls.localize('cancel', \"Cancel\")], {\n                  cancelId: 1\n                });\n\n              case 2:\n                result = _context3.sent;\n\n                if (!(result.choice === 1)) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 5:\n                return _context3.abrupt(\"return\", this._undo(strResource, sourceId, true));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"_findClosestRedoElementWithSource\",\n    value: function _findClosestRedoElementWithSource(sourceId) {\n      if (!sourceId) {\n        return [null, null];\n      } // find an element with sourceId and with the lowest sourceOrder ready to be redone\n\n\n      var matchedElement = null;\n      var matchedStrResource = null;\n\n      var _iterator28 = _createForOfIteratorHelper(this._editStacks),\n          _step28;\n\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var _step28$value = _slicedToArray(_step28.value, 2),\n              strResource = _step28$value[0],\n              editStack = _step28$value[1];\n\n          var candidate = editStack.getClosestFutureElement();\n\n          if (!candidate) {\n            continue;\n          }\n\n          if (candidate.sourceId === sourceId) {\n            if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n              matchedElement = candidate;\n              matchedStrResource = strResource;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n\n      return [matchedElement, matchedStrResource];\n    }\n  }, {\n    key: \"canRedo\",\n    value: function canRedo(resourceOrSource) {\n      if (resourceOrSource instanceof UndoRedoSource) {\n        var _this$_findClosestRed = this._findClosestRedoElementWithSource(resourceOrSource.id),\n            _this$_findClosestRed2 = _slicedToArray(_this$_findClosestRed, 2),\n            matchedStrResource = _this$_findClosestRed2[1];\n\n        return matchedStrResource ? true : false;\n      }\n\n      var strResource = this.getUriComparisonKey(resourceOrSource);\n\n      if (this._editStacks.has(strResource)) {\n        var editStack = this._editStacks.get(strResource);\n\n        return editStack.hasFutureElements();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_tryToSplitAndRedo\",\n    value: function _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n      if (element.canSplit()) {\n        this._splitFutureWorkspaceElement(element, ignoreResources);\n\n        this._notificationService.info(message);\n\n        return new WorkspaceVerificationError(this._redo(strResource));\n      } else {\n        // Cannot safely split this workspace element => flush all undo/redo stacks\n        var _iterator29 = _createForOfIteratorHelper(element.strResources),\n            _step29;\n\n        try {\n          for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n            var _strResource5 = _step29.value;\n            this.removeElements(_strResource5);\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n\n        this._notificationService.info(message);\n\n        return new WorkspaceVerificationError();\n      }\n    }\n  }, {\n    key: \"_checkWorkspaceRedo\",\n    value: function _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n      if (element.removedResources) {\n        return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({\n          key: 'cannotWorkspaceRedo',\n          comment: ['{0} is a label for an operation. {1} is another message.']\n        }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n      }\n\n      if (checkInvalidatedResources && element.invalidatedResources) {\n        return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({\n          key: 'cannotWorkspaceRedo',\n          comment: ['{0} is a label for an operation. {1} is another message.']\n        }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n      } // this must be the last future element in all the impacted resources!\n\n\n      var cannotRedoDueToResources = [];\n\n      var _iterator30 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step30;\n\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var editStack = _step30.value;\n\n          if (editStack.getClosestFutureElement() !== element) {\n            cannotRedoDueToResources.push(editStack.resourceLabel);\n          }\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n\n      if (cannotRedoDueToResources.length > 0) {\n        return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceRedoDueToChanges',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n      }\n\n      var cannotLockDueToResources = [];\n\n      var _iterator31 = _createForOfIteratorHelper(editStackSnapshot.editStacks),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var _editStack3 = _step31.value;\n\n          if (_editStack3.locked) {\n            cannotLockDueToResources.push(_editStack3.resourceLabel);\n          }\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      if (cannotLockDueToResources.length > 0) {\n        return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceRedoDueToInProgressUndoRedo',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n      } // check if new stack elements were added in the meantime...\n\n\n      if (!editStackSnapshot.isValid()) {\n        return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n          key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo',\n          comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n        }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_workspaceRedo\",\n    value: function _workspaceRedo(strResource, element) {\n      var affectedEditStacks = this._getAffectedEditStacks(element);\n\n      var verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks,\n      /*invalidated resources will be checked after the prepare call*/\n      false);\n\n      if (verificationError) {\n        return verificationError.returnValue;\n      }\n\n      return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n  }, {\n    key: \"_executeWorkspaceRedo\",\n    value: function _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this4 = this;\n\n        var cleanup, verificationError, _iterator32, _step32, editStack;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this._invokeWorkspacePrepare(element);\n\n              case 3:\n                cleanup = _context4.sent;\n                _context4.next = 9;\n                break;\n\n              case 6:\n                _context4.prev = 6;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", this._onError(_context4.t0, element));\n\n              case 9:\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n                verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot,\n                /*now also check that there are no more invalidated resources*/\n                true);\n\n                if (!verificationError) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                cleanup.dispose();\n                return _context4.abrupt(\"return\", verificationError.returnValue);\n\n              case 13:\n                _iterator32 = _createForOfIteratorHelper(editStackSnapshot.editStacks);\n\n                try {\n                  for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                    editStack = _step32.value;\n                    editStack.moveForward(element);\n                  }\n                } catch (err) {\n                  _iterator32.e(err);\n                } finally {\n                  _iterator32.f();\n                }\n\n                return _context4.abrupt(\"return\", this._safeInvokeWithLocks(element, function () {\n                  return element.actual.redo();\n                }, editStackSnapshot, cleanup, function () {\n                  return _this4._continueRedoInGroup(element.groupId);\n                }));\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 6]]);\n      }));\n    }\n  }, {\n    key: \"_resourceRedo\",\n    value: function _resourceRedo(editStack, element) {\n      var _this5 = this;\n\n      if (!element.isValid) {\n        // invalid element => immediately flush edit stack!\n        editStack.flushAllElements();\n        return;\n      }\n\n      if (editStack.locked) {\n        var message = nls.localize({\n          key: 'cannotResourceRedoDueToInProgressUndoRedo',\n          comment: ['{0} is a label for an operation.']\n        }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n\n        this._notificationService.info(message);\n\n        return;\n      }\n\n      return this._invokeResourcePrepare(element, function (cleanup) {\n        editStack.moveForward(element);\n        return _this5._safeInvokeWithLocks(element, function () {\n          return element.actual.redo();\n        }, new EditStackSnapshot([editStack]), cleanup, function () {\n          return _this5._continueRedoInGroup(element.groupId);\n        });\n      });\n    }\n  }, {\n    key: \"_findClosestRedoElementInGroup\",\n    value: function _findClosestRedoElementInGroup(groupId) {\n      if (!groupId) {\n        return [null, null];\n      } // find another element with the same groupId and with the lowest groupOrder ready to be redone\n\n\n      var matchedElement = null;\n      var matchedStrResource = null;\n\n      var _iterator33 = _createForOfIteratorHelper(this._editStacks),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _step33$value = _slicedToArray(_step33.value, 2),\n              strResource = _step33$value[0],\n              editStack = _step33$value[1];\n\n          var candidate = editStack.getClosestFutureElement();\n\n          if (!candidate) {\n            continue;\n          }\n\n          if (candidate.groupId === groupId) {\n            if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n              matchedElement = candidate;\n              matchedStrResource = strResource;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      return [matchedElement, matchedStrResource];\n    }\n  }, {\n    key: \"_continueRedoInGroup\",\n    value: function _continueRedoInGroup(groupId) {\n      if (!groupId) {\n        return;\n      }\n\n      var _this$_findClosestRed3 = this._findClosestRedoElementInGroup(groupId),\n          _this$_findClosestRed4 = _slicedToArray(_this$_findClosestRed3, 2),\n          matchedStrResource = _this$_findClosestRed4[1];\n\n      if (matchedStrResource) {\n        return this._redo(matchedStrResource);\n      }\n    }\n  }, {\n    key: \"redo\",\n    value: function redo(resourceOrSource) {\n      if (resourceOrSource instanceof UndoRedoSource) {\n        var _this$_findClosestRed5 = this._findClosestRedoElementWithSource(resourceOrSource.id),\n            _this$_findClosestRed6 = _slicedToArray(_this$_findClosestRed5, 2),\n            matchedStrResource = _this$_findClosestRed6[1];\n\n        return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n      }\n\n      if (typeof resourceOrSource === 'string') {\n        return this._redo(resourceOrSource);\n      }\n\n      return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n  }, {\n    key: \"_redo\",\n    value: function _redo(strResource) {\n      if (!this._editStacks.has(strResource)) {\n        return;\n      }\n\n      var editStack = this._editStacks.get(strResource);\n\n      var element = editStack.getClosestFutureElement();\n\n      if (!element) {\n        return;\n      }\n\n      if (element.groupId) {\n        // this element is a part of a group, we need to make sure redoing in a group is in order\n        var _this$_findClosestRed7 = this._findClosestRedoElementInGroup(element.groupId),\n            _this$_findClosestRed8 = _slicedToArray(_this$_findClosestRed7, 2),\n            matchedElement = _this$_findClosestRed8[0],\n            matchedStrResource = _this$_findClosestRed8[1];\n\n        if (element !== matchedElement && matchedStrResource) {\n          // there is an element in the same group that should be redone before this one\n          return this._redo(matchedStrResource);\n        }\n      }\n\n      try {\n        if (element.type === 1\n        /* Workspace */\n        ) {\n            return this._workspaceRedo(strResource, element);\n          } else {\n          return this._resourceRedo(editStack, element);\n        }\n      } finally {\n        if (DEBUG) {\n          this._print('redo');\n        }\n      }\n    }\n  }]);\n\n  return UndoRedoService;\n}();\n\nUndoRedoService = __decorate([__param(0, IDialogService), __param(1, INotificationService)], UndoRedoService);\nexport { UndoRedoService };\n\nvar WorkspaceVerificationError = function WorkspaceVerificationError(returnValue) {\n  _classCallCheck(this, WorkspaceVerificationError);\n\n  this.returnValue = returnValue;\n};\n\nregisterSingleton(IUndoRedoService, UndoRedoService);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","nls","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","onUnexpectedError","registerSingleton","IDialogService","Severity","Schemas","INotificationService","Disposable","isDisposable","DEBUG","getResourceLabel","resource","scheme","file","fsPath","path","stackElementCounter","ResourceStackElement","actual","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","id","type","label","confirmBeforeUndo","resourceLabels","strResources","isValid","constructor","name","ResourceReasonPair","reason","RemovedResources","elements","Map","externalRemoval","noParallelUniverses","element","dest","push","messages","localize","comment","join","has","set","size","WorkspaceStackElement","removedResources","invalidatedResources","split","ResourceEditStack","_past","_future","locked","versionId","removeResource","setValid","filter","_setElementValidFlag","futureElement","len","snapshot","snapshotLength","isOK","snapshotIndex","removePastAfter","removeFutureBefore","slice","past","future","toRemove","individualMap","j","get","splice","pop","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_dialogService","_notificationService","_editStacks","_uriComparisonKeyComputers","uriComparisonKeyComputer","getComparisonKey","toString","console","log","str","group","None","source","getUriComparisonKey","_pushElement","nextOrder","seen","Set","resources","add","_print","editStack","pushElement","hasFutureElements","closestPastElement","getClosestPastElement","ignoreResources","individualArr","_element","splitPastWorkspaceElement","splitFutureWorkspaceElement","dispose","setElementsValidFlag","createSnapshot","restoreSnapshot","hasPastElements","getElements","matchedElement","matchedStrResource","candidate","resourceOrSource","_findClosestUndoElementWithSource","err","removeElements","error","editStackSnapshot","Error","invoke","cleanup","continuation","releaseLocks","_acquireLocks","_onError","prepareUndoRedo","callback","disposable","affectedEditStacks","message","canSplit","_splitPastWorkspaceElement","info","WorkspaceVerificationError","_undo","checkInvalidatedResources","_tryToSplitAndUndo","createMessage","cannotUndoDueToResources","cannotLockDueToResources","undoConfirmed","_getAffectedEditStacks","verificationError","_checkWorkspaceUndo","returnValue","_confirmAndExecuteWorkspaceUndo","pastElement","secondPastElement","getSecondClosestPastElement","_isPartOfUndoGroup","show","Info","cancelId","choice","verificationError1","_invokeWorkspacePrepare","verificationError2","moveBackward","_safeInvokeWithLocks","undo","_continueUndoInGroup","flushAllElements","_invokeResourcePrepare","_findClosestUndoElementInGroup","undefined","shouldPromptForConfirmation","_confirmAndContinueUndo","_workspaceUndo","_resourceUndo","getClosestFutureElement","_findClosestRedoElementWithSource","_splitFutureWorkspaceElement","_redo","_tryToSplitAndRedo","cannotRedoDueToResources","_checkWorkspaceRedo","_executeWorkspaceRedo","moveForward","redo","_continueRedoInGroup","_findClosestRedoElementInGroup","_workspaceRedo","_resourceRedo"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,IAAIA,UAAU,GAAI,QAAQ,KAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C;AAAiD,QAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAAxE;AACL,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,QAAQ,KAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGA,IAAIE,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA4B,UAAUC,OAAV,EAAmBC,UAAnB,EAA+BC,CAA/B,EAAkCC,SAAlC,EAA6C;AACrF,WAASC,KAAT,CAAeC,KAAf,EAAsB;AAAE,WAAOA,KAAK,YAAYH,CAAjB,GAAqBG,KAArB,GAA6B,IAAIH,CAAJ,CAAM,UAAUI,OAAV,EAAmB;AAAEA,MAAAA,OAAO,CAACD,KAAD,CAAP;AAAiB,KAA5C,CAApC;AAAoF;;AAC5G,SAAO,KAAKH,CAAC,KAAKA,CAAC,GAAGK,OAAT,CAAN,EAAyB,UAAUD,OAAV,EAAmBE,MAAnB,EAA2B;AACvD,aAASC,SAAT,CAAmBJ,KAAnB,EAA0B;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAACQ,IAAV,CAAeN,KAAf,CAAD,CAAJ;AAA8B,OAApC,CAAqC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC3F,aAASC,QAAT,CAAkBR,KAAlB,EAAyB;AAAE,UAAI;AAAEK,QAAAA,IAAI,CAACP,SAAS,CAAC,OAAD,CAAT,CAAmBE,KAAnB,CAAD,CAAJ;AAAkC,OAAxC,CAAyC,OAAOO,CAAP,EAAU;AAAEJ,QAAAA,MAAM,CAACI,CAAD,CAAN;AAAY;AAAE;;AAC9F,aAASF,IAAT,CAAcI,MAAd,EAAsB;AAAEA,MAAAA,MAAM,CAACC,IAAP,GAAcT,OAAO,CAACQ,MAAM,CAACT,KAAR,CAArB,GAAsCD,KAAK,CAACU,MAAM,CAACT,KAAR,CAAL,CAAoBW,IAApB,CAAyBP,SAAzB,EAAoCI,QAApC,CAAtC;AAAsF;;AAC9GH,IAAAA,IAAI,CAAC,CAACP,SAAS,GAAGA,SAAS,CAACc,KAAV,CAAgBjB,OAAhB,EAAyBC,UAAU,IAAI,EAAvC,CAAb,EAAyDU,IAAzD,EAAD,CAAJ;AACH,GALM,CAAP;AAMH,CARD;;AASA,OAAO,KAAKO,GAAZ,MAAqB,iBAArB;AACA,SAASC,gBAAT,EAA2BC,yBAA3B,EAAsDC,aAAtD,EAAqEC,cAArE,QAA2F,eAA3F;AACA,SAASC,iBAAT,QAAkC,gCAAlC;AACA,SAASC,iBAAT,QAAkC,0CAAlC;AACA,SAASC,cAAT,QAA+B,iCAA/B;AACA,OAAOC,QAAP,MAAqB,kCAArB;AACA,SAASC,OAAT,QAAwB,iCAAxB;AACA,SAASC,oBAAT,QAAqC,2CAArC;AACA,SAASC,UAAT,EAAqBC,YAArB,QAAyC,mCAAzC;AACA,IAAMC,KAAK,GAAG,KAAd;;AACA,SAASC,gBAAT,CAA0BC,QAA1B,EAAoC;AAChC,SAAOA,QAAQ,CAACC,MAAT,KAAoBP,OAAO,CAACQ,IAA5B,GAAmCF,QAAQ,CAACG,MAA5C,GAAqDH,QAAQ,CAACI,IAArE;AACH;;AACD,IAAIC,mBAAmB,GAAG,CAA1B;;IACMC,oB;AACF,gCAAYC,MAAZ,EAAoBC,aAApB,EAAmCC,WAAnC,EAAgDC,OAAhD,EAAyDC,UAAzD,EAAqEC,QAArE,EAA+EC,WAA/E,EAA4F;AAAA;;AACxF,SAAKC,EAAL,GAAW,EAAET,mBAAb;AACA,SAAKU,IAAL,GAAY;AAAE;AAAd;AACA,SAAKR,MAAL,GAAcA,MAAd;AACA,SAAKS,KAAL,GAAaT,MAAM,CAACS,KAApB;AACA,SAAKC,iBAAL,GAAyBV,MAAM,CAACU,iBAAP,IAA4B,KAArD;AACA,SAAKT,aAAL,GAAqBA,aAArB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKS,cAAL,GAAsB,CAAC,KAAKV,aAAN,CAAtB;AACA,SAAKW,YAAL,GAAoB,CAAC,KAAKV,WAAN,CAApB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKO,OAAL,GAAe,IAAf;AACH;;;;6BACQA,O,EAAS;AACd,WAAKA,OAAL,GAAeA,OAAf;AACH;;;+BACU;AACP,2BAAc,KAAKN,EAAnB,sBAAiC,KAAKJ,OAAtC,gBAAmD,KAAKU,OAAL,GAAe,SAAf,GAA2B,SAA9E,eAA4F,KAAKb,MAAL,CAAYc,WAAZ,CAAwBC,IAApH,gBAA8H,KAAKf,MAAnI;AACH;;;;;;IAECgB,kB,GACF,4BAAYf,aAAZ,EAA2BgB,MAA3B,EAAmC;AAAA;;AAC/B,OAAKhB,aAAL,GAAqBA,aAArB;AACA,OAAKgB,MAAL,GAAcA,MAAd;AACH,C;;IAECC,gB;AACF,8BAAc;AAAA;;AACV,SAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACH;;;;oCACe;AACZ,UAAMC,eAAe,GAAG,EAAxB;AACA,UAAMC,mBAAmB,GAAG,EAA5B;;AAFY,iDAGc,KAAKH,QAHnB;AAAA;;AAAA;AAGZ,4DAAyC;AAAA;AAAA,cAA3BI,OAA2B;;AACrC,cAAMC,IAAI,GAAID,OAAO,CAACN,MAAR,KAAmB;AAAE;AAArB,YACRI,eADQ,GAERC,mBAFN;AAGAE,UAAAA,IAAI,CAACC,IAAL,CAAUF,OAAO,CAACtB,aAAlB;AACH;AARW;AAAA;AAAA;AAAA;AAAA;;AASZ,UAAIyB,QAAQ,GAAG,EAAf;;AACA,UAAIL,eAAe,CAAC1E,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B+E,QAAAA,QAAQ,CAACD,IAAT,CAAc/C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,iBAAP;AAA0BqF,UAAAA,OAAO,EAAE,CAAC,4BAAD;AAAnC,SAAb,EAAkF,iEAAlF,EAAqJP,eAAe,CAACQ,IAAhB,CAAqB,IAArB,CAArJ,CAAd;AACH;;AACD,UAAIP,mBAAmB,CAAC3E,MAApB,GAA6B,CAAjC,EAAoC;AAChC+E,QAAAA,QAAQ,CAACD,IAAT,CAAc/C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,qBAAP;AAA8BqF,UAAAA,OAAO,EAAE,CAAC,4BAAD;AAAvC,SAAb,EAAsF,qEAAtF,EAA6JN,mBAAmB,CAACO,IAApB,CAAyB,IAAzB,CAA7J,CAAd;AACH;;AACD,aAAOH,QAAQ,CAACG,IAAT,CAAc,IAAd,CAAP;AACH;;;wBAIG3B,W,EAAa;AACb,aAAO,KAAKiB,QAAL,CAAcW,GAAd,CAAkB5B,WAAlB,CAAP;AACH;;;wBACGA,W,EAAarC,K,EAAO;AACpB,WAAKsD,QAAL,CAAcY,GAAd,CAAkB7B,WAAlB,EAA+BrC,KAA/B;AACH;;;4BACMqC,W,EAAa;AAChB,aAAO,KAAKiB,QAAL,WAAqBjB,WAArB,CAAP;AACH;;;wBAXU;AACP,aAAO,KAAKiB,QAAL,CAAca,IAArB;AACH;;;;;;IAWCC,qB;AACF,iCAAYjC,MAAZ,EAAoBW,cAApB,EAAoCC,YAApC,EAAkDT,OAAlD,EAA2DC,UAA3D,EAAuEC,QAAvE,EAAiFC,WAAjF,EAA8F;AAAA;;AAC1F,SAAKC,EAAL,GAAW,EAAET,mBAAb;AACA,SAAKU,IAAL,GAAY;AAAE;AAAd;AACA,SAAKR,MAAL,GAAcA,MAAd;AACA,SAAKS,KAAL,GAAaT,MAAM,CAACS,KAApB;AACA,SAAKC,iBAAL,GAAyBV,MAAM,CAACU,iBAAP,IAA4B,KAArD;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKT,OAAL,GAAeA,OAAf;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAK4B,gBAAL,GAAwB,IAAxB;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACH;;;;+BACU;AACP,aAAQ,OAAO,KAAKnC,MAAL,CAAYoC,KAAnB,KAA6B,UAArC;AACH;;;mCACcnC,a,EAAeC,W,EAAae,M,EAAQ;AAC/C,UAAI,CAAC,KAAKiB,gBAAV,EAA4B;AACxB,aAAKA,gBAAL,GAAwB,IAAIhB,gBAAJ,EAAxB;AACH;;AACD,UAAI,CAAC,KAAKgB,gBAAL,CAAsBJ,GAAtB,CAA0B5B,WAA1B,CAAL,EAA6C;AACzC,aAAKgC,gBAAL,CAAsBH,GAAtB,CAA0B7B,WAA1B,EAAuC,IAAIc,kBAAJ,CAAuBf,aAAvB,EAAsCgB,MAAtC,CAAvC;AACH;AACJ;;;6BACQhB,a,EAAeC,W,EAAaW,O,EAAS;AAC1C,UAAIA,OAAJ,EAAa;AACT,YAAI,KAAKsB,oBAAT,EAA+B;AAC3B,eAAKA,oBAAL,WAAiCjC,WAAjC;;AACA,cAAI,KAAKiC,oBAAL,CAA0BH,IAA1B,KAAmC,CAAvC,EAA0C;AACtC,iBAAKG,oBAAL,GAA4B,IAA5B;AACH;AACJ;AACJ,OAPD,MAQK;AACD,YAAI,CAAC,KAAKA,oBAAV,EAAgC;AAC5B,eAAKA,oBAAL,GAA4B,IAAIjB,gBAAJ,EAA5B;AACH;;AACD,YAAI,CAAC,KAAKiB,oBAAL,CAA0BL,GAA1B,CAA8B5B,WAA9B,CAAL,EAAiD;AAC7C,eAAKiC,oBAAL,CAA0BJ,GAA1B,CAA8B7B,WAA9B,EAA2C,IAAIc,kBAAJ,CAAuBf,aAAvB,EAAsC;AAAE;AAAxC,WAA3C;AACH;AACJ;AACJ;;;+BACU;AACP,2BAAc,KAAKM,EAAnB,sBAAiC,KAAKJ,OAAtC,gBAAmD,KAAKgC,oBAAL,GAA4B,SAA5B,GAAwC,SAA3F,eAAyG,KAAKnC,MAAL,CAAYc,WAAZ,CAAwBC,IAAjI,gBAA2I,KAAKf,MAAhJ;AACH;;;;;;IAECqC,iB;AACF,6BAAYpC,aAAZ,EAA2BC,WAA3B,EAAwC;AAAA;;AACpC,SAAKD,aAAL,GAAqBA,aAArB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKoC,KAAL,GAAa,EAAb;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,MAAL,GAAc,KAAd;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACH;;;;8BACS;AAAA,kDACgB,KAAKH,KADrB;AAAA;;AAAA;AACN,+DAAkC;AAAA,cAAvBf,OAAuB;;AAC9B,cAAIA,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,YAAwC;AACpCe,cAAAA,OAAO,CAACmB,cAAR,CAAuB,KAAKzC,aAA5B,EAA2C,KAAKC,WAAhD,EAA6D;AAAE;AAA/D;AACH;AACJ;AALK;AAAA;AAAA;AAAA;AAAA;;AAAA,kDAMgB,KAAKqC,OANrB;AAAA;;AAAA;AAMN,+DAAoC;AAAA,cAAzBhB,SAAyB;;AAChC,cAAIA,SAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,YAAwC;AACpCe,cAAAA,SAAO,CAACmB,cAAR,CAAuB,KAAKzC,aAA5B,EAA2C,KAAKC,WAAhD,EAA6D;AAAE;AAA/D;AACH;AACJ;AAVK;AAAA;AAAA;AAAA;AAAA;;AAWN,WAAKuC,SAAL;AACH;;;+BACU;AACP,UAAInE,MAAM,GAAG,EAAb;AACAA,MAAAA,MAAM,CAACmD,IAAP,aAAiB,KAAKvB,WAAtB;;AACA,WAAK,IAAIhD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKoF,KAAL,CAAW3F,MAA/B,EAAuCO,CAAC,EAAxC,EAA4C;AACxCoB,QAAAA,MAAM,CAACmD,IAAP,uBAA2B,KAAKa,KAAL,CAAWpF,CAAX,CAA3B;AACH;;AACD,WAAK,IAAIA,EAAC,GAAG,KAAKqF,OAAL,CAAa5F,MAAb,GAAsB,CAAnC,EAAsCO,EAAC,IAAI,CAA3C,EAA8CA,EAAC,EAA/C,EAAmD;AAC/CoB,QAAAA,MAAM,CAACmD,IAAP,uBAA2B,KAAKc,OAAL,CAAarF,EAAb,CAA3B;AACH;;AACD,aAAOoB,MAAM,CAACuD,IAAP,CAAY,IAAZ,CAAP;AACH;;;uCACkB;AACf,WAAKS,KAAL,GAAa,EAAb;AACA,WAAKC,OAAL,GAAe,EAAf;AACA,WAAKE,SAAL;AACH;;;yCACoBlB,O,EAASV,O,EAAS;AACnC,UAAIU,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,QAAwC;AACpCe,UAAAA,OAAO,CAACoB,QAAR,CAAiB,KAAK1C,aAAtB,EAAqC,KAAKC,WAA1C,EAAuDW,OAAvD;AACH,SAFD,MAGK;AACDU,QAAAA,OAAO,CAACoB,QAAR,CAAiB9B,OAAjB;AACH;AACJ;;;yCACoBA,O,EAAS+B,M,EAAQ;AAAA,kDACZ,KAAKN,KADO;AAAA;;AAAA;AAClC,+DAAkC;AAAA,cAAvBf,OAAuB;;AAC9B,cAAIqB,MAAM,CAACrB,OAAO,CAACvB,MAAT,CAAV,EAA4B;AACxB,iBAAK6C,oBAAL,CAA0BtB,OAA1B,EAAmCV,OAAnC;AACH;AACJ;AALiC;AAAA;AAAA;AAAA;AAAA;;AAAA,kDAMZ,KAAK0B,OANO;AAAA;;AAAA;AAMlC,+DAAoC;AAAA,cAAzBhB,SAAyB;;AAChC,cAAIqB,MAAM,CAACrB,SAAO,CAACvB,MAAT,CAAV,EAA4B;AACxB,iBAAK6C,oBAAL,CAA0BtB,SAA1B,EAAmCV,OAAnC;AACH;AACJ;AAViC;AAAA;AAAA;AAAA;AAAA;AAWrC;;;gCACWU,O,EAAS;AACjB;AADiB,kDAEW,KAAKgB,OAFhB;AAAA;;AAAA;AAEjB,+DAA0C;AAAA,cAA/BO,aAA+B;;AACtC,cAAIA,aAAa,CAACtC,IAAd,KAAuB;AAAE;AAA7B,YAA8C;AAC1CsC,cAAAA,aAAa,CAACJ,cAAd,CAA6B,KAAKzC,aAAlC,EAAiD,KAAKC,WAAtD,EAAmE;AAAE;AAArE;AACH;AACJ;AANgB;AAAA;AAAA;AAAA;AAAA;;AAOjB,WAAKqC,OAAL,GAAe,EAAf;;AACA,WAAKD,KAAL,CAAWb,IAAX,CAAgBF,OAAhB;;AACA,WAAKkB,SAAL;AACH;;;mCACchD,Q,EAAU;AACrB,UAAM0B,QAAQ,GAAG,EAAjB;;AACA,WAAK,IAAIjE,CAAC,GAAG,CAAR,EAAW6F,GAAG,GAAG,KAAKT,KAAL,CAAW3F,MAAjC,EAAyCO,CAAC,GAAG6F,GAA7C,EAAkD7F,CAAC,EAAnD,EAAuD;AACnDiE,QAAAA,QAAQ,CAACM,IAAT,CAAc,KAAKa,KAAL,CAAWpF,CAAX,EAAcqD,EAA5B;AACH;;AACD,WAAK,IAAIrD,GAAC,GAAG,KAAKqF,OAAL,CAAa5F,MAAb,GAAsB,CAAnC,EAAsCO,GAAC,IAAI,CAA3C,EAA8CA,GAAC,EAA/C,EAAmD;AAC/CiE,QAAAA,QAAQ,CAACM,IAAT,CAAc,KAAKc,OAAL,CAAarF,GAAb,EAAgBqD,EAA9B;AACH;;AACD,aAAO,IAAI3B,yBAAJ,CAA8Ba,QAA9B,EAAwC0B,QAAxC,CAAP;AACH;;;oCACe6B,Q,EAAU;AACtB,UAAMC,cAAc,GAAGD,QAAQ,CAAC7B,QAAT,CAAkBxE,MAAzC;AACA,UAAIuG,IAAI,GAAG,IAAX;AACA,UAAIC,aAAa,GAAG,CAApB;AACA,UAAIC,eAAe,GAAG,CAAC,CAAvB;;AACA,WAAK,IAAIlG,CAAC,GAAG,CAAR,EAAW6F,GAAG,GAAG,KAAKT,KAAL,CAAW3F,MAAjC,EAAyCO,CAAC,GAAG6F,GAA7C,EAAkD7F,CAAC,IAAIiG,aAAa,EAApE,EAAwE;AACpE,YAAM5B,OAAO,GAAG,KAAKe,KAAL,CAAWpF,CAAX,CAAhB;;AACA,YAAIgG,IAAI,KAAKC,aAAa,IAAIF,cAAjB,IAAmC1B,OAAO,CAAChB,EAAR,KAAeyC,QAAQ,CAAC7B,QAAT,CAAkBgC,aAAlB,CAAvD,CAAR,EAAkG;AAC9FD,UAAAA,IAAI,GAAG,KAAP;AACAE,UAAAA,eAAe,GAAG,CAAlB;AACH;;AACD,YAAI,CAACF,IAAD,IAAS3B,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAhC,UAAiD;AAC7Ce,YAAAA,OAAO,CAACmB,cAAR,CAAuB,KAAKzC,aAA5B,EAA2C,KAAKC,WAAhD,EAA6D;AAAE;AAA/D;AACH;AACJ;;AACD,UAAImD,kBAAkB,GAAG,CAAC,CAA1B;;AACA,WAAK,IAAInG,GAAC,GAAG,KAAKqF,OAAL,CAAa5F,MAAb,GAAsB,CAAnC,EAAsCO,GAAC,IAAI,CAA3C,EAA8CA,GAAC,IAAIiG,aAAa,EAAhE,EAAoE;AAChE,YAAM5B,SAAO,GAAG,KAAKgB,OAAL,CAAarF,GAAb,CAAhB;;AACA,YAAIgG,IAAI,KAAKC,aAAa,IAAIF,cAAjB,IAAmC1B,SAAO,CAAChB,EAAR,KAAeyC,QAAQ,CAAC7B,QAAT,CAAkBgC,aAAlB,CAAvD,CAAR,EAAkG;AAC9FD,UAAAA,IAAI,GAAG,KAAP;AACAG,UAAAA,kBAAkB,GAAGnG,GAArB;AACH;;AACD,YAAI,CAACgG,IAAD,IAAS3B,SAAO,CAACf,IAAR,KAAiB;AAAE;AAAhC,UAAiD;AAC7Ce,YAAAA,SAAO,CAACmB,cAAR,CAAuB,KAAKzC,aAA5B,EAA2C,KAAKC,WAAhD,EAA6D;AAAE;AAA/D;AACH;AACJ;;AACD,UAAIkD,eAAe,KAAK,CAAC,CAAzB,EAA4B;AACxB,aAAKd,KAAL,GAAa,KAAKA,KAAL,CAAWgB,KAAX,CAAiB,CAAjB,EAAoBF,eAApB,CAAb;AACH;;AACD,UAAIC,kBAAkB,KAAK,CAAC,CAA5B,EAA+B;AAC3B,aAAKd,OAAL,GAAe,KAAKA,OAAL,CAAae,KAAb,CAAmBD,kBAAkB,GAAG,CAAxC,CAAf;AACH;;AACD,WAAKZ,SAAL;AACH;;;kCACa;AACV,UAAMc,IAAI,GAAG,EAAb;AACA,UAAMC,MAAM,GAAG,EAAf;;AAFU,kDAGY,KAAKlB,KAHjB;AAAA;;AAAA;AAGV,+DAAkC;AAAA,cAAvBf,OAAuB;AAC9BgC,UAAAA,IAAI,CAAC9B,IAAL,CAAUF,OAAO,CAACvB,MAAlB;AACH;AALS;AAAA;AAAA;AAAA;AAAA;;AAAA,kDAMY,KAAKuC,OANjB;AAAA;;AAAA;AAMV,+DAAoC;AAAA,cAAzBhB,SAAyB;AAChCiC,UAAAA,MAAM,CAAC/B,IAAP,CAAYF,SAAO,CAACvB,MAApB;AACH;AARS;AAAA;AAAA;AAAA;AAAA;;AASV,aAAO;AAAEuD,QAAAA,IAAI,EAAJA,IAAF;AAAQC,QAAAA,MAAM,EAANA;AAAR,OAAP;AACH;;;4CACuB;AACpB,UAAI,KAAKlB,KAAL,CAAW3F,MAAX,KAAsB,CAA1B,EAA6B;AACzB,eAAO,IAAP;AACH;;AACD,aAAO,KAAK2F,KAAL,CAAW,KAAKA,KAAL,CAAW3F,MAAX,GAAoB,CAA/B,CAAP;AACH;;;kDAC6B;AAC1B,UAAI,KAAK2F,KAAL,CAAW3F,MAAX,GAAoB,CAAxB,EAA2B;AACvB,eAAO,IAAP;AACH;;AACD,aAAO,KAAK2F,KAAL,CAAW,KAAKA,KAAL,CAAW3F,MAAX,GAAoB,CAA/B,CAAP;AACH;;;8CACyB;AACtB,UAAI,KAAK4F,OAAL,CAAa5F,MAAb,KAAwB,CAA5B,EAA+B;AAC3B,eAAO,IAAP;AACH;;AACD,aAAO,KAAK4F,OAAL,CAAa,KAAKA,OAAL,CAAa5F,MAAb,GAAsB,CAAnC,CAAP;AACH;;;sCACiB;AACd,aAAQ,KAAK2F,KAAL,CAAW3F,MAAX,GAAoB,CAA5B;AACH;;;wCACmB;AAChB,aAAQ,KAAK4F,OAAL,CAAa5F,MAAb,GAAsB,CAA9B;AACH;;;8CACyB8G,Q,EAAUC,a,EAAe;AAC/C,WAAK,IAAIC,CAAC,GAAG,KAAKrB,KAAL,CAAW3F,MAAX,GAAoB,CAAjC,EAAoCgH,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EAAiD;AAC7C,YAAI,KAAKrB,KAAL,CAAWqB,CAAX,MAAkBF,QAAtB,EAAgC;AAC5B,cAAIC,aAAa,CAAC5B,GAAd,CAAkB,KAAK5B,WAAvB,CAAJ,EAAyC;AACrC;AACA,iBAAKoC,KAAL,CAAWqB,CAAX,IAAgBD,aAAa,CAACE,GAAd,CAAkB,KAAK1D,WAAvB,CAAhB;AACH,WAHD,MAIK;AACD;AACA,iBAAKoC,KAAL,CAAWuB,MAAX,CAAkBF,CAAlB,EAAqB,CAArB;AACH;;AACD;AACH;AACJ;;AACD,WAAKlB,SAAL;AACH;;;gDAC2BgB,Q,EAAUC,a,EAAe;AACjD,WAAK,IAAIC,CAAC,GAAG,KAAKpB,OAAL,CAAa5F,MAAb,GAAsB,CAAnC,EAAsCgH,CAAC,IAAI,CAA3C,EAA8CA,CAAC,EAA/C,EAAmD;AAC/C,YAAI,KAAKpB,OAAL,CAAaoB,CAAb,MAAoBF,QAAxB,EAAkC;AAC9B,cAAIC,aAAa,CAAC5B,GAAd,CAAkB,KAAK5B,WAAvB,CAAJ,EAAyC;AACrC;AACA,iBAAKqC,OAAL,CAAaoB,CAAb,IAAkBD,aAAa,CAACE,GAAd,CAAkB,KAAK1D,WAAvB,CAAlB;AACH,WAHD,MAIK;AACD;AACA,iBAAKqC,OAAL,CAAasB,MAAb,CAAoBF,CAApB,EAAuB,CAAvB;AACH;;AACD;AACH;AACJ;;AACD,WAAKlB,SAAL;AACH;;;iCACYlB,O,EAAS;AAClB,WAAKe,KAAL,CAAWwB,GAAX;;AACA,WAAKvB,OAAL,CAAad,IAAb,CAAkBF,OAAlB;;AACA,WAAKkB,SAAL;AACH;;;gCACWlB,O,EAAS;AACjB,WAAKgB,OAAL,CAAauB,GAAb;;AACA,WAAKxB,KAAL,CAAWb,IAAX,CAAgBF,OAAhB;;AACA,WAAKkB,SAAL;AACH;;;;;;IAECsB,iB;AACF,6BAAYC,UAAZ,EAAwB;AAAA;;AACpB,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKC,WAAL,GAAmB,EAAnB;;AACA,SAAK,IAAI/G,CAAC,GAAG,CAAR,EAAW6F,GAAG,GAAG,KAAKiB,UAAL,CAAgBrH,MAAtC,EAA8CO,CAAC,GAAG6F,GAAlD,EAAuD7F,CAAC,EAAxD,EAA4D;AACxD,WAAK+G,WAAL,CAAiB/G,CAAjB,IAAsB,KAAK8G,UAAL,CAAgB9G,CAAhB,EAAmBuF,SAAzC;AACH;AACJ;;;;8BACS;AACN,WAAK,IAAIvF,CAAC,GAAG,CAAR,EAAW6F,GAAG,GAAG,KAAKiB,UAAL,CAAgBrH,MAAtC,EAA8CO,CAAC,GAAG6F,GAAlD,EAAuD7F,CAAC,EAAxD,EAA4D;AACxD,YAAI,KAAK+G,WAAL,CAAiB/G,CAAjB,MAAwB,KAAK8G,UAAL,CAAgB9G,CAAhB,EAAmBuF,SAA/C,EAA0D;AACtD,iBAAO,KAAP;AACH;AACJ;;AACD,aAAO,IAAP;AACH;;;;;;AAEL,IAAMyB,gBAAgB,GAAG,IAAI7B,iBAAJ,CAAsB,EAAtB,EAA0B,EAA1B,CAAzB;AACA6B,gBAAgB,CAAC1B,MAAjB,GAA0B,IAA1B;;AACA,IAAI2B,eAAe;AACf,2BAAYC,cAAZ,EAA4BC,oBAA5B,EAAkD;AAAA;;AAC9C,SAAKD,cAAL,GAAsBA,cAAtB;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,WAAL,GAAmB,IAAIlD,GAAJ,EAAnB;AACA,SAAKmD,0BAAL,GAAkC,EAAlC;AACH;;AANc;AAAA;AAAA,wCAOK9E,QAPL,EAOe;AAAA,kDACa,KAAK8E,0BADlB;AAAA;;AAAA;AAC1B,+DAAwE;AAAA,cAA7DC,wBAA6D;;AACpE,cAAIA,wBAAwB,CAAC,CAAD,CAAxB,KAAgC/E,QAAQ,CAACC,MAA7C,EAAqD;AACjD,mBAAO8E,wBAAwB,CAAC,CAAD,CAAxB,CAA4BC,gBAA5B,CAA6ChF,QAA7C,CAAP;AACH;AACJ;AALyB;AAAA;AAAA;AAAA;AAAA;;AAM1B,aAAOA,QAAQ,CAACiF,QAAT,EAAP;AACH;AAdc;AAAA;AAAA,2BAeRjE,KAfQ,EAeD;AACVkE,MAAAA,OAAO,CAACC,GAAR;AACAD,MAAAA,OAAO,CAACC,GAAR,iBAAqBnE,KAArB;AACA,UAAIoE,GAAG,GAAG,EAAV;;AAHU,mDAIY,KAAKP,WAJjB;AAAA;;AAAA;AAIV,kEAAwC;AAAA,cAA7B/C,OAA6B;AACpCsD,UAAAA,GAAG,CAACpD,IAAJ,CAASF,OAAO,CAAC,CAAD,CAAP,CAAWmD,QAAX,EAAT;AACH;AANS;AAAA;AAAA;AAAA;AAAA;;AAOVC,MAAAA,OAAO,CAACC,GAAR,CAAYC,GAAG,CAAChD,IAAJ,CAAS,IAAT,CAAZ;AACH;AAvBc;AAAA;AAAA,gCAwBHN,OAxBG,EAwBgE;AAAA,UAA1DuD,KAA0D,uEAAlDjG,aAAa,CAACkG,IAAoC;AAAA,UAA9BC,MAA8B,uEAArBlG,cAAc,CAACiG,IAAM;;AAC3E,UAAIxD,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,QAAuC;AACnC,cAAMP,aAAa,GAAGT,gBAAgB,CAAC+B,OAAO,CAAC9B,QAAT,CAAtC;AACA,cAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyB1D,OAAO,CAAC9B,QAAjC,CAApB;;AACA,eAAKyF,YAAL,CAAkB,IAAInF,oBAAJ,CAAyBwB,OAAzB,EAAkCtB,aAAlC,EAAiDC,WAAjD,EAA8D4E,KAAK,CAACvE,EAApE,EAAwEuE,KAAK,CAACK,SAAN,EAAxE,EAA2FH,MAAM,CAACzE,EAAlG,EAAsGyE,MAAM,CAACG,SAAP,EAAtG,CAAlB;AACH,SAJD,MAKK;AACD,YAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;AACA,YAAM1E,cAAc,GAAG,EAAvB;AACA,YAAMC,YAAY,GAAG,EAArB;;AAHC,qDAIsBW,OAAO,CAAC+D,SAJ9B;AAAA;;AAAA;AAID,oEAA0C;AAAA,gBAA/B7F,QAA+B;;AACtC,gBAAMQ,cAAa,GAAGT,gBAAgB,CAACC,QAAD,CAAtC;;AACA,gBAAMS,YAAW,GAAG,KAAK+E,mBAAL,CAAyBxF,QAAzB,CAApB;;AACA,gBAAI2F,IAAI,CAACtD,GAAL,CAAS5B,YAAT,CAAJ,EAA2B;AACvB;AACH;;AACDkF,YAAAA,IAAI,CAACG,GAAL,CAASrF,YAAT;AACAS,YAAAA,cAAc,CAACc,IAAf,CAAoBxB,cAApB;AACAW,YAAAA,YAAY,CAACa,IAAb,CAAkBvB,YAAlB;AACH;AAbA;AAAA;AAAA;AAAA;AAAA;;AAcD,YAAIS,cAAc,CAAChE,MAAf,KAA0B,CAA9B,EAAiC;AAC7B,eAAKuI,YAAL,CAAkB,IAAInF,oBAAJ,CAAyBwB,OAAzB,EAAkCZ,cAAc,CAAC,CAAD,CAAhD,EAAqDC,YAAY,CAAC,CAAD,CAAjE,EAAsEkE,KAAK,CAACvE,EAA5E,EAAgFuE,KAAK,CAACK,SAAN,EAAhF,EAAmGH,MAAM,CAACzE,EAA1G,EAA8GyE,MAAM,CAACG,SAAP,EAA9G,CAAlB;AACH,SAFD,MAGK;AACD,eAAKD,YAAL,CAAkB,IAAIjD,qBAAJ,CAA0BV,OAA1B,EAAmCZ,cAAnC,EAAmDC,YAAnD,EAAiEkE,KAAK,CAACvE,EAAvE,EAA2EuE,KAAK,CAACK,SAAN,EAA3E,EAA8FH,MAAM,CAACzE,EAArG,EAAyGyE,MAAM,CAACG,SAAP,EAAzG,CAAlB;AACH;AACJ;;AACD,UAAI5F,KAAJ,EAAW;AACP,aAAKiG,MAAL,CAAY,aAAZ;AACH;AACJ;AAtDc;AAAA;AAAA,iCAuDFjE,OAvDE,EAuDO;AAClB,WAAK,IAAIrE,CAAC,GAAG,CAAR,EAAW6F,GAAG,GAAGxB,OAAO,CAACX,YAAR,CAAqBjE,MAA3C,EAAmDO,CAAC,GAAG6F,GAAvD,EAA4D7F,CAAC,EAA7D,EAAiE;AAC7D,YAAM+C,aAAa,GAAGsB,OAAO,CAACZ,cAAR,CAAuBzD,CAAvB,CAAtB;AACA,YAAMgD,WAAW,GAAGqB,OAAO,CAACX,YAAR,CAAqB1D,CAArB,CAApB;AACA,YAAIuI,SAAS,SAAb;;AACA,YAAI,KAAKnB,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnCuF,UAAAA,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAZ;AACH,SAFD,MAGK;AACDuF,UAAAA,SAAS,GAAG,IAAIpD,iBAAJ,CAAsBpC,aAAtB,EAAqCC,WAArC,CAAZ;;AACA,eAAKoE,WAAL,CAAiBvC,GAAjB,CAAqB7B,WAArB,EAAkCuF,SAAlC;AACH;;AACDA,QAAAA,SAAS,CAACC,WAAV,CAAsBnE,OAAtB;AACH;AACJ;AArEc;AAAA;AAAA,mCAsEA9B,QAtEA,EAsEU;AACrB,UAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyBxF,QAAzB,CAApB;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,YAAIuF,SAAS,CAACE,iBAAV,EAAJ,EAAmC;AAC/B,iBAAO,IAAP;AACH;;AACD,YAAMC,kBAAkB,GAAGH,SAAS,CAACI,qBAAV,EAA3B;AACA,eAAOD,kBAAkB,GAAGA,kBAAkB,CAAC5F,MAAtB,GAA+B,IAAxD;AACH;;AACD,aAAO,IAAP;AACH;AAjFc;AAAA;AAAA,+CAkFYyD,QAlFZ,EAkFsBqC,eAlFtB,EAkFuC;AAClD,UAAMC,aAAa,GAAGtC,QAAQ,CAACzD,MAAT,CAAgBoC,KAAhB,EAAtB;AACA,UAAMsB,aAAa,GAAG,IAAItC,GAAJ,EAAtB;;AAFkD,mDAG3B2E,aAH2B;AAAA;;AAAA;AAGlD,kEAAsC;AAAA,cAA3BC,QAA2B;AAClC,cAAM/F,aAAa,GAAGT,gBAAgB,CAACwG,QAAQ,CAACvG,QAAV,CAAtC;AACA,cAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyBe,QAAQ,CAACvG,QAAlC,CAApB;AACA,cAAM8B,OAAO,GAAG,IAAIxB,oBAAJ,CAAyBiG,QAAzB,EAAmC/F,aAAnC,EAAkDC,WAAlD,EAA+D,CAA/D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,CAAhB;AACAwD,UAAAA,aAAa,CAAC3B,GAAd,CAAkBR,OAAO,CAACrB,WAA1B,EAAuCqB,OAAvC;AACH;AARiD;AAAA;AAAA;AAAA;AAAA;;AAAA,mDASxBkC,QAAQ,CAAC7C,YATe;AAAA;;AAAA;AASlD,kEAAiD;AAAA,cAAtCV,aAAsC;;AAC7C,cAAI4F,eAAe,IAAIA,eAAe,CAAChE,GAAhB,CAAoB5B,aAApB,CAAvB,EAAyD;AACrD;AACH;;AACD,cAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,aAArB,CAAlB;;AACAuF,UAAAA,SAAS,CAACQ,yBAAV,CAAoCxC,QAApC,EAA8CC,aAA9C;AACH;AAfiD;AAAA;AAAA;AAAA;AAAA;AAgBrD;AAlGc;AAAA;AAAA,iDAmGcD,QAnGd,EAmGwBqC,eAnGxB,EAmGyC;AACpD,UAAMC,aAAa,GAAGtC,QAAQ,CAACzD,MAAT,CAAgBoC,KAAhB,EAAtB;AACA,UAAMsB,aAAa,GAAG,IAAItC,GAAJ,EAAtB;;AAFoD,mDAG7B2E,aAH6B;AAAA;;AAAA;AAGpD,kEAAsC;AAAA,cAA3BC,QAA2B;AAClC,cAAM/F,aAAa,GAAGT,gBAAgB,CAACwG,QAAQ,CAACvG,QAAV,CAAtC;AACA,cAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyBe,QAAQ,CAACvG,QAAlC,CAApB;AACA,cAAM8B,OAAO,GAAG,IAAIxB,oBAAJ,CAAyBiG,QAAzB,EAAmC/F,aAAnC,EAAkDC,WAAlD,EAA+D,CAA/D,EAAkE,CAAlE,EAAqE,CAArE,EAAwE,CAAxE,CAAhB;AACAwD,UAAAA,aAAa,CAAC3B,GAAd,CAAkBR,OAAO,CAACrB,WAA1B,EAAuCqB,OAAvC;AACH;AARmD;AAAA;AAAA;AAAA;AAAA;;AAAA,mDAS1BkC,QAAQ,CAAC7C,YATiB;AAAA;;AAAA;AASpD,kEAAiD;AAAA,cAAtCV,aAAsC;;AAC7C,cAAI4F,eAAe,IAAIA,eAAe,CAAChE,GAAhB,CAAoB5B,aAApB,CAAvB,EAAyD;AACrD;AACH;;AACD,cAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,aAArB,CAAlB;;AACAuF,UAAAA,SAAS,CAACS,2BAAV,CAAsCzC,QAAtC,EAAgDC,aAAhD;AACH;AAfmD;AAAA;AAAA;AAAA;AAAA;AAgBvD;AAnHc;AAAA;AAAA,mCAoHAjE,QApHA,EAoHU;AACrB,UAAMS,WAAW,GAAG,OAAOT,QAAP,KAAoB,QAApB,GAA+BA,QAA/B,GAA0C,KAAKwF,mBAAL,CAAyBxF,QAAzB,CAA9D;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACAuF,QAAAA,SAAS,CAACU,OAAV;;AACA,aAAK7B,WAAL,WAAwBpE,WAAxB;AACH;;AACD,UAAIX,KAAJ,EAAW;AACP,aAAKiG,MAAL,CAAY,gBAAZ;AACH;AACJ;AA9Hc;AAAA;AAAA,yCA+HM/F,QA/HN,EA+HgBoB,OA/HhB,EA+HyB+B,MA/HzB,EA+HiC;AAC5C,UAAM1C,WAAW,GAAG,KAAK+E,mBAAL,CAAyBxF,QAAzB,CAApB;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACAuF,QAAAA,SAAS,CAACW,oBAAV,CAA+BvF,OAA/B,EAAwC+B,MAAxC;AACH;;AACD,UAAIrD,KAAJ,EAAW;AACP,aAAKiG,MAAL,CAAY,sBAAZ;AACH;AACJ;AAxIc;AAAA;AAAA,mCAyIA/F,QAzIA,EAyIU;AACrB,UAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyBxF,QAAzB,CAApB;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,eAAOuF,SAAS,CAACY,cAAV,CAAyB5G,QAAzB,CAAP;AACH;;AACD,aAAO,IAAIb,yBAAJ,CAA8Ba,QAA9B,EAAwC,EAAxC,CAAP;AACH;AAhJc;AAAA;AAAA,oCAiJCuD,QAjJD,EAiJW;AACtB,UAAM9C,WAAW,GAAG,KAAK+E,mBAAL,CAAyBjC,QAAQ,CAACvD,QAAlC,CAApB;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACAuF,QAAAA,SAAS,CAACa,eAAV,CAA0BtD,QAA1B;;AACA,YAAI,CAACyC,SAAS,CAACc,eAAV,EAAD,IAAgC,CAACd,SAAS,CAACE,iBAAV,EAArC,EAAoE;AAChE;AACAF,UAAAA,SAAS,CAACU,OAAV;;AACA,eAAK7B,WAAL,WAAwBpE,WAAxB;AACH;AACJ;;AACD,UAAIX,KAAJ,EAAW;AACP,aAAKiG,MAAL,CAAY,iBAAZ;AACH;AACJ;AA/Jc;AAAA;AAAA,gCAgKH/F,QAhKG,EAgKO;AAClB,UAAMS,WAAW,GAAG,KAAK+E,mBAAL,CAAyBxF,QAAzB,CAApB;;AACA,UAAI,KAAK6E,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,eAAOuF,SAAS,CAACe,WAAV,EAAP;AACH;;AACD,aAAO;AAAEjD,QAAAA,IAAI,EAAE,EAAR;AAAYC,QAAAA,MAAM,EAAE;AAApB,OAAP;AACH;AAvKc;AAAA;AAAA,sDAwKmBnD,QAxKnB,EAwK6B;AACxC,UAAI,CAACA,QAAL,EAAe;AACX,eAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH,OAHuC,CAIxC;;;AACA,UAAIoG,cAAc,GAAG,IAArB;AACA,UAAIC,kBAAkB,GAAG,IAAzB;;AANwC,mDAOD,KAAKpC,WAPJ;AAAA;;AAAA;AAOxC,kEAAyD;AAAA;AAAA,cAA7CpE,WAA6C;AAAA,cAAhCuF,SAAgC;;AACrD,cAAMkB,SAAS,GAAGlB,SAAS,CAACI,qBAAV,EAAlB;;AACA,cAAI,CAACc,SAAL,EAAgB;AACZ;AACH;;AACD,cAAIA,SAAS,CAACtG,QAAV,KAAuBA,QAA3B,EAAqC;AACjC,gBAAI,CAACoG,cAAD,IAAmBE,SAAS,CAACrG,WAAV,GAAwBmG,cAAc,CAACnG,WAA9D,EAA2E;AACvEmG,cAAAA,cAAc,GAAGE,SAAjB;AACAD,cAAAA,kBAAkB,GAAGxG,WAArB;AACH;AACJ;AACJ;AAlBuC;AAAA;AAAA;AAAA;AAAA;;AAmBxC,aAAO,CAACuG,cAAD,EAAiBC,kBAAjB,CAAP;AACH;AA5Lc;AAAA;AAAA,4BA6LPE,gBA7LO,EA6LW;AACtB,UAAIA,gBAAgB,YAAY9H,cAAhC,EAAgD;AAAA,oCACb,KAAK+H,iCAAL,CAAuCD,gBAAgB,CAACrG,EAAxD,CADa;AAAA;AAAA,YACnCmG,kBADmC;;AAE5C,eAAOA,kBAAkB,GAAG,IAAH,GAAU,KAAnC;AACH;;AACD,UAAMxG,WAAW,GAAG,KAAK+E,mBAAL,CAAyB2B,gBAAzB,CAApB;;AACA,UAAI,KAAKtC,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,eAAOuF,SAAS,CAACc,eAAV,EAAP;AACH;;AACD,aAAO,KAAP;AACH;AAxMc;AAAA;AAAA,6BAyMNO,GAzMM,EAyMDvF,OAzMC,EAyMQ;AACnBxC,MAAAA,iBAAiB,CAAC+H,GAAD,CAAjB,CADmB,CAEnB;;AAFmB,mDAGOvF,OAAO,CAACX,YAHf;AAAA;;AAAA;AAGnB,kEAAgD;AAAA,cAArCV,WAAqC;AAC5C,eAAK6G,cAAL,CAAoB7G,WAApB;AACH;AALkB;AAAA;AAAA;AAAA;AAAA;;AAMnB,WAAKmE,oBAAL,CAA0B2C,KAA1B,CAAgCF,GAAhC;AACH;AAhNc;AAAA;AAAA,kCAiNDG,iBAjNC,EAiNkB;AAC7B;AAD6B,mDAELA,iBAAiB,CAACjD,UAFb;AAAA;;AAAA;AAE7B,kEAAsD;AAAA,cAA3CyB,SAA2C;;AAClD,cAAIA,SAAS,CAACjD,MAAd,EAAsB;AAClB,kBAAM,IAAI0E,KAAJ,CAAU,gCAAV,CAAN;AACH;AACJ,SAN4B,CAO7B;;AAP6B;AAAA;AAAA;AAAA;AAAA;;AAAA,mDAQLD,iBAAiB,CAACjD,UARb;AAAA;;AAAA;AAQ7B,kEAAsD;AAAA,cAA3CyB,UAA2C;AAClDA,UAAAA,UAAS,CAACjD,MAAV,GAAmB,IAAnB;AACH;AAV4B;AAAA;AAAA;AAAA;AAAA;;AAW7B,aAAO,YAAM;AACT;AADS,qDAEeyE,iBAAiB,CAACjD,UAFjC;AAAA;;AAAA;AAET,oEAAsD;AAAA,gBAA3CyB,SAA2C;AAClDA,YAAAA,SAAS,CAACjD,MAAV,GAAmB,KAAnB;AACH;AAJQ;AAAA;AAAA;AAAA;AAAA;AAKZ,OALD;AAMH;AAlOc;AAAA;AAAA,yCAmOMjB,OAnON,EAmOe4F,MAnOf,EAmOuBF,iBAnOvB,EAmO0CG,OAnO1C,EAmOmDC,YAnOnD,EAmOiE;AAAA;;AAC5E,UAAMC,YAAY,GAAG,KAAKC,aAAL,CAAmBN,iBAAnB,CAArB;;AACA,UAAI3I,MAAJ;;AACA,UAAI;AACAA,QAAAA,MAAM,GAAG6I,MAAM,EAAf;AACH,OAFD,CAGA,OAAOL,GAAP,EAAY;AACRQ,QAAAA,YAAY;AACZF,QAAAA,OAAO,CAACjB,OAAR;AACA,eAAO,KAAKqB,QAAL,CAAcV,GAAd,EAAmBvF,OAAnB,CAAP;AACH;;AACD,UAAIjD,MAAJ,EAAY;AACR;AACA,eAAOA,MAAM,CAACE,IAAP,CAAY,YAAM;AACrB8I,UAAAA,YAAY;AACZF,UAAAA,OAAO,CAACjB,OAAR;AACA,iBAAOkB,YAAY,EAAnB;AACH,SAJM,EAIJ,UAACP,GAAD,EAAS;AACRQ,UAAAA,YAAY;AACZF,UAAAA,OAAO,CAACjB,OAAR;AACA,iBAAO,KAAI,CAACqB,QAAL,CAAcV,GAAd,EAAmBvF,OAAnB,CAAP;AACH,SARM,CAAP;AASH,OAXD,MAYK;AACD;AACA+F,QAAAA,YAAY;AACZF,QAAAA,OAAO,CAACjB,OAAR;AACA,eAAOkB,YAAY,EAAnB;AACH;AACJ;AAhQc;AAAA;AAAA,4CAiQS9F,OAjQT,EAiQkB;AAC7B,aAAOhE,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAC/B,OAAOgE,OAAO,CAACvB,MAAR,CAAeyH,eAAtB,KAA0C,WADX;AAAA;AAAA;AAAA;;AAAA,iDAExBpI,UAAU,CAAC0F,IAFa;;AAAA;AAI7BzG,gBAAAA,MAJ6B,GAIpBiD,OAAO,CAACvB,MAAR,CAAeyH,eAAf,EAJoB;;AAAA,sBAK/B,OAAOnJ,MAAP,KAAkB,WALa;AAAA;AAAA;AAAA;;AAAA,iDAMxBe,UAAU,CAAC0F,IANa;;AAAA;AAAA,iDAQ5BzG,MAR4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAUH;AA5Qc;AAAA;AAAA,2CA6QQiD,OA7QR,EA6QiBmG,QA7QjB,EA6Q2B;AACtC,UAAInG,OAAO,CAACvB,MAAR,CAAeQ,IAAf,KAAwB;AAAE;AAA1B,SAA6C,OAAOe,OAAO,CAACvB,MAAR,CAAeyH,eAAtB,KAA0C,WAA3F,EAAwG;AACpG;AACA,eAAOC,QAAQ,CAACrI,UAAU,CAAC0F,IAAZ,CAAf;AACH;;AACD,UAAMnI,CAAC,GAAG2E,OAAO,CAACvB,MAAR,CAAeyH,eAAf,EAAV;;AACA,UAAI,CAAC7K,CAAL,EAAQ;AACJ;AACA,eAAO8K,QAAQ,CAACrI,UAAU,CAAC0F,IAAZ,CAAf;AACH;;AACD,UAAIzF,YAAY,CAAC1C,CAAD,CAAhB,EAAqB;AACjB,eAAO8K,QAAQ,CAAC9K,CAAD,CAAf;AACH;;AACD,aAAOA,CAAC,CAAC4B,IAAF,CAAO,UAACmJ,UAAD,EAAgB;AAC1B,eAAOD,QAAQ,CAACC,UAAD,CAAf;AACH,OAFM,CAAP;AAGH;AA7Rc;AAAA;AAAA,2CA8RQpG,OA9RR,EA8RiB;AAC5B,UAAMqG,kBAAkB,GAAG,EAA3B;;AAD4B,mDAEFrG,OAAO,CAACX,YAFN;AAAA;;AAAA;AAE5B,kEAAgD;AAAA,cAArCV,WAAqC;AAC5C0H,UAAAA,kBAAkB,CAACnG,IAAnB,CAAwB,KAAK6C,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,KAAqCgE,gBAA7D;AACH;AAJ2B;AAAA;AAAA;AAAA;AAAA;;AAK5B,aAAO,IAAIH,iBAAJ,CAAsB6D,kBAAtB,CAAP;AACH;AApSc;AAAA;AAAA,uCAqSI1H,WArSJ,EAqSiBqB,OArSjB,EAqS0BuE,eArS1B,EAqS2C+B,OArS3C,EAqSoD;AAC/D,UAAItG,OAAO,CAACuG,QAAR,EAAJ,EAAwB;AACpB,aAAKC,0BAAL,CAAgCxG,OAAhC,EAAyCuE,eAAzC;;AACA,aAAKzB,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA,eAAO,IAAII,0BAAJ,CAA+B,KAAKC,KAAL,CAAWhI,WAAX,EAAwB,CAAxB,EAA2B,IAA3B,CAA/B,CAAP;AACH,OAJD,MAKK;AACD;AADC,qDAEyBqB,OAAO,CAACX,YAFjC;AAAA;;AAAA;AAED,oEAAgD;AAAA,gBAArCV,aAAqC;AAC5C,iBAAK6G,cAAL,CAAoB7G,aAApB;AACH;AAJA;AAAA;AAAA;AAAA;AAAA;;AAKD,aAAKmE,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA,eAAO,IAAII,0BAAJ,EAAP;AACH;AACJ;AAnTc;AAAA;AAAA,wCAoTK/H,WApTL,EAoTkBqB,OApTlB,EAoT2B0F,iBApT3B,EAoT8CkB,yBApT9C,EAoTyE;AACpF,UAAI5G,OAAO,CAACW,gBAAZ,EAA8B;AAC1B,eAAO,KAAKkG,kBAAL,CAAwBlI,WAAxB,EAAqCqB,OAArC,EAA8CA,OAAO,CAACW,gBAAtD,EAAwExD,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,qBAAP;AAA8BqF,UAAAA,OAAO,EAAE,CAAC,0DAAD;AAAvC,SAAb,EAAoH,4CAApH,EAAkKL,OAAO,CAACd,KAA1K,EAAiLc,OAAO,CAACW,gBAAR,CAAyBmG,aAAzB,EAAjL,CAAxE,CAAP;AACH;;AACD,UAAIF,yBAAyB,IAAI5G,OAAO,CAACY,oBAAzC,EAA+D;AAC3D,eAAO,KAAKiG,kBAAL,CAAwBlI,WAAxB,EAAqCqB,OAArC,EAA8CA,OAAO,CAACY,oBAAtD,EAA4EzD,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,qBAAP;AAA8BqF,UAAAA,OAAO,EAAE,CAAC,0DAAD;AAAvC,SAAb,EAAoH,4CAApH,EAAkKL,OAAO,CAACd,KAA1K,EAAiLc,OAAO,CAACY,oBAAR,CAA6BkG,aAA7B,EAAjL,CAA5E,CAAP;AACH,OANmF,CAOpF;;;AACA,UAAMC,wBAAwB,GAAG,EAAjC;;AARoF,mDAS5DrB,iBAAiB,CAACjD,UAT0C;AAAA;;AAAA;AASpF,kEAAsD;AAAA,cAA3CyB,SAA2C;;AAClD,cAAIA,SAAS,CAACI,qBAAV,OAAsCtE,OAA1C,EAAmD;AAC/C+G,YAAAA,wBAAwB,CAAC7G,IAAzB,CAA8BgE,SAAS,CAACxF,aAAxC;AACH;AACJ;AAbmF;AAAA;AAAA;AAAA;AAAA;;AAcpF,UAAIqI,wBAAwB,CAAC3L,MAAzB,GAAkC,CAAtC,EAAyC;AACrC,eAAO,KAAKyL,kBAAL,CAAwBlI,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,iCAAP;AAA0CqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAAnD,SAAb,EAAoI,wEAApI,EAA8ML,OAAO,CAACd,KAAtN,EAA6N6H,wBAAwB,CAACzG,IAAzB,CAA8B,IAA9B,CAA7N,CAApD,CAAP;AACH;;AACD,UAAM0G,wBAAwB,GAAG,EAAjC;;AAjBoF,mDAkB5DtB,iBAAiB,CAACjD,UAlB0C;AAAA;;AAAA;AAkBpF,kEAAsD;AAAA,cAA3CyB,WAA2C;;AAClD,cAAIA,WAAS,CAACjD,MAAd,EAAsB;AAClB+F,YAAAA,wBAAwB,CAAC9G,IAAzB,CAA8BgE,WAAS,CAACxF,aAAxC;AACH;AACJ;AAtBmF;AAAA;AAAA;AAAA;AAAA;;AAuBpF,UAAIsI,wBAAwB,CAAC5L,MAAzB,GAAkC,CAAtC,EAAyC;AACrC,eAAO,KAAKyL,kBAAL,CAAwBlI,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,4CAAP;AAAqDqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAA9D,SAAb,EAA+I,yGAA/I,EAA0PL,OAAO,CAACd,KAAlQ,EAAyQ8H,wBAAwB,CAAC1G,IAAzB,CAA8B,IAA9B,CAAzQ,CAApD,CAAP;AACH,OAzBmF,CA0BpF;;;AACA,UAAI,CAACoF,iBAAiB,CAACpG,OAAlB,EAAL,EAAkC;AAC9B,eAAO,KAAKuH,kBAAL,CAAwBlI,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,4CAAP;AAAqDqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAA9D,SAAb,EAA+I,kGAA/I,EAAmPL,OAAO,CAACd,KAA3P,CAApD,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AAnVc;AAAA;AAAA,mCAoVAP,WApVA,EAoVaqB,OApVb,EAoVsBiH,aApVtB,EAoVqC;AAChD,UAAMZ,kBAAkB,GAAG,KAAKa,sBAAL,CAA4BlH,OAA5B,CAA3B;;AACA,UAAMmH,iBAAiB,GAAG,KAAKC,mBAAL,CAAyBzI,WAAzB,EAAsCqB,OAAtC,EAA+CqG,kBAA/C;AAAmE;AAAiE,WAApI,CAA1B;;AACA,UAAIc,iBAAJ,EAAuB;AACnB,eAAOA,iBAAiB,CAACE,WAAzB;AACH;;AACD,aAAO,KAAKC,+BAAL,CAAqC3I,WAArC,EAAkDqB,OAAlD,EAA2DqG,kBAA3D,EAA+EY,aAA/E,CAAP;AACH;AA3Vc;AAAA;AAAA,uCA4VIjH,OA5VJ,EA4Va;AACxB,UAAI,CAACA,OAAO,CAACpB,OAAb,EAAsB;AAClB,eAAO,KAAP;AACH,OAHuB,CAIxB;;;AAJwB,mDAKI,KAAKmE,WALT;AAAA;;AAAA;AAKxB,kEAA8C;AAAA;AAAA,cAAhCmB,SAAgC;;AAC1C,cAAMqD,WAAW,GAAGrD,SAAS,CAACI,qBAAV,EAApB;;AACA,cAAI,CAACiD,WAAL,EAAkB;AACd;AACH;;AACD,cAAIA,WAAW,KAAKvH,OAApB,EAA6B;AACzB,gBAAMwH,iBAAiB,GAAGtD,SAAS,CAACuD,2BAAV,EAA1B;;AACA,gBAAID,iBAAiB,IAAIA,iBAAiB,CAAC5I,OAAlB,KAA8BoB,OAAO,CAACpB,OAA/D,EAAwE;AACpE;AACA,qBAAO,IAAP;AACH;AACJ;;AACD,cAAI2I,WAAW,CAAC3I,OAAZ,KAAwBoB,OAAO,CAACpB,OAApC,EAA6C;AACzC;AACA,mBAAO,IAAP;AACH;AACJ;AArBuB;AAAA;AAAA;AAAA;AAAA;;AAsBxB,aAAO,KAAP;AACH;AAnXc;AAAA;AAAA,oDAoXiBD,WApXjB,EAoX8BqB,OApX9B,EAoXuC0F,iBApXvC,EAoX0DuB,aApX1D,EAoXyE;AACpF,aAAOjL,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,sBAC/BgE,OAAO,CAACuG,QAAR,MAAsB,CAAC,KAAKmB,kBAAL,CAAwB1H,OAAxB,CADQ;AAAA;AAAA;AAAA;;AAAA;AAGhB,uBAAM,KAAK6C,cAAL,CAAoB8E,IAApB,CAAyBhK,QAAQ,CAACiK,IAAlC,EAAwCzK,GAAG,CAACiD,QAAJ,CAAa,kBAAb,EAAiC,gDAAjC,EAAmFJ,OAAO,CAACd,KAA3F,CAAxC,EAA2I,CAC5J/B,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,kBAAAA,GAAG,EAAE,IAAP;AAAaqF,kBAAAA,OAAO,EAAE,CAAC,kCAAD;AAAtB,iBAAb,EAA2E,mBAA3E,EAAgGqF,iBAAiB,CAACjD,UAAlB,CAA6BrH,MAA7H,CAD4J,EAE5J+B,GAAG,CAACiD,QAAJ,CAAa,KAAb,EAAoB,gBAApB,CAF4J,EAG5JjD,GAAG,CAACiD,QAAJ,CAAa,QAAb,EAAuB,QAAvB,CAH4J,CAA3I,EAIlB;AACCyH,kBAAAA,QAAQ,EAAE;AADX,iBAJkB,CAAN;;AAHgB;AAGzB9K,gBAAAA,MAHyB;;AAAA,sBAU3BA,MAAM,CAAC+K,MAAP,KAAkB,CAVS;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,sBAc3B/K,MAAM,CAAC+K,MAAP,KAAkB,CAdS;AAAA;AAAA;AAAA;;AAe3B;AACA,qBAAKtB,0BAAL,CAAgCxG,OAAhC,EAAyC,IAAzC;;AAhB2B,kDAiBpB,KAAK2G,KAAL,CAAWhI,WAAX,EAAwB,CAAxB,EAA2B,IAA3B,CAjBoB;;AAAA;AAmB/B;AACA;AACMoJ,gBAAAA,kBArByB,GAqBJ,KAAKX,mBAAL,CAAyBzI,WAAzB,EAAsCqB,OAAtC,EAA+C0F,iBAA/C;AAAkE;AAAiE,qBAAnI,CArBI;;AAAA,qBAsB3BqC,kBAtB2B;AAAA;AAAA;AAAA;;AAAA,kDAuBpBA,kBAAkB,CAACV,WAvBC;;AAAA;AAyB/BJ,gBAAAA,aAAa,GAAG,IAAhB;;AAzB+B;AAAA;AAAA;AA8BrB,uBAAM,KAAKe,uBAAL,CAA6BhI,OAA7B,CAAN;;AA9BqB;AA8B/B6F,gBAAAA,OA9B+B;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,kDAiCxB,KAAKI,QAAL,eAAmBjG,OAAnB,CAjCwB;;AAAA;AAmCnC;AACMiI,gBAAAA,kBApC6B,GAoCR,KAAKb,mBAAL,CAAyBzI,WAAzB,EAAsCqB,OAAtC,EAA+C0F,iBAA/C;AAAkE;AAAgE,oBAAlI,CApCQ;;AAAA,qBAqC/BuC,kBArC+B;AAAA;AAAA;AAAA;;AAsC/BpC,gBAAAA,OAAO,CAACjB,OAAR;AAtC+B,kDAuCxBqD,kBAAkB,CAACZ,WAvCK;;AAAA;AAAA,yDAyCX3B,iBAAiB,CAACjD,UAzCP;;AAAA;AAyCnC,4EAAsD;AAA3CyB,oBAAAA,SAA2C;AAClDA,oBAAAA,SAAS,CAACgE,YAAV,CAAuBlI,OAAvB;AACH;AA3CkC;AAAA;AAAA;AAAA;AAAA;;AAAA,kDA4C5B,KAAKmI,oBAAL,CAA0BnI,OAA1B,EAAmC;AAAA,yBAAMA,OAAO,CAACvB,MAAR,CAAe2J,IAAf,EAAN;AAAA,iBAAnC,EAAgE1C,iBAAhE,EAAmFG,OAAnF,EAA4F;AAAA,yBAAM,MAAI,CAACwC,oBAAL,CAA0BrI,OAAO,CAACpB,OAAlC,EAA2CqI,aAA3C,CAAN;AAAA,iBAA5F,CA5C4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AA8CH;AAnac;AAAA;AAAA,kCAoaD/C,SApaC,EAoaUlE,OApaV,EAoamBiH,aApanB,EAoakC;AAAA;;AAC7C,UAAI,CAACjH,OAAO,CAACV,OAAb,EAAsB;AAClB;AACA4E,QAAAA,SAAS,CAACoE,gBAAV;AACA;AACH;;AACD,UAAIpE,SAAS,CAACjD,MAAd,EAAsB;AAClB,YAAMqF,OAAO,GAAGnJ,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,2CAAP;AAAoDqF,UAAAA,OAAO,EAAE,CAAC,kCAAD;AAA7D,SAAb,EAAkH,kFAAlH,EAAsML,OAAO,CAACd,KAA9M,CAAhB;;AACA,aAAK4D,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA;AACH;;AACD,aAAO,KAAKiC,sBAAL,CAA4BvI,OAA5B,EAAqC,UAAC6F,OAAD,EAAa;AACrD3B,QAAAA,SAAS,CAACgE,YAAV,CAAuBlI,OAAvB;AACA,eAAO,MAAI,CAACmI,oBAAL,CAA0BnI,OAA1B,EAAmC;AAAA,iBAAMA,OAAO,CAACvB,MAAR,CAAe2J,IAAf,EAAN;AAAA,SAAnC,EAAgE,IAAI5F,iBAAJ,CAAsB,CAAC0B,SAAD,CAAtB,CAAhE,EAAoG2B,OAApG,EAA6G;AAAA,iBAAM,MAAI,CAACwC,oBAAL,CAA0BrI,OAAO,CAACpB,OAAlC,EAA2CqI,aAA3C,CAAN;AAAA,SAA7G,CAAP;AACH,OAHM,CAAP;AAIH;AAnbc;AAAA;AAAA,mDAobgBrI,OApbhB,EAobyB;AACpC,UAAI,CAACA,OAAL,EAAc;AACV,eAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH,OAHmC,CAIpC;;;AACA,UAAIsG,cAAc,GAAG,IAArB;AACA,UAAIC,kBAAkB,GAAG,IAAzB;;AANoC,mDAOG,KAAKpC,WAPR;AAAA;;AAAA;AAOpC,kEAAyD;AAAA;AAAA,cAA7CpE,WAA6C;AAAA,cAAhCuF,SAAgC;;AACrD,cAAMkB,SAAS,GAAGlB,SAAS,CAACI,qBAAV,EAAlB;;AACA,cAAI,CAACc,SAAL,EAAgB;AACZ;AACH;;AACD,cAAIA,SAAS,CAACxG,OAAV,KAAsBA,OAA1B,EAAmC;AAC/B,gBAAI,CAACsG,cAAD,IAAmBE,SAAS,CAACvG,UAAV,GAAuBqG,cAAc,CAACrG,UAA7D,EAAyE;AACrEqG,cAAAA,cAAc,GAAGE,SAAjB;AACAD,cAAAA,kBAAkB,GAAGxG,WAArB;AACH;AACJ;AACJ;AAlBmC;AAAA;AAAA;AAAA;AAAA;;AAmBpC,aAAO,CAACuG,cAAD,EAAiBC,kBAAjB,CAAP;AACH;AAxcc;AAAA;AAAA,yCAycMvG,OAzcN,EAyceqI,aAzcf,EAyc8B;AACzC,UAAI,CAACrI,OAAL,EAAc;AACV;AACH;;AAHwC,mCAIV,KAAK4J,8BAAL,CAAoC5J,OAApC,CAJU;AAAA;AAAA,UAIhCuG,kBAJgC;;AAKzC,UAAIA,kBAAJ,EAAwB;AACpB,eAAO,KAAKwB,KAAL,CAAWxB,kBAAX,EAA+B,CAA/B,EAAkC8B,aAAlC,CAAP;AACH;AACJ;AAjdc;AAAA;AAAA,yBAkdV5B,gBAldU,EAkdQ;AACnB,UAAIA,gBAAgB,YAAY9H,cAAhC,EAAgD;AAAA,qCACb,KAAK+H,iCAAL,CAAuCD,gBAAgB,CAACrG,EAAxD,CADa;AAAA;AAAA,YACnCmG,kBADmC;;AAE5C,eAAOA,kBAAkB,GAAG,KAAKwB,KAAL,CAAWxB,kBAAX,EAA+BE,gBAAgB,CAACrG,EAAhD,EAAoD,KAApD,CAAH,GAAgEyJ,SAAzF;AACH;;AACD,UAAI,OAAOpD,gBAAP,KAA4B,QAAhC,EAA0C;AACtC,eAAO,KAAKsB,KAAL,CAAWtB,gBAAX,EAA6B,CAA7B,EAAgC,KAAhC,CAAP;AACH;;AACD,aAAO,KAAKsB,KAAL,CAAW,KAAKjD,mBAAL,CAAyB2B,gBAAzB,CAAX,EAAuD,CAAvD,EAA0D,KAA1D,CAAP;AACH;AA3dc;AAAA;AAAA,0BA4dT1G,WA5dS,EA4diC;AAAA,UAA7BG,QAA6B,uEAAlB,CAAkB;AAAA,UAAfmI,aAAe;;AAC5C,UAAI,CAAC,KAAKlE,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAL,EAAwC;AACpC;AACH;;AACD,UAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,UAAMqB,OAAO,GAAGkE,SAAS,CAACI,qBAAV,EAAhB;;AACA,UAAI,CAACtE,OAAL,EAAc;AACV;AACH;;AACD,UAAIA,OAAO,CAACpB,OAAZ,EAAqB;AACjB;AADiB,qCAE4B,KAAK4J,8BAAL,CAAoCxI,OAAO,CAACpB,OAA5C,CAF5B;AAAA;AAAA,YAEVsG,cAFU;AAAA,YAEMC,kBAFN;;AAGjB,YAAInF,OAAO,KAAKkF,cAAZ,IAA8BC,kBAAlC,EAAsD;AAClD;AACA,iBAAO,KAAKwB,KAAL,CAAWxB,kBAAX,EAA+BrG,QAA/B,EAAyCmI,aAAzC,CAAP;AACH;AACJ;;AACD,UAAMyB,2BAA2B,GAAI1I,OAAO,CAAClB,QAAR,KAAqBA,QAArB,IAAiCkB,OAAO,CAACb,iBAA9E;;AACA,UAAIuJ,2BAA2B,IAAI,CAACzB,aAApC,EAAmD;AAC/C;AACA,eAAO,KAAK0B,uBAAL,CAA6BhK,WAA7B,EAA0CG,QAA1C,EAAoDkB,OAApD,CAAP;AACH;;AACD,UAAI;AACA,YAAIA,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,UAAwC;AACpC,mBAAO,KAAK2J,cAAL,CAAoBjK,WAApB,EAAiCqB,OAAjC,EAA0CiH,aAA1C,CAAP;AACH,WAFD,MAGK;AACD,iBAAO,KAAK4B,aAAL,CAAmB3E,SAAnB,EAA8BlE,OAA9B,EAAuCiH,aAAvC,CAAP;AACH;AACJ,OAPD,SAQQ;AACJ,YAAIjJ,KAAJ,EAAW;AACP,eAAKiG,MAAL,CAAY,MAAZ;AACH;AACJ;AACJ;AA/fc;AAAA;AAAA,4CAggBStF,WAhgBT,EAggBsBG,QAhgBtB,EAggBgCkB,OAhgBhC,EAggByC;AACpD,aAAOhE,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACpB,uBAAM,KAAK6G,cAAL,CAAoB8E,IAApB,CAAyBhK,QAAQ,CAACiK,IAAlC,EAAwCzK,GAAG,CAACiD,QAAJ,CAAa,wBAAb,EAAuC,+BAAvC,EAAwEJ,OAAO,CAACd,KAAhF,CAAxC,EAAgI,CACjJ/B,GAAG,CAACiD,QAAJ,CAAa,2BAAb,EAA0C,MAA1C,CADiJ,EAEjJjD,GAAG,CAACiD,QAAJ,CAAa,QAAb,EAAuB,QAAvB,CAFiJ,CAAhI,EAGlB;AACCyH,kBAAAA,QAAQ,EAAE;AADX,iBAHkB,CAAN;;AADoB;AAC7B9K,gBAAAA,MAD6B;;AAAA,sBAO/BA,MAAM,CAAC+K,MAAP,KAAkB,CAPa;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,kDAY5B,KAAKnB,KAAL,CAAWhI,WAAX,EAAwBG,QAAxB,EAAkC,IAAlC,CAZ4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAcH;AA/gBc;AAAA;AAAA,sDAghBmBA,QAhhBnB,EAghB6B;AACxC,UAAI,CAACA,QAAL,EAAe;AACX,eAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH,OAHuC,CAIxC;;;AACA,UAAIoG,cAAc,GAAG,IAArB;AACA,UAAIC,kBAAkB,GAAG,IAAzB;;AANwC,mDAOD,KAAKpC,WAPJ;AAAA;;AAAA;AAOxC,kEAAyD;AAAA;AAAA,cAA7CpE,WAA6C;AAAA,cAAhCuF,SAAgC;;AACrD,cAAMkB,SAAS,GAAGlB,SAAS,CAAC4E,uBAAV,EAAlB;;AACA,cAAI,CAAC1D,SAAL,EAAgB;AACZ;AACH;;AACD,cAAIA,SAAS,CAACtG,QAAV,KAAuBA,QAA3B,EAAqC;AACjC,gBAAI,CAACoG,cAAD,IAAmBE,SAAS,CAACrG,WAAV,GAAwBmG,cAAc,CAACnG,WAA9D,EAA2E;AACvEmG,cAAAA,cAAc,GAAGE,SAAjB;AACAD,cAAAA,kBAAkB,GAAGxG,WAArB;AACH;AACJ;AACJ;AAlBuC;AAAA;AAAA;AAAA;AAAA;;AAmBxC,aAAO,CAACuG,cAAD,EAAiBC,kBAAjB,CAAP;AACH;AApiBc;AAAA;AAAA,4BAqiBPE,gBAriBO,EAqiBW;AACtB,UAAIA,gBAAgB,YAAY9H,cAAhC,EAAgD;AAAA,oCACb,KAAKwL,iCAAL,CAAuC1D,gBAAgB,CAACrG,EAAxD,CADa;AAAA;AAAA,YACnCmG,kBADmC;;AAE5C,eAAOA,kBAAkB,GAAG,IAAH,GAAU,KAAnC;AACH;;AACD,UAAMxG,WAAW,GAAG,KAAK+E,mBAAL,CAAyB2B,gBAAzB,CAApB;;AACA,UAAI,KAAKtC,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAJ,EAAuC;AACnC,YAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,eAAOuF,SAAS,CAACE,iBAAV,EAAP;AACH;;AACD,aAAO,KAAP;AACH;AAhjBc;AAAA;AAAA,uCAijBIzF,WAjjBJ,EAijBiBqB,OAjjBjB,EAijB0BuE,eAjjB1B,EAijB2C+B,OAjjB3C,EAijBoD;AAC/D,UAAItG,OAAO,CAACuG,QAAR,EAAJ,EAAwB;AACpB,aAAKyC,4BAAL,CAAkChJ,OAAlC,EAA2CuE,eAA3C;;AACA,aAAKzB,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA,eAAO,IAAII,0BAAJ,CAA+B,KAAKuC,KAAL,CAAWtK,WAAX,CAA/B,CAAP;AACH,OAJD,MAKK;AACD;AADC,qDAEyBqB,OAAO,CAACX,YAFjC;AAAA;;AAAA;AAED,oEAAgD;AAAA,gBAArCV,aAAqC;AAC5C,iBAAK6G,cAAL,CAAoB7G,aAApB;AACH;AAJA;AAAA;AAAA;AAAA;AAAA;;AAKD,aAAKmE,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA,eAAO,IAAII,0BAAJ,EAAP;AACH;AACJ;AA/jBc;AAAA;AAAA,wCAgkBK/H,WAhkBL,EAgkBkBqB,OAhkBlB,EAgkB2B0F,iBAhkB3B,EAgkB8CkB,yBAhkB9C,EAgkByE;AACpF,UAAI5G,OAAO,CAACW,gBAAZ,EAA8B;AAC1B,eAAO,KAAKuI,kBAAL,CAAwBvK,WAAxB,EAAqCqB,OAArC,EAA8CA,OAAO,CAACW,gBAAtD,EAAwExD,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,qBAAP;AAA8BqF,UAAAA,OAAO,EAAE,CAAC,0DAAD;AAAvC,SAAb,EAAoH,4CAApH,EAAkKL,OAAO,CAACd,KAA1K,EAAiLc,OAAO,CAACW,gBAAR,CAAyBmG,aAAzB,EAAjL,CAAxE,CAAP;AACH;;AACD,UAAIF,yBAAyB,IAAI5G,OAAO,CAACY,oBAAzC,EAA+D;AAC3D,eAAO,KAAKsI,kBAAL,CAAwBvK,WAAxB,EAAqCqB,OAArC,EAA8CA,OAAO,CAACY,oBAAtD,EAA4EzD,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,qBAAP;AAA8BqF,UAAAA,OAAO,EAAE,CAAC,0DAAD;AAAvC,SAAb,EAAoH,4CAApH,EAAkKL,OAAO,CAACd,KAA1K,EAAiLc,OAAO,CAACY,oBAAR,CAA6BkG,aAA7B,EAAjL,CAA5E,CAAP;AACH,OANmF,CAOpF;;;AACA,UAAMqC,wBAAwB,GAAG,EAAjC;;AARoF,mDAS5DzD,iBAAiB,CAACjD,UAT0C;AAAA;;AAAA;AASpF,kEAAsD;AAAA,cAA3CyB,SAA2C;;AAClD,cAAIA,SAAS,CAAC4E,uBAAV,OAAwC9I,OAA5C,EAAqD;AACjDmJ,YAAAA,wBAAwB,CAACjJ,IAAzB,CAA8BgE,SAAS,CAACxF,aAAxC;AACH;AACJ;AAbmF;AAAA;AAAA;AAAA;AAAA;;AAcpF,UAAIyK,wBAAwB,CAAC/N,MAAzB,GAAkC,CAAtC,EAAyC;AACrC,eAAO,KAAK8N,kBAAL,CAAwBvK,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,iCAAP;AAA0CqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAAnD,SAAb,EAAoI,wEAApI,EAA8ML,OAAO,CAACd,KAAtN,EAA6NiK,wBAAwB,CAAC7I,IAAzB,CAA8B,IAA9B,CAA7N,CAApD,CAAP;AACH;;AACD,UAAM0G,wBAAwB,GAAG,EAAjC;;AAjBoF,mDAkB5DtB,iBAAiB,CAACjD,UAlB0C;AAAA;;AAAA;AAkBpF,kEAAsD;AAAA,cAA3CyB,WAA2C;;AAClD,cAAIA,WAAS,CAACjD,MAAd,EAAsB;AAClB+F,YAAAA,wBAAwB,CAAC9G,IAAzB,CAA8BgE,WAAS,CAACxF,aAAxC;AACH;AACJ;AAtBmF;AAAA;AAAA;AAAA;AAAA;;AAuBpF,UAAIsI,wBAAwB,CAAC5L,MAAzB,GAAkC,CAAtC,EAAyC;AACrC,eAAO,KAAK8N,kBAAL,CAAwBvK,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,4CAAP;AAAqDqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAA9D,SAAb,EAA+I,yGAA/I,EAA0PL,OAAO,CAACd,KAAlQ,EAAyQ8H,wBAAwB,CAAC1G,IAAzB,CAA8B,IAA9B,CAAzQ,CAApD,CAAP;AACH,OAzBmF,CA0BpF;;;AACA,UAAI,CAACoF,iBAAiB,CAACpG,OAAlB,EAAL,EAAkC;AAC9B,eAAO,KAAK4J,kBAAL,CAAwBvK,WAAxB,EAAqCqB,OAArC,EAA8C,IAA9C,EAAoD7C,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,4CAAP;AAAqDqF,UAAAA,OAAO,EAAE,CAAC,8DAAD;AAA9D,SAAb,EAA+I,kGAA/I,EAAmPL,OAAO,CAACd,KAA3P,CAApD,CAAP;AACH;;AACD,aAAO,IAAP;AACH;AA/lBc;AAAA;AAAA,mCAgmBAP,WAhmBA,EAgmBaqB,OAhmBb,EAgmBsB;AACjC,UAAMqG,kBAAkB,GAAG,KAAKa,sBAAL,CAA4BlH,OAA5B,CAA3B;;AACA,UAAMmH,iBAAiB,GAAG,KAAKiC,mBAAL,CAAyBzK,WAAzB,EAAsCqB,OAAtC,EAA+CqG,kBAA/C;AAAmE;AAAiE,WAApI,CAA1B;;AACA,UAAIc,iBAAJ,EAAuB;AACnB,eAAOA,iBAAiB,CAACE,WAAzB;AACH;;AACD,aAAO,KAAKgC,qBAAL,CAA2B1K,WAA3B,EAAwCqB,OAAxC,EAAiDqG,kBAAjD,CAAP;AACH;AAvmBc;AAAA;AAAA,0CAwmBO1H,WAxmBP,EAwmBoBqB,OAxmBpB,EAwmB6B0F,iBAxmB7B,EAwmBgD;AAC3D,aAAO1J,SAAS,CAAC,IAAD,EAAO,KAAK,CAAZ,EAAe,KAAK,CAApB,wCAAuB;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIrB,uBAAM,KAAKgM,uBAAL,CAA6BhI,OAA7B,CAAN;;AAJqB;AAI/B6F,gBAAAA,OAJ+B;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,kDAOxB,KAAKI,QAAL,eAAmBjG,OAAnB,CAPwB;;AAAA;AASnC;AACMmH,gBAAAA,iBAV6B,GAUT,KAAKiC,mBAAL,CAAyBzK,WAAzB,EAAsCqB,OAAtC,EAA+C0F,iBAA/C;AAAkE;AAAgE,oBAAlI,CAVS;;AAAA,qBAW/ByB,iBAX+B;AAAA;AAAA;AAAA;;AAY/BtB,gBAAAA,OAAO,CAACjB,OAAR;AAZ+B,kDAaxBuC,iBAAiB,CAACE,WAbM;;AAAA;AAAA,yDAeX3B,iBAAiB,CAACjD,UAfP;;AAAA;AAenC,4EAAsD;AAA3CyB,oBAAAA,SAA2C;AAClDA,oBAAAA,SAAS,CAACoF,WAAV,CAAsBtJ,OAAtB;AACH;AAjBkC;AAAA;AAAA;AAAA;AAAA;;AAAA,kDAkB5B,KAAKmI,oBAAL,CAA0BnI,OAA1B,EAAmC;AAAA,yBAAMA,OAAO,CAACvB,MAAR,CAAe8K,IAAf,EAAN;AAAA,iBAAnC,EAAgE7D,iBAAhE,EAAmFG,OAAnF,EAA4F;AAAA,yBAAM,MAAI,CAAC2D,oBAAL,CAA0BxJ,OAAO,CAACpB,OAAlC,CAAN;AAAA,iBAA5F,CAlB4B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAvB,EAAhB;AAoBH;AA7nBc;AAAA;AAAA,kCA8nBDsF,SA9nBC,EA8nBUlE,OA9nBV,EA8nBmB;AAAA;;AAC9B,UAAI,CAACA,OAAO,CAACV,OAAb,EAAsB;AAClB;AACA4E,QAAAA,SAAS,CAACoE,gBAAV;AACA;AACH;;AACD,UAAIpE,SAAS,CAACjD,MAAd,EAAsB;AAClB,YAAMqF,OAAO,GAAGnJ,GAAG,CAACiD,QAAJ,CAAa;AAAEpF,UAAAA,GAAG,EAAE,2CAAP;AAAoDqF,UAAAA,OAAO,EAAE,CAAC,kCAAD;AAA7D,SAAb,EAAkH,kFAAlH,EAAsML,OAAO,CAACd,KAA9M,CAAhB;;AACA,aAAK4D,oBAAL,CAA0B2D,IAA1B,CAA+BH,OAA/B;;AACA;AACH;;AACD,aAAO,KAAKiC,sBAAL,CAA4BvI,OAA5B,EAAqC,UAAC6F,OAAD,EAAa;AACrD3B,QAAAA,SAAS,CAACoF,WAAV,CAAsBtJ,OAAtB;AACA,eAAO,MAAI,CAACmI,oBAAL,CAA0BnI,OAA1B,EAAmC;AAAA,iBAAMA,OAAO,CAACvB,MAAR,CAAe8K,IAAf,EAAN;AAAA,SAAnC,EAAgE,IAAI/G,iBAAJ,CAAsB,CAAC0B,SAAD,CAAtB,CAAhE,EAAoG2B,OAApG,EAA6G;AAAA,iBAAM,MAAI,CAAC2D,oBAAL,CAA0BxJ,OAAO,CAACpB,OAAlC,CAAN;AAAA,SAA7G,CAAP;AACH,OAHM,CAAP;AAIH;AA7oBc;AAAA;AAAA,mDA8oBgBA,OA9oBhB,EA8oByB;AACpC,UAAI,CAACA,OAAL,EAAc;AACV,eAAO,CAAC,IAAD,EAAO,IAAP,CAAP;AACH,OAHmC,CAIpC;;;AACA,UAAIsG,cAAc,GAAG,IAArB;AACA,UAAIC,kBAAkB,GAAG,IAAzB;;AANoC,mDAOG,KAAKpC,WAPR;AAAA;;AAAA;AAOpC,kEAAyD;AAAA;AAAA,cAA7CpE,WAA6C;AAAA,cAAhCuF,SAAgC;;AACrD,cAAMkB,SAAS,GAAGlB,SAAS,CAAC4E,uBAAV,EAAlB;;AACA,cAAI,CAAC1D,SAAL,EAAgB;AACZ;AACH;;AACD,cAAIA,SAAS,CAACxG,OAAV,KAAsBA,OAA1B,EAAmC;AAC/B,gBAAI,CAACsG,cAAD,IAAmBE,SAAS,CAACvG,UAAV,GAAuBqG,cAAc,CAACrG,UAA7D,EAAyE;AACrEqG,cAAAA,cAAc,GAAGE,SAAjB;AACAD,cAAAA,kBAAkB,GAAGxG,WAArB;AACH;AACJ;AACJ;AAlBmC;AAAA;AAAA;AAAA;AAAA;;AAmBpC,aAAO,CAACuG,cAAD,EAAiBC,kBAAjB,CAAP;AACH;AAlqBc;AAAA;AAAA,yCAmqBMvG,OAnqBN,EAmqBe;AAC1B,UAAI,CAACA,OAAL,EAAc;AACV;AACH;;AAHyB,mCAIK,KAAK6K,8BAAL,CAAoC7K,OAApC,CAJL;AAAA;AAAA,UAIjBuG,kBAJiB;;AAK1B,UAAIA,kBAAJ,EAAwB;AACpB,eAAO,KAAK8D,KAAL,CAAW9D,kBAAX,CAAP;AACH;AACJ;AA3qBc;AAAA;AAAA,yBA4qBVE,gBA5qBU,EA4qBQ;AACnB,UAAIA,gBAAgB,YAAY9H,cAAhC,EAAgD;AAAA,qCACb,KAAKwL,iCAAL,CAAuC1D,gBAAgB,CAACrG,EAAxD,CADa;AAAA;AAAA,YACnCmG,kBADmC;;AAE5C,eAAOA,kBAAkB,GAAG,KAAK8D,KAAL,CAAW9D,kBAAX,CAAH,GAAoCsD,SAA7D;AACH;;AACD,UAAI,OAAOpD,gBAAP,KAA4B,QAAhC,EAA0C;AACtC,eAAO,KAAK4D,KAAL,CAAW5D,gBAAX,CAAP;AACH;;AACD,aAAO,KAAK4D,KAAL,CAAW,KAAKvF,mBAAL,CAAyB2B,gBAAzB,CAAX,CAAP;AACH;AArrBc;AAAA;AAAA,0BAsrBT1G,WAtrBS,EAsrBI;AACf,UAAI,CAAC,KAAKoE,WAAL,CAAiBxC,GAAjB,CAAqB5B,WAArB,CAAL,EAAwC;AACpC;AACH;;AACD,UAAMuF,SAAS,GAAG,KAAKnB,WAAL,CAAiBV,GAAjB,CAAqB1D,WAArB,CAAlB;;AACA,UAAMqB,OAAO,GAAGkE,SAAS,CAAC4E,uBAAV,EAAhB;;AACA,UAAI,CAAC9I,OAAL,EAAc;AACV;AACH;;AACD,UAAIA,OAAO,CAACpB,OAAZ,EAAqB;AACjB;AADiB,qCAE4B,KAAK6K,8BAAL,CAAoCzJ,OAAO,CAACpB,OAA5C,CAF5B;AAAA;AAAA,YAEVsG,cAFU;AAAA,YAEMC,kBAFN;;AAGjB,YAAInF,OAAO,KAAKkF,cAAZ,IAA8BC,kBAAlC,EAAsD;AAClD;AACA,iBAAO,KAAK8D,KAAL,CAAW9D,kBAAX,CAAP;AACH;AACJ;;AACD,UAAI;AACA,YAAInF,OAAO,CAACf,IAAR,KAAiB;AAAE;AAAvB,UAAwC;AACpC,mBAAO,KAAKyK,cAAL,CAAoB/K,WAApB,EAAiCqB,OAAjC,CAAP;AACH,WAFD,MAGK;AACD,iBAAO,KAAK2J,aAAL,CAAmBzF,SAAnB,EAA8BlE,OAA9B,CAAP;AACH;AACJ,OAPD,SAQQ;AACJ,YAAIhC,KAAJ,EAAW;AACP,eAAKiG,MAAL,CAAY,MAAZ;AACH;AACJ;AACJ;AAptBc;;AAAA;AAAA,GAAnB;;AAstBArB,eAAe,GAAG/H,UAAU,CAAC,CACzBgB,OAAO,CAAC,CAAD,EAAI6B,cAAJ,CADkB,EAEzB7B,OAAO,CAAC,CAAD,EAAIgC,oBAAJ,CAFkB,CAAD,EAGzB+E,eAHyB,CAA5B;AAIA,SAASA,eAAT;;IACM8D,0B,GACF,oCAAYW,WAAZ,EAAyB;AAAA;;AACrB,OAAKA,WAAL,GAAmBA,WAAnB;AACH,C;;AAEL5J,iBAAiB,CAACL,gBAAD,EAAmBwF,eAAnB,CAAjB","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport * as nls from '../../../nls.js';\r\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\r\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\r\nimport Severity from '../../../base/common/severity.js';\r\nimport { Schemas } from '../../../base/common/network.js';\r\nimport { INotificationService } from '../../notification/common/notification.js';\r\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\r\nconst DEBUG = false;\r\nfunction getResourceLabel(resource) {\r\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\r\n}\r\nlet stackElementCounter = 0;\r\nclass ResourceStackElement {\r\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\r\n        this.id = (++stackElementCounter);\r\n        this.type = 0 /* Resource */;\r\n        this.actual = actual;\r\n        this.label = actual.label;\r\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\r\n        this.resourceLabel = resourceLabel;\r\n        this.strResource = strResource;\r\n        this.resourceLabels = [this.resourceLabel];\r\n        this.strResources = [this.strResource];\r\n        this.groupId = groupId;\r\n        this.groupOrder = groupOrder;\r\n        this.sourceId = sourceId;\r\n        this.sourceOrder = sourceOrder;\r\n        this.isValid = true;\r\n    }\r\n    setValid(isValid) {\r\n        this.isValid = isValid;\r\n    }\r\n    toString() {\r\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\r\n    }\r\n}\r\nclass ResourceReasonPair {\r\n    constructor(resourceLabel, reason) {\r\n        this.resourceLabel = resourceLabel;\r\n        this.reason = reason;\r\n    }\r\n}\r\nclass RemovedResources {\r\n    constructor() {\r\n        this.elements = new Map();\r\n    }\r\n    createMessage() {\r\n        const externalRemoval = [];\r\n        const noParallelUniverses = [];\r\n        for (const [, element] of this.elements) {\r\n            const dest = (element.reason === 0 /* ExternalRemoval */\r\n                ? externalRemoval\r\n                : noParallelUniverses);\r\n            dest.push(element.resourceLabel);\r\n        }\r\n        let messages = [];\r\n        if (externalRemoval.length > 0) {\r\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\r\n        }\r\n        if (noParallelUniverses.length > 0) {\r\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\r\n        }\r\n        return messages.join('\\n');\r\n    }\r\n    get size() {\r\n        return this.elements.size;\r\n    }\r\n    has(strResource) {\r\n        return this.elements.has(strResource);\r\n    }\r\n    set(strResource, value) {\r\n        this.elements.set(strResource, value);\r\n    }\r\n    delete(strResource) {\r\n        return this.elements.delete(strResource);\r\n    }\r\n}\r\nclass WorkspaceStackElement {\r\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\r\n        this.id = (++stackElementCounter);\r\n        this.type = 1 /* Workspace */;\r\n        this.actual = actual;\r\n        this.label = actual.label;\r\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\r\n        this.resourceLabels = resourceLabels;\r\n        this.strResources = strResources;\r\n        this.groupId = groupId;\r\n        this.groupOrder = groupOrder;\r\n        this.sourceId = sourceId;\r\n        this.sourceOrder = sourceOrder;\r\n        this.removedResources = null;\r\n        this.invalidatedResources = null;\r\n    }\r\n    canSplit() {\r\n        return (typeof this.actual.split === 'function');\r\n    }\r\n    removeResource(resourceLabel, strResource, reason) {\r\n        if (!this.removedResources) {\r\n            this.removedResources = new RemovedResources();\r\n        }\r\n        if (!this.removedResources.has(strResource)) {\r\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\r\n        }\r\n    }\r\n    setValid(resourceLabel, strResource, isValid) {\r\n        if (isValid) {\r\n            if (this.invalidatedResources) {\r\n                this.invalidatedResources.delete(strResource);\r\n                if (this.invalidatedResources.size === 0) {\r\n                    this.invalidatedResources = null;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (!this.invalidatedResources) {\r\n                this.invalidatedResources = new RemovedResources();\r\n            }\r\n            if (!this.invalidatedResources.has(strResource)) {\r\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* ExternalRemoval */));\r\n            }\r\n        }\r\n    }\r\n    toString() {\r\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\r\n    }\r\n}\r\nclass ResourceEditStack {\r\n    constructor(resourceLabel, strResource) {\r\n        this.resourceLabel = resourceLabel;\r\n        this.strResource = strResource;\r\n        this._past = [];\r\n        this._future = [];\r\n        this.locked = false;\r\n        this.versionId = 1;\r\n    }\r\n    dispose() {\r\n        for (const element of this._past) {\r\n            if (element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        for (const element of this._future) {\r\n            if (element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    toString() {\r\n        let result = [];\r\n        result.push(`* ${this.strResource}:`);\r\n        for (let i = 0; i < this._past.length; i++) {\r\n            result.push(`   * [UNDO] ${this._past[i]}`);\r\n        }\r\n        for (let i = this._future.length - 1; i >= 0; i--) {\r\n            result.push(`   * [REDO] ${this._future[i]}`);\r\n        }\r\n        return result.join('\\n');\r\n    }\r\n    flushAllElements() {\r\n        this._past = [];\r\n        this._future = [];\r\n        this.versionId++;\r\n    }\r\n    _setElementValidFlag(element, isValid) {\r\n        if (element.type === 1 /* Workspace */) {\r\n            element.setValid(this.resourceLabel, this.strResource, isValid);\r\n        }\r\n        else {\r\n            element.setValid(isValid);\r\n        }\r\n    }\r\n    setElementsValidFlag(isValid, filter) {\r\n        for (const element of this._past) {\r\n            if (filter(element.actual)) {\r\n                this._setElementValidFlag(element, isValid);\r\n            }\r\n        }\r\n        for (const element of this._future) {\r\n            if (filter(element.actual)) {\r\n                this._setElementValidFlag(element, isValid);\r\n            }\r\n        }\r\n    }\r\n    pushElement(element) {\r\n        // remove the future\r\n        for (const futureElement of this._future) {\r\n            if (futureElement.type === 1 /* Workspace */) {\r\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* NoParallelUniverses */);\r\n            }\r\n        }\r\n        this._future = [];\r\n        this._past.push(element);\r\n        this.versionId++;\r\n    }\r\n    createSnapshot(resource) {\r\n        const elements = [];\r\n        for (let i = 0, len = this._past.length; i < len; i++) {\r\n            elements.push(this._past[i].id);\r\n        }\r\n        for (let i = this._future.length - 1; i >= 0; i--) {\r\n            elements.push(this._future[i].id);\r\n        }\r\n        return new ResourceEditStackSnapshot(resource, elements);\r\n    }\r\n    restoreSnapshot(snapshot) {\r\n        const snapshotLength = snapshot.elements.length;\r\n        let isOK = true;\r\n        let snapshotIndex = 0;\r\n        let removePastAfter = -1;\r\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\r\n            const element = this._past[i];\r\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\r\n                isOK = false;\r\n                removePastAfter = 0;\r\n            }\r\n            if (!isOK && element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        let removeFutureBefore = -1;\r\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\r\n            const element = this._future[i];\r\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\r\n                isOK = false;\r\n                removeFutureBefore = i;\r\n            }\r\n            if (!isOK && element.type === 1 /* Workspace */) {\r\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* ExternalRemoval */);\r\n            }\r\n        }\r\n        if (removePastAfter !== -1) {\r\n            this._past = this._past.slice(0, removePastAfter);\r\n        }\r\n        if (removeFutureBefore !== -1) {\r\n            this._future = this._future.slice(removeFutureBefore + 1);\r\n        }\r\n        this.versionId++;\r\n    }\r\n    getElements() {\r\n        const past = [];\r\n        const future = [];\r\n        for (const element of this._past) {\r\n            past.push(element.actual);\r\n        }\r\n        for (const element of this._future) {\r\n            future.push(element.actual);\r\n        }\r\n        return { past, future };\r\n    }\r\n    getClosestPastElement() {\r\n        if (this._past.length === 0) {\r\n            return null;\r\n        }\r\n        return this._past[this._past.length - 1];\r\n    }\r\n    getSecondClosestPastElement() {\r\n        if (this._past.length < 2) {\r\n            return null;\r\n        }\r\n        return this._past[this._past.length - 2];\r\n    }\r\n    getClosestFutureElement() {\r\n        if (this._future.length === 0) {\r\n            return null;\r\n        }\r\n        return this._future[this._future.length - 1];\r\n    }\r\n    hasPastElements() {\r\n        return (this._past.length > 0);\r\n    }\r\n    hasFutureElements() {\r\n        return (this._future.length > 0);\r\n    }\r\n    splitPastWorkspaceElement(toRemove, individualMap) {\r\n        for (let j = this._past.length - 1; j >= 0; j--) {\r\n            if (this._past[j] === toRemove) {\r\n                if (individualMap.has(this.strResource)) {\r\n                    // gets replaced\r\n                    this._past[j] = individualMap.get(this.strResource);\r\n                }\r\n                else {\r\n                    // gets deleted\r\n                    this._past.splice(j, 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    splitFutureWorkspaceElement(toRemove, individualMap) {\r\n        for (let j = this._future.length - 1; j >= 0; j--) {\r\n            if (this._future[j] === toRemove) {\r\n                if (individualMap.has(this.strResource)) {\r\n                    // gets replaced\r\n                    this._future[j] = individualMap.get(this.strResource);\r\n                }\r\n                else {\r\n                    // gets deleted\r\n                    this._future.splice(j, 1);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        this.versionId++;\r\n    }\r\n    moveBackward(element) {\r\n        this._past.pop();\r\n        this._future.push(element);\r\n        this.versionId++;\r\n    }\r\n    moveForward(element) {\r\n        this._future.pop();\r\n        this._past.push(element);\r\n        this.versionId++;\r\n    }\r\n}\r\nclass EditStackSnapshot {\r\n    constructor(editStacks) {\r\n        this.editStacks = editStacks;\r\n        this._versionIds = [];\r\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\r\n            this._versionIds[i] = this.editStacks[i].versionId;\r\n        }\r\n    }\r\n    isValid() {\r\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\r\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nconst missingEditStack = new ResourceEditStack('', '');\r\nmissingEditStack.locked = true;\r\nlet UndoRedoService = class UndoRedoService {\r\n    constructor(_dialogService, _notificationService) {\r\n        this._dialogService = _dialogService;\r\n        this._notificationService = _notificationService;\r\n        this._editStacks = new Map();\r\n        this._uriComparisonKeyComputers = [];\r\n    }\r\n    getUriComparisonKey(resource) {\r\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\r\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\r\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\r\n            }\r\n        }\r\n        return resource.toString();\r\n    }\r\n    _print(label) {\r\n        console.log(`------------------------------------`);\r\n        console.log(`AFTER ${label}: `);\r\n        let str = [];\r\n        for (const element of this._editStacks) {\r\n            str.push(element[1].toString());\r\n        }\r\n        console.log(str.join('\\n'));\r\n    }\r\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\r\n        if (element.type === 0 /* Resource */) {\r\n            const resourceLabel = getResourceLabel(element.resource);\r\n            const strResource = this.getUriComparisonKey(element.resource);\r\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n        }\r\n        else {\r\n            const seen = new Set();\r\n            const resourceLabels = [];\r\n            const strResources = [];\r\n            for (const resource of element.resources) {\r\n                const resourceLabel = getResourceLabel(resource);\r\n                const strResource = this.getUriComparisonKey(resource);\r\n                if (seen.has(strResource)) {\r\n                    continue;\r\n                }\r\n                seen.add(strResource);\r\n                resourceLabels.push(resourceLabel);\r\n                strResources.push(strResource);\r\n            }\r\n            if (resourceLabels.length === 1) {\r\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n            }\r\n            else {\r\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            this._print('pushElement');\r\n        }\r\n    }\r\n    _pushElement(element) {\r\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\r\n            const resourceLabel = element.resourceLabels[i];\r\n            const strResource = element.strResources[i];\r\n            let editStack;\r\n            if (this._editStacks.has(strResource)) {\r\n                editStack = this._editStacks.get(strResource);\r\n            }\r\n            else {\r\n                editStack = new ResourceEditStack(resourceLabel, strResource);\r\n                this._editStacks.set(strResource, editStack);\r\n            }\r\n            editStack.pushElement(element);\r\n        }\r\n    }\r\n    getLastElement(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            if (editStack.hasFutureElements()) {\r\n                return null;\r\n            }\r\n            const closestPastElement = editStack.getClosestPastElement();\r\n            return closestPastElement ? closestPastElement.actual : null;\r\n        }\r\n        return null;\r\n    }\r\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\r\n        const individualArr = toRemove.actual.split();\r\n        const individualMap = new Map();\r\n        for (const _element of individualArr) {\r\n            const resourceLabel = getResourceLabel(_element.resource);\r\n            const strResource = this.getUriComparisonKey(_element.resource);\r\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\r\n            individualMap.set(element.strResource, element);\r\n        }\r\n        for (const strResource of toRemove.strResources) {\r\n            if (ignoreResources && ignoreResources.has(strResource)) {\r\n                continue;\r\n            }\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\r\n        }\r\n    }\r\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\r\n        const individualArr = toRemove.actual.split();\r\n        const individualMap = new Map();\r\n        for (const _element of individualArr) {\r\n            const resourceLabel = getResourceLabel(_element.resource);\r\n            const strResource = this.getUriComparisonKey(_element.resource);\r\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\r\n            individualMap.set(element.strResource, element);\r\n        }\r\n        for (const strResource of toRemove.strResources) {\r\n            if (ignoreResources && ignoreResources.has(strResource)) {\r\n                continue;\r\n            }\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\r\n        }\r\n    }\r\n    removeElements(resource) {\r\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.dispose();\r\n            this._editStacks.delete(strResource);\r\n        }\r\n        if (DEBUG) {\r\n            this._print('removeElements');\r\n        }\r\n    }\r\n    setElementsValidFlag(resource, isValid, filter) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.setElementsValidFlag(isValid, filter);\r\n        }\r\n        if (DEBUG) {\r\n            this._print('setElementsValidFlag');\r\n        }\r\n    }\r\n    createSnapshot(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.createSnapshot(resource);\r\n        }\r\n        return new ResourceEditStackSnapshot(resource, []);\r\n    }\r\n    restoreSnapshot(snapshot) {\r\n        const strResource = this.getUriComparisonKey(snapshot.resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            editStack.restoreSnapshot(snapshot);\r\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\r\n                // the edit stack is now empty, just remove it entirely\r\n                editStack.dispose();\r\n                this._editStacks.delete(strResource);\r\n            }\r\n        }\r\n        if (DEBUG) {\r\n            this._print('restoreSnapshot');\r\n        }\r\n    }\r\n    getElements(resource) {\r\n        const strResource = this.getUriComparisonKey(resource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.getElements();\r\n        }\r\n        return { past: [], future: [] };\r\n    }\r\n    _findClosestUndoElementWithSource(sourceId) {\r\n        if (!sourceId) {\r\n            return [null, null];\r\n        }\r\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestPastElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.sourceId === sourceId) {\r\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    canUndo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? true : false;\r\n        }\r\n        const strResource = this.getUriComparisonKey(resourceOrSource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.hasPastElements();\r\n        }\r\n        return false;\r\n    }\r\n    _onError(err, element) {\r\n        onUnexpectedError(err);\r\n        // An error occured while undoing or redoing => drop the undo/redo stack for all affected resources\r\n        for (const strResource of element.strResources) {\r\n            this.removeElements(strResource);\r\n        }\r\n        this._notificationService.error(err);\r\n    }\r\n    _acquireLocks(editStackSnapshot) {\r\n        // first, check if all locks can be acquired\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                throw new Error('Cannot acquire edit stack lock');\r\n            }\r\n        }\r\n        // can acquire all locks\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            editStack.locked = true;\r\n        }\r\n        return () => {\r\n            // release all locks\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.locked = false;\r\n            }\r\n        };\r\n    }\r\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\r\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\r\n        let result;\r\n        try {\r\n            result = invoke();\r\n        }\r\n        catch (err) {\r\n            releaseLocks();\r\n            cleanup.dispose();\r\n            return this._onError(err, element);\r\n        }\r\n        if (result) {\r\n            // result is Promise<void>\r\n            return result.then(() => {\r\n                releaseLocks();\r\n                cleanup.dispose();\r\n                return continuation();\r\n            }, (err) => {\r\n                releaseLocks();\r\n                cleanup.dispose();\r\n                return this._onError(err, element);\r\n            });\r\n        }\r\n        else {\r\n            // result is void\r\n            releaseLocks();\r\n            cleanup.dispose();\r\n            return continuation();\r\n        }\r\n    }\r\n    _invokeWorkspacePrepare(element) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (typeof element.actual.prepareUndoRedo === 'undefined') {\r\n                return Disposable.None;\r\n            }\r\n            const result = element.actual.prepareUndoRedo();\r\n            if (typeof result === 'undefined') {\r\n                return Disposable.None;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    _invokeResourcePrepare(element, callback) {\r\n        if (element.actual.type !== 1 /* Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\r\n            // no preparation needed\r\n            return callback(Disposable.None);\r\n        }\r\n        const r = element.actual.prepareUndoRedo();\r\n        if (!r) {\r\n            // nothing to clean up\r\n            return callback(Disposable.None);\r\n        }\r\n        if (isDisposable(r)) {\r\n            return callback(r);\r\n        }\r\n        return r.then((disposable) => {\r\n            return callback(disposable);\r\n        });\r\n    }\r\n    _getAffectedEditStacks(element) {\r\n        const affectedEditStacks = [];\r\n        for (const strResource of element.strResources) {\r\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\r\n        }\r\n        return new EditStackSnapshot(affectedEditStacks);\r\n    }\r\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\r\n        if (element.canSplit()) {\r\n            this._splitPastWorkspaceElement(element, ignoreResources);\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\r\n        }\r\n        else {\r\n            // Cannot safely split this workspace element => flush all undo/redo stacks\r\n            for (const strResource of element.strResources) {\r\n                this.removeElements(strResource);\r\n            }\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError();\r\n        }\r\n    }\r\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\r\n        if (element.removedResources) {\r\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\r\n        }\r\n        if (checkInvalidatedResources && element.invalidatedResources) {\r\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\r\n        }\r\n        // this must be the last past element in all the impacted resources!\r\n        const cannotUndoDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.getClosestPastElement() !== element) {\r\n                cannotUndoDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotUndoDueToResources.length > 0) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\r\n        }\r\n        const cannotLockDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                cannotLockDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotLockDueToResources.length > 0) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\r\n        }\r\n        // check if new stack elements were added in the meantime...\r\n        if (!editStackSnapshot.isValid()) {\r\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\r\n        }\r\n        return null;\r\n    }\r\n    _workspaceUndo(strResource, element, undoConfirmed) {\r\n        const affectedEditStacks = this._getAffectedEditStacks(element);\r\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\r\n        if (verificationError) {\r\n            return verificationError.returnValue;\r\n        }\r\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\r\n    }\r\n    _isPartOfUndoGroup(element) {\r\n        if (!element.groupId) {\r\n            return false;\r\n        }\r\n        // check that there is at least another element with the same groupId ready to be undone\r\n        for (const [, editStack] of this._editStacks) {\r\n            const pastElement = editStack.getClosestPastElement();\r\n            if (!pastElement) {\r\n                continue;\r\n            }\r\n            if (pastElement === element) {\r\n                const secondPastElement = editStack.getSecondClosestPastElement();\r\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\r\n                    // there is another element with the same group id in the same stack!\r\n                    return true;\r\n                }\r\n            }\r\n            if (pastElement.groupId === element.groupId) {\r\n                // there is another element with the same group id in another stack!\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\r\n                // this element can be split\r\n                const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label), [\r\n                    nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1'] }, \"Undo in {0} Files\", editStackSnapshot.editStacks.length),\r\n                    nls.localize('nok', \"Undo this File\"),\r\n                    nls.localize('cancel', \"Cancel\"),\r\n                ], {\r\n                    cancelId: 2\r\n                });\r\n                if (result.choice === 2) {\r\n                    // choice: cancel\r\n                    return;\r\n                }\r\n                if (result.choice === 1) {\r\n                    // choice: undo this file\r\n                    this._splitPastWorkspaceElement(element, null);\r\n                    return this._undo(strResource, 0, true);\r\n                }\r\n                // choice: undo in all files\r\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\r\n                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\r\n                if (verificationError1) {\r\n                    return verificationError1.returnValue;\r\n                }\r\n                undoConfirmed = true;\r\n            }\r\n            // prepare\r\n            let cleanup;\r\n            try {\r\n                cleanup = yield this._invokeWorkspacePrepare(element);\r\n            }\r\n            catch (err) {\r\n                return this._onError(err, element);\r\n            }\r\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\r\n            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\r\n            if (verificationError2) {\r\n                cleanup.dispose();\r\n                return verificationError2.returnValue;\r\n            }\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.moveBackward(element);\r\n            }\r\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\r\n        });\r\n    }\r\n    _resourceUndo(editStack, element, undoConfirmed) {\r\n        if (!element.isValid) {\r\n            // invalid element => immediately flush edit stack!\r\n            editStack.flushAllElements();\r\n            return;\r\n        }\r\n        if (editStack.locked) {\r\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\r\n            this._notificationService.info(message);\r\n            return;\r\n        }\r\n        return this._invokeResourcePrepare(element, (cleanup) => {\r\n            editStack.moveBackward(element);\r\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\r\n        });\r\n    }\r\n    _findClosestUndoElementInGroup(groupId) {\r\n        if (!groupId) {\r\n            return [null, null];\r\n        }\r\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestPastElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.groupId === groupId) {\r\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    _continueUndoInGroup(groupId, undoConfirmed) {\r\n        if (!groupId) {\r\n            return;\r\n        }\r\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\r\n        if (matchedStrResource) {\r\n            return this._undo(matchedStrResource, 0, undoConfirmed);\r\n        }\r\n    }\r\n    undo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\r\n        }\r\n        if (typeof resourceOrSource === 'string') {\r\n            return this._undo(resourceOrSource, 0, false);\r\n        }\r\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\r\n    }\r\n    _undo(strResource, sourceId = 0, undoConfirmed) {\r\n        if (!this._editStacks.has(strResource)) {\r\n            return;\r\n        }\r\n        const editStack = this._editStacks.get(strResource);\r\n        const element = editStack.getClosestPastElement();\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (element.groupId) {\r\n            // this element is a part of a group, we need to make sure undoing in a group is in order\r\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\r\n            if (element !== matchedElement && matchedStrResource) {\r\n                // there is an element in the same group that should be undone before this one\r\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\r\n            }\r\n        }\r\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\r\n        if (shouldPromptForConfirmation && !undoConfirmed) {\r\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\r\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\r\n        }\r\n        try {\r\n            if (element.type === 1 /* Workspace */) {\r\n                return this._workspaceUndo(strResource, element, undoConfirmed);\r\n            }\r\n            else {\r\n                return this._resourceUndo(editStack, element, undoConfirmed);\r\n            }\r\n        }\r\n        finally {\r\n            if (DEBUG) {\r\n                this._print('undo');\r\n            }\r\n        }\r\n    }\r\n    _confirmAndContinueUndo(strResource, sourceId, element) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = yield this._dialogService.show(Severity.Info, nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label), [\r\n                nls.localize('confirmDifferentSource.ok', \"Undo\"),\r\n                nls.localize('cancel', \"Cancel\"),\r\n            ], {\r\n                cancelId: 1\r\n            });\r\n            if (result.choice === 1) {\r\n                // choice: cancel\r\n                return;\r\n            }\r\n            // choice: undo\r\n            return this._undo(strResource, sourceId, true);\r\n        });\r\n    }\r\n    _findClosestRedoElementWithSource(sourceId) {\r\n        if (!sourceId) {\r\n            return [null, null];\r\n        }\r\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestFutureElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.sourceId === sourceId) {\r\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    canRedo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? true : false;\r\n        }\r\n        const strResource = this.getUriComparisonKey(resourceOrSource);\r\n        if (this._editStacks.has(strResource)) {\r\n            const editStack = this._editStacks.get(strResource);\r\n            return editStack.hasFutureElements();\r\n        }\r\n        return false;\r\n    }\r\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\r\n        if (element.canSplit()) {\r\n            this._splitFutureWorkspaceElement(element, ignoreResources);\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError(this._redo(strResource));\r\n        }\r\n        else {\r\n            // Cannot safely split this workspace element => flush all undo/redo stacks\r\n            for (const strResource of element.strResources) {\r\n                this.removeElements(strResource);\r\n            }\r\n            this._notificationService.info(message);\r\n            return new WorkspaceVerificationError();\r\n        }\r\n    }\r\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\r\n        if (element.removedResources) {\r\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\r\n        }\r\n        if (checkInvalidatedResources && element.invalidatedResources) {\r\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\r\n        }\r\n        // this must be the last future element in all the impacted resources!\r\n        const cannotRedoDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.getClosestFutureElement() !== element) {\r\n                cannotRedoDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotRedoDueToResources.length > 0) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\r\n        }\r\n        const cannotLockDueToResources = [];\r\n        for (const editStack of editStackSnapshot.editStacks) {\r\n            if (editStack.locked) {\r\n                cannotLockDueToResources.push(editStack.resourceLabel);\r\n            }\r\n        }\r\n        if (cannotLockDueToResources.length > 0) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\r\n        }\r\n        // check if new stack elements were added in the meantime...\r\n        if (!editStackSnapshot.isValid()) {\r\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\r\n        }\r\n        return null;\r\n    }\r\n    _workspaceRedo(strResource, element) {\r\n        const affectedEditStacks = this._getAffectedEditStacks(element);\r\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\r\n        if (verificationError) {\r\n            return verificationError.returnValue;\r\n        }\r\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\r\n    }\r\n    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // prepare\r\n            let cleanup;\r\n            try {\r\n                cleanup = yield this._invokeWorkspacePrepare(element);\r\n            }\r\n            catch (err) {\r\n                return this._onError(err, element);\r\n            }\r\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\r\n            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\r\n            if (verificationError) {\r\n                cleanup.dispose();\r\n                return verificationError.returnValue;\r\n            }\r\n            for (const editStack of editStackSnapshot.editStacks) {\r\n                editStack.moveForward(element);\r\n            }\r\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\r\n        });\r\n    }\r\n    _resourceRedo(editStack, element) {\r\n        if (!element.isValid) {\r\n            // invalid element => immediately flush edit stack!\r\n            editStack.flushAllElements();\r\n            return;\r\n        }\r\n        if (editStack.locked) {\r\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\r\n            this._notificationService.info(message);\r\n            return;\r\n        }\r\n        return this._invokeResourcePrepare(element, (cleanup) => {\r\n            editStack.moveForward(element);\r\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\r\n        });\r\n    }\r\n    _findClosestRedoElementInGroup(groupId) {\r\n        if (!groupId) {\r\n            return [null, null];\r\n        }\r\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\r\n        let matchedElement = null;\r\n        let matchedStrResource = null;\r\n        for (const [strResource, editStack] of this._editStacks) {\r\n            const candidate = editStack.getClosestFutureElement();\r\n            if (!candidate) {\r\n                continue;\r\n            }\r\n            if (candidate.groupId === groupId) {\r\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\r\n                    matchedElement = candidate;\r\n                    matchedStrResource = strResource;\r\n                }\r\n            }\r\n        }\r\n        return [matchedElement, matchedStrResource];\r\n    }\r\n    _continueRedoInGroup(groupId) {\r\n        if (!groupId) {\r\n            return;\r\n        }\r\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\r\n        if (matchedStrResource) {\r\n            return this._redo(matchedStrResource);\r\n        }\r\n    }\r\n    redo(resourceOrSource) {\r\n        if (resourceOrSource instanceof UndoRedoSource) {\r\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\r\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\r\n        }\r\n        if (typeof resourceOrSource === 'string') {\r\n            return this._redo(resourceOrSource);\r\n        }\r\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\r\n    }\r\n    _redo(strResource) {\r\n        if (!this._editStacks.has(strResource)) {\r\n            return;\r\n        }\r\n        const editStack = this._editStacks.get(strResource);\r\n        const element = editStack.getClosestFutureElement();\r\n        if (!element) {\r\n            return;\r\n        }\r\n        if (element.groupId) {\r\n            // this element is a part of a group, we need to make sure redoing in a group is in order\r\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\r\n            if (element !== matchedElement && matchedStrResource) {\r\n                // there is an element in the same group that should be redone before this one\r\n                return this._redo(matchedStrResource);\r\n            }\r\n        }\r\n        try {\r\n            if (element.type === 1 /* Workspace */) {\r\n                return this._workspaceRedo(strResource, element);\r\n            }\r\n            else {\r\n                return this._resourceRedo(editStack, element);\r\n            }\r\n        }\r\n        finally {\r\n            if (DEBUG) {\r\n                this._print('redo');\r\n            }\r\n        }\r\n    }\r\n};\r\nUndoRedoService = __decorate([\r\n    __param(0, IDialogService),\r\n    __param(1, INotificationService)\r\n], UndoRedoService);\r\nexport { UndoRedoService };\r\nclass WorkspaceVerificationError {\r\n    constructor(returnValue) {\r\n        this.returnValue = returnValue;\r\n    }\r\n}\r\nregisterSingleton(IUndoRedoService, UndoRedoService);\r\n"]},"metadata":{},"sourceType":"module"}