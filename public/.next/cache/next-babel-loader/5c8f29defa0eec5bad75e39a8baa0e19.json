{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nexport var DeleteOperations = /*#__PURE__*/function () {\n  function DeleteOperations() {\n    _classCallCheck(this, DeleteOperations);\n  }\n\n  _createClass(DeleteOperations, null, [{\n    key: \"deleteRight\",\n    value: function deleteRight(prevEditOperationType, config, model, selections) {\n      var commands = [];\n      var shouldPushStackElementBefore = prevEditOperationType !== 3\n      /* DeletingRight */\n      ;\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var deleteSelection = selection;\n\n        if (deleteSelection.isEmpty()) {\n          var position = selection.getPosition();\n          var rightOfPosition = MoveOperations.right(config, model, position.lineNumber, position.column);\n          deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n        }\n\n        if (deleteSelection.isEmpty()) {\n          // Probably at end of file => ignore\n          commands[i] = null;\n          continue;\n        }\n\n        if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n          shouldPushStackElementBefore = true;\n        }\n\n        commands[i] = new ReplaceCommand(deleteSelection, '');\n      }\n\n      return [shouldPushStackElementBefore, commands];\n    }\n  }, {\n    key: \"isAutoClosingPairDelete\",\n    value: function isAutoClosingPairDelete(autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections) {\n      if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n        return false;\n      }\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var position = selection.getPosition();\n\n        if (!selection.isEmpty()) {\n          return false;\n        }\n\n        var lineText = model.getLineContent(position.lineNumber);\n\n        if (position.column < 2 || position.column >= lineText.length + 1) {\n          return false;\n        }\n\n        var character = lineText.charAt(position.column - 2);\n        var autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n\n        if (!autoClosingPairCandidates) {\n          return false;\n        }\n\n        if (isQuote(character)) {\n          if (autoClosingQuotes === 'never') {\n            return false;\n          }\n        } else {\n          if (autoClosingBrackets === 'never') {\n            return false;\n          }\n        }\n\n        var afterCharacter = lineText.charAt(position.column - 1);\n        var foundAutoClosingPair = false;\n\n        var _iterator = _createForOfIteratorHelper(autoClosingPairCandidates),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var autoClosingPairCandidate = _step.value;\n\n            if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n              foundAutoClosingPair = true;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!foundAutoClosingPair) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_runAutoClosingPairDelete\",\n    value: function _runAutoClosingPairDelete(config, model, selections) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var position = selections[i].getPosition();\n        var deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        commands[i] = new ReplaceCommand(deleteSelection, '');\n      }\n\n      return [true, commands];\n    }\n  }, {\n    key: \"deleteLeft\",\n    value: function deleteLeft(prevEditOperationType, config, model, selections) {\n      if (this.isAutoClosingPairDelete(config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections)) {\n        return this._runAutoClosingPairDelete(config, model, selections);\n      }\n\n      var commands = [];\n      var shouldPushStackElementBefore = prevEditOperationType !== 2\n      /* DeletingLeft */\n      ;\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        var deleteSelection = selection;\n\n        if (deleteSelection.isEmpty()) {\n          var position = selection.getPosition();\n\n          if (config.useTabStops && position.column > 1) {\n            var lineContent = model.getLineContent(position.lineNumber);\n            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            var lastIndentationColumn = firstNonWhitespaceIndex === -1 ?\n            /* entire string is whitespace */\n            lineContent.length + 1 : firstNonWhitespaceIndex + 1;\n\n            if (position.column <= lastIndentationColumn) {\n              var fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\n              var toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n              var toColumn = CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);\n              deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            } else {\n              deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);\n            }\n          } else {\n            var leftOfPosition = MoveOperations.left(config, model, position.lineNumber, position.column);\n            deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);\n          }\n        }\n\n        if (deleteSelection.isEmpty()) {\n          // Probably at beginning of file => ignore\n          commands[i] = null;\n          continue;\n        }\n\n        if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n          shouldPushStackElementBefore = true;\n        }\n\n        commands[i] = new ReplaceCommand(deleteSelection, '');\n      }\n\n      return [shouldPushStackElementBefore, commands];\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(config, model, selections) {\n      var commands = [];\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n\n        if (selection.isEmpty()) {\n          if (config.emptySelectionClipboard) {\n            // This is a full line cut\n            var position = selection.getPosition();\n            var startLineNumber = void 0,\n                startColumn = void 0,\n                endLineNumber = void 0,\n                endColumn = void 0;\n\n            if (position.lineNumber < model.getLineCount()) {\n              // Cutting a line in the middle of the model\n              startLineNumber = position.lineNumber;\n              startColumn = 1;\n              endLineNumber = position.lineNumber + 1;\n              endColumn = 1;\n            } else if (position.lineNumber > 1) {\n              // Cutting the last line & there are more than 1 lines in the model\n              startLineNumber = position.lineNumber - 1;\n              startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n              endLineNumber = position.lineNumber;\n              endColumn = model.getLineMaxColumn(position.lineNumber);\n            } else {\n              // Cutting the single line that the model contains\n              startLineNumber = position.lineNumber;\n              startColumn = 1;\n              endLineNumber = position.lineNumber;\n              endColumn = model.getLineMaxColumn(position.lineNumber);\n            }\n\n            var deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\n            if (!deleteSelection.isEmpty()) {\n              commands[i] = new ReplaceCommand(deleteSelection, '');\n            } else {\n              commands[i] = null;\n            }\n          } else {\n            // Cannot cut empty selection\n            commands[i] = null;\n          }\n        } else {\n          commands[i] = new ReplaceCommand(selection, '');\n        }\n      }\n\n      return new EditOperationResult(0\n      /* Other */\n      , commands, {\n        shouldPushStackElementBefore: true,\n        shouldPushStackElementAfter: true\n      });\n    }\n  }]);\n\n  return DeleteOperations;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorDeleteOperations.js"],"names":["strings","ReplaceCommand","CursorColumns","EditOperationResult","isQuote","MoveOperations","Range","DeleteOperations","prevEditOperationType","config","model","selections","commands","shouldPushStackElementBefore","i","len","length","selection","deleteSelection","isEmpty","position","getPosition","rightOfPosition","right","lineNumber","column","startLineNumber","endLineNumber","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","getLineContent","character","charAt","autoClosingPairCandidates","get","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","open","close","isAutoClosingPairDelete","autoClosingPairs","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","useTabStops","lineContent","firstNonWhitespaceIndex","lastIndentationColumn","fromVisibleColumn","visibleColumnFromColumn2","toVisibleColumn","prevIndentTabStop","indentSize","toColumn","columnFromVisibleColumn2","leftOfPosition","left","emptySelectionClipboard","startColumn","endColumn","getLineCount","getLineMaxColumn","shouldPushStackElementAfter"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\r\nimport { CursorColumns, EditOperationResult, isQuote } from './cursorCommon.js';\r\nimport { MoveOperations } from './cursorMoveOperations.js';\r\nimport { Range } from '../core/range.js';\r\nexport class DeleteOperations {\r\n    static deleteRight(prevEditOperationType, config, model, selections) {\r\n        let commands = [];\r\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* DeletingRight */);\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            let deleteSelection = selection;\r\n            if (deleteSelection.isEmpty()) {\r\n                let position = selection.getPosition();\r\n                let rightOfPosition = MoveOperations.right(config, model, position.lineNumber, position.column);\r\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\r\n            }\r\n            if (deleteSelection.isEmpty()) {\r\n                // Probably at end of file => ignore\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\r\n                shouldPushStackElementBefore = true;\r\n            }\r\n            commands[i] = new ReplaceCommand(deleteSelection, '');\r\n        }\r\n        return [shouldPushStackElementBefore, commands];\r\n    }\r\n    static isAutoClosingPairDelete(autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections) {\r\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            const position = selection.getPosition();\r\n            if (!selection.isEmpty()) {\r\n                return false;\r\n            }\r\n            const lineText = model.getLineContent(position.lineNumber);\r\n            if (position.column < 2 || position.column >= lineText.length + 1) {\r\n                return false;\r\n            }\r\n            const character = lineText.charAt(position.column - 2);\r\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\r\n            if (!autoClosingPairCandidates) {\r\n                return false;\r\n            }\r\n            if (isQuote(character)) {\r\n                if (autoClosingQuotes === 'never') {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                if (autoClosingBrackets === 'never') {\r\n                    return false;\r\n                }\r\n            }\r\n            const afterCharacter = lineText.charAt(position.column - 1);\r\n            let foundAutoClosingPair = false;\r\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\r\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\r\n                    foundAutoClosingPair = true;\r\n                }\r\n            }\r\n            if (!foundAutoClosingPair) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _runAutoClosingPairDelete(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const position = selections[i].getPosition();\r\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\r\n            commands[i] = new ReplaceCommand(deleteSelection, '');\r\n        }\r\n        return [true, commands];\r\n    }\r\n    static deleteLeft(prevEditOperationType, config, model, selections) {\r\n        if (this.isAutoClosingPairDelete(config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections)) {\r\n            return this._runAutoClosingPairDelete(config, model, selections);\r\n        }\r\n        let commands = [];\r\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* DeletingLeft */);\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            let deleteSelection = selection;\r\n            if (deleteSelection.isEmpty()) {\r\n                let position = selection.getPosition();\r\n                if (config.useTabStops && position.column > 1) {\r\n                    let lineContent = model.getLineContent(position.lineNumber);\r\n                    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\r\n                    let lastIndentationColumn = (firstNonWhitespaceIndex === -1\r\n                        ? /* entire string is whitespace */ lineContent.length + 1\r\n                        : firstNonWhitespaceIndex + 1);\r\n                    if (position.column <= lastIndentationColumn) {\r\n                        let fromVisibleColumn = CursorColumns.visibleColumnFromColumn2(config, model, position);\r\n                        let toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\r\n                        let toColumn = CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);\r\n                        deleteSelection = new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\r\n                    }\r\n                    else {\r\n                        deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);\r\n                    }\r\n                }\r\n                else {\r\n                    let leftOfPosition = MoveOperations.left(config, model, position.lineNumber, position.column);\r\n                    deleteSelection = new Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);\r\n                }\r\n            }\r\n            if (deleteSelection.isEmpty()) {\r\n                // Probably at beginning of file => ignore\r\n                commands[i] = null;\r\n                continue;\r\n            }\r\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\r\n                shouldPushStackElementBefore = true;\r\n            }\r\n            commands[i] = new ReplaceCommand(deleteSelection, '');\r\n        }\r\n        return [shouldPushStackElementBefore, commands];\r\n    }\r\n    static cut(config, model, selections) {\r\n        let commands = [];\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            if (selection.isEmpty()) {\r\n                if (config.emptySelectionClipboard) {\r\n                    // This is a full line cut\r\n                    let position = selection.getPosition();\r\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\r\n                    if (position.lineNumber < model.getLineCount()) {\r\n                        // Cutting a line in the middle of the model\r\n                        startLineNumber = position.lineNumber;\r\n                        startColumn = 1;\r\n                        endLineNumber = position.lineNumber + 1;\r\n                        endColumn = 1;\r\n                    }\r\n                    else if (position.lineNumber > 1) {\r\n                        // Cutting the last line & there are more than 1 lines in the model\r\n                        startLineNumber = position.lineNumber - 1;\r\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\r\n                        endLineNumber = position.lineNumber;\r\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\r\n                    }\r\n                    else {\r\n                        // Cutting the single line that the model contains\r\n                        startLineNumber = position.lineNumber;\r\n                        startColumn = 1;\r\n                        endLineNumber = position.lineNumber;\r\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\r\n                    }\r\n                    let deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n                    if (!deleteSelection.isEmpty()) {\r\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\r\n                    }\r\n                    else {\r\n                        commands[i] = null;\r\n                    }\r\n                }\r\n                else {\r\n                    // Cannot cut empty selection\r\n                    commands[i] = null;\r\n                }\r\n            }\r\n            else {\r\n                commands[i] = new ReplaceCommand(selection, '');\r\n            }\r\n        }\r\n        return new EditOperationResult(0 /* Other */, commands, {\r\n            shouldPushStackElementBefore: true,\r\n            shouldPushStackElementAfter: true\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}