{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\n\nexport var Range = /*#__PURE__*/function () {\n  function Range(startLineNumber, startColumn, endLineNumber, endColumn) {\n    _classCallCheck(this, Range);\n\n    if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {\n      this.startLineNumber = endLineNumber;\n      this.startColumn = endColumn;\n      this.endLineNumber = startLineNumber;\n      this.endColumn = startColumn;\n    } else {\n      this.startLineNumber = startLineNumber;\n      this.startColumn = startColumn;\n      this.endLineNumber = endLineNumber;\n      this.endColumn = endColumn;\n    }\n  }\n  /**\r\n   * Test if this range is empty.\r\n   */\n\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return Range.isEmpty(this);\n    }\n    /**\r\n     * Test if `range` is empty.\r\n     */\n\n  }, {\n    key: \"containsPosition\",\n\n    /**\r\n     * Test if position is in this range. If the position is at the edges, will return true.\r\n     */\n    value: function containsPosition(position) {\n      return Range.containsPosition(this, position);\n    }\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n     */\n\n  }, {\n    key: \"containsRange\",\n\n    /**\r\n     * Test if range is in this range. If the range is equal to this range, will return true.\r\n     */\n    value: function containsRange(range) {\n      return Range.containsRange(this, range);\n    }\n    /**\r\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n     */\n\n  }, {\n    key: \"strictContainsRange\",\n\n    /**\r\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n     */\n    value: function strictContainsRange(range) {\n      return Range.strictContainsRange(this, range);\n    }\n    /**\r\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n     */\n\n  }, {\n    key: \"plusRange\",\n\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\n    value: function plusRange(range) {\n      return Range.plusRange(this, range);\n    }\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\n\n  }, {\n    key: \"intersectRanges\",\n\n    /**\r\n     * A intersection of the two ranges.\r\n     */\n    value: function intersectRanges(range) {\n      return Range.intersectRanges(this, range);\n    }\n    /**\r\n     * A intersection of the two ranges.\r\n     */\n\n  }, {\n    key: \"equalsRange\",\n\n    /**\r\n     * Test if this range equals other.\r\n     */\n    value: function equalsRange(other) {\n      return Range.equalsRange(this, other);\n    }\n    /**\r\n     * Test if range `a` equals `b`.\r\n     */\n\n  }, {\n    key: \"getEndPosition\",\n\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\n    value: function getEndPosition() {\n      return Range.getEndPosition(this);\n    }\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\n\n  }, {\n    key: \"getStartPosition\",\n\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\n    value: function getStartPosition() {\n      return Range.getStartPosition(this);\n    }\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\n\n  }, {\n    key: \"toString\",\n\n    /**\r\n     * Transform to a user presentable string representation.\r\n     */\n    value: function toString() {\n      return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\r\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n     */\n\n  }, {\n    key: \"setEndPosition\",\n    value: function setEndPosition(endLineNumber, endColumn) {\n      return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\r\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n     */\n\n  }, {\n    key: \"setStartPosition\",\n    value: function setStartPosition(startLineNumber, startColumn) {\n      return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\n\n  }, {\n    key: \"collapseToStart\",\n    value: function collapseToStart() {\n      return Range.collapseToStart(this);\n    }\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\n\n  }], [{\n    key: \"isEmpty\",\n    value: function isEmpty(range) {\n      return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;\n    }\n  }, {\n    key: \"containsPosition\",\n    value: function containsPosition(range, position) {\n      if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n        return false;\n      }\n\n      if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n        return false;\n      }\n\n      if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"containsRange\",\n    value: function containsRange(range, otherRange) {\n      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n        return false;\n      }\n\n      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n        return false;\n      }\n\n      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n        return false;\n      }\n\n      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"strictContainsRange\",\n    value: function strictContainsRange(range, otherRange) {\n      if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n        return false;\n      }\n\n      if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n        return false;\n      }\n\n      if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n        return false;\n      }\n\n      if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"plusRange\",\n    value: function plusRange(a, b) {\n      var startLineNumber;\n      var startColumn;\n      var endLineNumber;\n      var endColumn;\n\n      if (b.startLineNumber < a.startLineNumber) {\n        startLineNumber = b.startLineNumber;\n        startColumn = b.startColumn;\n      } else if (b.startLineNumber === a.startLineNumber) {\n        startLineNumber = b.startLineNumber;\n        startColumn = Math.min(b.startColumn, a.startColumn);\n      } else {\n        startLineNumber = a.startLineNumber;\n        startColumn = a.startColumn;\n      }\n\n      if (b.endLineNumber > a.endLineNumber) {\n        endLineNumber = b.endLineNumber;\n        endColumn = b.endColumn;\n      } else if (b.endLineNumber === a.endLineNumber) {\n        endLineNumber = b.endLineNumber;\n        endColumn = Math.max(b.endColumn, a.endColumn);\n      } else {\n        endLineNumber = a.endLineNumber;\n        endColumn = a.endColumn;\n      }\n\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n  }, {\n    key: \"intersectRanges\",\n    value: function intersectRanges(a, b) {\n      var resultStartLineNumber = a.startLineNumber;\n      var resultStartColumn = a.startColumn;\n      var resultEndLineNumber = a.endLineNumber;\n      var resultEndColumn = a.endColumn;\n      var otherStartLineNumber = b.startLineNumber;\n      var otherStartColumn = b.startColumn;\n      var otherEndLineNumber = b.endLineNumber;\n      var otherEndColumn = b.endColumn;\n\n      if (resultStartLineNumber < otherStartLineNumber) {\n        resultStartLineNumber = otherStartLineNumber;\n        resultStartColumn = otherStartColumn;\n      } else if (resultStartLineNumber === otherStartLineNumber) {\n        resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n      }\n\n      if (resultEndLineNumber > otherEndLineNumber) {\n        resultEndLineNumber = otherEndLineNumber;\n        resultEndColumn = otherEndColumn;\n      } else if (resultEndLineNumber === otherEndLineNumber) {\n        resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n      } // Check if selection is now empty\n\n\n      if (resultStartLineNumber > resultEndLineNumber) {\n        return null;\n      }\n\n      if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n        return null;\n      }\n\n      return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n  }, {\n    key: \"equalsRange\",\n    value: function equalsRange(a, b) {\n      return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;\n    }\n  }, {\n    key: \"getEndPosition\",\n    value: function getEndPosition(range) {\n      return new Position(range.endLineNumber, range.endColumn);\n    }\n  }, {\n    key: \"getStartPosition\",\n    value: function getStartPosition(range) {\n      return new Position(range.startLineNumber, range.startColumn);\n    }\n  }, {\n    key: \"collapseToStart\",\n    value: function collapseToStart(range) {\n      return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    } // ---\n\n  }, {\n    key: \"fromPositions\",\n    value: function fromPositions(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }, {\n    key: \"lift\",\n    value: function lift(range) {\n      if (!range) {\n        return null;\n      }\n\n      return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\r\n     * Test if `obj` is an `IRange`.\r\n     */\n\n  }, {\n    key: \"isIRange\",\n    value: function isIRange(obj) {\n      return obj && typeof obj.startLineNumber === 'number' && typeof obj.startColumn === 'number' && typeof obj.endLineNumber === 'number' && typeof obj.endColumn === 'number';\n    }\n    /**\r\n     * Test if the two ranges are touching in any way.\r\n     */\n\n  }, {\n    key: \"areIntersectingOrTouching\",\n    value: function areIntersectingOrTouching(a, b) {\n      // Check if `a` is before `b`\n      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) {\n        return false;\n      } // Check if `b` is before `a`\n\n\n      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) {\n        return false;\n      } // These ranges must intersect\n\n\n      return true;\n    }\n    /**\r\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n     */\n\n  }, {\n    key: \"areIntersecting\",\n    value: function areIntersecting(a, b) {\n      // Check if `a` is before `b`\n      if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) {\n        return false;\n      } // Check if `b` is before `a`\n\n\n      if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) {\n        return false;\n      } // These ranges must intersect\n\n\n      return true;\n    }\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the startPosition and then on the endPosition\r\n     */\n\n  }, {\n    key: \"compareRangesUsingStarts\",\n    value: function compareRangesUsingStarts(a, b) {\n      if (a && b) {\n        var aStartLineNumber = a.startLineNumber | 0;\n        var bStartLineNumber = b.startLineNumber | 0;\n\n        if (aStartLineNumber === bStartLineNumber) {\n          var aStartColumn = a.startColumn | 0;\n          var bStartColumn = b.startColumn | 0;\n\n          if (aStartColumn === bStartColumn) {\n            var aEndLineNumber = a.endLineNumber | 0;\n            var bEndLineNumber = b.endLineNumber | 0;\n\n            if (aEndLineNumber === bEndLineNumber) {\n              var aEndColumn = a.endColumn | 0;\n              var bEndColumn = b.endColumn | 0;\n              return aEndColumn - bEndColumn;\n            }\n\n            return aEndLineNumber - bEndLineNumber;\n          }\n\n          return aStartColumn - bStartColumn;\n        }\n\n        return aStartLineNumber - bStartLineNumber;\n      }\n\n      var aExists = a ? 1 : 0;\n      var bExists = b ? 1 : 0;\n      return aExists - bExists;\n    }\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the endPosition and then on the startPosition\r\n     */\n\n  }, {\n    key: \"compareRangesUsingEnds\",\n    value: function compareRangesUsingEnds(a, b) {\n      if (a.endLineNumber === b.endLineNumber) {\n        if (a.endColumn === b.endColumn) {\n          if (a.startLineNumber === b.startLineNumber) {\n            return a.startColumn - b.startColumn;\n          }\n\n          return a.startLineNumber - b.startLineNumber;\n        }\n\n        return a.endColumn - b.endColumn;\n      }\n\n      return a.endLineNumber - b.endLineNumber;\n    }\n    /**\r\n     * Test if the range spans multiple lines.\r\n     */\n\n  }, {\n    key: \"spansMultipleLines\",\n    value: function spansMultipleLines(range) {\n      return range.endLineNumber > range.startLineNumber;\n    }\n  }]);\n\n  return Range;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/core/range.js"],"names":["Position","Range","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","position","containsPosition","range","containsRange","strictContainsRange","plusRange","intersectRanges","other","equalsRange","getEndPosition","getStartPosition","collapseToStart","lineNumber","column","otherRange","a","b","Math","min","max","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","start","end","obj","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","aExists","bExists"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Position } from './position.js';\r\n/**\r\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\r\n */\r\nexport class Range {\r\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n            this.startLineNumber = endLineNumber;\r\n            this.startColumn = endColumn;\r\n            this.endLineNumber = startLineNumber;\r\n            this.endColumn = startColumn;\r\n        }\r\n        else {\r\n            this.startLineNumber = startLineNumber;\r\n            this.startColumn = startColumn;\r\n            this.endLineNumber = endLineNumber;\r\n            this.endColumn = endColumn;\r\n        }\r\n    }\r\n    /**\r\n     * Test if this range is empty.\r\n     */\r\n    isEmpty() {\r\n        return Range.isEmpty(this);\r\n    }\r\n    /**\r\n     * Test if `range` is empty.\r\n     */\r\n    static isEmpty(range) {\r\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n    }\r\n    /**\r\n     * Test if position is in this range. If the position is at the edges, will return true.\r\n     */\r\n    containsPosition(position) {\r\n        return Range.containsPosition(this, position);\r\n    }\r\n    /**\r\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\r\n     */\r\n    static containsPosition(range, position) {\r\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if range is in this range. If the range is equal to this range, will return true.\r\n     */\r\n    containsRange(range) {\r\n        return Range.containsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\r\n     */\r\n    static containsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\r\n     */\r\n    strictContainsRange(range) {\r\n        return Range.strictContainsRange(this, range);\r\n    }\r\n    /**\r\n     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.\r\n     */\r\n    static strictContainsRange(range, otherRange) {\r\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n            return false;\r\n        }\r\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\r\n            return false;\r\n        }\r\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    plusRange(range) {\r\n        return Range.plusRange(this, range);\r\n    }\r\n    /**\r\n     * A reunion of the two ranges.\r\n     * The smallest position will be used as the start point, and the largest one as the end point.\r\n     */\r\n    static plusRange(a, b) {\r\n        let startLineNumber;\r\n        let startColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (b.startLineNumber < a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = b.startColumn;\r\n        }\r\n        else if (b.startLineNumber === a.startLineNumber) {\r\n            startLineNumber = b.startLineNumber;\r\n            startColumn = Math.min(b.startColumn, a.startColumn);\r\n        }\r\n        else {\r\n            startLineNumber = a.startLineNumber;\r\n            startColumn = a.startColumn;\r\n        }\r\n        if (b.endLineNumber > a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = b.endColumn;\r\n        }\r\n        else if (b.endLineNumber === a.endLineNumber) {\r\n            endLineNumber = b.endLineNumber;\r\n            endColumn = Math.max(b.endColumn, a.endColumn);\r\n        }\r\n        else {\r\n            endLineNumber = a.endLineNumber;\r\n            endColumn = a.endColumn;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    intersectRanges(range) {\r\n        return Range.intersectRanges(this, range);\r\n    }\r\n    /**\r\n     * A intersection of the two ranges.\r\n     */\r\n    static intersectRanges(a, b) {\r\n        let resultStartLineNumber = a.startLineNumber;\r\n        let resultStartColumn = a.startColumn;\r\n        let resultEndLineNumber = a.endLineNumber;\r\n        let resultEndColumn = a.endColumn;\r\n        let otherStartLineNumber = b.startLineNumber;\r\n        let otherStartColumn = b.startColumn;\r\n        let otherEndLineNumber = b.endLineNumber;\r\n        let otherEndColumn = b.endColumn;\r\n        if (resultStartLineNumber < otherStartLineNumber) {\r\n            resultStartLineNumber = otherStartLineNumber;\r\n            resultStartColumn = otherStartColumn;\r\n        }\r\n        else if (resultStartLineNumber === otherStartLineNumber) {\r\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n        }\r\n        if (resultEndLineNumber > otherEndLineNumber) {\r\n            resultEndLineNumber = otherEndLineNumber;\r\n            resultEndColumn = otherEndColumn;\r\n        }\r\n        else if (resultEndLineNumber === otherEndLineNumber) {\r\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n        }\r\n        // Check if selection is now empty\r\n        if (resultStartLineNumber > resultEndLineNumber) {\r\n            return null;\r\n        }\r\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n            return null;\r\n        }\r\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n    }\r\n    /**\r\n     * Test if this range equals other.\r\n     */\r\n    equalsRange(other) {\r\n        return Range.equalsRange(this, other);\r\n    }\r\n    /**\r\n     * Test if range `a` equals `b`.\r\n     */\r\n    static equalsRange(a, b) {\r\n        return (!!a &&\r\n            !!b &&\r\n            a.startLineNumber === b.startLineNumber &&\r\n            a.startColumn === b.startColumn &&\r\n            a.endLineNumber === b.endLineNumber &&\r\n            a.endColumn === b.endColumn);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    getEndPosition() {\r\n        return Range.getEndPosition(this);\r\n    }\r\n    /**\r\n     * Return the end position (which will be after or equal to the start position)\r\n     */\r\n    static getEndPosition(range) {\r\n        return new Position(range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    getStartPosition() {\r\n        return Range.getStartPosition(this);\r\n    }\r\n    /**\r\n     * Return the start position (which will be before or equal to the end position)\r\n     */\r\n    static getStartPosition(range) {\r\n        return new Position(range.startLineNumber, range.startColumn);\r\n    }\r\n    /**\r\n     * Transform to a user presentable string representation.\r\n     */\r\n    toString() {\r\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n    }\r\n    /**\r\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n     */\r\n    setEndPosition(endLineNumber, endColumn) {\r\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n    }\r\n    /**\r\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n     */\r\n    setStartPosition(startLineNumber, startColumn) {\r\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    collapseToStart() {\r\n        return Range.collapseToStart(this);\r\n    }\r\n    /**\r\n     * Create a new empty range using this range's start position.\r\n     */\r\n    static collapseToStart(range) {\r\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\r\n    }\r\n    // ---\r\n    static fromPositions(start, end = start) {\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    static lift(range) {\r\n        if (!range) {\r\n            return null;\r\n        }\r\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n    }\r\n    /**\r\n     * Test if `obj` is an `IRange`.\r\n     */\r\n    static isIRange(obj) {\r\n        return (obj\r\n            && (typeof obj.startLineNumber === 'number')\r\n            && (typeof obj.startColumn === 'number')\r\n            && (typeof obj.endLineNumber === 'number')\r\n            && (typeof obj.endColumn === 'number'));\r\n    }\r\n    /**\r\n     * Test if the two ranges are touching in any way.\r\n     */\r\n    static areIntersectingOrTouching(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\r\n     */\r\n    static areIntersecting(a, b) {\r\n        // Check if `a` is before `b`\r\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\r\n            return false;\r\n        }\r\n        // Check if `b` is before `a`\r\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\r\n            return false;\r\n        }\r\n        // These ranges must intersect\r\n        return true;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the startPosition and then on the endPosition\r\n     */\r\n    static compareRangesUsingStarts(a, b) {\r\n        if (a && b) {\r\n            const aStartLineNumber = a.startLineNumber | 0;\r\n            const bStartLineNumber = b.startLineNumber | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                const aStartColumn = a.startColumn | 0;\r\n                const bStartColumn = b.startColumn | 0;\r\n                if (aStartColumn === bStartColumn) {\r\n                    const aEndLineNumber = a.endLineNumber | 0;\r\n                    const bEndLineNumber = b.endLineNumber | 0;\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        const aEndColumn = a.endColumn | 0;\r\n                        const bEndColumn = b.endColumn | 0;\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        }\r\n        const aExists = (a ? 1 : 0);\r\n        const bExists = (b ? 1 : 0);\r\n        return aExists - bExists;\r\n    }\r\n    /**\r\n     * A function that compares ranges, useful for sorting ranges\r\n     * It will first compare ranges on the endPosition and then on the startPosition\r\n     */\r\n    static compareRangesUsingEnds(a, b) {\r\n        if (a.endLineNumber === b.endLineNumber) {\r\n            if (a.endColumn === b.endColumn) {\r\n                if (a.startLineNumber === b.startLineNumber) {\r\n                    return a.startColumn - b.startColumn;\r\n                }\r\n                return a.startLineNumber - b.startLineNumber;\r\n            }\r\n            return a.endColumn - b.endColumn;\r\n        }\r\n        return a.endLineNumber - b.endLineNumber;\r\n    }\r\n    /**\r\n     * Test if the range spans multiple lines.\r\n     */\r\n    static spansMultipleLines(range) {\r\n        return range.endLineNumber > range.startLineNumber;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}