{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nvar hasDifferentOriginAncestorFlag = false;\nvar sameOriginWindowChainCache = null;\n\nfunction getParentWindowIfSameOrigin(w) {\n  if (!w.parent || w.parent === w) {\n    return null;\n  } // Cannot really tell if we have access to the parent window unless we try to access something in it\n\n\n  try {\n    var location = w.location;\n    var parentLocation = w.parent.location;\n\n    if (location.origin !== 'null' && parentLocation.origin !== 'null') {\n      if (location.protocol !== parentLocation.protocol || location.hostname !== parentLocation.hostname || location.port !== parentLocation.port) {\n        hasDifferentOriginAncestorFlag = true;\n        return null;\n      }\n    }\n  } catch (e) {\n    hasDifferentOriginAncestorFlag = true;\n    return null;\n  }\n\n  return w.parent;\n}\n\nexport var IframeUtils = /*#__PURE__*/function () {\n  function IframeUtils() {\n    _classCallCheck(this, IframeUtils);\n  }\n\n  _createClass(IframeUtils, null, [{\n    key: \"getSameOriginWindowChain\",\n\n    /**\r\n     * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\r\n     * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\r\n     * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()\r\n     */\n    value: function getSameOriginWindowChain() {\n      if (!sameOriginWindowChainCache) {\n        sameOriginWindowChainCache = [];\n        var w = window;\n        var parent;\n\n        do {\n          parent = getParentWindowIfSameOrigin(w);\n\n          if (parent) {\n            sameOriginWindowChainCache.push({\n              window: w,\n              iframeElement: w.frameElement || null\n            });\n          } else {\n            sameOriginWindowChainCache.push({\n              window: w,\n              iframeElement: null\n            });\n          }\n\n          w = parent;\n        } while (w);\n      }\n\n      return sameOriginWindowChainCache.slice(0);\n    }\n    /**\r\n     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.\r\n     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.\r\n     */\n\n  }, {\n    key: \"hasDifferentOriginAncestor\",\n    value: function hasDifferentOriginAncestor() {\n      if (!sameOriginWindowChainCache) {\n        this.getSameOriginWindowChain();\n      }\n\n      return hasDifferentOriginAncestorFlag;\n    }\n    /**\r\n     * Returns the position of `childWindow` relative to `ancestorWindow`\r\n     */\n\n  }, {\n    key: \"getPositionOfChildWindowRelativeToAncestorWindow\",\n    value: function getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {\n      if (!ancestorWindow || childWindow === ancestorWindow) {\n        return {\n          top: 0,\n          left: 0\n        };\n      }\n\n      var top = 0,\n          left = 0;\n      var windowChain = this.getSameOriginWindowChain();\n\n      var _iterator = _createForOfIteratorHelper(windowChain),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var windowChainEl = _step.value;\n          top += windowChainEl.window.scrollY;\n          left += windowChainEl.window.scrollX;\n\n          if (windowChainEl.window === ancestorWindow) {\n            break;\n          }\n\n          if (!windowChainEl.iframeElement) {\n            break;\n          }\n\n          var boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n          top += boundingRect.top;\n          left += boundingRect.left;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        top: top,\n        left: left\n      };\n    }\n  }]);\n\n  return IframeUtils;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/browser/iframe.js"],"names":["hasDifferentOriginAncestorFlag","sameOriginWindowChainCache","getParentWindowIfSameOrigin","w","parent","location","parentLocation","origin","protocol","hostname","port","e","IframeUtils","window","push","iframeElement","frameElement","slice","getSameOriginWindowChain","childWindow","ancestorWindow","top","left","windowChain","windowChainEl","scrollY","scrollX","boundingRect","getBoundingClientRect"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nlet hasDifferentOriginAncestorFlag = false;\r\nlet sameOriginWindowChainCache = null;\r\nfunction getParentWindowIfSameOrigin(w) {\r\n    if (!w.parent || w.parent === w) {\r\n        return null;\r\n    }\r\n    // Cannot really tell if we have access to the parent window unless we try to access something in it\r\n    try {\r\n        let location = w.location;\r\n        let parentLocation = w.parent.location;\r\n        if (location.origin !== 'null' && parentLocation.origin !== 'null') {\r\n            if (location.protocol !== parentLocation.protocol || location.hostname !== parentLocation.hostname || location.port !== parentLocation.port) {\r\n                hasDifferentOriginAncestorFlag = true;\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        hasDifferentOriginAncestorFlag = true;\r\n        return null;\r\n    }\r\n    return w.parent;\r\n}\r\nexport class IframeUtils {\r\n    /**\r\n     * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\r\n     * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\r\n     * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()\r\n     */\r\n    static getSameOriginWindowChain() {\r\n        if (!sameOriginWindowChainCache) {\r\n            sameOriginWindowChainCache = [];\r\n            let w = window;\r\n            let parent;\r\n            do {\r\n                parent = getParentWindowIfSameOrigin(w);\r\n                if (parent) {\r\n                    sameOriginWindowChainCache.push({\r\n                        window: w,\r\n                        iframeElement: w.frameElement || null\r\n                    });\r\n                }\r\n                else {\r\n                    sameOriginWindowChainCache.push({\r\n                        window: w,\r\n                        iframeElement: null\r\n                    });\r\n                }\r\n                w = parent;\r\n            } while (w);\r\n        }\r\n        return sameOriginWindowChainCache.slice(0);\r\n    }\r\n    /**\r\n     * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.\r\n     * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.\r\n     */\r\n    static hasDifferentOriginAncestor() {\r\n        if (!sameOriginWindowChainCache) {\r\n            this.getSameOriginWindowChain();\r\n        }\r\n        return hasDifferentOriginAncestorFlag;\r\n    }\r\n    /**\r\n     * Returns the position of `childWindow` relative to `ancestorWindow`\r\n     */\r\n    static getPositionOfChildWindowRelativeToAncestorWindow(childWindow, ancestorWindow) {\r\n        if (!ancestorWindow || childWindow === ancestorWindow) {\r\n            return {\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        }\r\n        let top = 0, left = 0;\r\n        let windowChain = this.getSameOriginWindowChain();\r\n        for (const windowChainEl of windowChain) {\r\n            top += windowChainEl.window.scrollY;\r\n            left += windowChainEl.window.scrollX;\r\n            if (windowChainEl.window === ancestorWindow) {\r\n                break;\r\n            }\r\n            if (!windowChainEl.iframeElement) {\r\n                break;\r\n            }\r\n            let boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\r\n            top += boundingRect.top;\r\n            left += boundingRect.left;\r\n        }\r\n        return {\r\n            top: top,\r\n            left: left\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}