{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport * as viewEvents from '../view/viewEvents.js';\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\nimport { LineBreakData, ViewLineData } from './viewModel.js';\nexport var CoordinatesConverter = /*#__PURE__*/function () {\n  function CoordinatesConverter(lines) {\n    _classCallCheck(this, CoordinatesConverter);\n\n    this._lines = lines;\n  } // View -> Model conversion and related methods\n\n\n  _createClass(CoordinatesConverter, [{\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewPosition) {\n      return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(viewPosition, expectedModelPosition) {\n      return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(viewRange, expectedModelRange) {\n      return this._lines.validateViewRange(viewRange, expectedModelRange);\n    } // Model -> View conversion and related methods\n\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(modelPosition) {\n      return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\n    }\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange) {\n      return this._lines.convertModelRangeToViewRange(modelRange);\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelPosition) {\n      return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n  }]);\n\n  return CoordinatesConverter;\n}();\n\nvar LineNumberMapper = /*#__PURE__*/function () {\n  function LineNumberMapper(viewLineCounts) {\n    _classCallCheck(this, LineNumberMapper);\n\n    this._counts = viewLineCounts;\n    this._isValid = false;\n    this._validEndIndex = -1;\n    this._modelToView = [];\n    this._viewToModel = [];\n  }\n\n  _createClass(LineNumberMapper, [{\n    key: \"_invalidate\",\n    value: function _invalidate(index) {\n      this._isValid = false;\n      this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n  }, {\n    key: \"_ensureValid\",\n    value: function _ensureValid() {\n      if (this._isValid) {\n        return;\n      }\n\n      for (var i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\n        var viewLineCount = this._counts[i];\n        var viewLinesAbove = i > 0 ? this._modelToView[i - 1] : 0;\n        this._modelToView[i] = viewLinesAbove + viewLineCount;\n\n        for (var j = 0; j < viewLineCount; j++) {\n          this._viewToModel[viewLinesAbove + j] = i;\n        }\n      } // trim things\n\n\n      this._modelToView.length = this._counts.length;\n      this._viewToModel.length = this._modelToView[this._modelToView.length - 1]; // mark as valid\n\n      this._isValid = true;\n      this._validEndIndex = this._counts.length - 1;\n    }\n  }, {\n    key: \"changeValue\",\n    value: function changeValue(index, value) {\n      if (this._counts[index] === value) {\n        // no change\n        return;\n      }\n\n      this._counts[index] = value;\n\n      this._invalidate(index);\n    }\n  }, {\n    key: \"removeValues\",\n    value: function removeValues(start, deleteCount) {\n      this._counts.splice(start, deleteCount);\n\n      this._invalidate(start);\n    }\n  }, {\n    key: \"insertValues\",\n    value: function insertValues(insertIndex, insertArr) {\n      this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\n\n      this._invalidate(insertIndex);\n    }\n  }, {\n    key: \"getTotalValue\",\n    value: function getTotalValue() {\n      this._ensureValid();\n\n      return this._viewToModel.length;\n    }\n  }, {\n    key: \"getAccumulatedValue\",\n    value: function getAccumulatedValue(index) {\n      this._ensureValid();\n\n      return this._modelToView[index];\n    }\n  }, {\n    key: \"getIndexOf\",\n    value: function getIndexOf(accumulatedValue) {\n      this._ensureValid();\n\n      var modelLineIndex = this._viewToModel[accumulatedValue];\n      var viewLinesAbove = modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0;\n      return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\n    }\n  }]);\n\n  return LineNumberMapper;\n}();\n\nexport var SplitLinesCollection = /*#__PURE__*/function () {\n  function SplitLinesCollection(model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n    _classCallCheck(this, SplitLinesCollection);\n\n    this.model = model;\n    this._validModelVersionId = -1;\n    this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n    this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n    this.fontInfo = fontInfo;\n    this.tabSize = tabSize;\n    this.wrappingStrategy = wrappingStrategy;\n    this.wrappingColumn = wrappingColumn;\n    this.wrappingIndent = wrappingIndent;\n\n    this._constructLines(\n    /*resetHiddenAreas*/\n    true, null);\n  }\n\n  _createClass(SplitLinesCollection, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\n    }\n  }, {\n    key: \"createCoordinatesConverter\",\n    value: function createCoordinatesConverter() {\n      return new CoordinatesConverter(this);\n    }\n  }, {\n    key: \"_constructLines\",\n    value: function _constructLines(resetHiddenAreas, previousLineBreaks) {\n      var _this = this;\n\n      this.lines = [];\n\n      if (resetHiddenAreas) {\n        this.hiddenAreasIds = [];\n      }\n\n      var linesContent = this.model.getLinesContent();\n      var lineCount = linesContent.length;\n      var lineBreaksComputer = this.createLineBreaksComputer();\n\n      for (var i = 0; i < lineCount; i++) {\n        lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);\n      }\n\n      var linesBreaks = lineBreaksComputer.finalize();\n      var values = [];\n      var hiddenAreas = this.hiddenAreasIds.map(function (areaId) {\n        return _this.model.getDecorationRange(areaId);\n      }).sort(Range.compareRangesUsingStarts);\n      var hiddenAreaStart = 1,\n          hiddenAreaEnd = 0;\n      var hiddenAreaIdx = -1;\n      var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n\n      for (var _i = 0; _i < lineCount; _i++) {\n        var lineNumber = _i + 1;\n\n        if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n          hiddenAreaIdx++;\n          hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n          hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n          nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : lineCount + 2;\n        }\n\n        var isInHiddenArea = lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd;\n        var line = createSplitLine(linesBreaks[_i], !isInHiddenArea);\n        values[_i] = line.getViewLineCount();\n        this.lines[_i] = line;\n      }\n\n      this._validModelVersionId = this.model.getVersionId();\n      this.prefixSumComputer = new LineNumberMapper(values);\n    }\n  }, {\n    key: \"getHiddenAreas\",\n    value: function getHiddenAreas() {\n      var _this2 = this;\n\n      return this.hiddenAreasIds.map(function (decId) {\n        return _this2.model.getDecorationRange(decId);\n      });\n    }\n  }, {\n    key: \"_reduceRanges\",\n    value: function _reduceRanges(_ranges) {\n      var _this3 = this;\n\n      if (_ranges.length === 0) {\n        return [];\n      }\n\n      var ranges = _ranges.map(function (r) {\n        return _this3.model.validateRange(r);\n      }).sort(Range.compareRangesUsingStarts);\n\n      var result = [];\n      var currentRangeStart = ranges[0].startLineNumber;\n      var currentRangeEnd = ranges[0].endLineNumber;\n\n      for (var i = 1, len = ranges.length; i < len; i++) {\n        var range = ranges[i];\n\n        if (range.startLineNumber > currentRangeEnd + 1) {\n          result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n          currentRangeStart = range.startLineNumber;\n          currentRangeEnd = range.endLineNumber;\n        } else if (range.endLineNumber > currentRangeEnd) {\n          currentRangeEnd = range.endLineNumber;\n        }\n      }\n\n      result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n      return result;\n    }\n  }, {\n    key: \"setHiddenAreas\",\n    value: function setHiddenAreas(_ranges) {\n      var _this4 = this;\n\n      var newRanges = this._reduceRanges(_ranges); // BEGIN TODO@Martin: Please stop calling this method on each model change!\n\n\n      var oldRanges = this.hiddenAreasIds.map(function (areaId) {\n        return _this4.model.getDecorationRange(areaId);\n      }).sort(Range.compareRangesUsingStarts);\n\n      if (newRanges.length === oldRanges.length) {\n        var hasDifference = false;\n\n        for (var i = 0; i < newRanges.length; i++) {\n          if (!newRanges[i].equalsRange(oldRanges[i])) {\n            hasDifference = true;\n            break;\n          }\n        }\n\n        if (!hasDifference) {\n          return false;\n        }\n      } // END TODO@Martin: Please stop calling this method on each model change!\n\n\n      var newDecorations = [];\n\n      var _iterator = _createForOfIteratorHelper(newRanges),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var newRange = _step.value;\n          newDecorations.push({\n            range: newRange,\n            options: ModelDecorationOptions.EMPTY\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\n      var hiddenAreas = newRanges;\n      var hiddenAreaStart = 1,\n          hiddenAreaEnd = 0;\n      var hiddenAreaIdx = -1;\n      var nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n      var hasVisibleLine = false;\n\n      for (var _i2 = 0; _i2 < this.lines.length; _i2++) {\n        var lineNumber = _i2 + 1;\n\n        if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n          hiddenAreaIdx++;\n          hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n          hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n          nextLineNumberToUpdateHiddenArea = hiddenAreaIdx + 1 < hiddenAreas.length ? hiddenAreaEnd + 1 : this.lines.length + 2;\n        }\n\n        var lineChanged = false;\n\n        if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n          // Line should be hidden\n          if (this.lines[_i2].isVisible()) {\n            this.lines[_i2] = this.lines[_i2].setVisible(false);\n            lineChanged = true;\n          }\n        } else {\n          hasVisibleLine = true; // Line should be visible\n\n          if (!this.lines[_i2].isVisible()) {\n            this.lines[_i2] = this.lines[_i2].setVisible(true);\n            lineChanged = true;\n          }\n        }\n\n        if (lineChanged) {\n          var newOutputLineCount = this.lines[_i2].getViewLineCount();\n\n          this.prefixSumComputer.changeValue(_i2, newOutputLineCount);\n        }\n      }\n\n      if (!hasVisibleLine) {\n        // Cannot have everything be hidden => reveal everything!\n        this.setHiddenAreas([]);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelLineNumber, _modelColumn) {\n      if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n        // invalid arguments\n        return false;\n      }\n\n      return this.lines[modelLineNumber - 1].isVisible();\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\n        // invalid arguments\n        return 1;\n      }\n\n      return this.lines[modelLineNumber - 1].getViewLineCount();\n    }\n  }, {\n    key: \"setTabSize\",\n    value: function setTabSize(newTabSize) {\n      if (this.tabSize === newTabSize) {\n        return false;\n      }\n\n      this.tabSize = newTabSize;\n\n      this._constructLines(\n      /*resetHiddenAreas*/\n      false, null);\n\n      return true;\n    }\n  }, {\n    key: \"setWrappingSettings\",\n    value: function setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n      var equalFontInfo = this.fontInfo.equals(fontInfo);\n      var equalWrappingStrategy = this.wrappingStrategy === wrappingStrategy;\n      var equalWrappingColumn = this.wrappingColumn === wrappingColumn;\n      var equalWrappingIndent = this.wrappingIndent === wrappingIndent;\n\n      if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n        return false;\n      }\n\n      var onlyWrappingColumnChanged = equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent;\n      this.fontInfo = fontInfo;\n      this.wrappingStrategy = wrappingStrategy;\n      this.wrappingColumn = wrappingColumn;\n      this.wrappingIndent = wrappingIndent;\n      var previousLineBreaks = null;\n\n      if (onlyWrappingColumnChanged) {\n        previousLineBreaks = [];\n\n        for (var i = 0, len = this.lines.length; i < len; i++) {\n          previousLineBreaks[i] = this.lines[i].getLineBreakData();\n        }\n      }\n\n      this._constructLines(\n      /*resetHiddenAreas*/\n      false, previousLineBreaks);\n\n      return true;\n    }\n  }, {\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer() {\n      var lineBreaksComputerFactory = this.wrappingStrategy === 'advanced' ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory;\n      return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n  }, {\n    key: \"onModelFlushed\",\n    value: function onModelFlushed() {\n      this._constructLines(\n      /*resetHiddenAreas*/\n      true, null);\n    }\n  }, {\n    key: \"onModelLinesDeleted\",\n    value: function onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n      if (versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return null;\n      }\n\n      var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n      var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\n      this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n      this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n      return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n  }, {\n    key: \"onModelLinesInserted\",\n    value: function onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n      if (versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return null;\n      } // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n\n\n      var isInHiddenArea = fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible();\n      var outputFromLineNumber = fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1;\n      var totalOutputLineCount = 0;\n      var insertLines = [];\n      var insertPrefixSumValues = [];\n\n      for (var i = 0, len = lineBreaks.length; i < len; i++) {\n        var line = createSplitLine(lineBreaks[i], !isInHiddenArea);\n        insertLines.push(line);\n        var outputLineCount = line.getViewLineCount();\n        totalOutputLineCount += outputLineCount;\n        insertPrefixSumValues[i] = outputLineCount;\n      } // TODO@Alex: use arrays.arrayInsert\n\n\n      this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\n      this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n      return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n  }, {\n    key: \"onModelLineChanged\",\n    value: function onModelLineChanged(versionId, lineNumber, lineBreakData) {\n      if (versionId <= this._validModelVersionId) {\n        // Here we check for versionId in case the lines were reconstructed in the meantime.\n        // We don't want to apply stale change events on top of a newer read model state.\n        return [false, null, null, null];\n      }\n\n      var lineIndex = lineNumber - 1;\n      var oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\n      var isVisible = this.lines[lineIndex].isVisible();\n      var line = createSplitLine(lineBreakData, isVisible);\n      this.lines[lineIndex] = line;\n      var newOutputLineCount = this.lines[lineIndex].getViewLineCount();\n      var lineMappingChanged = false;\n      var changeFrom = 0;\n      var changeTo = -1;\n      var insertFrom = 0;\n      var insertTo = -1;\n      var deleteFrom = 0;\n      var deleteTo = -1;\n\n      if (oldOutputLineCount > newOutputLineCount) {\n        changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n        changeTo = changeFrom + newOutputLineCount - 1;\n        deleteFrom = changeTo + 1;\n        deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n        lineMappingChanged = true;\n      } else if (oldOutputLineCount < newOutputLineCount) {\n        changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n        changeTo = changeFrom + oldOutputLineCount - 1;\n        insertFrom = changeTo + 1;\n        insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n        lineMappingChanged = true;\n      } else {\n        changeFrom = lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1;\n        changeTo = changeFrom + newOutputLineCount - 1;\n      }\n\n      this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\n      var viewLinesChangedEvent = changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null;\n      var viewLinesInsertedEvent = insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null;\n      var viewLinesDeletedEvent = deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null;\n      return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n  }, {\n    key: \"acceptVersionId\",\n    value: function acceptVersionId(versionId) {\n      this._validModelVersionId = versionId;\n\n      if (this.lines.length === 1 && !this.lines[0].isVisible()) {\n        // At least one line must be visible => reset hidden areas\n        this.setHiddenAreas([]);\n      }\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return this.prefixSumComputer.getTotalValue();\n    }\n  }, {\n    key: \"_toValidViewLineNumber\",\n    value: function _toValidViewLineNumber(viewLineNumber) {\n      if (viewLineNumber < 1) {\n        return 1;\n      }\n\n      var viewLineCount = this.getViewLineCount();\n\n      if (viewLineNumber > viewLineCount) {\n        return viewLineCount;\n      }\n\n      return viewLineNumber | 0;\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      minLineNumber = this._toValidViewLineNumber(minLineNumber);\n      maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n      var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n      var modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n      var modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n      var result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n      var viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n      var viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n      return {\n        startLineNumber: viewStartPosition.lineNumber,\n        endLineNumber: viewEndPosition.lineNumber,\n        indent: result.indent\n      };\n    }\n  }, {\n    key: \"getViewLinesIndentGuides\",\n    value: function getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n      var modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n      var modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n      var result = [];\n      var resultRepeatCount = [];\n      var resultRepeatOption = [];\n      var modelStartLineIndex = modelStart.lineNumber - 1;\n      var modelEndLineIndex = modelEnd.lineNumber - 1;\n      var reqStart = null;\n\n      for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n        var line = this.lines[modelLineIndex];\n\n        if (line.isVisible()) {\n          var viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n          var viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n          var count = viewLineEndIndex - viewLineStartIndex + 1;\n          var option = 0\n          /* BlockNone */\n          ;\n\n          if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n            // wrapped lines should block indent guides\n            option = viewLineStartIndex === 0 ? 1\n            /* BlockSubsequent */\n            : 2\n            /* BlockAll */\n            ;\n          }\n\n          resultRepeatCount.push(count);\n          resultRepeatOption.push(option); // merge into previous request\n\n          if (reqStart === null) {\n            reqStart = new Position(modelLineIndex + 1, 0);\n          }\n        } else {\n          // hit invisible line => flush request\n          if (reqStart !== null) {\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n            reqStart = null;\n          }\n        }\n      }\n\n      if (reqStart !== null) {\n        result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n        reqStart = null;\n      }\n\n      var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n      var viewIndents = new Array(viewLineCount);\n      var currIndex = 0;\n\n      for (var i = 0, len = result.length; i < len; i++) {\n        var value = result[i];\n\n        var _count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n\n        var _option = resultRepeatOption[i];\n        var blockAtIndex = void 0;\n\n        if (_option === 2\n        /* BlockAll */\n        ) {\n            blockAtIndex = 0;\n          } else if (_option === 1\n        /* BlockSubsequent */\n        ) {\n            blockAtIndex = 1;\n          } else {\n          blockAtIndex = _count;\n        }\n\n        for (var j = 0; j < _count; j++) {\n          if (j === blockAtIndex) {\n            value = 0;\n          }\n\n          viewIndents[currIndex++] = value;\n        }\n      }\n\n      return viewIndents;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(viewLineNumber) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n      viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n      viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n      var start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\n      var viewLineNumber = viewStartLineNumber;\n      var startModelLineIndex = start.index;\n      var startRemainder = start.remainder;\n      var result = [];\n\n      for (var modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n        var line = this.lines[modelLineIndex];\n\n        if (!line.isVisible()) {\n          continue;\n        }\n\n        var fromViewLineIndex = modelLineIndex === startModelLineIndex ? startRemainder : 0;\n        var remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n        var lastLine = false;\n\n        if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n          lastLine = true;\n          remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n        }\n\n        var toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\n        line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\n        viewLineNumber += remainingViewLineCount;\n\n        if (lastLine) {\n          break;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      var line = this.lines[lineIndex];\n      var minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n      var maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n\n      if (viewColumn < minColumn) {\n        viewColumn = minColumn;\n      }\n\n      if (viewColumn > maxColumn) {\n        viewColumn = maxColumn;\n      }\n\n      var computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n      var computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n\n      if (computedModelPosition.equals(expectedModelPosition)) {\n        return new Position(viewLineNumber, viewColumn);\n      }\n\n      return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(viewRange, expectedModelRange) {\n      var validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n      var validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n      return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n  }, {\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n      viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n      var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\n      var lineIndex = r.index;\n      var remainder = r.remainder;\n      var inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn); // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n\n      return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      var start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n      var end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\n      var validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n      var inputLineNumber = validPosition.lineNumber;\n      var inputColumn = validPosition.column;\n      var lineIndex = inputLineNumber - 1,\n          lineIndexChanged = false;\n\n      while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n        lineIndex--;\n        lineIndexChanged = true;\n      }\n\n      if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n        // Could not reach a real line\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n        return new Position(1, 1);\n      }\n\n      var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n      var r;\n\n      if (lineIndexChanged) {\n        r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n      } else {\n        r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\n      } // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n\n\n      return r;\n    }\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange) {\n      var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\n      var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\n\n      if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {\n        // This is a single line range that ends up taking more lines due to wrapping\n        if (end.column === this.getViewLineMinColumn(end.lineNumber)) {\n          // the end column lands on the first column of the next line\n          return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));\n        }\n      }\n\n      return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n  }, {\n    key: \"_getViewLineNumberForModelPosition\",\n    value: function _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\n      var lineIndex = inputLineNumber - 1;\n\n      if (this.lines[lineIndex].isVisible()) {\n        // this model line is visible\n        var _deltaLineNumber2 = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(_deltaLineNumber2, inputColumn);\n      } // this model line is not visible\n\n\n      while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\n        lineIndex--;\n      }\n\n      if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\n        // Could not reach a real line\n        return 1;\n      }\n\n      var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\n      return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n  }, {\n    key: \"getAllOverviewRulerDecorations\",\n    value: function getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n      var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n      var result = new OverviewRulerDecorations();\n\n      var _iterator2 = _createForOfIteratorHelper(decorations),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var decoration = _step2.value;\n          var opts = decoration.options.overviewRuler;\n          var lane = opts ? opts.position : 0;\n\n          if (lane === 0) {\n            continue;\n          }\n\n          var color = opts.getColor(theme);\n\n          var viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n\n          var viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n\n          result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result.result;\n    }\n  }, {\n    key: \"getDecorationsInRange\",\n    value: function getDecorationsInRange(range, ownerId, filterOutValidation) {\n      var modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n      var modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n\n      if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n        // most likely there are no hidden lines => fast path\n        // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n        return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n      }\n\n      var result = [];\n      var modelStartLineIndex = modelStart.lineNumber - 1;\n      var modelEndLineIndex = modelEnd.lineNumber - 1;\n      var reqStart = null;\n\n      for (var modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n        var line = this.lines[modelLineIndex];\n\n        if (line.isVisible()) {\n          // merge into previous request\n          if (reqStart === null) {\n            reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n          }\n        } else {\n          // hit invisible line => flush request\n          if (reqStart !== null) {\n            var maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n            reqStart = null;\n          }\n        }\n      }\n\n      if (reqStart !== null) {\n        result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n        reqStart = null;\n      }\n\n      result.sort(function (a, b) {\n        var res = Range.compareRangesUsingStarts(a.range, b.range);\n\n        if (res === 0) {\n          if (a.id < b.id) {\n            return -1;\n          }\n\n          if (a.id > b.id) {\n            return 1;\n          }\n\n          return 0;\n        }\n\n        return res;\n      }); // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n\n      var finalResult = [],\n          finalResultLen = 0;\n      var prevDecId = null;\n\n      var _iterator3 = _createForOfIteratorHelper(result),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var dec = _step3.value;\n          var decId = dec.id;\n\n          if (prevDecId === decId) {\n            // skip\n            continue;\n          }\n\n          prevDecId = decId;\n          finalResult[finalResultLen++] = dec;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return finalResult;\n    }\n  }]);\n\n  return SplitLinesCollection;\n}();\n\nvar VisibleIdentitySplitLine = /*#__PURE__*/function () {\n  function VisibleIdentitySplitLine() {\n    _classCallCheck(this, VisibleIdentitySplitLine);\n  }\n\n  _createClass(VisibleIdentitySplitLine, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return true;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      if (isVisible) {\n        return this;\n      }\n\n      return InvisibleIdentitySplitLine.INSTANCE;\n    }\n  }, {\n    key: \"getLineBreakData\",\n    value: function getLineBreakData() {\n      return null;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return 1;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineContent(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineLength(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineMinColumn(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n      return model.getLineMaxColumn(modelLineNumber);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(model, modelLineNumber, _outputLineIndex) {\n      var lineTokens = model.getLineTokens(modelLineNumber);\n      var lineContent = lineTokens.getLineContent();\n      return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n      if (!needed[globalStartIndex]) {\n        result[globalStartIndex] = null;\n        return;\n      }\n\n      result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n      return outputColumn;\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n      return new Position(deltaLineNumber, inputColumn);\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n      return deltaLineNumber;\n    }\n  }]);\n\n  return VisibleIdentitySplitLine;\n}();\n\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\n\nvar InvisibleIdentitySplitLine = /*#__PURE__*/function () {\n  function InvisibleIdentitySplitLine() {\n    _classCallCheck(this, InvisibleIdentitySplitLine);\n  }\n\n  _createClass(InvisibleIdentitySplitLine, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return false;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      if (!isVisible) {\n        return this;\n      }\n\n      return VisibleIdentitySplitLine.INSTANCE;\n    }\n  }, {\n    key: \"getLineBreakData\",\n    value: function getLineBreakData() {\n      return null;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return 0;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n      throw new Error('Not supported');\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n      throw new Error('Not supported');\n    }\n  }]);\n\n  return InvisibleIdentitySplitLine;\n}();\n\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\nexport var SplitLine = /*#__PURE__*/function () {\n  function SplitLine(lineBreakData, isVisible) {\n    _classCallCheck(this, SplitLine);\n\n    this._lineBreakData = lineBreakData;\n    this._isVisible = isVisible;\n  }\n\n  _createClass(SplitLine, [{\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this._isVisible;\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(isVisible) {\n      this._isVisible = isVisible;\n      return this;\n    }\n  }, {\n    key: \"getLineBreakData\",\n    value: function getLineBreakData() {\n      return this._lineBreakData;\n    }\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      if (!this._isVisible) {\n        return 0;\n      }\n\n      return this._lineBreakData.breakOffsets.length;\n    }\n  }, {\n    key: \"getInputStartOffsetOfOutputLineIndex\",\n    value: function getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\n      return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);\n    }\n  }, {\n    key: \"getInputEndOffsetOfOutputLineIndex\",\n    value: function getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\n      if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\n        return model.getLineMaxColumn(modelLineNumber) - 1;\n      }\n\n      return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(model, modelLineNumber, outputLineIndex) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n      var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n      var r = model.getValueInRange({\n        startLineNumber: modelLineNumber,\n        startColumn: startOffset + 1,\n        endLineNumber: modelLineNumber,\n        endColumn: endOffset + 1\n      });\n\n      if (outputLineIndex > 0) {\n        r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(model, modelLineNumber, outputLineIndex) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n      var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n      var r = endOffset - startOffset;\n\n      if (outputLineIndex > 0) {\n        r = this._lineBreakData.wrappedTextIndentLength + r;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      if (outputLineIndex > 0) {\n        return this._lineBreakData.wrappedTextIndentLength + 1;\n      }\n\n      return 1;\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(model, modelLineNumber, outputLineIndex) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\n      var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\n      var lineContent = model.getValueInRange({\n        startLineNumber: modelLineNumber,\n        startColumn: startOffset + 1,\n        endLineNumber: modelLineNumber,\n        endColumn: endOffset + 1\n      });\n\n      if (outputLineIndex > 0) {\n        lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;\n      }\n\n      var minColumn = outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1;\n      var maxColumn = lineContent.length + 1;\n      var continuesWithWrappedLine = outputLineIndex + 1 < this.getViewLineCount();\n      var deltaStartIndex = 0;\n\n      if (outputLineIndex > 0) {\n        deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;\n      }\n\n      var lineTokens = model.getLineTokens(modelLineNumber);\n      var startVisibleColumn = outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1];\n      return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      for (var outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\n        var globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\n\n        if (!needed[globalIndex]) {\n          result[globalIndex] = null;\n          continue;\n        }\n\n        result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\n      }\n    }\n  }, {\n    key: \"getModelColumnOfViewPosition\",\n    value: function getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var adjustedColumn = outputColumn - 1;\n\n      if (outputLineIndex > 0) {\n        if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\n          adjustedColumn = 0;\n        } else {\n          adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\n        }\n      }\n\n      return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;\n    }\n  }, {\n    key: \"getViewPositionOfModelPosition\",\n    value: function getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n      var outputLineIndex = r.outputLineIndex;\n      var outputColumn = r.outputOffset + 1;\n\n      if (outputLineIndex > 0) {\n        outputColumn += this._lineBreakData.wrappedTextIndentLength;\n      } //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\n\n\n      return new Position(deltaLineNumber + outputLineIndex, outputColumn);\n    }\n  }, {\n    key: \"getViewLineNumberOfModelPosition\",\n    value: function getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n      if (!this._isVisible) {\n        throw new Error('Not supported');\n      }\n\n      var r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\n      return deltaLineNumber + r.outputLineIndex;\n    }\n  }]);\n\n  return SplitLine;\n}();\nvar _spaces = [''];\n\nfunction spaces(count) {\n  if (count >= _spaces.length) {\n    for (var i = 1; i <= count; i++) {\n      _spaces[i] = _makeSpaces(i);\n    }\n  }\n\n  return _spaces[count];\n}\n\nfunction _makeSpaces(count) {\n  return new Array(count + 1).join(' ');\n}\n\nfunction createSplitLine(lineBreakData, isVisible) {\n  if (lineBreakData === null) {\n    // No mapping needed\n    if (isVisible) {\n      return VisibleIdentitySplitLine.INSTANCE;\n    }\n\n    return InvisibleIdentitySplitLine.INSTANCE;\n  } else {\n    return new SplitLine(lineBreakData, isVisible);\n  }\n}\n\nexport var IdentityCoordinatesConverter = /*#__PURE__*/function () {\n  function IdentityCoordinatesConverter(lines) {\n    _classCallCheck(this, IdentityCoordinatesConverter);\n\n    this._lines = lines;\n  }\n\n  _createClass(IdentityCoordinatesConverter, [{\n    key: \"_validPosition\",\n    value: function _validPosition(pos) {\n      return this._lines.model.validatePosition(pos);\n    }\n  }, {\n    key: \"_validRange\",\n    value: function _validRange(range) {\n      return this._lines.model.validateRange(range);\n    } // View -> Model conversion and related methods\n\n  }, {\n    key: \"convertViewPositionToModelPosition\",\n    value: function convertViewPositionToModelPosition(viewPosition) {\n      return this._validPosition(viewPosition);\n    }\n  }, {\n    key: \"convertViewRangeToModelRange\",\n    value: function convertViewRangeToModelRange(viewRange) {\n      return this._validRange(viewRange);\n    }\n  }, {\n    key: \"validateViewPosition\",\n    value: function validateViewPosition(_viewPosition, expectedModelPosition) {\n      return this._validPosition(expectedModelPosition);\n    }\n  }, {\n    key: \"validateViewRange\",\n    value: function validateViewRange(_viewRange, expectedModelRange) {\n      return this._validRange(expectedModelRange);\n    } // Model -> View conversion and related methods\n\n  }, {\n    key: \"convertModelPositionToViewPosition\",\n    value: function convertModelPositionToViewPosition(modelPosition) {\n      return this._validPosition(modelPosition);\n    }\n  }, {\n    key: \"convertModelRangeToViewRange\",\n    value: function convertModelRangeToViewRange(modelRange) {\n      return this._validRange(modelRange);\n    }\n  }, {\n    key: \"modelPositionIsVisible\",\n    value: function modelPositionIsVisible(modelPosition) {\n      var lineCount = this._lines.model.getLineCount();\n\n      if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n        // invalid arguments\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getModelLineViewLineCount\",\n    value: function getModelLineViewLineCount(modelLineNumber) {\n      return 1;\n    }\n  }]);\n\n  return IdentityCoordinatesConverter;\n}();\nexport var IdentityLinesCollection = /*#__PURE__*/function () {\n  function IdentityLinesCollection(model) {\n    _classCallCheck(this, IdentityLinesCollection);\n\n    this.model = model;\n  }\n\n  _createClass(IdentityLinesCollection, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }, {\n    key: \"createCoordinatesConverter\",\n    value: function createCoordinatesConverter() {\n      return new IdentityCoordinatesConverter(this);\n    }\n  }, {\n    key: \"getHiddenAreas\",\n    value: function getHiddenAreas() {\n      return [];\n    }\n  }, {\n    key: \"setHiddenAreas\",\n    value: function setHiddenAreas(_ranges) {\n      return false;\n    }\n  }, {\n    key: \"setTabSize\",\n    value: function setTabSize(_newTabSize) {\n      return false;\n    }\n  }, {\n    key: \"setWrappingSettings\",\n    value: function setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n      return false;\n    }\n  }, {\n    key: \"createLineBreaksComputer\",\n    value: function createLineBreaksComputer() {\n      var result = [];\n      return {\n        addRequest: function addRequest(lineText, previousLineBreakData) {\n          result.push(null);\n        },\n        finalize: function finalize() {\n          return result;\n        }\n      };\n    }\n  }, {\n    key: \"onModelFlushed\",\n    value: function onModelFlushed() {}\n  }, {\n    key: \"onModelLinesDeleted\",\n    value: function onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n      return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n  }, {\n    key: \"onModelLinesInserted\",\n    value: function onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n      return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n  }, {\n    key: \"onModelLineChanged\",\n    value: function onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n      return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n  }, {\n    key: \"acceptVersionId\",\n    value: function acceptVersionId(_versionId) {}\n  }, {\n    key: \"getViewLineCount\",\n    value: function getViewLineCount() {\n      return this.model.getLineCount();\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n      return {\n        startLineNumber: viewLineNumber,\n        endLineNumber: viewLineNumber,\n        indent: 0\n      };\n    }\n  }, {\n    key: \"getViewLinesIndentGuides\",\n    value: function getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n      var viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n      var result = new Array(viewLineCount);\n\n      for (var i = 0; i < viewLineCount; i++) {\n        result[i] = 0;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getViewLineContent\",\n    value: function getViewLineContent(viewLineNumber) {\n      return this.model.getLineContent(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineLength\",\n    value: function getViewLineLength(viewLineNumber) {\n      return this.model.getLineLength(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineMinColumn\",\n    value: function getViewLineMinColumn(viewLineNumber) {\n      return this.model.getLineMinColumn(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineMaxColumn\",\n    value: function getViewLineMaxColumn(viewLineNumber) {\n      return this.model.getLineMaxColumn(viewLineNumber);\n    }\n  }, {\n    key: \"getViewLineData\",\n    value: function getViewLineData(viewLineNumber) {\n      var lineTokens = this.model.getLineTokens(viewLineNumber);\n      var lineContent = lineTokens.getLineContent();\n      return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\n    }\n  }, {\n    key: \"getViewLinesData\",\n    value: function getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n      var lineCount = this.model.getLineCount();\n      viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n      viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n      var result = [];\n\n      for (var lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n        var idx = lineNumber - viewStartLineNumber;\n\n        if (!needed[idx]) {\n          result[idx] = null;\n        }\n\n        result[idx] = this.getViewLineData(lineNumber);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAllOverviewRulerDecorations\",\n    value: function getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\n      var decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\n      var result = new OverviewRulerDecorations();\n\n      var _iterator4 = _createForOfIteratorHelper(decorations),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var decoration = _step4.value;\n          var opts = decoration.options.overviewRuler;\n          var lane = opts ? opts.position : 0;\n\n          if (lane === 0) {\n            continue;\n          }\n\n          var color = opts.getColor(theme);\n          var viewStartLineNumber = decoration.range.startLineNumber;\n          var viewEndLineNumber = decoration.range.endLineNumber;\n          result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return result.result;\n    }\n  }, {\n    key: \"getDecorationsInRange\",\n    value: function getDecorationsInRange(range, ownerId, filterOutValidation) {\n      return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n  }]);\n\n  return IdentityLinesCollection;\n}();\n\nvar OverviewRulerDecorations = /*#__PURE__*/function () {\n  function OverviewRulerDecorations() {\n    _classCallCheck(this, OverviewRulerDecorations);\n\n    this.result = Object.create(null);\n  }\n\n  _createClass(OverviewRulerDecorations, [{\n    key: \"accept\",\n    value: function accept(color, startLineNumber, endLineNumber, lane) {\n      var prev = this.result[color];\n\n      if (prev) {\n        var prevLane = prev[prev.length - 3];\n        var prevEndLineNumber = prev[prev.length - 1];\n\n        if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n          // merge into prev\n          if (endLineNumber > prevEndLineNumber) {\n            prev[prev.length - 1] = endLineNumber;\n          }\n\n          return;\n        } // push\n\n\n        prev.push(lane, startLineNumber, endLineNumber);\n      } else {\n        this.result[color] = [lane, startLineNumber, endLineNumber];\n      }\n    }\n  }]);\n\n  return OverviewRulerDecorations;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/viewModel/splitLinesCollection.js"],"names":["arrays","Position","Range","ModelDecorationOptions","viewEvents","PrefixSumIndexOfResult","LineBreakData","ViewLineData","CoordinatesConverter","lines","_lines","viewPosition","convertViewPositionToModelPosition","lineNumber","column","viewRange","convertViewRangeToModelRange","expectedModelPosition","validateViewPosition","expectedModelRange","validateViewRange","modelPosition","convertModelPositionToViewPosition","modelRange","convertModelRangeToViewRange","modelPositionIsVisible","modelLineNumber","getModelLineViewLineCount","LineNumberMapper","viewLineCounts","_counts","_isValid","_validEndIndex","_modelToView","_viewToModel","index","Math","min","i","len","length","viewLineCount","viewLinesAbove","j","value","_invalidate","start","deleteCount","splice","insertIndex","insertArr","arrayInsert","_ensureValid","accumulatedValue","modelLineIndex","SplitLinesCollection","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","fontInfo","tabSize","wrappingStrategy","wrappingColumn","wrappingIndent","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasIds","deltaDecorations","resetHiddenAreas","previousLineBreaks","linesContent","getLinesContent","lineCount","lineBreaksComputer","createLineBreaksComputer","addRequest","linesBreaks","finalize","values","hiddenAreas","map","areaId","getDecorationRange","sort","compareRangesUsingStarts","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","startLineNumber","endLineNumber","isInHiddenArea","line","createSplitLine","getViewLineCount","getVersionId","prefixSumComputer","decId","_ranges","ranges","r","validateRange","result","currentRangeStart","currentRangeEnd","range","push","newRanges","_reduceRanges","oldRanges","hasDifference","equalsRange","newDecorations","newRange","options","EMPTY","hasVisibleLine","lineChanged","isVisible","setVisible","newOutputLineCount","changeValue","setHiddenAreas","_modelColumn","newTabSize","equalFontInfo","equals","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getLineBreakData","lineBreaksComputerFactory","versionId","fromLineNumber","toLineNumber","outputFromLineNumber","getAccumulatedValue","outputToLineNumber","removeValues","ViewLinesDeletedEvent","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","slice","concat","insertValues","ViewLinesInsertedEvent","lineBreakData","lineIndex","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","viewLinesChangedEvent","ViewLinesChangedEvent","viewLinesInsertedEvent","viewLinesDeletedEvent","getTotalValue","viewLineNumber","minLineNumber","maxLineNumber","_toValidViewLineNumber","getViewLineMinColumn","modelMinPosition","modelMaxPosition","getActiveIndentGuide","viewStartPosition","viewEndPosition","getLineMaxColumn","indent","viewStartLineNumber","viewEndLineNumber","modelStart","modelEnd","getViewLineMaxColumn","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","count","option","getLinesIndentGuides","viewIndents","Array","currIndex","blockAtIndex","getIndexOf","remainder","getViewLineContent","getViewLineLength","getViewLineData","needed","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","toViewLineIndex","getViewLinesData","viewColumn","minColumn","maxColumn","computedModelColumn","getModelColumnOfViewPosition","computedModelPosition","validatePosition","validViewStart","startColumn","getStartPosition","validViewEnd","endColumn","getEndPosition","inputColumn","end","_modelLineNumber","validPosition","inputLineNumber","lineIndexChanged","deltaLineNumber","getViewPositionOfModelPosition","ownerId","filterOutValidation","theme","decorations","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","opts","overviewRuler","lane","position","color","getColor","_getViewLineNumberForModelPosition","accept","getDecorationsInRange","maxLineColumn","a","b","res","id","finalResult","finalResultLen","prevDecId","dec","VisibleIdentitySplitLine","InvisibleIdentitySplitLine","INSTANCE","_outputLineIndex","getLineContent","getLineLength","getLineMinColumn","lineTokens","getLineTokens","lineContent","inflate","_fromOuputLineIndex","_toOutputLineIndex","globalStartIndex","outputColumn","_inputColumn","_model","Error","_globalStartIndex","_needed","_result","_outputColumn","_deltaLineNumber","SplitLine","_lineBreakData","_isVisible","breakOffsets","outputLineIndex","getInputOffsetOfOutputPosition","startOffset","getInputStartOffsetOfOutputLineIndex","endOffset","getInputEndOffsetOfOutputLineIndex","getValueInRange","spaces","wrappedTextIndentLength","continuesWithWrappedLine","deltaStartIndex","startVisibleColumn","breakOffsetsVisibleColumn","sliceAndInflate","fromOuputLineIndex","toOutputLineIndex","globalIndex","adjustedColumn","getOutputPositionOfInputOffset","outputOffset","_spaces","_makeSpaces","join","IdentityCoordinatesConverter","pos","_validPosition","_validRange","_viewPosition","_viewRange","IdentityLinesCollection","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","lineText","previousLineBreakData","_versionId","_minLineNumber","_maxLineNumber","max","idx","Object","create","prev","prevLane","prevEndLineNumber"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { ModelDecorationOptions } from '../model/textModel.js';\r\nimport * as viewEvents from '../view/viewEvents.js';\r\nimport { PrefixSumIndexOfResult } from './prefixSumComputer.js';\r\nimport { LineBreakData, ViewLineData } from './viewModel.js';\r\nexport class CoordinatesConverter {\r\n    constructor(lines) {\r\n        this._lines = lines;\r\n    }\r\n    // View -> Model conversion and related methods\r\n    convertViewPositionToModelPosition(viewPosition) {\r\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        return this._lines.convertViewRangeToModelRange(viewRange);\r\n    }\r\n    validateViewPosition(viewPosition, expectedModelPosition) {\r\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\r\n    }\r\n    validateViewRange(viewRange, expectedModelRange) {\r\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\r\n    }\r\n    // Model -> View conversion and related methods\r\n    convertModelPositionToViewPosition(modelPosition) {\r\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        return this._lines.convertModelRangeToViewRange(modelRange);\r\n    }\r\n    modelPositionIsVisible(modelPosition) {\r\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\r\n    }\r\n}\r\nclass LineNumberMapper {\r\n    constructor(viewLineCounts) {\r\n        this._counts = viewLineCounts;\r\n        this._isValid = false;\r\n        this._validEndIndex = -1;\r\n        this._modelToView = [];\r\n        this._viewToModel = [];\r\n    }\r\n    _invalidate(index) {\r\n        this._isValid = false;\r\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\r\n    }\r\n    _ensureValid() {\r\n        if (this._isValid) {\r\n            return;\r\n        }\r\n        for (let i = this._validEndIndex + 1, len = this._counts.length; i < len; i++) {\r\n            const viewLineCount = this._counts[i];\r\n            const viewLinesAbove = (i > 0 ? this._modelToView[i - 1] : 0);\r\n            this._modelToView[i] = viewLinesAbove + viewLineCount;\r\n            for (let j = 0; j < viewLineCount; j++) {\r\n                this._viewToModel[viewLinesAbove + j] = i;\r\n            }\r\n        }\r\n        // trim things\r\n        this._modelToView.length = this._counts.length;\r\n        this._viewToModel.length = this._modelToView[this._modelToView.length - 1];\r\n        // mark as valid\r\n        this._isValid = true;\r\n        this._validEndIndex = this._counts.length - 1;\r\n    }\r\n    changeValue(index, value) {\r\n        if (this._counts[index] === value) {\r\n            // no change\r\n            return;\r\n        }\r\n        this._counts[index] = value;\r\n        this._invalidate(index);\r\n    }\r\n    removeValues(start, deleteCount) {\r\n        this._counts.splice(start, deleteCount);\r\n        this._invalidate(start);\r\n    }\r\n    insertValues(insertIndex, insertArr) {\r\n        this._counts = arrays.arrayInsert(this._counts, insertIndex, insertArr);\r\n        this._invalidate(insertIndex);\r\n    }\r\n    getTotalValue() {\r\n        this._ensureValid();\r\n        return this._viewToModel.length;\r\n    }\r\n    getAccumulatedValue(index) {\r\n        this._ensureValid();\r\n        return this._modelToView[index];\r\n    }\r\n    getIndexOf(accumulatedValue) {\r\n        this._ensureValid();\r\n        const modelLineIndex = this._viewToModel[accumulatedValue];\r\n        const viewLinesAbove = (modelLineIndex > 0 ? this._modelToView[modelLineIndex - 1] : 0);\r\n        return new PrefixSumIndexOfResult(modelLineIndex, accumulatedValue - viewLinesAbove);\r\n    }\r\n}\r\nexport class SplitLinesCollection {\r\n    constructor(model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\r\n        this.model = model;\r\n        this._validModelVersionId = -1;\r\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\r\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\r\n        this.fontInfo = fontInfo;\r\n        this.tabSize = tabSize;\r\n        this.wrappingStrategy = wrappingStrategy;\r\n        this.wrappingColumn = wrappingColumn;\r\n        this.wrappingIndent = wrappingIndent;\r\n        this._constructLines(/*resetHiddenAreas*/ true, null);\r\n    }\r\n    dispose() {\r\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);\r\n    }\r\n    createCoordinatesConverter() {\r\n        return new CoordinatesConverter(this);\r\n    }\r\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\r\n        this.lines = [];\r\n        if (resetHiddenAreas) {\r\n            this.hiddenAreasIds = [];\r\n        }\r\n        let linesContent = this.model.getLinesContent();\r\n        const lineCount = linesContent.length;\r\n        const lineBreaksComputer = this.createLineBreaksComputer();\r\n        for (let i = 0; i < lineCount; i++) {\r\n            lineBreaksComputer.addRequest(linesContent[i], previousLineBreaks ? previousLineBreaks[i] : null);\r\n        }\r\n        const linesBreaks = lineBreaksComputer.finalize();\r\n        let values = [];\r\n        let hiddenAreas = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\r\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\r\n        let hiddenAreaIdx = -1;\r\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            let lineNumber = i + 1;\r\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\r\n                hiddenAreaIdx++;\r\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\r\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\r\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\r\n            }\r\n            let isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\r\n            let line = createSplitLine(linesBreaks[i], !isInHiddenArea);\r\n            values[i] = line.getViewLineCount();\r\n            this.lines[i] = line;\r\n        }\r\n        this._validModelVersionId = this.model.getVersionId();\r\n        this.prefixSumComputer = new LineNumberMapper(values);\r\n    }\r\n    getHiddenAreas() {\r\n        return this.hiddenAreasIds.map((decId) => {\r\n            return this.model.getDecorationRange(decId);\r\n        });\r\n    }\r\n    _reduceRanges(_ranges) {\r\n        if (_ranges.length === 0) {\r\n            return [];\r\n        }\r\n        let ranges = _ranges.map(r => this.model.validateRange(r)).sort(Range.compareRangesUsingStarts);\r\n        let result = [];\r\n        let currentRangeStart = ranges[0].startLineNumber;\r\n        let currentRangeEnd = ranges[0].endLineNumber;\r\n        for (let i = 1, len = ranges.length; i < len; i++) {\r\n            let range = ranges[i];\r\n            if (range.startLineNumber > currentRangeEnd + 1) {\r\n                result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\r\n                currentRangeStart = range.startLineNumber;\r\n                currentRangeEnd = range.endLineNumber;\r\n            }\r\n            else if (range.endLineNumber > currentRangeEnd) {\r\n                currentRangeEnd = range.endLineNumber;\r\n            }\r\n        }\r\n        result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\r\n        return result;\r\n    }\r\n    setHiddenAreas(_ranges) {\r\n        let newRanges = this._reduceRanges(_ranges);\r\n        // BEGIN TODO@Martin: Please stop calling this method on each model change!\r\n        let oldRanges = this.hiddenAreasIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\r\n        if (newRanges.length === oldRanges.length) {\r\n            let hasDifference = false;\r\n            for (let i = 0; i < newRanges.length; i++) {\r\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\r\n                    hasDifference = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!hasDifference) {\r\n                return false;\r\n            }\r\n        }\r\n        // END TODO@Martin: Please stop calling this method on each model change!\r\n        let newDecorations = [];\r\n        for (const newRange of newRanges) {\r\n            newDecorations.push({\r\n                range: newRange,\r\n                options: ModelDecorationOptions.EMPTY\r\n            });\r\n        }\r\n        this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);\r\n        let hiddenAreas = newRanges;\r\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\r\n        let hiddenAreaIdx = -1;\r\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\r\n        let hasVisibleLine = false;\r\n        for (let i = 0; i < this.lines.length; i++) {\r\n            let lineNumber = i + 1;\r\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\r\n                hiddenAreaIdx++;\r\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\r\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\r\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;\r\n            }\r\n            let lineChanged = false;\r\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\r\n                // Line should be hidden\r\n                if (this.lines[i].isVisible()) {\r\n                    this.lines[i] = this.lines[i].setVisible(false);\r\n                    lineChanged = true;\r\n                }\r\n            }\r\n            else {\r\n                hasVisibleLine = true;\r\n                // Line should be visible\r\n                if (!this.lines[i].isVisible()) {\r\n                    this.lines[i] = this.lines[i].setVisible(true);\r\n                    lineChanged = true;\r\n                }\r\n            }\r\n            if (lineChanged) {\r\n                let newOutputLineCount = this.lines[i].getViewLineCount();\r\n                this.prefixSumComputer.changeValue(i, newOutputLineCount);\r\n            }\r\n        }\r\n        if (!hasVisibleLine) {\r\n            // Cannot have everything be hidden => reveal everything!\r\n            this.setHiddenAreas([]);\r\n        }\r\n        return true;\r\n    }\r\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\r\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\r\n            // invalid arguments\r\n            return false;\r\n        }\r\n        return this.lines[modelLineNumber - 1].isVisible();\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        if (modelLineNumber < 1 || modelLineNumber > this.lines.length) {\r\n            // invalid arguments\r\n            return 1;\r\n        }\r\n        return this.lines[modelLineNumber - 1].getViewLineCount();\r\n    }\r\n    setTabSize(newTabSize) {\r\n        if (this.tabSize === newTabSize) {\r\n            return false;\r\n        }\r\n        this.tabSize = newTabSize;\r\n        this._constructLines(/*resetHiddenAreas*/ false, null);\r\n        return true;\r\n    }\r\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\r\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\r\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\r\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\r\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\r\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\r\n            return false;\r\n        }\r\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\r\n        this.fontInfo = fontInfo;\r\n        this.wrappingStrategy = wrappingStrategy;\r\n        this.wrappingColumn = wrappingColumn;\r\n        this.wrappingIndent = wrappingIndent;\r\n        let previousLineBreaks = null;\r\n        if (onlyWrappingColumnChanged) {\r\n            previousLineBreaks = [];\r\n            for (let i = 0, len = this.lines.length; i < len; i++) {\r\n                previousLineBreaks[i] = this.lines[i].getLineBreakData();\r\n            }\r\n        }\r\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\r\n        return true;\r\n    }\r\n    createLineBreaksComputer() {\r\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\r\n            ? this._domLineBreaksComputerFactory\r\n            : this._monospaceLineBreaksComputerFactory);\r\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\r\n    }\r\n    onModelFlushed() {\r\n        this._constructLines(/*resetHiddenAreas*/ true, null);\r\n    }\r\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return null;\r\n        }\r\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\r\n        let outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);\r\n        this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\r\n        this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\r\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\r\n    }\r\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return null;\r\n        }\r\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\r\n        const isInHiddenArea = (fromLineNumber > 2 && !this.lines[fromLineNumber - 2].isVisible());\r\n        let outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);\r\n        let totalOutputLineCount = 0;\r\n        let insertLines = [];\r\n        let insertPrefixSumValues = [];\r\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\r\n            let line = createSplitLine(lineBreaks[i], !isInHiddenArea);\r\n            insertLines.push(line);\r\n            let outputLineCount = line.getViewLineCount();\r\n            totalOutputLineCount += outputLineCount;\r\n            insertPrefixSumValues[i] = outputLineCount;\r\n        }\r\n        // TODO@Alex: use arrays.arrayInsert\r\n        this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));\r\n        this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);\r\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\r\n    }\r\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\r\n        if (versionId <= this._validModelVersionId) {\r\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\r\n            // We don't want to apply stale change events on top of a newer read model state.\r\n            return [false, null, null, null];\r\n        }\r\n        let lineIndex = lineNumber - 1;\r\n        let oldOutputLineCount = this.lines[lineIndex].getViewLineCount();\r\n        let isVisible = this.lines[lineIndex].isVisible();\r\n        let line = createSplitLine(lineBreakData, isVisible);\r\n        this.lines[lineIndex] = line;\r\n        let newOutputLineCount = this.lines[lineIndex].getViewLineCount();\r\n        let lineMappingChanged = false;\r\n        let changeFrom = 0;\r\n        let changeTo = -1;\r\n        let insertFrom = 0;\r\n        let insertTo = -1;\r\n        let deleteFrom = 0;\r\n        let deleteTo = -1;\r\n        if (oldOutputLineCount > newOutputLineCount) {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + newOutputLineCount - 1;\r\n            deleteFrom = changeTo + 1;\r\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\r\n            lineMappingChanged = true;\r\n        }\r\n        else if (oldOutputLineCount < newOutputLineCount) {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + oldOutputLineCount - 1;\r\n            insertFrom = changeTo + 1;\r\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\r\n            lineMappingChanged = true;\r\n        }\r\n        else {\r\n            changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);\r\n            changeTo = changeFrom + newOutputLineCount - 1;\r\n        }\r\n        this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);\r\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\r\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\r\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\r\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\r\n    }\r\n    acceptVersionId(versionId) {\r\n        this._validModelVersionId = versionId;\r\n        if (this.lines.length === 1 && !this.lines[0].isVisible()) {\r\n            // At least one line must be visible => reset hidden areas\r\n            this.setHiddenAreas([]);\r\n        }\r\n    }\r\n    getViewLineCount() {\r\n        return this.prefixSumComputer.getTotalValue();\r\n    }\r\n    _toValidViewLineNumber(viewLineNumber) {\r\n        if (viewLineNumber < 1) {\r\n            return 1;\r\n        }\r\n        const viewLineCount = this.getViewLineCount();\r\n        if (viewLineNumber > viewLineCount) {\r\n            return viewLineCount;\r\n        }\r\n        return viewLineNumber | 0;\r\n    }\r\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\r\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\r\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\r\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\r\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\r\n        const result = this.model.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\r\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\r\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\r\n        return {\r\n            startLineNumber: viewStartPosition.lineNumber,\r\n            endLineNumber: viewEndPosition.lineNumber,\r\n            indent: result.indent\r\n        };\r\n    }\r\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\r\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\r\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\r\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\r\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\r\n        let result = [];\r\n        let resultRepeatCount = [];\r\n        let resultRepeatOption = [];\r\n        const modelStartLineIndex = modelStart.lineNumber - 1;\r\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\r\n        let reqStart = null;\r\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\r\n            const line = this.lines[modelLineIndex];\r\n            if (line.isVisible()) {\r\n                let viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\r\n                let viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\r\n                let count = viewLineEndIndex - viewLineStartIndex + 1;\r\n                let option = 0 /* BlockNone */;\r\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\r\n                    // wrapped lines should block indent guides\r\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\r\n                }\r\n                resultRepeatCount.push(count);\r\n                resultRepeatOption.push(option);\r\n                // merge into previous request\r\n                if (reqStart === null) {\r\n                    reqStart = new Position(modelLineIndex + 1, 0);\r\n                }\r\n            }\r\n            else {\r\n                // hit invisible line => flush request\r\n                if (reqStart !== null) {\r\n                    result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\r\n                    reqStart = null;\r\n                }\r\n            }\r\n        }\r\n        if (reqStart !== null) {\r\n            result = result.concat(this.model.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\r\n            reqStart = null;\r\n        }\r\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\r\n        let viewIndents = new Array(viewLineCount);\r\n        let currIndex = 0;\r\n        for (let i = 0, len = result.length; i < len; i++) {\r\n            let value = result[i];\r\n            let count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\r\n            let option = resultRepeatOption[i];\r\n            let blockAtIndex;\r\n            if (option === 2 /* BlockAll */) {\r\n                blockAtIndex = 0;\r\n            }\r\n            else if (option === 1 /* BlockSubsequent */) {\r\n                blockAtIndex = 1;\r\n            }\r\n            else {\r\n                blockAtIndex = count;\r\n            }\r\n            for (let j = 0; j < count; j++) {\r\n                if (j === blockAtIndex) {\r\n                    value = 0;\r\n                }\r\n                viewIndents[currIndex++] = value;\r\n            }\r\n        }\r\n        return viewIndents;\r\n    }\r\n    getViewLineContent(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineContent(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineLength(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineLength(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineMinColumn(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineMinColumn(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineMaxColumn(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLineData(viewLineNumber) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        return this.lines[lineIndex].getViewLineData(this.model, lineIndex + 1, remainder);\r\n    }\r\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\r\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\r\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\r\n        let start = this.prefixSumComputer.getIndexOf(viewStartLineNumber - 1);\r\n        let viewLineNumber = viewStartLineNumber;\r\n        let startModelLineIndex = start.index;\r\n        let startRemainder = start.remainder;\r\n        let result = [];\r\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\r\n            let line = this.lines[modelLineIndex];\r\n            if (!line.isVisible()) {\r\n                continue;\r\n            }\r\n            let fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\r\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\r\n            let lastLine = false;\r\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\r\n                lastLine = true;\r\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\r\n            }\r\n            let toViewLineIndex = fromViewLineIndex + remainingViewLineCount;\r\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, toViewLineIndex, viewLineNumber - viewStartLineNumber, needed, result);\r\n            viewLineNumber += remainingViewLineCount;\r\n            if (lastLine) {\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        let line = this.lines[lineIndex];\r\n        let minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\r\n        let maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\r\n        if (viewColumn < minColumn) {\r\n            viewColumn = minColumn;\r\n        }\r\n        if (viewColumn > maxColumn) {\r\n            viewColumn = maxColumn;\r\n        }\r\n        let computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\r\n        let computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\r\n        if (computedModelPosition.equals(expectedModelPosition)) {\r\n            return new Position(viewLineNumber, viewColumn);\r\n        }\r\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\r\n    }\r\n    validateViewRange(viewRange, expectedModelRange) {\r\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\r\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\r\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\r\n    }\r\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\r\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\r\n        let r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);\r\n        let lineIndex = r.index;\r\n        let remainder = r.remainder;\r\n        let inputColumn = this.lines[lineIndex].getModelColumnOfViewPosition(remainder, viewColumn);\r\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\r\n        return this.model.validatePosition(new Position(lineIndex + 1, inputColumn));\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\r\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn) {\r\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\r\n        const inputLineNumber = validPosition.lineNumber;\r\n        const inputColumn = validPosition.column;\r\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\r\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\r\n            lineIndex--;\r\n            lineIndexChanged = true;\r\n        }\r\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\r\n            // Could not reach a real line\r\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\r\n            return new Position(1, 1);\r\n        }\r\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n        let r;\r\n        if (lineIndexChanged) {\r\n            r = this.lines[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\r\n        }\r\n        else {\r\n            r = this.lines[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn);\r\n        }\r\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\r\n        return r;\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        let start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);\r\n        let end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);\r\n        if (modelRange.startLineNumber === modelRange.endLineNumber && start.lineNumber !== end.lineNumber) {\r\n            // This is a single line range that ends up taking more lines due to wrapping\r\n            if (end.column === this.getViewLineMinColumn(end.lineNumber)) {\r\n                // the end column lands on the first column of the next line\r\n                return new Range(start.lineNumber, start.column, end.lineNumber - 1, this.getViewLineMaxColumn(end.lineNumber - 1));\r\n            }\r\n        }\r\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\r\n    }\r\n    _getViewLineNumberForModelPosition(inputLineNumber, inputColumn) {\r\n        let lineIndex = inputLineNumber - 1;\r\n        if (this.lines[lineIndex].isVisible()) {\r\n            // this model line is visible\r\n            const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n            return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn);\r\n        }\r\n        // this model line is not visible\r\n        while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {\r\n            lineIndex--;\r\n        }\r\n        if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {\r\n            // Could not reach a real line\r\n            return 1;\r\n        }\r\n        const deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));\r\n        return this.lines[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\r\n    }\r\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\r\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\r\n        const result = new OverviewRulerDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.overviewRuler;\r\n            const lane = opts ? opts.position : 0;\r\n            if (lane === 0) {\r\n                continue;\r\n            }\r\n            const color = opts.getColor(theme);\r\n            const viewStartLineNumber = this._getViewLineNumberForModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\r\n            const viewEndLineNumber = this._getViewLineNumberForModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\r\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\r\n        }\r\n        return result.result;\r\n    }\r\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\r\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\r\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\r\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\r\n            // most likely there are no hidden lines => fast path\r\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\r\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\r\n        }\r\n        let result = [];\r\n        const modelStartLineIndex = modelStart.lineNumber - 1;\r\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\r\n        let reqStart = null;\r\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\r\n            const line = this.lines[modelLineIndex];\r\n            if (line.isVisible()) {\r\n                // merge into previous request\r\n                if (reqStart === null) {\r\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\r\n                }\r\n            }\r\n            else {\r\n                // hit invisible line => flush request\r\n                if (reqStart !== null) {\r\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\r\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\r\n                    reqStart = null;\r\n                }\r\n            }\r\n        }\r\n        if (reqStart !== null) {\r\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\r\n            reqStart = null;\r\n        }\r\n        result.sort((a, b) => {\r\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\r\n            if (res === 0) {\r\n                if (a.id < b.id) {\r\n                    return -1;\r\n                }\r\n                if (a.id > b.id) {\r\n                    return 1;\r\n                }\r\n                return 0;\r\n            }\r\n            return res;\r\n        });\r\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\r\n        let finalResult = [], finalResultLen = 0;\r\n        let prevDecId = null;\r\n        for (const dec of result) {\r\n            const decId = dec.id;\r\n            if (prevDecId === decId) {\r\n                // skip\r\n                continue;\r\n            }\r\n            prevDecId = decId;\r\n            finalResult[finalResultLen++] = dec;\r\n        }\r\n        return finalResult;\r\n    }\r\n}\r\nclass VisibleIdentitySplitLine {\r\n    constructor() { }\r\n    isVisible() {\r\n        return true;\r\n    }\r\n    setVisible(isVisible) {\r\n        if (isVisible) {\r\n            return this;\r\n        }\r\n        return InvisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    getLineBreakData() {\r\n        return null;\r\n    }\r\n    getViewLineCount() {\r\n        return 1;\r\n    }\r\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineContent(modelLineNumber);\r\n    }\r\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineLength(modelLineNumber);\r\n    }\r\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineMinColumn(modelLineNumber);\r\n    }\r\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\r\n        return model.getLineMaxColumn(modelLineNumber);\r\n    }\r\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\r\n        let lineTokens = model.getLineTokens(modelLineNumber);\r\n        let lineContent = lineTokens.getLineContent();\r\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\r\n    }\r\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\r\n        if (!needed[globalStartIndex]) {\r\n            result[globalStartIndex] = null;\r\n            return;\r\n        }\r\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\r\n    }\r\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\r\n        return outputColumn;\r\n    }\r\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\r\n        return new Position(deltaLineNumber, inputColumn);\r\n    }\r\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\r\n        return deltaLineNumber;\r\n    }\r\n}\r\nVisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();\r\nclass InvisibleIdentitySplitLine {\r\n    constructor() { }\r\n    isVisible() {\r\n        return false;\r\n    }\r\n    setVisible(isVisible) {\r\n        if (!isVisible) {\r\n            return this;\r\n        }\r\n        return VisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    getLineBreakData() {\r\n        return null;\r\n    }\r\n    getViewLineCount() {\r\n        return 0;\r\n    }\r\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\r\n        throw new Error('Not supported');\r\n    }\r\n}\r\nInvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();\r\nexport class SplitLine {\r\n    constructor(lineBreakData, isVisible) {\r\n        this._lineBreakData = lineBreakData;\r\n        this._isVisible = isVisible;\r\n    }\r\n    isVisible() {\r\n        return this._isVisible;\r\n    }\r\n    setVisible(isVisible) {\r\n        this._isVisible = isVisible;\r\n        return this;\r\n    }\r\n    getLineBreakData() {\r\n        return this._lineBreakData;\r\n    }\r\n    getViewLineCount() {\r\n        if (!this._isVisible) {\r\n            return 0;\r\n        }\r\n        return this._lineBreakData.breakOffsets.length;\r\n    }\r\n    getInputStartOffsetOfOutputLineIndex(outputLineIndex) {\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, 0);\r\n    }\r\n    getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex) {\r\n        if (outputLineIndex + 1 === this._lineBreakData.breakOffsets.length) {\r\n            return model.getLineMaxColumn(modelLineNumber) - 1;\r\n        }\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex + 1, 0);\r\n    }\r\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let r = model.getValueInRange({\r\n            startLineNumber: modelLineNumber,\r\n            startColumn: startOffset + 1,\r\n            endLineNumber: modelLineNumber,\r\n            endColumn: endOffset + 1\r\n        });\r\n        if (outputLineIndex > 0) {\r\n            r = spaces(this._lineBreakData.wrappedTextIndentLength) + r;\r\n        }\r\n        return r;\r\n    }\r\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let r = endOffset - startOffset;\r\n        if (outputLineIndex > 0) {\r\n            r = this._lineBreakData.wrappedTextIndentLength + r;\r\n        }\r\n        return r;\r\n    }\r\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        if (outputLineIndex > 0) {\r\n            return this._lineBreakData.wrappedTextIndentLength + 1;\r\n        }\r\n        return 1;\r\n    }\r\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        return this.getViewLineContent(model, modelLineNumber, outputLineIndex).length + 1;\r\n    }\r\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);\r\n        let endOffset = this.getInputEndOffsetOfOutputLineIndex(model, modelLineNumber, outputLineIndex);\r\n        let lineContent = model.getValueInRange({\r\n            startLineNumber: modelLineNumber,\r\n            startColumn: startOffset + 1,\r\n            endLineNumber: modelLineNumber,\r\n            endColumn: endOffset + 1\r\n        });\r\n        if (outputLineIndex > 0) {\r\n            lineContent = spaces(this._lineBreakData.wrappedTextIndentLength) + lineContent;\r\n        }\r\n        let minColumn = (outputLineIndex > 0 ? this._lineBreakData.wrappedTextIndentLength + 1 : 1);\r\n        let maxColumn = lineContent.length + 1;\r\n        let continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\r\n        let deltaStartIndex = 0;\r\n        if (outputLineIndex > 0) {\r\n            deltaStartIndex = this._lineBreakData.wrappedTextIndentLength;\r\n        }\r\n        let lineTokens = model.getLineTokens(modelLineNumber);\r\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : this._lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\r\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex));\r\n    }\r\n    getViewLinesData(model, modelLineNumber, fromOuputLineIndex, toOutputLineIndex, globalStartIndex, needed, result) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        for (let outputLineIndex = fromOuputLineIndex; outputLineIndex < toOutputLineIndex; outputLineIndex++) {\r\n            let globalIndex = globalStartIndex + outputLineIndex - fromOuputLineIndex;\r\n            if (!needed[globalIndex]) {\r\n                result[globalIndex] = null;\r\n                continue;\r\n            }\r\n            result[globalIndex] = this.getViewLineData(model, modelLineNumber, outputLineIndex);\r\n        }\r\n    }\r\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let adjustedColumn = outputColumn - 1;\r\n        if (outputLineIndex > 0) {\r\n            if (adjustedColumn < this._lineBreakData.wrappedTextIndentLength) {\r\n                adjustedColumn = 0;\r\n            }\r\n            else {\r\n                adjustedColumn -= this._lineBreakData.wrappedTextIndentLength;\r\n            }\r\n        }\r\n        return LineBreakData.getInputOffsetOfOutputPosition(this._lineBreakData.breakOffsets, outputLineIndex, adjustedColumn) + 1;\r\n    }\r\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        let r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\r\n        let outputLineIndex = r.outputLineIndex;\r\n        let outputColumn = r.outputOffset + 1;\r\n        if (outputLineIndex > 0) {\r\n            outputColumn += this._lineBreakData.wrappedTextIndentLength;\r\n        }\r\n        //\t\tconsole.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);\r\n        return new Position(deltaLineNumber + outputLineIndex, outputColumn);\r\n    }\r\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\r\n        if (!this._isVisible) {\r\n            throw new Error('Not supported');\r\n        }\r\n        const r = LineBreakData.getOutputPositionOfInputOffset(this._lineBreakData.breakOffsets, inputColumn - 1);\r\n        return (deltaLineNumber + r.outputLineIndex);\r\n    }\r\n}\r\nlet _spaces = [''];\r\nfunction spaces(count) {\r\n    if (count >= _spaces.length) {\r\n        for (let i = 1; i <= count; i++) {\r\n            _spaces[i] = _makeSpaces(i);\r\n        }\r\n    }\r\n    return _spaces[count];\r\n}\r\nfunction _makeSpaces(count) {\r\n    return new Array(count + 1).join(' ');\r\n}\r\nfunction createSplitLine(lineBreakData, isVisible) {\r\n    if (lineBreakData === null) {\r\n        // No mapping needed\r\n        if (isVisible) {\r\n            return VisibleIdentitySplitLine.INSTANCE;\r\n        }\r\n        return InvisibleIdentitySplitLine.INSTANCE;\r\n    }\r\n    else {\r\n        return new SplitLine(lineBreakData, isVisible);\r\n    }\r\n}\r\nexport class IdentityCoordinatesConverter {\r\n    constructor(lines) {\r\n        this._lines = lines;\r\n    }\r\n    _validPosition(pos) {\r\n        return this._lines.model.validatePosition(pos);\r\n    }\r\n    _validRange(range) {\r\n        return this._lines.model.validateRange(range);\r\n    }\r\n    // View -> Model conversion and related methods\r\n    convertViewPositionToModelPosition(viewPosition) {\r\n        return this._validPosition(viewPosition);\r\n    }\r\n    convertViewRangeToModelRange(viewRange) {\r\n        return this._validRange(viewRange);\r\n    }\r\n    validateViewPosition(_viewPosition, expectedModelPosition) {\r\n        return this._validPosition(expectedModelPosition);\r\n    }\r\n    validateViewRange(_viewRange, expectedModelRange) {\r\n        return this._validRange(expectedModelRange);\r\n    }\r\n    // Model -> View conversion and related methods\r\n    convertModelPositionToViewPosition(modelPosition) {\r\n        return this._validPosition(modelPosition);\r\n    }\r\n    convertModelRangeToViewRange(modelRange) {\r\n        return this._validRange(modelRange);\r\n    }\r\n    modelPositionIsVisible(modelPosition) {\r\n        const lineCount = this._lines.model.getLineCount();\r\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\r\n            // invalid arguments\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    getModelLineViewLineCount(modelLineNumber) {\r\n        return 1;\r\n    }\r\n}\r\nexport class IdentityLinesCollection {\r\n    constructor(model) {\r\n        this.model = model;\r\n    }\r\n    dispose() {\r\n    }\r\n    createCoordinatesConverter() {\r\n        return new IdentityCoordinatesConverter(this);\r\n    }\r\n    getHiddenAreas() {\r\n        return [];\r\n    }\r\n    setHiddenAreas(_ranges) {\r\n        return false;\r\n    }\r\n    setTabSize(_newTabSize) {\r\n        return false;\r\n    }\r\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\r\n        return false;\r\n    }\r\n    createLineBreaksComputer() {\r\n        let result = [];\r\n        return {\r\n            addRequest: (lineText, previousLineBreakData) => {\r\n                result.push(null);\r\n            },\r\n            finalize: () => {\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n    onModelFlushed() {\r\n    }\r\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\r\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\r\n    }\r\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\r\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\r\n    }\r\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\r\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\r\n    }\r\n    acceptVersionId(_versionId) {\r\n    }\r\n    getViewLineCount() {\r\n        return this.model.getLineCount();\r\n    }\r\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\r\n        return {\r\n            startLineNumber: viewLineNumber,\r\n            endLineNumber: viewLineNumber,\r\n            indent: 0\r\n        };\r\n    }\r\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\r\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\r\n        let result = new Array(viewLineCount);\r\n        for (let i = 0; i < viewLineCount; i++) {\r\n            result[i] = 0;\r\n        }\r\n        return result;\r\n    }\r\n    getViewLineContent(viewLineNumber) {\r\n        return this.model.getLineContent(viewLineNumber);\r\n    }\r\n    getViewLineLength(viewLineNumber) {\r\n        return this.model.getLineLength(viewLineNumber);\r\n    }\r\n    getViewLineMinColumn(viewLineNumber) {\r\n        return this.model.getLineMinColumn(viewLineNumber);\r\n    }\r\n    getViewLineMaxColumn(viewLineNumber) {\r\n        return this.model.getLineMaxColumn(viewLineNumber);\r\n    }\r\n    getViewLineData(viewLineNumber) {\r\n        let lineTokens = this.model.getLineTokens(viewLineNumber);\r\n        let lineContent = lineTokens.getLineContent();\r\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate());\r\n    }\r\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\r\n        const lineCount = this.model.getLineCount();\r\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\r\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\r\n        let result = [];\r\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\r\n            let idx = lineNumber - viewStartLineNumber;\r\n            if (!needed[idx]) {\r\n                result[idx] = null;\r\n            }\r\n            result[idx] = this.getViewLineData(lineNumber);\r\n        }\r\n        return result;\r\n    }\r\n    getAllOverviewRulerDecorations(ownerId, filterOutValidation, theme) {\r\n        const decorations = this.model.getOverviewRulerDecorations(ownerId, filterOutValidation);\r\n        const result = new OverviewRulerDecorations();\r\n        for (const decoration of decorations) {\r\n            const opts = decoration.options.overviewRuler;\r\n            const lane = opts ? opts.position : 0;\r\n            if (lane === 0) {\r\n                continue;\r\n            }\r\n            const color = opts.getColor(theme);\r\n            const viewStartLineNumber = decoration.range.startLineNumber;\r\n            const viewEndLineNumber = decoration.range.endLineNumber;\r\n            result.accept(color, viewStartLineNumber, viewEndLineNumber, lane);\r\n        }\r\n        return result.result;\r\n    }\r\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\r\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\r\n    }\r\n}\r\nclass OverviewRulerDecorations {\r\n    constructor() {\r\n        this.result = Object.create(null);\r\n    }\r\n    accept(color, startLineNumber, endLineNumber, lane) {\r\n        let prev = this.result[color];\r\n        if (prev) {\r\n            const prevLane = prev[prev.length - 3];\r\n            const prevEndLineNumber = prev[prev.length - 1];\r\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\r\n                // merge into prev\r\n                if (endLineNumber > prevEndLineNumber) {\r\n                    prev[prev.length - 1] = endLineNumber;\r\n                }\r\n                return;\r\n            }\r\n            // push\r\n            prev.push(lane, startLineNumber, endLineNumber);\r\n        }\r\n        else {\r\n            this.result[color] = [lane, startLineNumber, endLineNumber];\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}