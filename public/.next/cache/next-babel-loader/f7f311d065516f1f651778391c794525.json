{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../common/iterator.js';\nimport { Event } from '../../../common/event.js';\nimport { TreeError, WeakMapper } from './tree.js';\nimport { ObjectTreeModel } from './objectTreeModel.js';\n\nfunction noCompress(element) {\n  var elements = [element.element];\n  var incompressible = element.incompressible || false;\n  return {\n    element: {\n      elements: elements,\n      incompressible: incompressible\n    },\n    children: Iterable.map(Iterable.from(element.children), noCompress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n} // Exported only for test reasons, do not use directly\n\n\nexport function compress(element) {\n  var elements = [element.element];\n  var incompressible = element.incompressible || false;\n  var childrenIterator;\n  var children;\n\n  while (true) {\n    var _Iterable$consume = Iterable.consume(Iterable.from(element.children), 2);\n\n    var _Iterable$consume2 = _slicedToArray(_Iterable$consume, 2);\n\n    children = _Iterable$consume2[0];\n    childrenIterator = _Iterable$consume2[1];\n\n    if (children.length !== 1) {\n      break;\n    }\n\n    if (children[0].incompressible) {\n      break;\n    }\n\n    element = children[0];\n    elements.push(element.element);\n  }\n\n  return {\n    element: {\n      elements: elements,\n      incompressible: incompressible\n    },\n    children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n}\n\nfunction _decompress(element) {\n  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var children;\n\n  if (index < element.element.elements.length - 1) {\n    children = [_decompress(element, index + 1)];\n  } else {\n    children = Iterable.map(Iterable.from(element.children), function (el) {\n      return _decompress(el, 0);\n    });\n  }\n\n  if (index === 0 && element.element.incompressible) {\n    return {\n      element: element.element.elements[index],\n      children: children,\n      incompressible: true,\n      collapsible: element.collapsible,\n      collapsed: element.collapsed\n    };\n  }\n\n  return {\n    element: element.element.elements[index],\n    children: children,\n    collapsible: element.collapsible,\n    collapsed: element.collapsed\n  };\n} // Exported only for test reasons, do not use directly\n\n\nexport function decompress(element) {\n  return _decompress(element, 0);\n}\n\nfunction splice(treeElement, element, children) {\n  if (treeElement.element === element) {\n    return Object.assign(Object.assign({}, treeElement), {\n      children: children\n    });\n  }\n\n  return Object.assign(Object.assign({}, treeElement), {\n    children: Iterable.map(Iterable.from(treeElement.children), function (e) {\n      return splice(e, element, children);\n    })\n  });\n}\n\nvar wrapIdentityProvider = function wrapIdentityProvider(base) {\n  return {\n    getId: function getId(node) {\n      return node.elements.map(function (e) {\n        return base.getId(e).toString();\n      }).join('\\0');\n    }\n  };\n}; // Exported only for test reasons, do not use directly\n\n\nexport var CompressedObjectTreeModel = /*#__PURE__*/function () {\n  function CompressedObjectTreeModel(user, list) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, CompressedObjectTreeModel);\n\n    this.user = user;\n    this.rootRef = null;\n    this.nodes = new Map();\n    this.model = new ObjectTreeModel(user, list, options);\n    this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\n    this.identityProvider = options.identityProvider;\n  }\n\n  _createClass(CompressedObjectTreeModel, [{\n    key: \"setChildren\",\n    value: function setChildren(element) {\n      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n      var options = arguments.length > 2 ? arguments[2] : undefined;\n      // Diffs must be deem, since the compression can affect nested elements.\n      // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\n      var diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\n\n      if (element === null) {\n        var compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\n\n        this._setChildren(null, compressedChildren, {\n          diffIdentityProvider: diffIdentityProvider,\n          diffDepth: Infinity\n        });\n\n        return;\n      }\n\n      var compressedNode = this.nodes.get(element);\n\n      if (!compressedNode) {\n        throw new Error('Unknown compressed tree node');\n      }\n\n      var node = this.model.getNode(compressedNode);\n      var compressedParentNode = this.model.getParentNodeLocation(compressedNode);\n      var parent = this.model.getNode(compressedParentNode);\n      var decompressedElement = decompress(node);\n      var splicedElement = splice(decompressedElement, element, children);\n      var recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\n      var parentChildren = parent.children.map(function (child) {\n        return child === node ? recompressedElement : child;\n      });\n\n      this._setChildren(parent.element, parentChildren, {\n        diffIdentityProvider: diffIdentityProvider,\n        diffDepth: node.depth - parent.depth\n      });\n    }\n  }, {\n    key: \"setCompressionEnabled\",\n    value: function setCompressionEnabled(enabled) {\n      if (enabled === this.enabled) {\n        return;\n      }\n\n      this.enabled = enabled;\n      var root = this.model.getNode();\n      var rootChildren = root.children;\n      var decompressedRootChildren = Iterable.map(rootChildren, decompress);\n      var recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress); // it should be safe to always use deep diff mode here if an identity\n      // provider is available, since we know the raw nodes are unchanged.\n\n      this._setChildren(null, recompressedRootChildren, {\n        diffIdentityProvider: this.identityProvider,\n        diffDepth: Infinity\n      });\n    }\n  }, {\n    key: \"_setChildren\",\n    value: function _setChildren(node, children, options) {\n      var _this = this;\n\n      var insertedElements = new Set();\n\n      var onDidCreateNode = function onDidCreateNode(node) {\n        var _iterator = _createForOfIteratorHelper(node.element.elements),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var element = _step.value;\n            insertedElements.add(element);\n\n            _this.nodes.set(element, node.element);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      };\n\n      var onDidDeleteNode = function onDidDeleteNode(node) {\n        var _iterator2 = _createForOfIteratorHelper(node.element.elements),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var element = _step2.value;\n\n            if (!insertedElements.has(element)) {\n              _this.nodes[\"delete\"](element);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      };\n\n      this.model.setChildren(node, children, Object.assign(Object.assign({}, options), {\n        onDidCreateNode: onDidCreateNode,\n        onDidDeleteNode: onDidDeleteNode\n      }));\n    }\n  }, {\n    key: \"has\",\n    value: function has(element) {\n      return this.nodes.has(element);\n    }\n  }, {\n    key: \"getListIndex\",\n    value: function getListIndex(location) {\n      var node = this.getCompressedNode(location);\n      return this.model.getListIndex(node);\n    }\n  }, {\n    key: \"getListRenderCount\",\n    value: function getListRenderCount(location) {\n      var node = this.getCompressedNode(location);\n      return this.model.getListRenderCount(node);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(location) {\n      if (typeof location === 'undefined') {\n        return this.model.getNode();\n      }\n\n      var node = this.getCompressedNode(location);\n      return this.model.getNode(node);\n    } // TODO: review this\n\n  }, {\n    key: \"getNodeLocation\",\n    value: function getNodeLocation(node) {\n      var compressedNode = this.model.getNodeLocation(node);\n\n      if (compressedNode === null) {\n        return null;\n      }\n\n      return compressedNode.elements[compressedNode.elements.length - 1];\n    } // TODO: review this\n\n  }, {\n    key: \"getParentNodeLocation\",\n    value: function getParentNodeLocation(location) {\n      var compressedNode = this.getCompressedNode(location);\n      var parentNode = this.model.getParentNodeLocation(compressedNode);\n\n      if (parentNode === null) {\n        return null;\n      }\n\n      return parentNode.elements[parentNode.elements.length - 1];\n    }\n  }, {\n    key: \"isCollapsible\",\n    value: function isCollapsible(location) {\n      var compressedNode = this.getCompressedNode(location);\n      return this.model.isCollapsible(compressedNode);\n    }\n  }, {\n    key: \"setCollapsible\",\n    value: function setCollapsible(location, collapsible) {\n      var compressedNode = this.getCompressedNode(location);\n      return this.model.setCollapsible(compressedNode, collapsible);\n    }\n  }, {\n    key: \"isCollapsed\",\n    value: function isCollapsed(location) {\n      var compressedNode = this.getCompressedNode(location);\n      return this.model.isCollapsed(compressedNode);\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(location, collapsed, recursive) {\n      var compressedNode = this.getCompressedNode(location);\n      return this.model.setCollapsed(compressedNode, collapsed, recursive);\n    }\n  }, {\n    key: \"expandTo\",\n    value: function expandTo(location) {\n      var compressedNode = this.getCompressedNode(location);\n      this.model.expandTo(compressedNode);\n    }\n  }, {\n    key: \"rerender\",\n    value: function rerender(location) {\n      var compressedNode = this.getCompressedNode(location);\n      this.model.rerender(compressedNode);\n    }\n  }, {\n    key: \"refilter\",\n    value: function refilter() {\n      this.model.refilter();\n    }\n  }, {\n    key: \"getCompressedNode\",\n    value: function getCompressedNode(element) {\n      if (element === null) {\n        return null;\n      }\n\n      var node = this.nodes.get(element);\n\n      if (!node) {\n        throw new TreeError(this.user, \"Tree element not found: \".concat(element));\n      }\n\n      return node;\n    }\n  }, {\n    key: \"onDidSplice\",\n    get: function get() {\n      return this.model.onDidSplice;\n    }\n  }, {\n    key: \"onDidChangeCollapseState\",\n    get: function get() {\n      return this.model.onDidChangeCollapseState;\n    }\n  }, {\n    key: \"onDidChangeRenderNodeCount\",\n    get: function get() {\n      return this.model.onDidChangeRenderNodeCount;\n    }\n  }]);\n\n  return CompressedObjectTreeModel;\n}();\nexport var DefaultElementMapper = function DefaultElementMapper(elements) {\n  return elements[elements.length - 1];\n};\n_c = DefaultElementMapper;\n\nvar CompressedTreeNodeWrapper = /*#__PURE__*/function () {\n  function CompressedTreeNodeWrapper(unwrapper, node) {\n    _classCallCheck(this, CompressedTreeNodeWrapper);\n\n    this.unwrapper = unwrapper;\n    this.node = node;\n  }\n\n  _createClass(CompressedTreeNodeWrapper, [{\n    key: \"element\",\n    get: function get() {\n      return this.node.element === null ? null : this.unwrapper(this.node.element);\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      var _this2 = this;\n\n      return this.node.children.map(function (node) {\n        return new CompressedTreeNodeWrapper(_this2.unwrapper, node);\n      });\n    }\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.node.depth;\n    }\n  }, {\n    key: \"visibleChildrenCount\",\n    get: function get() {\n      return this.node.visibleChildrenCount;\n    }\n  }, {\n    key: \"visibleChildIndex\",\n    get: function get() {\n      return this.node.visibleChildIndex;\n    }\n  }, {\n    key: \"collapsible\",\n    get: function get() {\n      return this.node.collapsible;\n    }\n  }, {\n    key: \"collapsed\",\n    get: function get() {\n      return this.node.collapsed;\n    }\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this.node.visible;\n    }\n  }, {\n    key: \"filterData\",\n    get: function get() {\n      return this.node.filterData;\n    }\n  }]);\n\n  return CompressedTreeNodeWrapper;\n}();\n\nfunction mapList(nodeMapper, list) {\n  return {\n    splice: function splice(start, deleteCount, toInsert) {\n      list.splice(start, deleteCount, toInsert.map(function (node) {\n        return nodeMapper.map(node);\n      }));\n    },\n    updateElementHeight: function updateElementHeight(index, height) {\n      list.updateElementHeight(index, height);\n    }\n  };\n}\n\nfunction mapOptions(compressedNodeUnwrapper, options) {\n  return Object.assign(Object.assign({}, options), {\n    identityProvider: options.identityProvider && {\n      getId: function getId(node) {\n        return options.identityProvider.getId(compressedNodeUnwrapper(node));\n      }\n    },\n    sorter: options.sorter && {\n      compare: function compare(node, otherNode) {\n        return options.sorter.compare(node.elements[0], otherNode.elements[0]);\n      }\n    },\n    filter: options.filter && {\n      filter: function filter(node, parentVisibility) {\n        return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\n      }\n    }\n  });\n}\n\nexport var CompressibleObjectTreeModel = /*#__PURE__*/function () {\n  function CompressibleObjectTreeModel(user, list) {\n    var _this3 = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, CompressibleObjectTreeModel);\n\n    this.rootRef = null;\n    this.elementMapper = options.elementMapper || DefaultElementMapper;\n\n    var compressedNodeUnwrapper = function compressedNodeUnwrapper(node) {\n      return _this3.elementMapper(node.elements);\n    };\n\n    this.nodeMapper = new WeakMapper(function (node) {\n      return new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node);\n    });\n    this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\n  }\n\n  _createClass(CompressibleObjectTreeModel, [{\n    key: \"setChildren\",\n    value: function setChildren(element) {\n      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Iterable.empty();\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.model.setChildren(element, children, options);\n    }\n  }, {\n    key: \"setCompressionEnabled\",\n    value: function setCompressionEnabled(enabled) {\n      this.model.setCompressionEnabled(enabled);\n    }\n  }, {\n    key: \"has\",\n    value: function has(location) {\n      return this.model.has(location);\n    }\n  }, {\n    key: \"getListIndex\",\n    value: function getListIndex(location) {\n      return this.model.getListIndex(location);\n    }\n  }, {\n    key: \"getListRenderCount\",\n    value: function getListRenderCount(location) {\n      return this.model.getListRenderCount(location);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(location) {\n      return this.nodeMapper.map(this.model.getNode(location));\n    }\n  }, {\n    key: \"getNodeLocation\",\n    value: function getNodeLocation(node) {\n      return node.element;\n    }\n  }, {\n    key: \"getParentNodeLocation\",\n    value: function getParentNodeLocation(location) {\n      return this.model.getParentNodeLocation(location);\n    }\n  }, {\n    key: \"isCollapsible\",\n    value: function isCollapsible(location) {\n      return this.model.isCollapsible(location);\n    }\n  }, {\n    key: \"setCollapsible\",\n    value: function setCollapsible(location, collapsed) {\n      return this.model.setCollapsible(location, collapsed);\n    }\n  }, {\n    key: \"isCollapsed\",\n    value: function isCollapsed(location) {\n      return this.model.isCollapsed(location);\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(location, collapsed, recursive) {\n      return this.model.setCollapsed(location, collapsed, recursive);\n    }\n  }, {\n    key: \"expandTo\",\n    value: function expandTo(location) {\n      return this.model.expandTo(location);\n    }\n  }, {\n    key: \"rerender\",\n    value: function rerender(location) {\n      return this.model.rerender(location);\n    }\n  }, {\n    key: \"refilter\",\n    value: function refilter() {\n      return this.model.refilter();\n    }\n  }, {\n    key: \"getCompressedTreeNode\",\n    value: function getCompressedTreeNode() {\n      var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      return this.model.getNode(location);\n    }\n  }, {\n    key: \"onDidSplice\",\n    get: function get() {\n      var _this4 = this;\n\n      return Event.map(this.model.onDidSplice, function (_ref) {\n        var insertedNodes = _ref.insertedNodes,\n            deletedNodes = _ref.deletedNodes;\n        return {\n          insertedNodes: insertedNodes.map(function (node) {\n            return _this4.nodeMapper.map(node);\n          }),\n          deletedNodes: deletedNodes.map(function (node) {\n            return _this4.nodeMapper.map(node);\n          })\n        };\n      });\n    }\n  }, {\n    key: \"onDidChangeCollapseState\",\n    get: function get() {\n      var _this5 = this;\n\n      return Event.map(this.model.onDidChangeCollapseState, function (_ref2) {\n        var node = _ref2.node,\n            deep = _ref2.deep;\n        return {\n          node: _this5.nodeMapper.map(node),\n          deep: deep\n        };\n      });\n    }\n  }, {\n    key: \"onDidChangeRenderNodeCount\",\n    get: function get() {\n      var _this6 = this;\n\n      return Event.map(this.model.onDidChangeRenderNodeCount, function (node) {\n        return _this6.nodeMapper.map(node);\n      });\n    }\n  }]);\n\n  return CompressibleObjectTreeModel;\n}();\n\nvar _c;\n\n$RefreshReg$(_c, \"DefaultElementMapper\");","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/compressedObjectTreeModel.js"],"names":["Iterable","Event","TreeError","WeakMapper","ObjectTreeModel","noCompress","element","elements","incompressible","children","map","from","collapsible","collapsed","compress","childrenIterator","consume","length","push","concat","_decompress","index","el","decompress","splice","treeElement","Object","assign","e","wrapIdentityProvider","base","getId","node","toString","join","CompressedObjectTreeModel","user","list","options","rootRef","nodes","Map","model","enabled","compressionEnabled","identityProvider","empty","diffIdentityProvider","compressedChildren","_setChildren","diffDepth","Infinity","compressedNode","get","Error","getNode","compressedParentNode","getParentNodeLocation","parent","decompressedElement","splicedElement","recompressedElement","parentChildren","child","depth","root","rootChildren","decompressedRootChildren","recompressedRootChildren","insertedElements","Set","onDidCreateNode","add","set","onDidDeleteNode","has","setChildren","location","getCompressedNode","getListIndex","getListRenderCount","getNodeLocation","parentNode","isCollapsible","setCollapsible","isCollapsed","recursive","setCollapsed","expandTo","rerender","refilter","onDidSplice","onDidChangeCollapseState","onDidChangeRenderNodeCount","DefaultElementMapper","CompressedTreeNodeWrapper","unwrapper","visibleChildrenCount","visibleChildIndex","visible","filterData","mapList","nodeMapper","start","deleteCount","toInsert","updateElementHeight","height","mapOptions","compressedNodeUnwrapper","sorter","compare","otherNode","filter","parentVisibility","CompressibleObjectTreeModel","elementMapper","setCompressionEnabled","insertedNodes","deletedNodes","deep"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Iterable } from '../../../common/iterator.js';\r\nimport { Event } from '../../../common/event.js';\r\nimport { TreeError, WeakMapper } from './tree.js';\r\nimport { ObjectTreeModel } from './objectTreeModel.js';\r\nfunction noCompress(element) {\r\n    const elements = [element.element];\r\n    const incompressible = element.incompressible || false;\r\n    return {\r\n        element: { elements, incompressible },\r\n        children: Iterable.map(Iterable.from(element.children), noCompress),\r\n        collapsible: element.collapsible,\r\n        collapsed: element.collapsed\r\n    };\r\n}\r\n// Exported only for test reasons, do not use directly\r\nexport function compress(element) {\r\n    const elements = [element.element];\r\n    const incompressible = element.incompressible || false;\r\n    let childrenIterator;\r\n    let children;\r\n    while (true) {\r\n        [children, childrenIterator] = Iterable.consume(Iterable.from(element.children), 2);\r\n        if (children.length !== 1) {\r\n            break;\r\n        }\r\n        if (children[0].incompressible) {\r\n            break;\r\n        }\r\n        element = children[0];\r\n        elements.push(element.element);\r\n    }\r\n    return {\r\n        element: { elements, incompressible },\r\n        children: Iterable.map(Iterable.concat(children, childrenIterator), compress),\r\n        collapsible: element.collapsible,\r\n        collapsed: element.collapsed\r\n    };\r\n}\r\nfunction _decompress(element, index = 0) {\r\n    let children;\r\n    if (index < element.element.elements.length - 1) {\r\n        children = [_decompress(element, index + 1)];\r\n    }\r\n    else {\r\n        children = Iterable.map(Iterable.from(element.children), el => _decompress(el, 0));\r\n    }\r\n    if (index === 0 && element.element.incompressible) {\r\n        return {\r\n            element: element.element.elements[index],\r\n            children,\r\n            incompressible: true,\r\n            collapsible: element.collapsible,\r\n            collapsed: element.collapsed\r\n        };\r\n    }\r\n    return {\r\n        element: element.element.elements[index],\r\n        children,\r\n        collapsible: element.collapsible,\r\n        collapsed: element.collapsed\r\n    };\r\n}\r\n// Exported only for test reasons, do not use directly\r\nexport function decompress(element) {\r\n    return _decompress(element, 0);\r\n}\r\nfunction splice(treeElement, element, children) {\r\n    if (treeElement.element === element) {\r\n        return Object.assign(Object.assign({}, treeElement), { children });\r\n    }\r\n    return Object.assign(Object.assign({}, treeElement), { children: Iterable.map(Iterable.from(treeElement.children), e => splice(e, element, children)) });\r\n}\r\nconst wrapIdentityProvider = (base) => ({\r\n    getId(node) {\r\n        return node.elements.map(e => base.getId(e).toString()).join('\\0');\r\n    }\r\n});\r\n// Exported only for test reasons, do not use directly\r\nexport class CompressedObjectTreeModel {\r\n    constructor(user, list, options = {}) {\r\n        this.user = user;\r\n        this.rootRef = null;\r\n        this.nodes = new Map();\r\n        this.model = new ObjectTreeModel(user, list, options);\r\n        this.enabled = typeof options.compressionEnabled === 'undefined' ? true : options.compressionEnabled;\r\n        this.identityProvider = options.identityProvider;\r\n    }\r\n    get onDidSplice() { return this.model.onDidSplice; }\r\n    get onDidChangeCollapseState() { return this.model.onDidChangeCollapseState; }\r\n    get onDidChangeRenderNodeCount() { return this.model.onDidChangeRenderNodeCount; }\r\n    setChildren(element, children = Iterable.empty(), options) {\r\n        // Diffs must be deem, since the compression can affect nested elements.\r\n        // @see https://github.com/microsoft/vscode/pull/114237#issuecomment-759425034\r\n        const diffIdentityProvider = options.diffIdentityProvider && wrapIdentityProvider(options.diffIdentityProvider);\r\n        if (element === null) {\r\n            const compressedChildren = Iterable.map(children, this.enabled ? compress : noCompress);\r\n            this._setChildren(null, compressedChildren, { diffIdentityProvider, diffDepth: Infinity });\r\n            return;\r\n        }\r\n        const compressedNode = this.nodes.get(element);\r\n        if (!compressedNode) {\r\n            throw new Error('Unknown compressed tree node');\r\n        }\r\n        const node = this.model.getNode(compressedNode);\r\n        const compressedParentNode = this.model.getParentNodeLocation(compressedNode);\r\n        const parent = this.model.getNode(compressedParentNode);\r\n        const decompressedElement = decompress(node);\r\n        const splicedElement = splice(decompressedElement, element, children);\r\n        const recompressedElement = (this.enabled ? compress : noCompress)(splicedElement);\r\n        const parentChildren = parent.children\r\n            .map(child => child === node ? recompressedElement : child);\r\n        this._setChildren(parent.element, parentChildren, {\r\n            diffIdentityProvider,\r\n            diffDepth: node.depth - parent.depth,\r\n        });\r\n    }\r\n    setCompressionEnabled(enabled) {\r\n        if (enabled === this.enabled) {\r\n            return;\r\n        }\r\n        this.enabled = enabled;\r\n        const root = this.model.getNode();\r\n        const rootChildren = root.children;\r\n        const decompressedRootChildren = Iterable.map(rootChildren, decompress);\r\n        const recompressedRootChildren = Iterable.map(decompressedRootChildren, enabled ? compress : noCompress);\r\n        // it should be safe to always use deep diff mode here if an identity\r\n        // provider is available, since we know the raw nodes are unchanged.\r\n        this._setChildren(null, recompressedRootChildren, {\r\n            diffIdentityProvider: this.identityProvider,\r\n            diffDepth: Infinity,\r\n        });\r\n    }\r\n    _setChildren(node, children, options) {\r\n        const insertedElements = new Set();\r\n        const onDidCreateNode = (node) => {\r\n            for (const element of node.element.elements) {\r\n                insertedElements.add(element);\r\n                this.nodes.set(element, node.element);\r\n            }\r\n        };\r\n        const onDidDeleteNode = (node) => {\r\n            for (const element of node.element.elements) {\r\n                if (!insertedElements.has(element)) {\r\n                    this.nodes.delete(element);\r\n                }\r\n            }\r\n        };\r\n        this.model.setChildren(node, children, Object.assign(Object.assign({}, options), { onDidCreateNode, onDidDeleteNode }));\r\n    }\r\n    has(element) {\r\n        return this.nodes.has(element);\r\n    }\r\n    getListIndex(location) {\r\n        const node = this.getCompressedNode(location);\r\n        return this.model.getListIndex(node);\r\n    }\r\n    getListRenderCount(location) {\r\n        const node = this.getCompressedNode(location);\r\n        return this.model.getListRenderCount(node);\r\n    }\r\n    getNode(location) {\r\n        if (typeof location === 'undefined') {\r\n            return this.model.getNode();\r\n        }\r\n        const node = this.getCompressedNode(location);\r\n        return this.model.getNode(node);\r\n    }\r\n    // TODO: review this\r\n    getNodeLocation(node) {\r\n        const compressedNode = this.model.getNodeLocation(node);\r\n        if (compressedNode === null) {\r\n            return null;\r\n        }\r\n        return compressedNode.elements[compressedNode.elements.length - 1];\r\n    }\r\n    // TODO: review this\r\n    getParentNodeLocation(location) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        const parentNode = this.model.getParentNodeLocation(compressedNode);\r\n        if (parentNode === null) {\r\n            return null;\r\n        }\r\n        return parentNode.elements[parentNode.elements.length - 1];\r\n    }\r\n    isCollapsible(location) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        return this.model.isCollapsible(compressedNode);\r\n    }\r\n    setCollapsible(location, collapsible) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        return this.model.setCollapsible(compressedNode, collapsible);\r\n    }\r\n    isCollapsed(location) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        return this.model.isCollapsed(compressedNode);\r\n    }\r\n    setCollapsed(location, collapsed, recursive) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        return this.model.setCollapsed(compressedNode, collapsed, recursive);\r\n    }\r\n    expandTo(location) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        this.model.expandTo(compressedNode);\r\n    }\r\n    rerender(location) {\r\n        const compressedNode = this.getCompressedNode(location);\r\n        this.model.rerender(compressedNode);\r\n    }\r\n    refilter() {\r\n        this.model.refilter();\r\n    }\r\n    getCompressedNode(element) {\r\n        if (element === null) {\r\n            return null;\r\n        }\r\n        const node = this.nodes.get(element);\r\n        if (!node) {\r\n            throw new TreeError(this.user, `Tree element not found: ${element}`);\r\n        }\r\n        return node;\r\n    }\r\n}\r\nexport const DefaultElementMapper = elements => elements[elements.length - 1];\r\nclass CompressedTreeNodeWrapper {\r\n    constructor(unwrapper, node) {\r\n        this.unwrapper = unwrapper;\r\n        this.node = node;\r\n    }\r\n    get element() { return this.node.element === null ? null : this.unwrapper(this.node.element); }\r\n    get children() { return this.node.children.map(node => new CompressedTreeNodeWrapper(this.unwrapper, node)); }\r\n    get depth() { return this.node.depth; }\r\n    get visibleChildrenCount() { return this.node.visibleChildrenCount; }\r\n    get visibleChildIndex() { return this.node.visibleChildIndex; }\r\n    get collapsible() { return this.node.collapsible; }\r\n    get collapsed() { return this.node.collapsed; }\r\n    get visible() { return this.node.visible; }\r\n    get filterData() { return this.node.filterData; }\r\n}\r\nfunction mapList(nodeMapper, list) {\r\n    return {\r\n        splice(start, deleteCount, toInsert) {\r\n            list.splice(start, deleteCount, toInsert.map(node => nodeMapper.map(node)));\r\n        },\r\n        updateElementHeight(index, height) {\r\n            list.updateElementHeight(index, height);\r\n        }\r\n    };\r\n}\r\nfunction mapOptions(compressedNodeUnwrapper, options) {\r\n    return Object.assign(Object.assign({}, options), { identityProvider: options.identityProvider && {\r\n            getId(node) {\r\n                return options.identityProvider.getId(compressedNodeUnwrapper(node));\r\n            }\r\n        }, sorter: options.sorter && {\r\n            compare(node, otherNode) {\r\n                return options.sorter.compare(node.elements[0], otherNode.elements[0]);\r\n            }\r\n        }, filter: options.filter && {\r\n            filter(node, parentVisibility) {\r\n                return options.filter.filter(compressedNodeUnwrapper(node), parentVisibility);\r\n            }\r\n        } });\r\n}\r\nexport class CompressibleObjectTreeModel {\r\n    constructor(user, list, options = {}) {\r\n        this.rootRef = null;\r\n        this.elementMapper = options.elementMapper || DefaultElementMapper;\r\n        const compressedNodeUnwrapper = node => this.elementMapper(node.elements);\r\n        this.nodeMapper = new WeakMapper(node => new CompressedTreeNodeWrapper(compressedNodeUnwrapper, node));\r\n        this.model = new CompressedObjectTreeModel(user, mapList(this.nodeMapper, list), mapOptions(compressedNodeUnwrapper, options));\r\n    }\r\n    get onDidSplice() {\r\n        return Event.map(this.model.onDidSplice, ({ insertedNodes, deletedNodes }) => ({\r\n            insertedNodes: insertedNodes.map(node => this.nodeMapper.map(node)),\r\n            deletedNodes: deletedNodes.map(node => this.nodeMapper.map(node)),\r\n        }));\r\n    }\r\n    get onDidChangeCollapseState() {\r\n        return Event.map(this.model.onDidChangeCollapseState, ({ node, deep }) => ({\r\n            node: this.nodeMapper.map(node),\r\n            deep\r\n        }));\r\n    }\r\n    get onDidChangeRenderNodeCount() {\r\n        return Event.map(this.model.onDidChangeRenderNodeCount, node => this.nodeMapper.map(node));\r\n    }\r\n    setChildren(element, children = Iterable.empty(), options = {}) {\r\n        this.model.setChildren(element, children, options);\r\n    }\r\n    setCompressionEnabled(enabled) {\r\n        this.model.setCompressionEnabled(enabled);\r\n    }\r\n    has(location) {\r\n        return this.model.has(location);\r\n    }\r\n    getListIndex(location) {\r\n        return this.model.getListIndex(location);\r\n    }\r\n    getListRenderCount(location) {\r\n        return this.model.getListRenderCount(location);\r\n    }\r\n    getNode(location) {\r\n        return this.nodeMapper.map(this.model.getNode(location));\r\n    }\r\n    getNodeLocation(node) {\r\n        return node.element;\r\n    }\r\n    getParentNodeLocation(location) {\r\n        return this.model.getParentNodeLocation(location);\r\n    }\r\n    isCollapsible(location) {\r\n        return this.model.isCollapsible(location);\r\n    }\r\n    setCollapsible(location, collapsed) {\r\n        return this.model.setCollapsible(location, collapsed);\r\n    }\r\n    isCollapsed(location) {\r\n        return this.model.isCollapsed(location);\r\n    }\r\n    setCollapsed(location, collapsed, recursive) {\r\n        return this.model.setCollapsed(location, collapsed, recursive);\r\n    }\r\n    expandTo(location) {\r\n        return this.model.expandTo(location);\r\n    }\r\n    rerender(location) {\r\n        return this.model.rerender(location);\r\n    }\r\n    refilter() {\r\n        return this.model.refilter();\r\n    }\r\n    getCompressedTreeNode(location = null) {\r\n        return this.model.getNode(location);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}