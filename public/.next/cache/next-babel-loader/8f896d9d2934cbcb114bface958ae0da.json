{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js'; // Combined filters\n\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\n\nexport function or() {\n  for (var _len = arguments.length, filter = new Array(_len), _key = 0; _key < _len; _key++) {\n    filter[_key] = arguments[_key];\n  }\n\n  return function (word, wordToMatchAgainst) {\n    for (var i = 0, len = filter.length; i < len; i++) {\n      var match = filter[i](word, wordToMatchAgainst);\n\n      if (match) {\n        return match;\n      }\n    }\n\n    return null;\n  };\n}\nexport var matchesPrefix = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n\n  var matches;\n\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n\n  if (!matches) {\n    return null;\n  }\n\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n} // Contiguous Substring\n\n\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\n  if (index === -1) {\n    return null;\n  }\n\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n} // Substring\n\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      var result = null;\n\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n\n      return null;\n    }\n\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n} // CamelCase\n\n\nfunction isLower(code) {\n  return 97\n  /* a */\n  <= code && code <= 122\n  /* z */\n  ;\n}\n\nexport function isUpper(code) {\n  return 65\n  /* A */\n  <= code && code <= 90\n  /* Z */\n  ;\n}\n\nfunction isNumber(code) {\n  return 48\n  /* Digit0 */\n  <= code && code <= 57\n  /* Digit9 */\n  ;\n}\n\nfunction isWhitespace(code) {\n  return code === 32\n  /* Space */\n  || code === 9\n  /* Tab */\n  || code === 10\n  /* LineFeed */\n  || code === 13\n  /* CarriageReturn */\n  ;\n}\n\nvar wordSeparators = new Set();\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'.split('').forEach(function (s) {\n  return wordSeparators.add(s.charCodeAt(0));\n});\n\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\n\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n\n  return tail;\n}\n\nfunction nextAnchor(camelCaseWord, start) {\n  for (var i = start; i < camelCaseWord.length; i++) {\n    var c = camelCaseWord.charCodeAt(i);\n\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    var result = null;\n    var nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\n\n\nfunction analyzeCamelCaseWord(word) {\n  var upper = 0,\n      lower = 0,\n      alpha = 0,\n      numeric = 0,\n      code = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n\n  var upperPercent = upper / word.length;\n  var lowerPercent = lower / word.length;\n  var alphaPercent = alpha / word.length;\n  var numericPercent = numeric / word.length;\n  return {\n    upperPercent: upperPercent,\n    lowerPercent: lowerPercent,\n    alphaPercent: alphaPercent,\n    numericPercent: numericPercent\n  };\n}\n\nfunction isUpperCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis) {\n  var upperPercent = analysis.upperPercent,\n      lowerPercent = analysis.lowerPercent,\n      alphaPercent = analysis.alphaPercent,\n      numericPercent = analysis.numericPercent;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n} // Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\n\n\nfunction isCamelCasePattern(word) {\n  var upper = 0,\n      lower = 0,\n      code = 0,\n      whitespace = 0;\n\n  for (var i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n\n    if (isUpper(code)) {\n      upper++;\n    }\n\n    if (isLower(code)) {\n      lower++;\n    }\n\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\n\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n\n  camelCaseWord = camelCaseWord.trim();\n\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n\n  var analysis = analyzeCamelCaseWord(camelCaseWord);\n\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n\n  return result;\n} // Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word, target) {\n  var contiguous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!target || target.length === 0) {\n    return null;\n  }\n\n  var result = null;\n  var i = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n\n  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n    i = nextWord(target, i + 1);\n  }\n\n  return result;\n}\n\nfunction _matchesWords(word, target, i, j, contiguous) {\n  if (i === word.length) {\n    return [];\n  } else if (j === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n    return null;\n  } else {\n    var result = null;\n    var nextWordIndex = j + 1;\n    result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n\n    if (!contiguous) {\n      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n        nextWordIndex++;\n      }\n    }\n\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n\nfunction nextWord(word, start) {\n  for (var i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n\n  return word.length;\n} // Fuzzy\n\n\nvar fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nvar fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nvar fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word, wordToMatchAgainst) {\n  var enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  } // Form RegExp for wildcard matches\n\n\n  var regexp = fuzzyRegExpCache.get(word);\n\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  } // RegExp Filter\n\n\n  var match = regexp.exec(wordToMatchAgainst);\n\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  } // Default Filter\n\n\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\n  var result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\n\n  if (result) {\n    return result;\n  }\n\n  var matches = [];\n  var score = 0;\n  var idx = _wordPos;\n\n  for (var patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\n    var wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\n\n    if (wordPos >= 0) {\n      score += 1;\n      matches.unshift(wordPos);\n      idx = wordPos + 1;\n    } else if (matches.length > 0) {\n      // once we have started matching things\n      // we need to match the remaining pattern\n      // characters\n      break;\n    }\n  }\n\n  return [score, _wordPos].concat(matches);\n} //#region --- fuzzyScore ---\n\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n\n  var res = [];\n  var wordPos = score[1];\n\n  for (var i = score.length - 1; i > 1; i--) {\n    var pos = score[i] + wordPos;\n    var last = res[res.length - 1];\n\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n\n  return res;\n}\nvar _maxLen = 128;\n\nfunction initTable() {\n  var table = [];\n  var row = [];\n\n  for (var i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n\n  for (var _i = 0; _i <= _maxLen; _i++) {\n    table.push(row.slice(0));\n  }\n\n  return table;\n}\n\nfunction initArr(maxLen) {\n  var row = [];\n\n  for (var i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n\n  return row;\n}\n\nvar _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\n\n\nvar _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\n\n\nvar _diag = initTable(); // the length of a contiguous diagonal match\n\n\nvar _table = initTable();\n\nvar _arrows = initTable();\n\nvar _debug = false;\n\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n) {\n    var pad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ' ';\n\n    while (s.length < n) {\n      s = pad + s;\n    }\n\n    return s;\n  }\n\n  var ret = \" |   |\".concat(word.split('').map(function (c) {\n    return pad(c, 3);\n  }).join('|'), \"\\n\");\n\n  for (var i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += \"\".concat(pattern[i - 1], \"|\");\n    }\n\n    ret += table[i].slice(0, wordLen + 1).map(function (n) {\n      return pad(n.toString(), 3);\n    }).join('|') + '\\n';\n  }\n\n  return ret;\n}\n\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.codePointAt(index);\n\n  switch (code) {\n    case 95\n    /* Underline */\n    :\n    case 45\n    /* Dash */\n    :\n    case 46\n    /* Period */\n    :\n    case 32\n    /* Space */\n    :\n    case 47\n    /* Slash */\n    :\n    case 92\n    /* Backslash */\n    :\n    case 39\n    /* SingleQuote */\n    :\n    case 34\n    /* DoubleQuote */\n    :\n    case 58\n    /* Colon */\n    :\n    case 36\n    /* DollarSign */\n    :\n    case 60\n    /* LessThan */\n    :\n    case 40\n    /* OpenParen */\n    :\n    case 91\n    /* OpenSquareBracket */\n    :\n      return true;\n\n    case undefined:\n      return false;\n\n    default:\n      if (strings.isEmojiImprecise(code)) {\n        return true;\n      }\n\n      return false;\n  }\n}\n\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n\n  var code = value.charCodeAt(index);\n\n  switch (code) {\n    case 32\n    /* Space */\n    :\n    case 9\n    /* Tab */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen) {\n  var fillMinWordPosArr = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n\n      patternPos += 1;\n    }\n\n    wordPos += 1;\n  }\n\n  return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n\n(function (FuzzyScore) {\n  /**\r\n   * No matches and value `-100`\r\n   */\n  FuzzyScore.Default = [-100, 0];\n\n  function isDefault(score) {\n    return !score || score[0] === -100 && score[1] === 0 && score[2] === 0;\n  }\n\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\n\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\n  var patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  var wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  } // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n\n\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  } // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\n\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n  var row = 1;\n  var column = 1;\n  var patternPos = patternStart;\n  var wordPos = wordStart;\n  var hasStrongFirstMatch = [false]; // There will be a match, fill in tables\n\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    var minWordMatchPos = _minWordMatchPos[patternPos];\n    var maxWordMatchPos = _maxWordMatchPos[patternPos];\n    var nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      var score = Number.MIN_SAFE_INTEGER;\n      var canComeDiag = false;\n\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n\n      var diagScore = 0;\n\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n\n      var canComeLeft = wordPos > minWordMatchPos;\n      var leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      var canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      var leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3\n        /* LeftLeft */\n        ;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2\n        /* Left */\n        ;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1\n        /* Diag */\n        ;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(\"not possible\");\n      }\n    }\n  }\n\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n\n  if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\n    return undefined;\n  }\n\n  row--;\n  column--;\n  var result = [_table[row][column], wordStart];\n  var backwardsDiagLength = 0;\n  var maxMatchColumn = 0;\n\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    var diagColumn = column;\n\n    do {\n      var arrow = _arrows[row][diagColumn];\n\n      if (arrow === 3\n      /* LeftLeft */\n      ) {\n          diagColumn = diagColumn - 2;\n        } else if (arrow === 2\n      /* Left */\n      ) {\n          diagColumn = diagColumn - 1;\n        } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1); // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\n\n    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n        diagColumn = column;\n      }\n\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n\n  if (wordLen === patternLen) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  } // Add 1 penalty for each skipped character in the word\n\n\n  var skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  var patternPos = patternLen - 1;\n  var wordPos = wordLen - 1;\n\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n\n    wordPos--;\n  }\n}\n\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n\n  var score = 1;\n  var isGapLocation = false;\n\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  } //\n\n\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      // this would be the beginning of a new match (i.e. there would be a gap before this location)\n      score += isGapLocation ? 2 : 0;\n    } else {\n      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n\n  return score;\n} //#endregion\n//#region --- graceful ---\n\n\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\n}\n\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\n  var top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    var tries = Math.min(7, pattern.length - 1);\n\n    for (var movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      var newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\n      if (newPattern) {\n        var candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\n\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n\n  return top;\n}\n\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n\n  var swap1 = pattern[patternPos];\n  var swap2 = pattern[patternPos + 1];\n\n  if (swap1 === swap2) {\n    return undefined;\n  }\n\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n} //#endregion","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"names":["LRUCache","strings","or","filter","word","wordToMatchAgainst","i","len","length","match","matchesPrefix","_matchesPrefix","bind","undefined","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","matchesWords","target","contiguous","_matchesWords","nextWord","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","anyScore","pattern","lowPattern","_patternPos","lowWord","_wordPos","fuzzyScore","score","idx","patternPos","_maxLen","wordPos","charAt","createMatches","res","pos","last","push","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","map","toString","printTables","patternStart","wordStart","substr","console","log","isSeparatorAtPos","value","codePointAt","isEmojiImprecise","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","Default","isDefault","firstMatchCanBeWeak","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","Math","min","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { LRUCache } from './map.js';\r\nimport * as strings from './strings.js';\r\n// Combined filters\r\n/**\r\n * @returns A filter which combines the provided set\r\n * of filters with an or. The *first* filters that\r\n * matches defined the return value of the returned\r\n * filter.\r\n */\r\nexport function or(...filter) {\r\n    return function (word, wordToMatchAgainst) {\r\n        for (let i = 0, len = filter.length; i < len; i++) {\r\n            const match = filter[i](word, wordToMatchAgainst);\r\n            if (match) {\r\n                return match;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n}\r\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\r\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\r\n        return null;\r\n    }\r\n    let matches;\r\n    if (ignoreCase) {\r\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\r\n    }\r\n    else {\r\n        matches = wordToMatchAgainst.indexOf(word) === 0;\r\n    }\r\n    if (!matches) {\r\n        return null;\r\n    }\r\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n}\r\n// Contiguous Substring\r\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n    if (index === -1) {\r\n        return null;\r\n    }\r\n    return [{ start: index, end: index + word.length }];\r\n}\r\n// Substring\r\nexport function matchesSubString(word, wordToMatchAgainst) {\r\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n}\r\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === wordToMatchAgainst.length) {\r\n        return null;\r\n    }\r\n    else {\r\n        if (word[i] === wordToMatchAgainst[j]) {\r\n            let result = null;\r\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                return join({ start: j, end: j + 1 }, result);\r\n            }\r\n            return null;\r\n        }\r\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n    }\r\n}\r\n// CamelCase\r\nfunction isLower(code) {\r\n    return 97 /* a */ <= code && code <= 122 /* z */;\r\n}\r\nexport function isUpper(code) {\r\n    return 65 /* A */ <= code && code <= 90 /* Z */;\r\n}\r\nfunction isNumber(code) {\r\n    return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;\r\n}\r\nfunction isWhitespace(code) {\r\n    return (code === 32 /* Space */\r\n        || code === 9 /* Tab */\r\n        || code === 10 /* LineFeed */\r\n        || code === 13 /* CarriageReturn */);\r\n}\r\nconst wordSeparators = new Set();\r\n'`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?'\r\n    .split('')\r\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\r\nfunction isWordSeparator(code) {\r\n    return isWhitespace(code) || wordSeparators.has(code);\r\n}\r\nfunction charactersMatch(codeA, codeB) {\r\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\r\n}\r\nfunction isAlphanumeric(code) {\r\n    return isLower(code) || isUpper(code) || isNumber(code);\r\n}\r\nfunction join(head, tail) {\r\n    if (tail.length === 0) {\r\n        tail = [head];\r\n    }\r\n    else if (head.end === tail[0].start) {\r\n        tail[0].start = head.start;\r\n    }\r\n    else {\r\n        tail.unshift(head);\r\n    }\r\n    return tail;\r\n}\r\nfunction nextAnchor(camelCaseWord, start) {\r\n    for (let i = start; i < camelCaseWord.length; i++) {\r\n        const c = camelCaseWord.charCodeAt(i);\r\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return camelCaseWord.length;\r\n}\r\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === camelCaseWord.length) {\r\n        return null;\r\n    }\r\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n        return null;\r\n    }\r\n    else {\r\n        let result = null;\r\n        let nextUpperIndex = j + 1;\r\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n            nextUpperIndex++;\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camelCaseWords.\r\nfunction analyzeCamelCaseWord(word) {\r\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n    for (let i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isAlphanumeric(code)) {\r\n            alpha++;\r\n        }\r\n        if (isNumber(code)) {\r\n            numeric++;\r\n        }\r\n    }\r\n    const upperPercent = upper / word.length;\r\n    const lowerPercent = lower / word.length;\r\n    const alphaPercent = alpha / word.length;\r\n    const numericPercent = numeric / word.length;\r\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\r\n}\r\nfunction isUpperCaseWord(analysis) {\r\n    const { upperPercent, lowerPercent } = analysis;\r\n    return lowerPercent === 0 && upperPercent > 0.6;\r\n}\r\nfunction isCamelCaseWord(analysis) {\r\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\r\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n}\r\n// Heuristic to avoid computing camel case matcher for words that don't\r\n// look like camel case patterns.\r\nfunction isCamelCasePattern(word) {\r\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\r\n    for (let i = 0; i < word.length; i++) {\r\n        code = word.charCodeAt(i);\r\n        if (isUpper(code)) {\r\n            upper++;\r\n        }\r\n        if (isLower(code)) {\r\n            lower++;\r\n        }\r\n        if (isWhitespace(code)) {\r\n            whitespace++;\r\n        }\r\n    }\r\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n        return word.length <= 30;\r\n    }\r\n    else {\r\n        return upper <= 5;\r\n    }\r\n}\r\nexport function matchesCamelCase(word, camelCaseWord) {\r\n    if (!camelCaseWord) {\r\n        return null;\r\n    }\r\n    camelCaseWord = camelCaseWord.trim();\r\n    if (camelCaseWord.length === 0) {\r\n        return null;\r\n    }\r\n    if (!isCamelCasePattern(word)) {\r\n        return null;\r\n    }\r\n    if (camelCaseWord.length > 60) {\r\n        return null;\r\n    }\r\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\r\n    if (!isCamelCaseWord(analysis)) {\r\n        if (!isUpperCaseWord(analysis)) {\r\n            return null;\r\n        }\r\n        camelCaseWord = camelCaseWord.toLowerCase();\r\n    }\r\n    let result = null;\r\n    let i = 0;\r\n    word = word.toLowerCase();\r\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\r\n        i = nextAnchor(camelCaseWord, i + 1);\r\n    }\r\n    return result;\r\n}\r\n// Matches beginning of words supporting non-ASCII languages\r\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\r\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\r\n// Useful in cases where the target is words (e.g. command labels)\r\nexport function matchesWords(word, target, contiguous = false) {\r\n    if (!target || target.length === 0) {\r\n        return null;\r\n    }\r\n    let result = null;\r\n    let i = 0;\r\n    word = word.toLowerCase();\r\n    target = target.toLowerCase();\r\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\r\n        i = nextWord(target, i + 1);\r\n    }\r\n    return result;\r\n}\r\nfunction _matchesWords(word, target, i, j, contiguous) {\r\n    if (i === word.length) {\r\n        return [];\r\n    }\r\n    else if (j === target.length) {\r\n        return null;\r\n    }\r\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\r\n        return null;\r\n    }\r\n    else {\r\n        let result = null;\r\n        let nextWordIndex = j + 1;\r\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\r\n        if (!contiguous) {\r\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\r\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\r\n                nextWordIndex++;\r\n            }\r\n        }\r\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n    }\r\n}\r\nfunction nextWord(word, start) {\r\n    for (let i = start; i < word.length; i++) {\r\n        if (isWordSeparator(word.charCodeAt(i)) ||\r\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\r\n            return i;\r\n        }\r\n    }\r\n    return word.length;\r\n}\r\n// Fuzzy\r\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\r\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\r\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\r\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n        return null; // return early for invalid input\r\n    }\r\n    // Form RegExp for wildcard matches\r\n    let regexp = fuzzyRegExpCache.get(word);\r\n    if (!regexp) {\r\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n        fuzzyRegExpCache.set(word, regexp);\r\n    }\r\n    // RegExp Filter\r\n    const match = regexp.exec(wordToMatchAgainst);\r\n    if (match) {\r\n        return [{ start: match.index, end: match.index + match[0].length }];\r\n    }\r\n    // Default Filter\r\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n}\r\nexport function anyScore(pattern, lowPattern, _patternPos, word, lowWord, _wordPos) {\r\n    const result = fuzzyScore(pattern, lowPattern, 0, word, lowWord, 0, true);\r\n    if (result) {\r\n        return result;\r\n    }\r\n    let matches = [];\r\n    let score = 0;\r\n    let idx = _wordPos;\r\n    for (let patternPos = 0; patternPos < lowPattern.length && patternPos < _maxLen; ++patternPos) {\r\n        const wordPos = lowWord.indexOf(lowPattern.charAt(patternPos), idx);\r\n        if (wordPos >= 0) {\r\n            score += 1;\r\n            matches.unshift(wordPos);\r\n            idx = wordPos + 1;\r\n        }\r\n        else if (matches.length > 0) {\r\n            // once we have started matching things\r\n            // we need to match the remaining pattern\r\n            // characters\r\n            break;\r\n        }\r\n    }\r\n    return [score, _wordPos, ...matches];\r\n}\r\n//#region --- fuzzyScore ---\r\nexport function createMatches(score) {\r\n    if (typeof score === 'undefined') {\r\n        return [];\r\n    }\r\n    const res = [];\r\n    const wordPos = score[1];\r\n    for (let i = score.length - 1; i > 1; i--) {\r\n        const pos = score[i] + wordPos;\r\n        const last = res[res.length - 1];\r\n        if (last && last.end === pos) {\r\n            last.end = pos + 1;\r\n        }\r\n        else {\r\n            res.push({ start: pos, end: pos + 1 });\r\n        }\r\n    }\r\n    return res;\r\n}\r\nconst _maxLen = 128;\r\nfunction initTable() {\r\n    const table = [];\r\n    const row = [];\r\n    for (let i = 0; i <= _maxLen; i++) {\r\n        row[i] = 0;\r\n    }\r\n    for (let i = 0; i <= _maxLen; i++) {\r\n        table.push(row.slice(0));\r\n    }\r\n    return table;\r\n}\r\nfunction initArr(maxLen) {\r\n    const row = [];\r\n    for (let i = 0; i <= maxLen; i++) {\r\n        row[i] = 0;\r\n    }\r\n    return row;\r\n}\r\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\r\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\r\nconst _diag = initTable(); // the length of a contiguous diagonal match\r\nconst _table = initTable();\r\nconst _arrows = initTable();\r\nconst _debug = false;\r\nfunction printTable(table, pattern, patternLen, word, wordLen) {\r\n    function pad(s, n, pad = ' ') {\r\n        while (s.length < n) {\r\n            s = pad + s;\r\n        }\r\n        return s;\r\n    }\r\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\r\n    for (let i = 0; i <= patternLen; i++) {\r\n        if (i === 0) {\r\n            ret += ' |';\r\n        }\r\n        else {\r\n            ret += `${pattern[i - 1]}|`;\r\n        }\r\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\r\n    }\r\n    return ret;\r\n}\r\nfunction printTables(pattern, patternStart, word, wordStart) {\r\n    pattern = pattern.substr(patternStart);\r\n    word = word.substr(wordStart);\r\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\r\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\r\n}\r\nfunction isSeparatorAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    const code = value.codePointAt(index);\r\n    switch (code) {\r\n        case 95 /* Underline */:\r\n        case 45 /* Dash */:\r\n        case 46 /* Period */:\r\n        case 32 /* Space */:\r\n        case 47 /* Slash */:\r\n        case 92 /* Backslash */:\r\n        case 39 /* SingleQuote */:\r\n        case 34 /* DoubleQuote */:\r\n        case 58 /* Colon */:\r\n        case 36 /* DollarSign */:\r\n        case 60 /* LessThan */:\r\n        case 40 /* OpenParen */:\r\n        case 91 /* OpenSquareBracket */:\r\n            return true;\r\n        case undefined:\r\n            return false;\r\n        default:\r\n            if (strings.isEmojiImprecise(code)) {\r\n                return true;\r\n            }\r\n            return false;\r\n    }\r\n}\r\nfunction isWhitespaceAtPos(value, index) {\r\n    if (index < 0 || index >= value.length) {\r\n        return false;\r\n    }\r\n    const code = value.charCodeAt(index);\r\n    switch (code) {\r\n        case 32 /* Space */:\r\n        case 9 /* Tab */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isUpperCaseAtPos(pos, word, wordLow) {\r\n    return word[pos] !== wordLow[pos];\r\n}\r\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\r\n    while (patternPos < patternLen && wordPos < wordLen) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            if (fillMinWordPosArr) {\r\n                // Remember the min word position for each pattern position\r\n                _minWordMatchPos[patternPos] = wordPos;\r\n            }\r\n            patternPos += 1;\r\n        }\r\n        wordPos += 1;\r\n    }\r\n    return patternPos === patternLen; // pattern must be exhausted\r\n}\r\nexport var FuzzyScore;\r\n(function (FuzzyScore) {\r\n    /**\r\n     * No matches and value `-100`\r\n     */\r\n    FuzzyScore.Default = ([-100, 0]);\r\n    function isDefault(score) {\r\n        return !score || (score[0] === -100 && score[1] === 0 && score[2] === 0);\r\n    }\r\n    FuzzyScore.isDefault = isDefault;\r\n})(FuzzyScore || (FuzzyScore = {}));\r\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, firstMatchCanBeWeak) {\r\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\r\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\r\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\r\n        return undefined;\r\n    }\r\n    // Run a simple check if the characters of pattern occur\r\n    // (in order) at all in word. If that isn't the case we\r\n    // stop because no match will be possible\r\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\r\n        return undefined;\r\n    }\r\n    // Find the max matching word position for each pattern position\r\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\r\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\r\n    let row = 1;\r\n    let column = 1;\r\n    let patternPos = patternStart;\r\n    let wordPos = wordStart;\r\n    const hasStrongFirstMatch = [false];\r\n    // There will be a match, fill in tables\r\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\r\n        // Reduce search space to possible matching word positions and to possible access from next row\r\n        const minWordMatchPos = _minWordMatchPos[patternPos];\r\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\r\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\r\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\r\n            let score = Number.MIN_SAFE_INTEGER;\r\n            let canComeDiag = false;\r\n            if (wordPos <= maxWordMatchPos) {\r\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\r\n            }\r\n            let diagScore = 0;\r\n            if (score !== Number.MAX_SAFE_INTEGER) {\r\n                canComeDiag = true;\r\n                diagScore = score + _table[row - 1][column - 1];\r\n            }\r\n            const canComeLeft = wordPos > minWordMatchPos;\r\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\r\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\r\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\r\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\r\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\r\n                _table[row][column] = leftLeftScore;\r\n                _arrows[row][column] = 3 /* LeftLeft */;\r\n                _diag[row][column] = 0;\r\n            }\r\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\r\n                // always prefer choosing left since that means a match is earlier in the word\r\n                _table[row][column] = leftScore;\r\n                _arrows[row][column] = 2 /* Left */;\r\n                _diag[row][column] = 0;\r\n            }\r\n            else if (canComeDiag) {\r\n                _table[row][column] = diagScore;\r\n                _arrows[row][column] = 1 /* Diag */;\r\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\r\n            }\r\n            else {\r\n                throw new Error(`not possible`);\r\n            }\r\n        }\r\n    }\r\n    if (_debug) {\r\n        printTables(pattern, patternStart, word, wordStart);\r\n    }\r\n    if (!hasStrongFirstMatch[0] && !firstMatchCanBeWeak) {\r\n        return undefined;\r\n    }\r\n    row--;\r\n    column--;\r\n    const result = [_table[row][column], wordStart];\r\n    let backwardsDiagLength = 0;\r\n    let maxMatchColumn = 0;\r\n    while (row >= 1) {\r\n        // Find the column where we go diagonally up\r\n        let diagColumn = column;\r\n        do {\r\n            const arrow = _arrows[row][diagColumn];\r\n            if (arrow === 3 /* LeftLeft */) {\r\n                diagColumn = diagColumn - 2;\r\n            }\r\n            else if (arrow === 2 /* Left */) {\r\n                diagColumn = diagColumn - 1;\r\n            }\r\n            else {\r\n                // found the diagonal\r\n                break;\r\n            }\r\n        } while (diagColumn >= 1);\r\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\r\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\r\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\r\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\r\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\r\n        ) {\r\n            diagColumn = column;\r\n        }\r\n        if (diagColumn === column) {\r\n            // this is a contiguous match\r\n            backwardsDiagLength++;\r\n        }\r\n        else {\r\n            backwardsDiagLength = 1;\r\n        }\r\n        if (!maxMatchColumn) {\r\n            // remember the last matched column\r\n            maxMatchColumn = diagColumn;\r\n        }\r\n        row--;\r\n        column = diagColumn - 1;\r\n        result.push(column);\r\n    }\r\n    if (wordLen === patternLen) {\r\n        // the word matches the pattern with all characters!\r\n        // giving the score a total match boost (to come up ahead other words)\r\n        result[0] += 2;\r\n    }\r\n    // Add 1 penalty for each skipped character in the word\r\n    const skippedCharsCount = maxMatchColumn - patternLen;\r\n    result[0] -= skippedCharsCount;\r\n    return result;\r\n}\r\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\r\n    let patternPos = patternLen - 1;\r\n    let wordPos = wordLen - 1;\r\n    while (patternPos >= patternStart && wordPos >= wordStart) {\r\n        if (patternLow[patternPos] === wordLow[wordPos]) {\r\n            _maxWordMatchPos[patternPos] = wordPos;\r\n            patternPos--;\r\n        }\r\n        wordPos--;\r\n    }\r\n}\r\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\r\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\r\n        return Number.MIN_SAFE_INTEGER;\r\n    }\r\n    let score = 1;\r\n    let isGapLocation = false;\r\n    if (wordPos === (patternPos - patternStart)) {\r\n        // common prefix: `foobar <-> foobaz`\r\n        //                            ^^^^^\r\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\r\n    }\r\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\r\n        // hitting upper-case: `foo <-> forOthers`\r\n        //                              ^^ ^\r\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\r\n        isGapLocation = true;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\r\n        // hitting a separator: `. <-> foo.bar`\r\n        //                                ^\r\n        score = 5;\r\n    }\r\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\r\n        // post separator: `foo <-> bar_foo`\r\n        //                              ^^^\r\n        score = 5;\r\n        isGapLocation = true;\r\n    }\r\n    if (score > 1 && patternPos === patternStart) {\r\n        outFirstMatchStrong[0] = true;\r\n    }\r\n    if (!isGapLocation) {\r\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\r\n    }\r\n    //\r\n    if (patternPos === patternStart) { // first character in pattern\r\n        if (wordPos > wordStart) {\r\n            // the first pattern character would match a word character that is not at the word start\r\n            // so introduce a penalty to account for the gap preceding this match\r\n            score -= isGapLocation ? 3 : 5;\r\n        }\r\n    }\r\n    else {\r\n        if (newMatchStart) {\r\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\r\n            score += isGapLocation ? 2 : 0;\r\n        }\r\n        else {\r\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a prefered gap location\r\n            score += isGapLocation ? 0 : 1;\r\n        }\r\n    }\r\n    if (wordPos + 1 === wordLen) {\r\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\r\n        // so pretend there is a gap after the last character in the word to normalize things\r\n        score -= isGapLocation ? 3 : 5;\r\n    }\r\n    return score;\r\n}\r\n//#endregion\r\n//#region --- graceful ---\r\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak) {\r\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, firstMatchCanBeWeak);\r\n}\r\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, firstMatchCanBeWeak) {\r\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n    if (top && !aggressive) {\r\n        // when using the original pattern yield a result we`\r\n        // return it unless we are aggressive and try to find\r\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\r\n        return top;\r\n    }\r\n    if (pattern.length >= 3) {\r\n        // When the pattern is long enough then try a few (max 7)\r\n        // permutations of the pattern to find a better match. The\r\n        // permutations only swap neighbouring characters, e.g\r\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\r\n        const tries = Math.min(7, pattern.length - 1);\r\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\r\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\r\n            if (newPattern) {\r\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, firstMatchCanBeWeak);\r\n                if (candidate) {\r\n                    candidate[0] -= 3; // permutation penalty\r\n                    if (!top || candidate[0] > top[0]) {\r\n                        top = candidate;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return top;\r\n}\r\nfunction nextTypoPermutation(pattern, patternPos) {\r\n    if (patternPos + 1 >= pattern.length) {\r\n        return undefined;\r\n    }\r\n    const swap1 = pattern[patternPos];\r\n    const swap2 = pattern[patternPos + 1];\r\n    if (swap1 === swap2) {\r\n        return undefined;\r\n    }\r\n    return pattern.slice(0, patternPos)\r\n        + swap2\r\n        + swap1\r\n        + pattern.slice(patternPos + 2);\r\n}\r\n//#endregion\r\n"]},"metadata":{},"sourceType":"module"}