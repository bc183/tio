{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n  return (node.metadata & 1\n  /* ColorMask */\n  ) >>> 0\n  /* ColorOffset */\n  ;\n}\n\nfunction setNodeColor(node, color) {\n  node.metadata = node.metadata & 254\n  /* ColorMaskInverse */\n  | color << 0\n  /* ColorOffset */\n  ;\n}\n\nfunction getNodeIsVisited(node) {\n  return (node.metadata & 2\n  /* IsVisitedMask */\n  ) >>> 1\n  /* IsVisitedOffset */\n  === 1;\n}\n\nfunction setNodeIsVisited(node, value) {\n  node.metadata = node.metadata & 253\n  /* IsVisitedMaskInverse */\n  | (value ? 1 : 0) << 1\n  /* IsVisitedOffset */\n  ;\n}\n\nfunction getNodeIsForValidation(node) {\n  return (node.metadata & 4\n  /* IsForValidationMask */\n  ) >>> 2\n  /* IsForValidationOffset */\n  === 1;\n}\n\nfunction setNodeIsForValidation(node, value) {\n  node.metadata = node.metadata & 251\n  /* IsForValidationMaskInverse */\n  | (value ? 1 : 0) << 2\n  /* IsForValidationOffset */\n  ;\n}\n\nexport function getNodeIsInOverviewRuler(node) {\n  return (node.metadata & 8\n  /* IsInOverviewRulerMask */\n  ) >>> 3\n  /* IsInOverviewRulerOffset */\n  === 1;\n}\n\nfunction setNodeIsInOverviewRuler(node, value) {\n  node.metadata = node.metadata & 247\n  /* IsInOverviewRulerMaskInverse */\n  | (value ? 1 : 0) << 3\n  /* IsInOverviewRulerOffset */\n  ;\n}\n\nfunction getNodeStickiness(node) {\n  return (node.metadata & 48\n  /* StickinessMask */\n  ) >>> 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction _setNodeStickiness(node, stickiness) {\n  node.metadata = node.metadata & 207\n  /* StickinessMaskInverse */\n  | stickiness << 4\n  /* StickinessOffset */\n  ;\n}\n\nfunction getCollapseOnReplaceEdit(node) {\n  return (node.metadata & 64\n  /* CollapseOnReplaceEditMask */\n  ) >>> 6\n  /* CollapseOnReplaceEditOffset */\n  === 1;\n}\n\nfunction setCollapseOnReplaceEdit(node, value) {\n  node.metadata = node.metadata & 191\n  /* CollapseOnReplaceEditMaskInverse */\n  | (value ? 1 : 0) << 6\n  /* CollapseOnReplaceEditOffset */\n  ;\n}\n\nexport var IntervalNode = /*#__PURE__*/function () {\n  function IntervalNode(id, start, end) {\n    _classCallCheck(this, IntervalNode);\n\n    this.metadata = 0;\n    this.parent = this;\n    this.left = this;\n    this.right = this;\n    setNodeColor(this, 1\n    /* Red */\n    );\n    this.start = start;\n    this.end = end; // FORCE_OVERFLOWING_TEST: this.delta = start;\n\n    this.delta = 0;\n    this.maxEnd = end;\n    this.id = id;\n    this.ownerId = 0;\n    this.options = null;\n    setNodeIsForValidation(this, false);\n\n    _setNodeStickiness(this, 1\n    /* NeverGrowsWhenTypingAtEdges */\n    );\n\n    setNodeIsInOverviewRuler(this, false);\n    setCollapseOnReplaceEdit(this, false);\n    this.cachedVersionId = 0;\n    this.cachedAbsoluteStart = start;\n    this.cachedAbsoluteEnd = end;\n    this.range = null;\n    setNodeIsVisited(this, false);\n  }\n\n  _createClass(IntervalNode, [{\n    key: \"reset\",\n    value: function reset(versionId, start, end, range) {\n      this.start = start;\n      this.end = end;\n      this.maxEnd = end;\n      this.cachedVersionId = versionId;\n      this.cachedAbsoluteStart = start;\n      this.cachedAbsoluteEnd = end;\n      this.range = range;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      var className = this.options.className;\n      setNodeIsForValidation(this, className === \"squiggly-error\"\n      /* EditorErrorDecoration */\n      || className === \"squiggly-warning\"\n      /* EditorWarningDecoration */\n      || className === \"squiggly-info\"\n      /* EditorInfoDecoration */\n      );\n\n      _setNodeStickiness(this, this.options.stickiness);\n\n      setNodeIsInOverviewRuler(this, this.options.overviewRuler && this.options.overviewRuler.color ? true : false);\n      setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n  }, {\n    key: \"setCachedOffsets\",\n    value: function setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n      if (this.cachedVersionId !== cachedVersionId) {\n        this.range = null;\n      }\n\n      this.cachedVersionId = cachedVersionId;\n      this.cachedAbsoluteStart = absoluteStart;\n      this.cachedAbsoluteEnd = absoluteEnd;\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.parent = null;\n      this.left = null;\n      this.right = null;\n    }\n  }]);\n\n  return IntervalNode;\n}();\nexport var SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0\n/* Black */\n);\nexport var IntervalTree = /*#__PURE__*/function () {\n  function IntervalTree() {\n    _classCallCheck(this, IntervalTree);\n\n    this.root = SENTINEL;\n    this.requestNormalizeDelta = false;\n  }\n\n  _createClass(IntervalTree, [{\n    key: \"intervalSearch\",\n    value: function intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n      if (this.root === SENTINEL) {\n        return [];\n      }\n\n      return _intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n  }, {\n    key: \"search\",\n    value: function search(filterOwnerId, filterOutValidation, cachedVersionId) {\n      if (this.root === SENTINEL) {\n        return [];\n      }\n\n      return _search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\n\n  }, {\n    key: \"collectNodesFromOwner\",\n    value: function collectNodesFromOwner(ownerId) {\n      return _collectNodesFromOwner(this, ownerId);\n    }\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\n\n  }, {\n    key: \"collectNodesPostOrder\",\n    value: function collectNodesPostOrder() {\n      return _collectNodesPostOrder(this);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(node) {\n      rbTreeInsert(this, node);\n\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(node) {\n      rbTreeDelete(this, node);\n\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(node, cachedVersionId) {\n      var initialNode = node;\n      var delta = 0;\n\n      while (node !== this.root) {\n        if (node === node.parent.right) {\n          delta += node.parent.delta;\n        }\n\n        node = node.parent;\n      }\n\n      var nodeStart = initialNode.start + delta;\n      var nodeEnd = initialNode.end + delta;\n      initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n  }, {\n    key: \"acceptReplace\",\n    value: function acceptReplace(offset, length, textLength, forceMoveMarkers) {\n      // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n      // (1) collect all nodes that are intersecting this edit as nodes of interest\n      var nodesOfInterest = searchForEditing(this, offset, offset + length); // (2) remove all nodes that are intersecting this edit\n\n      for (var i = 0, len = nodesOfInterest.length; i < len; i++) {\n        var node = nodesOfInterest[i];\n        rbTreeDelete(this, node);\n      }\n\n      this._normalizeDeltaIfNecessary(); // (3) edit all tree nodes except the nodes of interest\n\n\n      noOverlapReplace(this, offset, offset + length, textLength);\n\n      this._normalizeDeltaIfNecessary(); // (4) edit the nodes of interest and insert them back in the tree\n\n\n      for (var _i = 0, _len = nodesOfInterest.length; _i < _len; _i++) {\n        var _node = nodesOfInterest[_i];\n        _node.start = _node.cachedAbsoluteStart;\n        _node.end = _node.cachedAbsoluteEnd;\n        nodeAcceptEdit(_node, offset, offset + length, textLength, forceMoveMarkers);\n        _node.maxEnd = _node.end;\n        rbTreeInsert(this, _node);\n      }\n\n      this._normalizeDeltaIfNecessary();\n    }\n  }, {\n    key: \"_normalizeDeltaIfNecessary\",\n    value: function _normalizeDeltaIfNecessary() {\n      if (!this.requestNormalizeDelta) {\n        return;\n      }\n\n      this.requestNormalizeDelta = false;\n      normalizeDelta(this);\n    }\n  }]);\n\n  return IntervalTree;\n}(); //#region Delta Normalization\n\nfunction normalizeDelta(T) {\n  var node = T.root;\n  var delta = 0;\n\n  while (node !== SENTINEL) {\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    node.start = delta + node.start;\n    node.end = delta + node.end;\n    node.delta = 0;\n    recomputeMaxEnd(node);\n    setNodeIsVisited(node, true); // going up from this node\n\n    setNodeIsVisited(node.left, false);\n    setNodeIsVisited(node.right, false);\n\n    if (node === node.parent.right) {\n      delta -= node.parent.delta;\n    }\n\n    node = node.parent;\n  }\n\n  setNodeIsVisited(T.root, false);\n}\n\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n  if (markerOffset < checkOffset) {\n    return true;\n  }\n\n  if (markerOffset > checkOffset) {\n    return false;\n  }\n\n  if (moveSemantics === 1\n  /* ForceMove */\n  ) {\n      return false;\n    }\n\n  if (moveSemantics === 2\n  /* ForceStay */\n  ) {\n      return true;\n    }\n\n  return markerStickToPreviousCharacter;\n}\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\n\n\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n  var nodeStickiness = getNodeStickiness(node);\n  var startStickToPreviousCharacter = nodeStickiness === 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var endStickToPreviousCharacter = nodeStickiness === 1\n  /* NeverGrowsWhenTypingAtEdges */\n  || nodeStickiness === 2\n  /* GrowsOnlyWhenTypingBefore */\n  ;\n  var deletingCnt = end - start;\n  var insertingCnt = textLength;\n  var commonLength = Math.min(deletingCnt, insertingCnt);\n  var nodeStart = node.start;\n  var startDone = false;\n  var nodeEnd = node.end;\n  var endDone = false;\n\n  if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n    // This edit encompasses the entire decoration range\n    // and the decoration has asked to become collapsed\n    node.start = start;\n    startDone = true;\n    node.end = start;\n    endDone = true;\n  }\n\n  {\n    var moveSemantics = forceMoveMarkers ? 1\n    /* ForceMove */\n    : deletingCnt > 0 ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  if (commonLength > 0 && !forceMoveMarkers) {\n    var _moveSemantics = deletingCnt > insertingCnt ? 2\n    /* ForceStay */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, _moveSemantics)) {\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, _moveSemantics)) {\n      endDone = true;\n    }\n  }\n\n  {\n    var _moveSemantics2 = forceMoveMarkers ? 1\n    /* ForceMove */\n    : 0\n    /* MarkerDefined */\n    ;\n\n    if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, _moveSemantics2)) {\n      node.start = start + insertingCnt;\n      startDone = true;\n    }\n\n    if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, _moveSemantics2)) {\n      node.end = start + insertingCnt;\n      endDone = true;\n    }\n  } // Finish\n\n  var deltaColumn = insertingCnt - deletingCnt;\n\n  if (!startDone) {\n    node.start = Math.max(0, nodeStart + deltaColumn);\n  }\n\n  if (!endDone) {\n    node.end = Math.max(0, nodeEnd + deltaColumn);\n  }\n\n  if (node.start > node.end) {\n    node.end = node.start;\n  }\n}\n\nfunction searchForEditing(T, start, end) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= start) {\n      node.setCachedOffsets(nodeStart, nodeEnd, 0);\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction noOverlapReplace(T, start, end, textLength) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var editDelta = textLength - (end - start);\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      recomputeMaxEnd(node);\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < start) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > end) {\n      node.start += editDelta;\n      node.end += editDelta;\n      node.delta += editDelta;\n\n      if (node.delta < -1073741824\n      /* MIN_SAFE_DELTA */\n      || node.delta > 1073741824\n      /* MAX_SAFE_DELTA */\n      ) {\n          T.requestNormalizeDelta = true;\n        } // cover case a) from above\n      // there is no need to search this node or its right subtree\n\n\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n} //#endregion\n//#region Searching\n\n\nfunction _collectNodesFromOwner(T, ownerId) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    if (node.ownerId === ownerId) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction _collectNodesPostOrder(T) {\n  var node = T.root;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    }\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      node = node.right;\n      continue;\n    } // handle current node\n\n\n    result[resultLen++] = node;\n    setNodeIsVisited(node, true);\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction _search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n  var node = T.root;\n  var delta = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n      // go left\n      node = node.left;\n      continue;\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n    nodeEnd = delta + node.end;\n    node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    var include = true;\n\n    if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n      include = false;\n    }\n\n    if (filterOutValidation && getNodeIsForValidation(node)) {\n      include = false;\n    }\n\n    if (include) {\n      result[resultLen++] = node;\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n}\n\nfunction _intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n  // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n  // Now, it is known that two intervals A and B overlap only when both\n  // A.low <= B.high and A.high >= B.low. When searching the trees for\n  // nodes overlapping with a given interval, you can immediately skip:\n  //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n  //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n  var node = T.root;\n  var delta = 0;\n  var nodeMaxEnd = 0;\n  var nodeStart = 0;\n  var nodeEnd = 0;\n  var result = [];\n  var resultLen = 0;\n\n  while (node !== SENTINEL) {\n    if (getNodeIsVisited(node)) {\n      // going up from this node\n      setNodeIsVisited(node.left, false);\n      setNodeIsVisited(node.right, false);\n\n      if (node === node.parent.right) {\n        delta -= node.parent.delta;\n      }\n\n      node = node.parent;\n      continue;\n    }\n\n    if (!getNodeIsVisited(node.left)) {\n      // first time seeing this node\n      nodeMaxEnd = delta + node.maxEnd;\n\n      if (nodeMaxEnd < intervalStart) {\n        // cover case b) from above\n        // there is no need to search this node or its children\n        setNodeIsVisited(node, true);\n        continue;\n      }\n\n      if (node.left !== SENTINEL) {\n        // go left\n        node = node.left;\n        continue;\n      }\n    } // handle current node\n\n\n    nodeStart = delta + node.start;\n\n    if (nodeStart > intervalEnd) {\n      // cover case a) from above\n      // there is no need to search this node or its right subtree\n      setNodeIsVisited(node, true);\n      continue;\n    }\n\n    nodeEnd = delta + node.end;\n\n    if (nodeEnd >= intervalStart) {\n      // There is overlap\n      node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n      var include = true;\n\n      if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n        include = false;\n      }\n\n      if (filterOutValidation && getNodeIsForValidation(node)) {\n        include = false;\n      }\n\n      if (include) {\n        result[resultLen++] = node;\n      }\n    }\n\n    setNodeIsVisited(node, true);\n\n    if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n      // go right\n      delta += node.delta;\n      node = node.right;\n      continue;\n    }\n  }\n\n  setNodeIsVisited(T.root, false);\n  return result;\n} //#endregion\n//#region Insertion\n\n\nfunction rbTreeInsert(T, newNode) {\n  if (T.root === SENTINEL) {\n    newNode.parent = SENTINEL;\n    newNode.left = SENTINEL;\n    newNode.right = SENTINEL;\n    setNodeColor(newNode, 0\n    /* Black */\n    );\n    T.root = newNode;\n    return T.root;\n  }\n\n  treeInsert(T, newNode);\n  recomputeMaxEndWalkToRoot(newNode.parent); // repair tree\n\n  var x = newNode;\n\n  while (x !== T.root && getNodeColor(x.parent) === 1\n  /* Red */\n  ) {\n    if (x.parent === x.parent.parent.left) {\n      var y = x.parent.parent.right;\n\n      if (getNodeColor(y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.right) {\n          x = x.parent;\n          leftRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        rightRotate(T, x.parent.parent);\n      }\n    } else {\n      var _y = x.parent.parent.left;\n\n      if (getNodeColor(_y) === 1\n      /* Red */\n      ) {\n          setNodeColor(x.parent, 0\n          /* Black */\n          );\n          setNodeColor(_y, 0\n          /* Black */\n          );\n          setNodeColor(x.parent.parent, 1\n          /* Red */\n          );\n          x = x.parent.parent;\n        } else {\n        if (x === x.parent.left) {\n          x = x.parent;\n          rightRotate(T, x);\n        }\n\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(x.parent.parent, 1\n        /* Red */\n        );\n        leftRotate(T, x.parent.parent);\n      }\n    }\n  }\n\n  setNodeColor(T.root, 0\n  /* Black */\n  );\n  return newNode;\n}\n\nfunction treeInsert(T, z) {\n  var delta = 0;\n  var x = T.root;\n  var zAbsoluteStart = z.start;\n  var zAbsoluteEnd = z.end;\n\n  while (true) {\n    var cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n\n    if (cmp < 0) {\n      // this node should be inserted to the left\n      // => it is not affected by the node's delta\n      if (x.left === SENTINEL) {\n        z.start -= delta;\n        z.end -= delta;\n        z.maxEnd -= delta;\n        x.left = z;\n        break;\n      } else {\n        x = x.left;\n      }\n    } else {\n      // this node should be inserted to the right\n      // => it is not affected by the node's delta\n      if (x.right === SENTINEL) {\n        z.start -= delta + x.delta;\n        z.end -= delta + x.delta;\n        z.maxEnd -= delta + x.delta;\n        x.right = z;\n        break;\n      } else {\n        delta += x.delta;\n        x = x.right;\n      }\n    }\n  }\n\n  z.parent = x;\n  z.left = SENTINEL;\n  z.right = SENTINEL;\n  setNodeColor(z, 1\n  /* Red */\n  );\n} //#endregion\n//#region Deletion\n\n\nfunction rbTreeDelete(T, z) {\n  var x;\n  var y; // RB-DELETE except we don't swap z and y in case c)\n  // i.e. we always delete what's pointed at by z.\n\n  if (z.left === SENTINEL) {\n    x = z.right;\n    y = z; // x's delta is no longer influenced by z's delta\n\n    x.delta += z.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    x.start += z.delta;\n    x.end += z.delta;\n  } else if (z.right === SENTINEL) {\n    x = z.left;\n    y = z;\n  } else {\n    y = leftest(z.right);\n    x = y.right; // y's delta is no longer influenced by z's delta,\n    // but we don't want to walk the entire right-hand-side subtree of x.\n    // we therefore maintain z's delta in y, and adjust only x\n\n    x.start += y.delta;\n    x.end += y.delta;\n    x.delta += y.delta;\n\n    if (x.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || x.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n\n    y.start += z.delta;\n    y.end += z.delta;\n    y.delta = z.delta;\n\n    if (y.delta < -1073741824\n    /* MIN_SAFE_DELTA */\n    || y.delta > 1073741824\n    /* MAX_SAFE_DELTA */\n    ) {\n        T.requestNormalizeDelta = true;\n      }\n  }\n\n  if (y === T.root) {\n    T.root = x;\n    setNodeColor(x, 0\n    /* Black */\n    );\n    z.detach();\n    resetSentinel();\n    recomputeMaxEnd(x);\n    T.root.parent = SENTINEL;\n    return;\n  }\n\n  var yWasRed = getNodeColor(y) === 1\n  /* Red */\n  ;\n\n  if (y === y.parent.left) {\n    y.parent.left = x;\n  } else {\n    y.parent.right = x;\n  }\n\n  if (y === z) {\n    x.parent = y.parent;\n  } else {\n    if (y.parent === z) {\n      x.parent = y;\n    } else {\n      x.parent = y.parent;\n    }\n\n    y.left = z.left;\n    y.right = z.right;\n    y.parent = z.parent;\n    setNodeColor(y, getNodeColor(z));\n\n    if (z === T.root) {\n      T.root = y;\n    } else {\n      if (z === z.parent.left) {\n        z.parent.left = y;\n      } else {\n        z.parent.right = y;\n      }\n    }\n\n    if (y.left !== SENTINEL) {\n      y.left.parent = y;\n    }\n\n    if (y.right !== SENTINEL) {\n      y.right.parent = y;\n    }\n  }\n\n  z.detach();\n\n  if (yWasRed) {\n    recomputeMaxEndWalkToRoot(x.parent);\n\n    if (y !== z) {\n      recomputeMaxEndWalkToRoot(y);\n      recomputeMaxEndWalkToRoot(y.parent);\n    }\n\n    resetSentinel();\n    return;\n  }\n\n  recomputeMaxEndWalkToRoot(x);\n  recomputeMaxEndWalkToRoot(x.parent);\n\n  if (y !== z) {\n    recomputeMaxEndWalkToRoot(y);\n    recomputeMaxEndWalkToRoot(y.parent);\n  } // RB-DELETE-FIXUP\n\n\n  var w;\n\n  while (x !== T.root && getNodeColor(x) === 0\n  /* Black */\n  ) {\n    if (x === x.parent.left) {\n      w = x.parent.right;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          leftRotate(T, x.parent);\n          w = x.parent.right;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.right) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.left, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            rightRotate(T, w);\n            w = x.parent.right;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.right, 0\n        /* Black */\n        );\n        leftRotate(T, x.parent);\n        x = T.root;\n      }\n    } else {\n      w = x.parent.left;\n\n      if (getNodeColor(w) === 1\n      /* Red */\n      ) {\n          setNodeColor(w, 0\n          /* Black */\n          );\n          setNodeColor(x.parent, 1\n          /* Red */\n          );\n          rightRotate(T, x.parent);\n          w = x.parent.left;\n        }\n\n      if (getNodeColor(w.left) === 0\n      /* Black */\n      && getNodeColor(w.right) === 0\n      /* Black */\n      ) {\n          setNodeColor(w, 1\n          /* Red */\n          );\n          x = x.parent;\n        } else {\n        if (getNodeColor(w.left) === 0\n        /* Black */\n        ) {\n            setNodeColor(w.right, 0\n            /* Black */\n            );\n            setNodeColor(w, 1\n            /* Red */\n            );\n            leftRotate(T, w);\n            w = x.parent.left;\n          }\n\n        setNodeColor(w, getNodeColor(x.parent));\n        setNodeColor(x.parent, 0\n        /* Black */\n        );\n        setNodeColor(w.left, 0\n        /* Black */\n        );\n        rightRotate(T, x.parent);\n        x = T.root;\n      }\n    }\n  }\n\n  setNodeColor(x, 0\n  /* Black */\n  );\n  resetSentinel();\n}\n\nfunction leftest(node) {\n  while (node.left !== SENTINEL) {\n    node = node.left;\n  }\n\n  return node;\n}\n\nfunction resetSentinel() {\n  SENTINEL.parent = SENTINEL;\n  SENTINEL.delta = 0; // optional\n\n  SENTINEL.start = 0; // optional\n\n  SENTINEL.end = 0; // optional\n} //#endregion\n//#region Rotations\n\n\nfunction leftRotate(T, x) {\n  var y = x.right; // set y.\n\n  y.delta += x.delta; // y's delta is no longer influenced by x's delta\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start += x.delta;\n  y.end += x.delta;\n  x.right = y.left; // turn y's left subtree into x's right subtree.\n\n  if (y.left !== SENTINEL) {\n    y.left.parent = x;\n  }\n\n  y.parent = x.parent; // link x's parent to y.\n\n  if (x.parent === SENTINEL) {\n    T.root = y;\n  } else if (x === x.parent.left) {\n    x.parent.left = y;\n  } else {\n    x.parent.right = y;\n  }\n\n  y.left = x; // put x on y's left.\n\n  x.parent = y;\n  recomputeMaxEnd(x);\n  recomputeMaxEnd(y);\n}\n\nfunction rightRotate(T, y) {\n  var x = y.left;\n  y.delta -= x.delta;\n\n  if (y.delta < -1073741824\n  /* MIN_SAFE_DELTA */\n  || y.delta > 1073741824\n  /* MAX_SAFE_DELTA */\n  ) {\n      T.requestNormalizeDelta = true;\n    }\n\n  y.start -= x.delta;\n  y.end -= x.delta;\n  y.left = x.right;\n\n  if (x.right !== SENTINEL) {\n    x.right.parent = y;\n  }\n\n  x.parent = y.parent;\n\n  if (y.parent === SENTINEL) {\n    T.root = x;\n  } else if (y === y.parent.right) {\n    y.parent.right = x;\n  } else {\n    y.parent.left = x;\n  }\n\n  x.right = y;\n  y.parent = x;\n  recomputeMaxEnd(y);\n  recomputeMaxEnd(x);\n} //#endregion\n//#region max end computation\n\n\nfunction computeMaxEnd(node) {\n  var maxEnd = node.end;\n\n  if (node.left !== SENTINEL) {\n    var leftMaxEnd = node.left.maxEnd;\n\n    if (leftMaxEnd > maxEnd) {\n      maxEnd = leftMaxEnd;\n    }\n  }\n\n  if (node.right !== SENTINEL) {\n    var rightMaxEnd = node.right.maxEnd + node.delta;\n\n    if (rightMaxEnd > maxEnd) {\n      maxEnd = rightMaxEnd;\n    }\n  }\n\n  return maxEnd;\n}\n\nexport function recomputeMaxEnd(node) {\n  node.maxEnd = computeMaxEnd(node);\n}\n\nfunction recomputeMaxEndWalkToRoot(node) {\n  while (node !== SENTINEL) {\n    var maxEnd = computeMaxEnd(node);\n\n    if (node.maxEnd === maxEnd) {\n      // no need to go further\n      return;\n    }\n\n    node.maxEnd = maxEnd;\n    node = node.parent;\n  }\n} //#endregion\n//#region utils\n\n\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n  if (aStart === bStart) {\n    return aEnd - bEnd;\n  }\n\n  return aStart - bStart;\n} //#endregion","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js"],"names":["getNodeColor","node","metadata","setNodeColor","color","getNodeIsVisited","setNodeIsVisited","value","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInOverviewRuler","setNodeIsInOverviewRuler","getNodeStickiness","_setNodeStickiness","stickiness","getCollapseOnReplaceEdit","setCollapseOnReplaceEdit","IntervalNode","id","start","end","parent","left","right","delta","maxEnd","ownerId","options","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","range","versionId","className","overviewRuler","collapseOnReplaceEdit","absoluteStart","absoluteEnd","SENTINEL","IntervalTree","root","requestNormalizeDelta","filterOwnerId","filterOutValidation","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","initialNode","nodeStart","nodeEnd","setCachedOffsets","offset","length","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","i","len","noOverlapReplace","nodeAcceptEdit","normalizeDelta","T","recomputeMaxEnd","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","Math","min","startDone","endDone","deltaColumn","max","nodeMaxEnd","result","resultLen","editDelta","include","intervalStart","intervalEnd","newNode","treeInsert","recomputeMaxEndWalkToRoot","x","y","leftRotate","rightRotate","z","zAbsoluteStart","zAbsoluteEnd","cmp","intervalCompare","leftest","detach","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC/B,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAE;AAAnB,QAAwC;AAAE;AAAlD;AACH;;AACD,SAASC,YAAT,CAAsBF,IAAtB,EAA4BG,KAA5B,EAAmC;AAC/BH,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAAgDE,KAAK,IAAI;AAAE;AAA5E;AACH;;AACD,SAASC,gBAAT,CAA0BJ,IAA1B,EAAgC;AAC5B,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAE;AAAnB,QAA4C;AAAE;AAA/C,MAA0E,CAAjF;AACH;;AACD,SAASI,gBAAT,CAA0BL,IAA1B,EAAgCM,KAAhC,EAAuC;AACnCN,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAAoD,CAACK,KAAK,GAAG,CAAH,GAAO,CAAb,KAAmB;AAAE;AAA1F;AACH;;AACD,SAASC,sBAAT,CAAgCP,IAAhC,EAAsC;AAClC,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAE;AAAnB,QAAkD;AAAE;AAArD,MAAsF,CAA7F;AACH;;AACD,SAASO,sBAAT,CAAgCR,IAAhC,EAAsCM,KAAtC,EAA6C;AACzCN,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAA0D,CAACK,KAAK,GAAG,CAAH,GAAO,CAAb,KAAmB;AAAE;AAAhG;AACH;;AACD,OAAO,SAASG,wBAAT,CAAkCT,IAAlC,EAAwC;AAC3C,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAE;AAAnB,QAAoD;AAAE;AAAvD,MAA0F,CAAjG;AACH;;AACD,SAASS,wBAAT,CAAkCV,IAAlC,EAAwCM,KAAxC,EAA+C;AAC3CN,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAA4D,CAACK,KAAK,GAAG,CAAH,GAAO,CAAb,KAAmB;AAAE;AAAlG;AACH;;AACD,SAASK,iBAAT,CAA2BX,IAA3B,EAAiC;AAC7B,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAG;AAApB,QAA8C;AAAE;AAAxD;AACH;;AACD,SAASW,kBAAT,CAA4BZ,IAA5B,EAAkCa,UAAlC,EAA8C;AAC1Cb,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAAqDY,UAAU,IAAI;AAAE;AAAtF;AACH;;AACD,SAASC,wBAAT,CAAkCd,IAAlC,EAAwC;AACpC,SAAQ,CAACA,IAAI,CAACC,QAAL,GAAgB;AAAG;AAApB,QAAyD;AAAE;AAA5D,MAAmG,CAA1G;AACH;;AACD,SAASc,wBAAT,CAAkCf,IAAlC,EAAwCM,KAAxC,EAA+C;AAC3CN,EAAAA,IAAI,CAACC,QAAL,GAAkBD,IAAI,CAACC,QAAL,GAAgB;AAAI;AAArB,IAAgE,CAACK,KAAK,GAAG,CAAH,GAAO,CAAb,KAAmB;AAAE;AAAtG;AACH;;AACD,WAAaU,YAAb;AACI,wBAAYC,EAAZ,EAAgBC,KAAhB,EAAuBC,GAAvB,EAA4B;AAAA;;AACxB,SAAKlB,QAAL,GAAgB,CAAhB;AACA,SAAKmB,MAAL,GAAc,IAAd;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,IAAb;AACApB,IAAAA,YAAY,CAAC,IAAD,EAAO;AAAE;AAAT,KAAZ;AACA,SAAKgB,KAAL,GAAaA,KAAb;AACA,SAAKC,GAAL,GAAWA,GAAX,CAPwB,CAQxB;;AACA,SAAKI,KAAL,GAAa,CAAb;AACA,SAAKC,MAAL,GAAcL,GAAd;AACA,SAAKF,EAAL,GAAUA,EAAV;AACA,SAAKQ,OAAL,GAAe,CAAf;AACA,SAAKC,OAAL,GAAe,IAAf;AACAlB,IAAAA,sBAAsB,CAAC,IAAD,EAAO,KAAP,CAAtB;;AACAI,IAAAA,kBAAkB,CAAC,IAAD,EAAO;AAAE;AAAT,KAAlB;;AACAF,IAAAA,wBAAwB,CAAC,IAAD,EAAO,KAAP,CAAxB;AACAK,IAAAA,wBAAwB,CAAC,IAAD,EAAO,KAAP,CAAxB;AACA,SAAKY,eAAL,GAAuB,CAAvB;AACA,SAAKC,mBAAL,GAA2BV,KAA3B;AACA,SAAKW,iBAAL,GAAyBV,GAAzB;AACA,SAAKW,KAAL,GAAa,IAAb;AACAzB,IAAAA,gBAAgB,CAAC,IAAD,EAAO,KAAP,CAAhB;AACH;;AAxBL;AAAA;AAAA,0BAyBU0B,SAzBV,EAyBqBb,KAzBrB,EAyB4BC,GAzB5B,EAyBiCW,KAzBjC,EAyBwC;AAChC,WAAKZ,KAAL,GAAaA,KAAb;AACA,WAAKC,GAAL,GAAWA,GAAX;AACA,WAAKK,MAAL,GAAcL,GAAd;AACA,WAAKQ,eAAL,GAAuBI,SAAvB;AACA,WAAKH,mBAAL,GAA2BV,KAA3B;AACA,WAAKW,iBAAL,GAAyBV,GAAzB;AACA,WAAKW,KAAL,GAAaA,KAAb;AACH;AAjCL;AAAA;AAAA,+BAkCeJ,OAlCf,EAkCwB;AAChB,WAAKA,OAAL,GAAeA,OAAf;AACA,UAAIM,SAAS,GAAG,KAAKN,OAAL,CAAaM,SAA7B;AACAxB,MAAAA,sBAAsB,CAAC,IAAD,EAAQwB,SAAS,KAAK;AAAiB;AAA/B,SACvBA,SAAS,KAAK;AAAmB;AADV,SAEvBA,SAAS,KAAK;AAAgB;AAFf,OAAtB;;AAGApB,MAAAA,kBAAkB,CAAC,IAAD,EAAO,KAAKc,OAAL,CAAab,UAApB,CAAlB;;AACAH,MAAAA,wBAAwB,CAAC,IAAD,EAAQ,KAAKgB,OAAL,CAAaO,aAAb,IAA8B,KAAKP,OAAL,CAAaO,aAAb,CAA2B9B,KAA1D,GAAmE,IAAnE,GAA0E,KAAjF,CAAxB;AACAY,MAAAA,wBAAwB,CAAC,IAAD,EAAO,KAAKW,OAAL,CAAaQ,qBAApB,CAAxB;AACH;AA3CL;AAAA;AAAA,qCA4CqBC,aA5CrB,EA4CoCC,WA5CpC,EA4CiDT,eA5CjD,EA4CkE;AAC1D,UAAI,KAAKA,eAAL,KAAyBA,eAA7B,EAA8C;AAC1C,aAAKG,KAAL,GAAa,IAAb;AACH;;AACD,WAAKH,eAAL,GAAuBA,eAAvB;AACA,WAAKC,mBAAL,GAA2BO,aAA3B;AACA,WAAKN,iBAAL,GAAyBO,WAAzB;AACH;AAnDL;AAAA;AAAA,6BAoDa;AACL,WAAKhB,MAAL,GAAc,IAAd;AACA,WAAKC,IAAL,GAAY,IAAZ;AACA,WAAKC,KAAL,GAAa,IAAb;AACH;AAxDL;;AAAA;AAAA;AA0DA,OAAO,IAAMe,QAAQ,GAAG,IAAIrB,YAAJ,CAAiB,IAAjB,EAAuB,CAAvB,EAA0B,CAA1B,CAAjB;AACPqB,QAAQ,CAACjB,MAAT,GAAkBiB,QAAlB;AACAA,QAAQ,CAAChB,IAAT,GAAgBgB,QAAhB;AACAA,QAAQ,CAACf,KAAT,GAAiBe,QAAjB;AACAnC,YAAY,CAACmC,QAAD,EAAW;AAAE;AAAb,CAAZ;AACA,WAAaC,YAAb;AACI,0BAAc;AAAA;;AACV,SAAKC,IAAL,GAAYF,QAAZ;AACA,SAAKG,qBAAL,GAA6B,KAA7B;AACH;;AAJL;AAAA;AAAA,mCAKmBtB,KALnB,EAK0BC,GAL1B,EAK+BsB,aAL/B,EAK8CC,mBAL9C,EAKmEf,eALnE,EAKoF;AAC5E,UAAI,KAAKY,IAAL,KAAcF,QAAlB,EAA4B;AACxB,eAAO,EAAP;AACH;;AACD,aAAOM,eAAc,CAAC,IAAD,EAAOzB,KAAP,EAAcC,GAAd,EAAmBsB,aAAnB,EAAkCC,mBAAlC,EAAuDf,eAAvD,CAArB;AACH;AAVL;AAAA;AAAA,2BAWWc,aAXX,EAW0BC,mBAX1B,EAW+Cf,eAX/C,EAWgE;AACxD,UAAI,KAAKY,IAAL,KAAcF,QAAlB,EAA4B;AACxB,eAAO,EAAP;AACH;;AACD,aAAOO,OAAM,CAAC,IAAD,EAAOH,aAAP,EAAsBC,mBAAtB,EAA2Cf,eAA3C,CAAb;AACH;AACD;AACJ;AACA;;AAnBA;AAAA;AAAA,0CAoB0BF,OApB1B,EAoBmC;AAC3B,aAAOoB,sBAAqB,CAAC,IAAD,EAAOpB,OAAP,CAA5B;AACH;AACD;AACJ;AACA;;AAzBA;AAAA;AAAA,4CA0B4B;AACpB,aAAOqB,sBAAqB,CAAC,IAAD,CAA5B;AACH;AA5BL;AAAA;AAAA,2BA6BW9C,IA7BX,EA6BiB;AACT+C,MAAAA,YAAY,CAAC,IAAD,EAAO/C,IAAP,CAAZ;;AACA,WAAKgD,0BAAL;AACH;AAhCL;AAAA;AAAA,4BAiCWhD,IAjCX,EAiCiB;AACTiD,MAAAA,YAAY,CAAC,IAAD,EAAOjD,IAAP,CAAZ;;AACA,WAAKgD,0BAAL;AACH;AApCL;AAAA;AAAA,gCAqCgBhD,IArChB,EAqCsB2B,eArCtB,EAqCuC;AAC/B,UAAMuB,WAAW,GAAGlD,IAApB;AACA,UAAIuB,KAAK,GAAG,CAAZ;;AACA,aAAOvB,IAAI,KAAK,KAAKuC,IAArB,EAA2B;AACvB,YAAIvC,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,UAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACDvB,QAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACH;;AACD,UAAM+B,SAAS,GAAGD,WAAW,CAAChC,KAAZ,GAAoBK,KAAtC;AACA,UAAM6B,OAAO,GAAGF,WAAW,CAAC/B,GAAZ,GAAkBI,KAAlC;AACA2B,MAAAA,WAAW,CAACG,gBAAZ,CAA6BF,SAA7B,EAAwCC,OAAxC,EAAiDzB,eAAjD;AACH;AAjDL;AAAA;AAAA,kCAkDkB2B,MAlDlB,EAkD0BC,MAlD1B,EAkDkCC,UAlDlC,EAkD8CC,gBAlD9C,EAkDgE;AACxD;AACA;AACA,UAAMC,eAAe,GAAGC,gBAAgB,CAAC,IAAD,EAAOL,MAAP,EAAeA,MAAM,GAAGC,MAAxB,CAAxC,CAHwD,CAIxD;;AACA,WAAK,IAAIK,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGH,eAAe,CAACH,MAAtC,EAA8CK,CAAC,GAAGC,GAAlD,EAAuDD,CAAC,EAAxD,EAA4D;AACxD,YAAM5D,IAAI,GAAG0D,eAAe,CAACE,CAAD,CAA5B;AACAX,QAAAA,YAAY,CAAC,IAAD,EAAOjD,IAAP,CAAZ;AACH;;AACD,WAAKgD,0BAAL,GATwD,CAUxD;;;AACAc,MAAAA,gBAAgB,CAAC,IAAD,EAAOR,MAAP,EAAeA,MAAM,GAAGC,MAAxB,EAAgCC,UAAhC,CAAhB;;AACA,WAAKR,0BAAL,GAZwD,CAaxD;;;AACA,WAAK,IAAIY,EAAC,GAAG,CAAR,EAAWC,IAAG,GAAGH,eAAe,CAACH,MAAtC,EAA8CK,EAAC,GAAGC,IAAlD,EAAuDD,EAAC,EAAxD,EAA4D;AACxD,YAAM5D,KAAI,GAAG0D,eAAe,CAACE,EAAD,CAA5B;AACA5D,QAAAA,KAAI,CAACkB,KAAL,GAAalB,KAAI,CAAC4B,mBAAlB;AACA5B,QAAAA,KAAI,CAACmB,GAAL,GAAWnB,KAAI,CAAC6B,iBAAhB;AACAkC,QAAAA,cAAc,CAAC/D,KAAD,EAAOsD,MAAP,EAAgBA,MAAM,GAAGC,MAAzB,EAAkCC,UAAlC,EAA8CC,gBAA9C,CAAd;AACAzD,QAAAA,KAAI,CAACwB,MAAL,GAAcxB,KAAI,CAACmB,GAAnB;AACA4B,QAAAA,YAAY,CAAC,IAAD,EAAO/C,KAAP,CAAZ;AACH;;AACD,WAAKgD,0BAAL;AACH;AAzEL;AAAA;AAAA,iDA0EiC;AACzB,UAAI,CAAC,KAAKR,qBAAV,EAAiC;AAC7B;AACH;;AACD,WAAKA,qBAAL,GAA6B,KAA7B;AACAwB,MAAAA,cAAc,CAAC,IAAD,CAAd;AACH;AAhFL;;AAAA;AAAA,I,CAkFA;;AACA,SAASA,cAAT,CAAwBC,CAAxB,EAA2B;AACvB,MAAIjE,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAIhB,KAAK,GAAG,CAAZ;;AACA,SAAOvB,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIrC,IAAI,CAACqB,IAAL,KAAcgB,QAAd,IAA0B,CAACjC,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAA/C,EAA4D;AACxD;AACArB,MAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH;;AACD,QAAIrB,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAC,MAAAA,KAAK,IAAIvB,IAAI,CAACuB,KAAd;AACAvB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH,KAXqB,CAYtB;;;AACAtB,IAAAA,IAAI,CAACkB,KAAL,GAAaK,KAAK,GAAGvB,IAAI,CAACkB,KAA1B;AACAlB,IAAAA,IAAI,CAACmB,GAAL,GAAWI,KAAK,GAAGvB,IAAI,CAACmB,GAAxB;AACAnB,IAAAA,IAAI,CAACuB,KAAL,GAAa,CAAb;AACA2C,IAAAA,eAAe,CAAClE,IAAD,CAAf;AACAK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB,CAjBsB,CAkBtB;;AACAK,IAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,IAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;;AACA,QAAItB,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,MAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACDvB,IAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACH;;AACDf,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACH;;AACD,SAAS4B,wBAAT,CAAkCC,YAAlC,EAAgDC,8BAAhD,EAAgFC,WAAhF,EAA6FC,aAA7F,EAA4G;AACxG,MAAIH,YAAY,GAAGE,WAAnB,EAAgC;AAC5B,WAAO,IAAP;AACH;;AACD,MAAIF,YAAY,GAAGE,WAAnB,EAAgC;AAC5B,WAAO,KAAP;AACH;;AACD,MAAIC,aAAa,KAAK;AAAE;AAAxB,IAAyC;AACrC,aAAO,KAAP;AACH;;AACD,MAAIA,aAAa,KAAK;AAAE;AAAxB,IAAyC;AACrC,aAAO,IAAP;AACH;;AACD,SAAOF,8BAAP;AACH;AACD;AACA;AACA;AACA;;;AACA,OAAO,SAASN,cAAT,CAAwB/D,IAAxB,EAA8BkB,KAA9B,EAAqCC,GAArC,EAA0CqC,UAA1C,EAAsDC,gBAAtD,EAAwE;AAC3E,MAAMe,cAAc,GAAG7D,iBAAiB,CAACX,IAAD,CAAxC;AACA,MAAMyE,6BAA6B,GAAID,cAAc,KAAK;AAAE;AAArB,KAChCA,cAAc,KAAK;AAAE;AAD5B;AAEA,MAAME,2BAA2B,GAAIF,cAAc,KAAK;AAAE;AAArB,KAC9BA,cAAc,KAAK;AAAE;AAD5B;AAEA,MAAMG,WAAW,GAAIxD,GAAG,GAAGD,KAA3B;AACA,MAAM0D,YAAY,GAAGpB,UAArB;AACA,MAAMqB,YAAY,GAAGC,IAAI,CAACC,GAAL,CAASJ,WAAT,EAAsBC,YAAtB,CAArB;AACA,MAAMzB,SAAS,GAAGnD,IAAI,CAACkB,KAAvB;AACA,MAAI8D,SAAS,GAAG,KAAhB;AACA,MAAM5B,OAAO,GAAGpD,IAAI,CAACmB,GAArB;AACA,MAAI8D,OAAO,GAAG,KAAd;;AACA,MAAI/D,KAAK,IAAIiC,SAAT,IAAsBC,OAAO,IAAIjC,GAAjC,IAAwCL,wBAAwB,CAACd,IAAD,CAApE,EAA4E;AACxE;AACA;AACAA,IAAAA,IAAI,CAACkB,KAAL,GAAaA,KAAb;AACA8D,IAAAA,SAAS,GAAG,IAAZ;AACAhF,IAAAA,IAAI,CAACmB,GAAL,GAAWD,KAAX;AACA+D,IAAAA,OAAO,GAAG,IAAV;AACH;;AACD;AACI,QAAMV,aAAa,GAAGd,gBAAgB,GAAG;AAAE;AAAL,MAAwBkB,WAAW,GAAG,CAAd,GAAkB;AAAE;AAApB,MAAsC;AAAE;AAAtG;;AACA,QAAI,CAACK,SAAD,IAAcb,wBAAwB,CAAChB,SAAD,EAAYsB,6BAAZ,EAA2CvD,KAA3C,EAAkDqD,aAAlD,CAA1C,EAA4G;AACxGS,MAAAA,SAAS,GAAG,IAAZ;AACH;;AACD,QAAI,CAACC,OAAD,IAAYd,wBAAwB,CAACf,OAAD,EAAUsB,2BAAV,EAAuCxD,KAAvC,EAA8CqD,aAA9C,CAAxC,EAAsG;AAClGU,MAAAA,OAAO,GAAG,IAAV;AACH;AACJ;;AACD,MAAIJ,YAAY,GAAG,CAAf,IAAoB,CAACpB,gBAAzB,EAA2C;AACvC,QAAMc,cAAa,GAAII,WAAW,GAAGC,YAAd,GAA6B;AAAE;AAA/B,MAAiD;AAAE;AAA1E;;AACA,QAAI,CAACI,SAAD,IAAcb,wBAAwB,CAAChB,SAAD,EAAYsB,6BAAZ,EAA2CvD,KAAK,GAAG2D,YAAnD,EAAiEN,cAAjE,CAA1C,EAA2H;AACvHS,MAAAA,SAAS,GAAG,IAAZ;AACH;;AACD,QAAI,CAACC,OAAD,IAAYd,wBAAwB,CAACf,OAAD,EAAUsB,2BAAV,EAAuCxD,KAAK,GAAG2D,YAA/C,EAA6DN,cAA7D,CAAxC,EAAqH;AACjHU,MAAAA,OAAO,GAAG,IAAV;AACH;AACJ;;AACD;AACI,QAAMV,eAAa,GAAGd,gBAAgB,GAAG;AAAE;AAAL,MAAuB;AAAE;AAA/D;;AACA,QAAI,CAACuB,SAAD,IAAcb,wBAAwB,CAAChB,SAAD,EAAYsB,6BAAZ,EAA2CtD,GAA3C,EAAgDoD,eAAhD,CAA1C,EAA0G;AACtGvE,MAAAA,IAAI,CAACkB,KAAL,GAAaA,KAAK,GAAG0D,YAArB;AACAI,MAAAA,SAAS,GAAG,IAAZ;AACH;;AACD,QAAI,CAACC,OAAD,IAAYd,wBAAwB,CAACf,OAAD,EAAUsB,2BAAV,EAAuCvD,GAAvC,EAA4CoD,eAA5C,CAAxC,EAAoG;AAChGvE,MAAAA,IAAI,CAACmB,GAAL,GAAWD,KAAK,GAAG0D,YAAnB;AACAK,MAAAA,OAAO,GAAG,IAAV;AACH;AACJ,GAjD0E,CAkD3E;;AACA,MAAMC,WAAW,GAAIN,YAAY,GAAGD,WAApC;;AACA,MAAI,CAACK,SAAL,EAAgB;AACZhF,IAAAA,IAAI,CAACkB,KAAL,GAAa4D,IAAI,CAACK,GAAL,CAAS,CAAT,EAAYhC,SAAS,GAAG+B,WAAxB,CAAb;AACH;;AACD,MAAI,CAACD,OAAL,EAAc;AACVjF,IAAAA,IAAI,CAACmB,GAAL,GAAW2D,IAAI,CAACK,GAAL,CAAS,CAAT,EAAY/B,OAAO,GAAG8B,WAAtB,CAAX;AACH;;AACD,MAAIlF,IAAI,CAACkB,KAAL,GAAalB,IAAI,CAACmB,GAAtB,EAA2B;AACvBnB,IAAAA,IAAI,CAACmB,GAAL,GAAWnB,IAAI,CAACkB,KAAhB;AACH;AACJ;;AACD,SAASyC,gBAAT,CAA0BM,CAA1B,EAA6B/C,KAA7B,EAAoCC,GAApC,EAAyC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,MAAInB,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAIhB,KAAK,GAAG,CAAZ;AACA,MAAI6D,UAAU,GAAG,CAAjB;AACA,MAAIjC,SAAS,GAAG,CAAhB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIiC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,CAAhB;;AACA,SAAOtF,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;;AACA,UAAItB,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,QAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACDvB,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAI,CAAChB,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAArB,EAAkC;AAC9B;AACA+D,MAAAA,UAAU,GAAG7D,KAAK,GAAGvB,IAAI,CAACwB,MAA1B;;AACA,UAAI4D,UAAU,GAAGlE,KAAjB,EAAwB;AACpB;AACA;AACAb,QAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACD,UAAIA,IAAI,CAACqB,IAAL,KAAcgB,QAAlB,EAA4B;AACxB;AACArC,QAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH;AACJ,KAzBqB,CA0BtB;;;AACA8B,IAAAA,SAAS,GAAG5B,KAAK,GAAGvB,IAAI,CAACkB,KAAzB;;AACA,QAAIiC,SAAS,GAAGhC,GAAhB,EAAqB;AACjB;AACA;AACAd,MAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACDoD,IAAAA,OAAO,GAAG7B,KAAK,GAAGvB,IAAI,CAACmB,GAAvB;;AACA,QAAIiC,OAAO,IAAIlC,KAAf,EAAsB;AAClBlB,MAAAA,IAAI,CAACqD,gBAAL,CAAsBF,SAAtB,EAAiCC,OAAjC,EAA0C,CAA1C;AACAiC,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBtF,IAAtB;AACH;;AACDK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;;AACA,QAAIA,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAC,MAAAA,KAAK,IAAIvB,IAAI,CAACuB,KAAd;AACAvB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH;AACJ;;AACDjB,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACA,SAAO8C,MAAP;AACH;;AACD,SAASvB,gBAAT,CAA0BG,CAA1B,EAA6B/C,KAA7B,EAAoCC,GAApC,EAAyCqC,UAAzC,EAAqD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,MAAIxD,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAIhB,KAAK,GAAG,CAAZ;AACA,MAAI6D,UAAU,GAAG,CAAjB;AACA,MAAIjC,SAAS,GAAG,CAAhB;AACA,MAAMoC,SAAS,GAAI/B,UAAU,IAAIrC,GAAG,GAAGD,KAAV,CAA7B;;AACA,SAAOlB,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;;AACA,UAAItB,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,QAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACD2C,MAAAA,eAAe,CAAClE,IAAD,CAAf;AACAA,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAI,CAAChB,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAArB,EAAkC;AAC9B;AACA+D,MAAAA,UAAU,GAAG7D,KAAK,GAAGvB,IAAI,CAACwB,MAA1B;;AACA,UAAI4D,UAAU,GAAGlE,KAAjB,EAAwB;AACpB;AACA;AACAb,QAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACD,UAAIA,IAAI,CAACqB,IAAL,KAAcgB,QAAlB,EAA4B;AACxB;AACArC,QAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH;AACJ,KA1BqB,CA2BtB;;;AACA8B,IAAAA,SAAS,GAAG5B,KAAK,GAAGvB,IAAI,CAACkB,KAAzB;;AACA,QAAIiC,SAAS,GAAGhC,GAAhB,EAAqB;AACjBnB,MAAAA,IAAI,CAACkB,KAAL,IAAcqE,SAAd;AACAvF,MAAAA,IAAI,CAACmB,GAAL,IAAYoE,SAAZ;AACAvF,MAAAA,IAAI,CAACuB,KAAL,IAAcgE,SAAd;;AACA,UAAIvF,IAAI,CAACuB,KAAL,GAAa,CAAC;AAAW;AAAzB,SAAiDvB,IAAI,CAACuB,KAAL,GAAa;AAAW;AAA7E,QAAmG;AAC/F0C,UAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH,SANgB,CAOjB;AACA;;;AACAnC,MAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACDK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;;AACA,QAAIA,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAC,MAAAA,KAAK,IAAIvB,IAAI,CAACuB,KAAd;AACAvB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH;AACJ;;AACDjB,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACH,C,CACD;AACA;;;AACA,SAASM,sBAAT,CAA+BoB,CAA/B,EAAkCxC,OAAlC,EAA2C;AACvC,MAAIzB,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAI8C,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,CAAhB;;AACA,SAAOtF,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;AACAtB,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAIpB,IAAI,CAACqB,IAAL,KAAcgB,QAAd,IAA0B,CAACjC,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAA/C,EAA4D;AACxD;AACArB,MAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH,KAZqB,CAatB;;;AACA,QAAIrB,IAAI,CAACyB,OAAL,KAAiBA,OAArB,EAA8B;AAC1B4D,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBtF,IAAtB;AACH;;AACDK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;;AACA,QAAIA,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAtB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH;AACJ;;AACDjB,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACA,SAAO8C,MAAP;AACH;;AACD,SAASvC,sBAAT,CAA+BmB,CAA/B,EAAkC;AAC9B,MAAIjE,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAI8C,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,CAAhB;;AACA,SAAOtF,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;AACAtB,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAIpB,IAAI,CAACqB,IAAL,KAAcgB,QAAd,IAA0B,CAACjC,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAA/C,EAA4D;AACxD;AACArB,MAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH;;AACD,QAAIrB,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAtB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH,KAjBqB,CAkBtB;;;AACA+D,IAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBtF,IAAtB;AACAK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACH;;AACDK,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACA,SAAO8C,MAAP;AACH;;AACD,SAASzC,OAAT,CAAgBqB,CAAhB,EAAmBxB,aAAnB,EAAkCC,mBAAlC,EAAuDf,eAAvD,EAAwE;AACpE,MAAI3B,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAIhB,KAAK,GAAG,CAAZ;AACA,MAAI4B,SAAS,GAAG,CAAhB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIiC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,CAAhB;;AACA,SAAOtF,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;;AACA,UAAItB,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,QAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACDvB,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAIpB,IAAI,CAACqB,IAAL,KAAcgB,QAAd,IAA0B,CAACjC,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAA/C,EAA4D;AACxD;AACArB,MAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH,KAfqB,CAgBtB;;;AACA8B,IAAAA,SAAS,GAAG5B,KAAK,GAAGvB,IAAI,CAACkB,KAAzB;AACAkC,IAAAA,OAAO,GAAG7B,KAAK,GAAGvB,IAAI,CAACmB,GAAvB;AACAnB,IAAAA,IAAI,CAACqD,gBAAL,CAAsBF,SAAtB,EAAiCC,OAAjC,EAA0CzB,eAA1C;AACA,QAAI6D,OAAO,GAAG,IAAd;;AACA,QAAI/C,aAAa,IAAIzC,IAAI,CAACyB,OAAtB,IAAiCzB,IAAI,CAACyB,OAAL,KAAiBgB,aAAtD,EAAqE;AACjE+C,MAAAA,OAAO,GAAG,KAAV;AACH;;AACD,QAAI9C,mBAAmB,IAAInC,sBAAsB,CAACP,IAAD,CAAjD,EAAyD;AACrDwF,MAAAA,OAAO,GAAG,KAAV;AACH;;AACD,QAAIA,OAAJ,EAAa;AACTH,MAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBtF,IAAtB;AACH;;AACDK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;;AACA,QAAIA,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAC,MAAAA,KAAK,IAAIvB,IAAI,CAACuB,KAAd;AACAvB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH;AACJ;;AACDjB,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACA,SAAO8C,MAAP;AACH;;AACD,SAAS1C,eAAT,CAAwBsB,CAAxB,EAA2BwB,aAA3B,EAA0CC,WAA1C,EAAuDjD,aAAvD,EAAsEC,mBAAtE,EAA2Ff,eAA3F,EAA4G;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,MAAI3B,IAAI,GAAGiE,CAAC,CAAC1B,IAAb;AACA,MAAIhB,KAAK,GAAG,CAAZ;AACA,MAAI6D,UAAU,GAAG,CAAjB;AACA,MAAIjC,SAAS,GAAG,CAAhB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIiC,MAAM,GAAG,EAAb;AACA,MAAIC,SAAS,GAAG,CAAhB;;AACA,SAAOtF,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAIjC,gBAAgB,CAACJ,IAAD,CAApB,EAA4B;AACxB;AACAK,MAAAA,gBAAgB,CAACL,IAAI,CAACqB,IAAN,EAAY,KAAZ,CAAhB;AACAhB,MAAAA,gBAAgB,CAACL,IAAI,CAACsB,KAAN,EAAa,KAAb,CAAhB;;AACA,UAAItB,IAAI,KAAKA,IAAI,CAACoB,MAAL,CAAYE,KAAzB,EAAgC;AAC5BC,QAAAA,KAAK,IAAIvB,IAAI,CAACoB,MAAL,CAAYG,KAArB;AACH;;AACDvB,MAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACA;AACH;;AACD,QAAI,CAAChB,gBAAgB,CAACJ,IAAI,CAACqB,IAAN,CAArB,EAAkC;AAC9B;AACA+D,MAAAA,UAAU,GAAG7D,KAAK,GAAGvB,IAAI,CAACwB,MAA1B;;AACA,UAAI4D,UAAU,GAAGK,aAAjB,EAAgC;AAC5B;AACA;AACApF,QAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACD,UAAIA,IAAI,CAACqB,IAAL,KAAcgB,QAAlB,EAA4B;AACxB;AACArC,QAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACA;AACH;AACJ,KAzBqB,CA0BtB;;;AACA8B,IAAAA,SAAS,GAAG5B,KAAK,GAAGvB,IAAI,CAACkB,KAAzB;;AACA,QAAIiC,SAAS,GAAGuC,WAAhB,EAA6B;AACzB;AACA;AACArF,MAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;AACA;AACH;;AACDoD,IAAAA,OAAO,GAAG7B,KAAK,GAAGvB,IAAI,CAACmB,GAAvB;;AACA,QAAIiC,OAAO,IAAIqC,aAAf,EAA8B;AAC1B;AACAzF,MAAAA,IAAI,CAACqD,gBAAL,CAAsBF,SAAtB,EAAiCC,OAAjC,EAA0CzB,eAA1C;AACA,UAAI6D,OAAO,GAAG,IAAd;;AACA,UAAI/C,aAAa,IAAIzC,IAAI,CAACyB,OAAtB,IAAiCzB,IAAI,CAACyB,OAAL,KAAiBgB,aAAtD,EAAqE;AACjE+C,QAAAA,OAAO,GAAG,KAAV;AACH;;AACD,UAAI9C,mBAAmB,IAAInC,sBAAsB,CAACP,IAAD,CAAjD,EAAyD;AACrDwF,QAAAA,OAAO,GAAG,KAAV;AACH;;AACD,UAAIA,OAAJ,EAAa;AACTH,QAAAA,MAAM,CAACC,SAAS,EAAV,CAAN,GAAsBtF,IAAtB;AACH;AACJ;;AACDK,IAAAA,gBAAgB,CAACL,IAAD,EAAO,IAAP,CAAhB;;AACA,QAAIA,IAAI,CAACsB,KAAL,KAAee,QAAf,IAA2B,CAACjC,gBAAgB,CAACJ,IAAI,CAACsB,KAAN,CAAhD,EAA8D;AAC1D;AACAC,MAAAA,KAAK,IAAIvB,IAAI,CAACuB,KAAd;AACAvB,MAAAA,IAAI,GAAGA,IAAI,CAACsB,KAAZ;AACA;AACH;AACJ;;AACDjB,EAAAA,gBAAgB,CAAC4D,CAAC,CAAC1B,IAAH,EAAS,KAAT,CAAhB;AACA,SAAO8C,MAAP;AACH,C,CACD;AACA;;;AACA,SAAStC,YAAT,CAAsBkB,CAAtB,EAAyB0B,OAAzB,EAAkC;AAC9B,MAAI1B,CAAC,CAAC1B,IAAF,KAAWF,QAAf,EAAyB;AACrBsD,IAAAA,OAAO,CAACvE,MAAR,GAAiBiB,QAAjB;AACAsD,IAAAA,OAAO,CAACtE,IAAR,GAAegB,QAAf;AACAsD,IAAAA,OAAO,CAACrE,KAAR,GAAgBe,QAAhB;AACAnC,IAAAA,YAAY,CAACyF,OAAD,EAAU;AAAE;AAAZ,KAAZ;AACA1B,IAAAA,CAAC,CAAC1B,IAAF,GAASoD,OAAT;AACA,WAAO1B,CAAC,CAAC1B,IAAT;AACH;;AACDqD,EAAAA,UAAU,CAAC3B,CAAD,EAAI0B,OAAJ,CAAV;AACAE,EAAAA,yBAAyB,CAACF,OAAO,CAACvE,MAAT,CAAzB,CAV8B,CAW9B;;AACA,MAAI0E,CAAC,GAAGH,OAAR;;AACA,SAAOG,CAAC,KAAK7B,CAAC,CAAC1B,IAAR,IAAgBxC,YAAY,CAAC+F,CAAC,CAAC1E,MAAH,CAAZ,KAA2B;AAAE;AAApD,IAA+D;AAC3D,QAAI0E,CAAC,CAAC1E,MAAF,KAAa0E,CAAC,CAAC1E,MAAF,CAASA,MAAT,CAAgBC,IAAjC,EAAuC;AACnC,UAAM0E,CAAC,GAAGD,CAAC,CAAC1E,MAAF,CAASA,MAAT,CAAgBE,KAA1B;;AACA,UAAIvB,YAAY,CAACgG,CAAD,CAAZ,KAAoB;AAAE;AAA1B,QAAqC;AACjC7F,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,WAAZ;AACAlB,UAAAA,YAAY,CAAC6F,CAAD,EAAI;AAAE;AAAN,WAAZ;AACA7F,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAF,CAASA,MAAV,EAAkB;AAAE;AAApB,WAAZ;AACA0E,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAF,CAASA,MAAb;AACH,SALD,MAMK;AACD,YAAI0E,CAAC,KAAKA,CAAC,CAAC1E,MAAF,CAASE,KAAnB,EAA0B;AACtBwE,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAN;AACA4E,UAAAA,UAAU,CAAC/B,CAAD,EAAI6B,CAAJ,CAAV;AACH;;AACD5F,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,SAAZ;AACAlB,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAF,CAASA,MAAV,EAAkB;AAAE;AAApB,SAAZ;AACA6E,QAAAA,WAAW,CAAChC,CAAD,EAAI6B,CAAC,CAAC1E,MAAF,CAASA,MAAb,CAAX;AACH;AACJ,KAjBD,MAkBK;AACD,UAAM2E,EAAC,GAAGD,CAAC,CAAC1E,MAAF,CAASA,MAAT,CAAgBC,IAA1B;;AACA,UAAItB,YAAY,CAACgG,EAAD,CAAZ,KAAoB;AAAE;AAA1B,QAAqC;AACjC7F,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,WAAZ;AACAlB,UAAAA,YAAY,CAAC6F,EAAD,EAAI;AAAE;AAAN,WAAZ;AACA7F,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAF,CAASA,MAAV,EAAkB;AAAE;AAApB,WAAZ;AACA0E,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAF,CAASA,MAAb;AACH,SALD,MAMK;AACD,YAAI0E,CAAC,KAAKA,CAAC,CAAC1E,MAAF,CAASC,IAAnB,EAAyB;AACrByE,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAN;AACA6E,UAAAA,WAAW,CAAChC,CAAD,EAAI6B,CAAJ,CAAX;AACH;;AACD5F,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,SAAZ;AACAlB,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAF,CAASA,MAAV,EAAkB;AAAE;AAApB,SAAZ;AACA4E,QAAAA,UAAU,CAAC/B,CAAD,EAAI6B,CAAC,CAAC1E,MAAF,CAASA,MAAb,CAAV;AACH;AACJ;AACJ;;AACDlB,EAAAA,YAAY,CAAC+D,CAAC,CAAC1B,IAAH,EAAS;AAAE;AAAX,GAAZ;AACA,SAAOoD,OAAP;AACH;;AACD,SAASC,UAAT,CAAoB3B,CAApB,EAAuBiC,CAAvB,EAA0B;AACtB,MAAI3E,KAAK,GAAG,CAAZ;AACA,MAAIuE,CAAC,GAAG7B,CAAC,CAAC1B,IAAV;AACA,MAAM4D,cAAc,GAAGD,CAAC,CAAChF,KAAzB;AACA,MAAMkF,YAAY,GAAGF,CAAC,CAAC/E,GAAvB;;AACA,SAAO,IAAP,EAAa;AACT,QAAMkF,GAAG,GAAGC,eAAe,CAACH,cAAD,EAAiBC,YAAjB,EAA+BN,CAAC,CAAC5E,KAAF,GAAUK,KAAzC,EAAgDuE,CAAC,CAAC3E,GAAF,GAAQI,KAAxD,CAA3B;;AACA,QAAI8E,GAAG,GAAG,CAAV,EAAa;AACT;AACA;AACA,UAAIP,CAAC,CAACzE,IAAF,KAAWgB,QAAf,EAAyB;AACrB6D,QAAAA,CAAC,CAAChF,KAAF,IAAWK,KAAX;AACA2E,QAAAA,CAAC,CAAC/E,GAAF,IAASI,KAAT;AACA2E,QAAAA,CAAC,CAAC1E,MAAF,IAAYD,KAAZ;AACAuE,QAAAA,CAAC,CAACzE,IAAF,GAAS6E,CAAT;AACA;AACH,OAND,MAOK;AACDJ,QAAAA,CAAC,GAAGA,CAAC,CAACzE,IAAN;AACH;AACJ,KAbD,MAcK;AACD;AACA;AACA,UAAIyE,CAAC,CAACxE,KAAF,KAAYe,QAAhB,EAA0B;AACtB6D,QAAAA,CAAC,CAAChF,KAAF,IAAYK,KAAK,GAAGuE,CAAC,CAACvE,KAAtB;AACA2E,QAAAA,CAAC,CAAC/E,GAAF,IAAUI,KAAK,GAAGuE,CAAC,CAACvE,KAApB;AACA2E,QAAAA,CAAC,CAAC1E,MAAF,IAAaD,KAAK,GAAGuE,CAAC,CAACvE,KAAvB;AACAuE,QAAAA,CAAC,CAACxE,KAAF,GAAU4E,CAAV;AACA;AACH,OAND,MAOK;AACD3E,QAAAA,KAAK,IAAIuE,CAAC,CAACvE,KAAX;AACAuE,QAAAA,CAAC,GAAGA,CAAC,CAACxE,KAAN;AACH;AACJ;AACJ;;AACD4E,EAAAA,CAAC,CAAC9E,MAAF,GAAW0E,CAAX;AACAI,EAAAA,CAAC,CAAC7E,IAAF,GAASgB,QAAT;AACA6D,EAAAA,CAAC,CAAC5E,KAAF,GAAUe,QAAV;AACAnC,EAAAA,YAAY,CAACgG,CAAD,EAAI;AAAE;AAAN,GAAZ;AACH,C,CACD;AACA;;;AACA,SAASjD,YAAT,CAAsBgB,CAAtB,EAAyBiC,CAAzB,EAA4B;AACxB,MAAIJ,CAAJ;AACA,MAAIC,CAAJ,CAFwB,CAGxB;AACA;;AACA,MAAIG,CAAC,CAAC7E,IAAF,KAAWgB,QAAf,EAAyB;AACrByD,IAAAA,CAAC,GAAGI,CAAC,CAAC5E,KAAN;AACAyE,IAAAA,CAAC,GAAGG,CAAJ,CAFqB,CAGrB;;AACAJ,IAAAA,CAAC,CAACvE,KAAF,IAAW2E,CAAC,CAAC3E,KAAb;;AACA,QAAIuE,CAAC,CAACvE,KAAF,GAAU,CAAC;AAAW;AAAtB,OAA8CuE,CAAC,CAACvE,KAAF,GAAU;AAAW;AAAvE,MAA6F;AACzF0C,QAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH;;AACDsD,IAAAA,CAAC,CAAC5E,KAAF,IAAWgF,CAAC,CAAC3E,KAAb;AACAuE,IAAAA,CAAC,CAAC3E,GAAF,IAAS+E,CAAC,CAAC3E,KAAX;AACH,GAVD,MAWK,IAAI2E,CAAC,CAAC5E,KAAF,KAAYe,QAAhB,EAA0B;AAC3ByD,IAAAA,CAAC,GAAGI,CAAC,CAAC7E,IAAN;AACA0E,IAAAA,CAAC,GAAGG,CAAJ;AACH,GAHI,MAIA;AACDH,IAAAA,CAAC,GAAGQ,OAAO,CAACL,CAAC,CAAC5E,KAAH,CAAX;AACAwE,IAAAA,CAAC,GAAGC,CAAC,CAACzE,KAAN,CAFC,CAGD;AACA;AACA;;AACAwE,IAAAA,CAAC,CAAC5E,KAAF,IAAW6E,CAAC,CAACxE,KAAb;AACAuE,IAAAA,CAAC,CAAC3E,GAAF,IAAS4E,CAAC,CAACxE,KAAX;AACAuE,IAAAA,CAAC,CAACvE,KAAF,IAAWwE,CAAC,CAACxE,KAAb;;AACA,QAAIuE,CAAC,CAACvE,KAAF,GAAU,CAAC;AAAW;AAAtB,OAA8CuE,CAAC,CAACvE,KAAF,GAAU;AAAW;AAAvE,MAA6F;AACzF0C,QAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH;;AACDuD,IAAAA,CAAC,CAAC7E,KAAF,IAAWgF,CAAC,CAAC3E,KAAb;AACAwE,IAAAA,CAAC,CAAC5E,GAAF,IAAS+E,CAAC,CAAC3E,KAAX;AACAwE,IAAAA,CAAC,CAACxE,KAAF,GAAU2E,CAAC,CAAC3E,KAAZ;;AACA,QAAIwE,CAAC,CAACxE,KAAF,GAAU,CAAC;AAAW;AAAtB,OAA8CwE,CAAC,CAACxE,KAAF,GAAU;AAAW;AAAvE,MAA6F;AACzF0C,QAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH;AACJ;;AACD,MAAIuD,CAAC,KAAK9B,CAAC,CAAC1B,IAAZ,EAAkB;AACd0B,IAAAA,CAAC,CAAC1B,IAAF,GAASuD,CAAT;AACA5F,IAAAA,YAAY,CAAC4F,CAAD,EAAI;AAAE;AAAN,KAAZ;AACAI,IAAAA,CAAC,CAACM,MAAF;AACAC,IAAAA,aAAa;AACbvC,IAAAA,eAAe,CAAC4B,CAAD,CAAf;AACA7B,IAAAA,CAAC,CAAC1B,IAAF,CAAOnB,MAAP,GAAgBiB,QAAhB;AACA;AACH;;AACD,MAAIqE,OAAO,GAAI3G,YAAY,CAACgG,CAAD,CAAZ,KAAoB;AAAE;AAArC;;AACA,MAAIA,CAAC,KAAKA,CAAC,CAAC3E,MAAF,CAASC,IAAnB,EAAyB;AACrB0E,IAAAA,CAAC,CAAC3E,MAAF,CAASC,IAAT,GAAgByE,CAAhB;AACH,GAFD,MAGK;AACDC,IAAAA,CAAC,CAAC3E,MAAF,CAASE,KAAT,GAAiBwE,CAAjB;AACH;;AACD,MAAIC,CAAC,KAAKG,CAAV,EAAa;AACTJ,IAAAA,CAAC,CAAC1E,MAAF,GAAW2E,CAAC,CAAC3E,MAAb;AACH,GAFD,MAGK;AACD,QAAI2E,CAAC,CAAC3E,MAAF,KAAa8E,CAAjB,EAAoB;AAChBJ,MAAAA,CAAC,CAAC1E,MAAF,GAAW2E,CAAX;AACH,KAFD,MAGK;AACDD,MAAAA,CAAC,CAAC1E,MAAF,GAAW2E,CAAC,CAAC3E,MAAb;AACH;;AACD2E,IAAAA,CAAC,CAAC1E,IAAF,GAAS6E,CAAC,CAAC7E,IAAX;AACA0E,IAAAA,CAAC,CAACzE,KAAF,GAAU4E,CAAC,CAAC5E,KAAZ;AACAyE,IAAAA,CAAC,CAAC3E,MAAF,GAAW8E,CAAC,CAAC9E,MAAb;AACAlB,IAAAA,YAAY,CAAC6F,CAAD,EAAIhG,YAAY,CAACmG,CAAD,CAAhB,CAAZ;;AACA,QAAIA,CAAC,KAAKjC,CAAC,CAAC1B,IAAZ,EAAkB;AACd0B,MAAAA,CAAC,CAAC1B,IAAF,GAASwD,CAAT;AACH,KAFD,MAGK;AACD,UAAIG,CAAC,KAAKA,CAAC,CAAC9E,MAAF,CAASC,IAAnB,EAAyB;AACrB6E,QAAAA,CAAC,CAAC9E,MAAF,CAASC,IAAT,GAAgB0E,CAAhB;AACH,OAFD,MAGK;AACDG,QAAAA,CAAC,CAAC9E,MAAF,CAASE,KAAT,GAAiByE,CAAjB;AACH;AACJ;;AACD,QAAIA,CAAC,CAAC1E,IAAF,KAAWgB,QAAf,EAAyB;AACrB0D,MAAAA,CAAC,CAAC1E,IAAF,CAAOD,MAAP,GAAgB2E,CAAhB;AACH;;AACD,QAAIA,CAAC,CAACzE,KAAF,KAAYe,QAAhB,EAA0B;AACtB0D,MAAAA,CAAC,CAACzE,KAAF,CAAQF,MAAR,GAAiB2E,CAAjB;AACH;AACJ;;AACDG,EAAAA,CAAC,CAACM,MAAF;;AACA,MAAIE,OAAJ,EAAa;AACTb,IAAAA,yBAAyB,CAACC,CAAC,CAAC1E,MAAH,CAAzB;;AACA,QAAI2E,CAAC,KAAKG,CAAV,EAAa;AACTL,MAAAA,yBAAyB,CAACE,CAAD,CAAzB;AACAF,MAAAA,yBAAyB,CAACE,CAAC,CAAC3E,MAAH,CAAzB;AACH;;AACDqF,IAAAA,aAAa;AACb;AACH;;AACDZ,EAAAA,yBAAyB,CAACC,CAAD,CAAzB;AACAD,EAAAA,yBAAyB,CAACC,CAAC,CAAC1E,MAAH,CAAzB;;AACA,MAAI2E,CAAC,KAAKG,CAAV,EAAa;AACTL,IAAAA,yBAAyB,CAACE,CAAD,CAAzB;AACAF,IAAAA,yBAAyB,CAACE,CAAC,CAAC3E,MAAH,CAAzB;AACH,GAtGuB,CAuGxB;;;AACA,MAAIuF,CAAJ;;AACA,SAAOb,CAAC,KAAK7B,CAAC,CAAC1B,IAAR,IAAgBxC,YAAY,CAAC+F,CAAD,CAAZ,KAAoB;AAAE;AAA7C,IAA0D;AACtD,QAAIA,CAAC,KAAKA,CAAC,CAAC1E,MAAF,CAASC,IAAnB,EAAyB;AACrBsF,MAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASE,KAAb;;AACA,UAAIvB,YAAY,CAAC4G,CAAD,CAAZ,KAAoB;AAAE;AAA1B,QAAqC;AACjCzG,UAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,WAAZ;AACAzG,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,WAAZ;AACA4E,UAAAA,UAAU,CAAC/B,CAAD,EAAI6B,CAAC,CAAC1E,MAAN,CAAV;AACAuF,UAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASE,KAAb;AACH;;AACD,UAAIvB,YAAY,CAAC4G,CAAC,CAACtF,IAAH,CAAZ,KAAyB;AAAE;AAA3B,SAA0CtB,YAAY,CAAC4G,CAAC,CAACrF,KAAH,CAAZ,KAA0B;AAAE;AAA1E,QAAuF;AACnFpB,UAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,WAAZ;AACAb,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAN;AACH,SAHD,MAIK;AACD,YAAIrB,YAAY,CAAC4G,CAAC,CAACrF,KAAH,CAAZ,KAA0B;AAAE;AAAhC,UAA6C;AACzCpB,YAAAA,YAAY,CAACyG,CAAC,CAACtF,IAAH,EAAS;AAAE;AAAX,aAAZ;AACAnB,YAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,aAAZ;AACAV,YAAAA,WAAW,CAAChC,CAAD,EAAI0C,CAAJ,CAAX;AACAA,YAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASE,KAAb;AACH;;AACDpB,QAAAA,YAAY,CAACyG,CAAD,EAAI5G,YAAY,CAAC+F,CAAC,CAAC1E,MAAH,CAAhB,CAAZ;AACAlB,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,SAAZ;AACAlB,QAAAA,YAAY,CAACyG,CAAC,CAACrF,KAAH,EAAU;AAAE;AAAZ,SAAZ;AACA0E,QAAAA,UAAU,CAAC/B,CAAD,EAAI6B,CAAC,CAAC1E,MAAN,CAAV;AACA0E,QAAAA,CAAC,GAAG7B,CAAC,CAAC1B,IAAN;AACH;AACJ,KAzBD,MA0BK;AACDoE,MAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASC,IAAb;;AACA,UAAItB,YAAY,CAAC4G,CAAD,CAAZ,KAAoB;AAAE;AAA1B,QAAqC;AACjCzG,UAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,WAAZ;AACAzG,UAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,WAAZ;AACA6E,UAAAA,WAAW,CAAChC,CAAD,EAAI6B,CAAC,CAAC1E,MAAN,CAAX;AACAuF,UAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASC,IAAb;AACH;;AACD,UAAItB,YAAY,CAAC4G,CAAC,CAACtF,IAAH,CAAZ,KAAyB;AAAE;AAA3B,SAA0CtB,YAAY,CAAC4G,CAAC,CAACrF,KAAH,CAAZ,KAA0B;AAAE;AAA1E,QAAuF;AACnFpB,UAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,WAAZ;AACAb,UAAAA,CAAC,GAAGA,CAAC,CAAC1E,MAAN;AACH,SAHD,MAIK;AACD,YAAIrB,YAAY,CAAC4G,CAAC,CAACtF,IAAH,CAAZ,KAAyB;AAAE;AAA/B,UAA4C;AACxCnB,YAAAA,YAAY,CAACyG,CAAC,CAACrF,KAAH,EAAU;AAAE;AAAZ,aAAZ;AACApB,YAAAA,YAAY,CAACyG,CAAD,EAAI;AAAE;AAAN,aAAZ;AACAX,YAAAA,UAAU,CAAC/B,CAAD,EAAI0C,CAAJ,CAAV;AACAA,YAAAA,CAAC,GAAGb,CAAC,CAAC1E,MAAF,CAASC,IAAb;AACH;;AACDnB,QAAAA,YAAY,CAACyG,CAAD,EAAI5G,YAAY,CAAC+F,CAAC,CAAC1E,MAAH,CAAhB,CAAZ;AACAlB,QAAAA,YAAY,CAAC4F,CAAC,CAAC1E,MAAH,EAAW;AAAE;AAAb,SAAZ;AACAlB,QAAAA,YAAY,CAACyG,CAAC,CAACtF,IAAH,EAAS;AAAE;AAAX,SAAZ;AACA4E,QAAAA,WAAW,CAAChC,CAAD,EAAI6B,CAAC,CAAC1E,MAAN,CAAX;AACA0E,QAAAA,CAAC,GAAG7B,CAAC,CAAC1B,IAAN;AACH;AACJ;AACJ;;AACDrC,EAAAA,YAAY,CAAC4F,CAAD,EAAI;AAAE;AAAN,GAAZ;AACAW,EAAAA,aAAa;AAChB;;AACD,SAASF,OAAT,CAAiBvG,IAAjB,EAAuB;AACnB,SAAOA,IAAI,CAACqB,IAAL,KAAcgB,QAArB,EAA+B;AAC3BrC,IAAAA,IAAI,GAAGA,IAAI,CAACqB,IAAZ;AACH;;AACD,SAAOrB,IAAP;AACH;;AACD,SAASyG,aAAT,GAAyB;AACrBpE,EAAAA,QAAQ,CAACjB,MAAT,GAAkBiB,QAAlB;AACAA,EAAAA,QAAQ,CAACd,KAAT,GAAiB,CAAjB,CAFqB,CAED;;AACpBc,EAAAA,QAAQ,CAACnB,KAAT,GAAiB,CAAjB,CAHqB,CAGD;;AACpBmB,EAAAA,QAAQ,CAAClB,GAAT,GAAe,CAAf,CAJqB,CAIH;AACrB,C,CACD;AACA;;;AACA,SAAS6E,UAAT,CAAoB/B,CAApB,EAAuB6B,CAAvB,EAA0B;AACtB,MAAMC,CAAC,GAAGD,CAAC,CAACxE,KAAZ,CADsB,CACH;;AACnByE,EAAAA,CAAC,CAACxE,KAAF,IAAWuE,CAAC,CAACvE,KAAb,CAFsB,CAEF;;AACpB,MAAIwE,CAAC,CAACxE,KAAF,GAAU,CAAC;AAAW;AAAtB,KAA8CwE,CAAC,CAACxE,KAAF,GAAU;AAAW;AAAvE,IAA6F;AACzF0C,MAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH;;AACDuD,EAAAA,CAAC,CAAC7E,KAAF,IAAW4E,CAAC,CAACvE,KAAb;AACAwE,EAAAA,CAAC,CAAC5E,GAAF,IAAS2E,CAAC,CAACvE,KAAX;AACAuE,EAAAA,CAAC,CAACxE,KAAF,GAAUyE,CAAC,CAAC1E,IAAZ,CARsB,CAQJ;;AAClB,MAAI0E,CAAC,CAAC1E,IAAF,KAAWgB,QAAf,EAAyB;AACrB0D,IAAAA,CAAC,CAAC1E,IAAF,CAAOD,MAAP,GAAgB0E,CAAhB;AACH;;AACDC,EAAAA,CAAC,CAAC3E,MAAF,GAAW0E,CAAC,CAAC1E,MAAb,CAZsB,CAYD;;AACrB,MAAI0E,CAAC,CAAC1E,MAAF,KAAaiB,QAAjB,EAA2B;AACvB4B,IAAAA,CAAC,CAAC1B,IAAF,GAASwD,CAAT;AACH,GAFD,MAGK,IAAID,CAAC,KAAKA,CAAC,CAAC1E,MAAF,CAASC,IAAnB,EAAyB;AAC1ByE,IAAAA,CAAC,CAAC1E,MAAF,CAASC,IAAT,GAAgB0E,CAAhB;AACH,GAFI,MAGA;AACDD,IAAAA,CAAC,CAAC1E,MAAF,CAASE,KAAT,GAAiByE,CAAjB;AACH;;AACDA,EAAAA,CAAC,CAAC1E,IAAF,GAASyE,CAAT,CAtBsB,CAsBV;;AACZA,EAAAA,CAAC,CAAC1E,MAAF,GAAW2E,CAAX;AACA7B,EAAAA,eAAe,CAAC4B,CAAD,CAAf;AACA5B,EAAAA,eAAe,CAAC6B,CAAD,CAAf;AACH;;AACD,SAASE,WAAT,CAAqBhC,CAArB,EAAwB8B,CAAxB,EAA2B;AACvB,MAAMD,CAAC,GAAGC,CAAC,CAAC1E,IAAZ;AACA0E,EAAAA,CAAC,CAACxE,KAAF,IAAWuE,CAAC,CAACvE,KAAb;;AACA,MAAIwE,CAAC,CAACxE,KAAF,GAAU,CAAC;AAAW;AAAtB,KAA8CwE,CAAC,CAACxE,KAAF,GAAU;AAAW;AAAvE,IAA6F;AACzF0C,MAAAA,CAAC,CAACzB,qBAAF,GAA0B,IAA1B;AACH;;AACDuD,EAAAA,CAAC,CAAC7E,KAAF,IAAW4E,CAAC,CAACvE,KAAb;AACAwE,EAAAA,CAAC,CAAC5E,GAAF,IAAS2E,CAAC,CAACvE,KAAX;AACAwE,EAAAA,CAAC,CAAC1E,IAAF,GAASyE,CAAC,CAACxE,KAAX;;AACA,MAAIwE,CAAC,CAACxE,KAAF,KAAYe,QAAhB,EAA0B;AACtByD,IAAAA,CAAC,CAACxE,KAAF,CAAQF,MAAR,GAAiB2E,CAAjB;AACH;;AACDD,EAAAA,CAAC,CAAC1E,MAAF,GAAW2E,CAAC,CAAC3E,MAAb;;AACA,MAAI2E,CAAC,CAAC3E,MAAF,KAAaiB,QAAjB,EAA2B;AACvB4B,IAAAA,CAAC,CAAC1B,IAAF,GAASuD,CAAT;AACH,GAFD,MAGK,IAAIC,CAAC,KAAKA,CAAC,CAAC3E,MAAF,CAASE,KAAnB,EAA0B;AAC3ByE,IAAAA,CAAC,CAAC3E,MAAF,CAASE,KAAT,GAAiBwE,CAAjB;AACH,GAFI,MAGA;AACDC,IAAAA,CAAC,CAAC3E,MAAF,CAASC,IAAT,GAAgByE,CAAhB;AACH;;AACDA,EAAAA,CAAC,CAACxE,KAAF,GAAUyE,CAAV;AACAA,EAAAA,CAAC,CAAC3E,MAAF,GAAW0E,CAAX;AACA5B,EAAAA,eAAe,CAAC6B,CAAD,CAAf;AACA7B,EAAAA,eAAe,CAAC4B,CAAD,CAAf;AACH,C,CACD;AACA;;;AACA,SAASc,aAAT,CAAuB5G,IAAvB,EAA6B;AACzB,MAAIwB,MAAM,GAAGxB,IAAI,CAACmB,GAAlB;;AACA,MAAInB,IAAI,CAACqB,IAAL,KAAcgB,QAAlB,EAA4B;AACxB,QAAMwE,UAAU,GAAG7G,IAAI,CAACqB,IAAL,CAAUG,MAA7B;;AACA,QAAIqF,UAAU,GAAGrF,MAAjB,EAAyB;AACrBA,MAAAA,MAAM,GAAGqF,UAAT;AACH;AACJ;;AACD,MAAI7G,IAAI,CAACsB,KAAL,KAAee,QAAnB,EAA6B;AACzB,QAAMyE,WAAW,GAAG9G,IAAI,CAACsB,KAAL,CAAWE,MAAX,GAAoBxB,IAAI,CAACuB,KAA7C;;AACA,QAAIuF,WAAW,GAAGtF,MAAlB,EAA0B;AACtBA,MAAAA,MAAM,GAAGsF,WAAT;AACH;AACJ;;AACD,SAAOtF,MAAP;AACH;;AACD,OAAO,SAAS0C,eAAT,CAAyBlE,IAAzB,EAA+B;AAClCA,EAAAA,IAAI,CAACwB,MAAL,GAAcoF,aAAa,CAAC5G,IAAD,CAA3B;AACH;;AACD,SAAS6F,yBAAT,CAAmC7F,IAAnC,EAAyC;AACrC,SAAOA,IAAI,KAAKqC,QAAhB,EAA0B;AACtB,QAAMb,MAAM,GAAGoF,aAAa,CAAC5G,IAAD,CAA5B;;AACA,QAAIA,IAAI,CAACwB,MAAL,KAAgBA,MAApB,EAA4B;AACxB;AACA;AACH;;AACDxB,IAAAA,IAAI,CAACwB,MAAL,GAAcA,MAAd;AACAxB,IAAAA,IAAI,GAAGA,IAAI,CAACoB,MAAZ;AACH;AACJ,C,CACD;AACA;;;AACA,OAAO,SAASkF,eAAT,CAAyBS,MAAzB,EAAiCC,IAAjC,EAAuCC,MAAvC,EAA+CC,IAA/C,EAAqD;AACxD,MAAIH,MAAM,KAAKE,MAAf,EAAuB;AACnB,WAAOD,IAAI,GAAGE,IAAd;AACH;;AACD,SAAOH,MAAM,GAAGE,MAAhB;AACH,C,CACD","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport function getNodeColor(node) {\r\n    return ((node.metadata & 1 /* ColorMask */) >>> 0 /* ColorOffset */);\r\n}\r\nfunction setNodeColor(node, color) {\r\n    node.metadata = ((node.metadata & 254 /* ColorMaskInverse */) | (color << 0 /* ColorOffset */));\r\n}\r\nfunction getNodeIsVisited(node) {\r\n    return ((node.metadata & 2 /* IsVisitedMask */) >>> 1 /* IsVisitedOffset */) === 1;\r\n}\r\nfunction setNodeIsVisited(node, value) {\r\n    node.metadata = ((node.metadata & 253 /* IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* IsVisitedOffset */));\r\n}\r\nfunction getNodeIsForValidation(node) {\r\n    return ((node.metadata & 4 /* IsForValidationMask */) >>> 2 /* IsForValidationOffset */) === 1;\r\n}\r\nfunction setNodeIsForValidation(node, value) {\r\n    node.metadata = ((node.metadata & 251 /* IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* IsForValidationOffset */));\r\n}\r\nexport function getNodeIsInOverviewRuler(node) {\r\n    return ((node.metadata & 8 /* IsInOverviewRulerMask */) >>> 3 /* IsInOverviewRulerOffset */) === 1;\r\n}\r\nfunction setNodeIsInOverviewRuler(node, value) {\r\n    node.metadata = ((node.metadata & 247 /* IsInOverviewRulerMaskInverse */) | ((value ? 1 : 0) << 3 /* IsInOverviewRulerOffset */));\r\n}\r\nfunction getNodeStickiness(node) {\r\n    return ((node.metadata & 48 /* StickinessMask */) >>> 4 /* StickinessOffset */);\r\n}\r\nfunction _setNodeStickiness(node, stickiness) {\r\n    node.metadata = ((node.metadata & 207 /* StickinessMaskInverse */) | (stickiness << 4 /* StickinessOffset */));\r\n}\r\nfunction getCollapseOnReplaceEdit(node) {\r\n    return ((node.metadata & 64 /* CollapseOnReplaceEditMask */) >>> 6 /* CollapseOnReplaceEditOffset */) === 1;\r\n}\r\nfunction setCollapseOnReplaceEdit(node, value) {\r\n    node.metadata = ((node.metadata & 191 /* CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 6 /* CollapseOnReplaceEditOffset */));\r\n}\r\nexport class IntervalNode {\r\n    constructor(id, start, end) {\r\n        this.metadata = 0;\r\n        this.parent = this;\r\n        this.left = this;\r\n        this.right = this;\r\n        setNodeColor(this, 1 /* Red */);\r\n        this.start = start;\r\n        this.end = end;\r\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\r\n        this.delta = 0;\r\n        this.maxEnd = end;\r\n        this.id = id;\r\n        this.ownerId = 0;\r\n        this.options = null;\r\n        setNodeIsForValidation(this, false);\r\n        _setNodeStickiness(this, 1 /* NeverGrowsWhenTypingAtEdges */);\r\n        setNodeIsInOverviewRuler(this, false);\r\n        setCollapseOnReplaceEdit(this, false);\r\n        this.cachedVersionId = 0;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = null;\r\n        setNodeIsVisited(this, false);\r\n    }\r\n    reset(versionId, start, end, range) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.maxEnd = end;\r\n        this.cachedVersionId = versionId;\r\n        this.cachedAbsoluteStart = start;\r\n        this.cachedAbsoluteEnd = end;\r\n        this.range = range;\r\n    }\r\n    setOptions(options) {\r\n        this.options = options;\r\n        let className = this.options.className;\r\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* EditorErrorDecoration */\r\n            || className === \"squiggly-warning\" /* EditorWarningDecoration */\r\n            || className === \"squiggly-info\" /* EditorInfoDecoration */));\r\n        _setNodeStickiness(this, this.options.stickiness);\r\n        setNodeIsInOverviewRuler(this, (this.options.overviewRuler && this.options.overviewRuler.color) ? true : false);\r\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\r\n    }\r\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\r\n        if (this.cachedVersionId !== cachedVersionId) {\r\n            this.range = null;\r\n        }\r\n        this.cachedVersionId = cachedVersionId;\r\n        this.cachedAbsoluteStart = absoluteStart;\r\n        this.cachedAbsoluteEnd = absoluteEnd;\r\n    }\r\n    detach() {\r\n        this.parent = null;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\nexport const SENTINEL = new IntervalNode(null, 0, 0);\r\nSENTINEL.parent = SENTINEL;\r\nSENTINEL.left = SENTINEL;\r\nSENTINEL.right = SENTINEL;\r\nsetNodeColor(SENTINEL, 0 /* Black */);\r\nexport class IntervalTree {\r\n    constructor() {\r\n        this.root = SENTINEL;\r\n        this.requestNormalizeDelta = false;\r\n    }\r\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    }\r\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        if (this.root === SENTINEL) {\r\n            return [];\r\n        }\r\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\r\n    }\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    collectNodesFromOwner(ownerId) {\r\n        return collectNodesFromOwner(this, ownerId);\r\n    }\r\n    /**\r\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\r\n     */\r\n    collectNodesPostOrder() {\r\n        return collectNodesPostOrder(this);\r\n    }\r\n    insert(node) {\r\n        rbTreeInsert(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    delete(node) {\r\n        rbTreeDelete(this, node);\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    resolveNode(node, cachedVersionId) {\r\n        const initialNode = node;\r\n        let delta = 0;\r\n        while (node !== this.root) {\r\n            if (node === node.parent.right) {\r\n                delta += node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        const nodeStart = initialNode.start + delta;\r\n        const nodeEnd = initialNode.end + delta;\r\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n    }\r\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\r\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\r\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\r\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\r\n        // (2) remove all nodes that are intersecting this edit\r\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            const node = nodesOfInterest[i];\r\n            rbTreeDelete(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n        // (3) edit all tree nodes except the nodes of interest\r\n        noOverlapReplace(this, offset, offset + length, textLength);\r\n        this._normalizeDeltaIfNecessary();\r\n        // (4) edit the nodes of interest and insert them back in the tree\r\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\r\n            const node = nodesOfInterest[i];\r\n            node.start = node.cachedAbsoluteStart;\r\n            node.end = node.cachedAbsoluteEnd;\r\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\r\n            node.maxEnd = node.end;\r\n            rbTreeInsert(this, node);\r\n        }\r\n        this._normalizeDeltaIfNecessary();\r\n    }\r\n    _normalizeDeltaIfNecessary() {\r\n        if (!this.requestNormalizeDelta) {\r\n            return;\r\n        }\r\n        this.requestNormalizeDelta = false;\r\n        normalizeDelta(this);\r\n    }\r\n}\r\n//#region Delta Normalization\r\nfunction normalizeDelta(T) {\r\n    let node = T.root;\r\n    let delta = 0;\r\n    while (node !== SENTINEL) {\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        node.start = delta + node.start;\r\n        node.end = delta + node.end;\r\n        node.delta = 0;\r\n        recomputeMaxEnd(node);\r\n        setNodeIsVisited(node, true);\r\n        // going up from this node\r\n        setNodeIsVisited(node.left, false);\r\n        setNodeIsVisited(node.right, false);\r\n        if (node === node.parent.right) {\r\n            delta -= node.parent.delta;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\r\n    if (markerOffset < checkOffset) {\r\n        return true;\r\n    }\r\n    if (markerOffset > checkOffset) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 1 /* ForceMove */) {\r\n        return false;\r\n    }\r\n    if (moveSemantics === 2 /* ForceStay */) {\r\n        return true;\r\n    }\r\n    return markerStickToPreviousCharacter;\r\n}\r\n/**\r\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\r\n * as when decorations were implemented using two markers.\r\n */\r\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\r\n    const nodeStickiness = getNodeStickiness(node);\r\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* AlwaysGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* NeverGrowsWhenTypingAtEdges */\r\n        || nodeStickiness === 2 /* GrowsOnlyWhenTypingBefore */);\r\n    const deletingCnt = (end - start);\r\n    const insertingCnt = textLength;\r\n    const commonLength = Math.min(deletingCnt, insertingCnt);\r\n    const nodeStart = node.start;\r\n    let startDone = false;\r\n    const nodeEnd = node.end;\r\n    let endDone = false;\r\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\r\n        // This edit encompasses the entire decoration range\r\n        // and the decoration has asked to become collapsed\r\n        node.start = start;\r\n        startDone = true;\r\n        node.end = start;\r\n        endDone = true;\r\n    }\r\n    {\r\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    if (commonLength > 0 && !forceMoveMarkers) {\r\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */);\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\r\n            endDone = true;\r\n        }\r\n    }\r\n    {\r\n        const moveSemantics = forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */;\r\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.start = start + insertingCnt;\r\n            startDone = true;\r\n        }\r\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\r\n            node.end = start + insertingCnt;\r\n            endDone = true;\r\n        }\r\n    }\r\n    // Finish\r\n    const deltaColumn = (insertingCnt - deletingCnt);\r\n    if (!startDone) {\r\n        node.start = Math.max(0, nodeStart + deltaColumn);\r\n    }\r\n    if (!endDone) {\r\n        node.end = Math.max(0, nodeEnd + deltaColumn);\r\n    }\r\n    if (node.start > node.end) {\r\n        node.end = node.start;\r\n    }\r\n}\r\nfunction searchForEditing(T, start, end) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= start) {\r\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction noOverlapReplace(T, start, end, textLength) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    const editDelta = (textLength - (end - start));\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            recomputeMaxEnd(node);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < start) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > end) {\r\n            node.start += editDelta;\r\n            node.end += editDelta;\r\n            node.delta += editDelta;\r\n            if (node.delta < -1073741824 /* MIN_SAFE_DELTA */ || node.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n                T.requestNormalizeDelta = true;\r\n            }\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n}\r\n//#endregion\r\n//#region Searching\r\nfunction collectNodesFromOwner(T, ownerId) {\r\n    let node = T.root;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        if (node.ownerId === ownerId) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction collectNodesPostOrder(T) {\r\n    let node = T.root;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            node = node.right;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        result[resultLen++] = node;\r\n        setNodeIsVisited(node, true);\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\r\n            // go left\r\n            node = node.left;\r\n            continue;\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        nodeEnd = delta + node.end;\r\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n        let include = true;\r\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n            include = false;\r\n        }\r\n        if (filterOutValidation && getNodeIsForValidation(node)) {\r\n            include = false;\r\n        }\r\n        if (include) {\r\n            result[resultLen++] = node;\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\r\n    // Now, it is known that two intervals A and B overlap only when both\r\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\r\n    // nodes overlapping with a given interval, you can immediately skip:\r\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\r\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\r\n    let node = T.root;\r\n    let delta = 0;\r\n    let nodeMaxEnd = 0;\r\n    let nodeStart = 0;\r\n    let nodeEnd = 0;\r\n    let result = [];\r\n    let resultLen = 0;\r\n    while (node !== SENTINEL) {\r\n        if (getNodeIsVisited(node)) {\r\n            // going up from this node\r\n            setNodeIsVisited(node.left, false);\r\n            setNodeIsVisited(node.right, false);\r\n            if (node === node.parent.right) {\r\n                delta -= node.parent.delta;\r\n            }\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n        if (!getNodeIsVisited(node.left)) {\r\n            // first time seeing this node\r\n            nodeMaxEnd = delta + node.maxEnd;\r\n            if (nodeMaxEnd < intervalStart) {\r\n                // cover case b) from above\r\n                // there is no need to search this node or its children\r\n                setNodeIsVisited(node, true);\r\n                continue;\r\n            }\r\n            if (node.left !== SENTINEL) {\r\n                // go left\r\n                node = node.left;\r\n                continue;\r\n            }\r\n        }\r\n        // handle current node\r\n        nodeStart = delta + node.start;\r\n        if (nodeStart > intervalEnd) {\r\n            // cover case a) from above\r\n            // there is no need to search this node or its right subtree\r\n            setNodeIsVisited(node, true);\r\n            continue;\r\n        }\r\n        nodeEnd = delta + node.end;\r\n        if (nodeEnd >= intervalStart) {\r\n            // There is overlap\r\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\r\n            let include = true;\r\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\r\n                include = false;\r\n            }\r\n            if (filterOutValidation && getNodeIsForValidation(node)) {\r\n                include = false;\r\n            }\r\n            if (include) {\r\n                result[resultLen++] = node;\r\n            }\r\n        }\r\n        setNodeIsVisited(node, true);\r\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\r\n            // go right\r\n            delta += node.delta;\r\n            node = node.right;\r\n            continue;\r\n        }\r\n    }\r\n    setNodeIsVisited(T.root, false);\r\n    return result;\r\n}\r\n//#endregion\r\n//#region Insertion\r\nfunction rbTreeInsert(T, newNode) {\r\n    if (T.root === SENTINEL) {\r\n        newNode.parent = SENTINEL;\r\n        newNode.left = SENTINEL;\r\n        newNode.right = SENTINEL;\r\n        setNodeColor(newNode, 0 /* Black */);\r\n        T.root = newNode;\r\n        return T.root;\r\n    }\r\n    treeInsert(T, newNode);\r\n    recomputeMaxEndWalkToRoot(newNode.parent);\r\n    // repair tree\r\n    let x = newNode;\r\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* Red */) {\r\n        if (x.parent === x.parent.parent.left) {\r\n            const y = x.parent.parent.right;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.right) {\r\n                    x = x.parent;\r\n                    leftRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n        else {\r\n            const y = x.parent.parent.left;\r\n            if (getNodeColor(y) === 1 /* Red */) {\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(y, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                x = x.parent.parent;\r\n            }\r\n            else {\r\n                if (x === x.parent.left) {\r\n                    x = x.parent;\r\n                    rightRotate(T, x);\r\n                }\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(x.parent.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent.parent);\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(T.root, 0 /* Black */);\r\n    return newNode;\r\n}\r\nfunction treeInsert(T, z) {\r\n    let delta = 0;\r\n    let x = T.root;\r\n    const zAbsoluteStart = z.start;\r\n    const zAbsoluteEnd = z.end;\r\n    while (true) {\r\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\r\n        if (cmp < 0) {\r\n            // this node should be inserted to the left\r\n            // => it is not affected by the node's delta\r\n            if (x.left === SENTINEL) {\r\n                z.start -= delta;\r\n                z.end -= delta;\r\n                z.maxEnd -= delta;\r\n                x.left = z;\r\n                break;\r\n            }\r\n            else {\r\n                x = x.left;\r\n            }\r\n        }\r\n        else {\r\n            // this node should be inserted to the right\r\n            // => it is not affected by the node's delta\r\n            if (x.right === SENTINEL) {\r\n                z.start -= (delta + x.delta);\r\n                z.end -= (delta + x.delta);\r\n                z.maxEnd -= (delta + x.delta);\r\n                x.right = z;\r\n                break;\r\n            }\r\n            else {\r\n                delta += x.delta;\r\n                x = x.right;\r\n            }\r\n        }\r\n    }\r\n    z.parent = x;\r\n    z.left = SENTINEL;\r\n    z.right = SENTINEL;\r\n    setNodeColor(z, 1 /* Red */);\r\n}\r\n//#endregion\r\n//#region Deletion\r\nfunction rbTreeDelete(T, z) {\r\n    let x;\r\n    let y;\r\n    // RB-DELETE except we don't swap z and y in case c)\r\n    // i.e. we always delete what's pointed at by z.\r\n    if (z.left === SENTINEL) {\r\n        x = z.right;\r\n        y = z;\r\n        // x's delta is no longer influenced by z's delta\r\n        x.delta += z.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        x.start += z.delta;\r\n        x.end += z.delta;\r\n    }\r\n    else if (z.right === SENTINEL) {\r\n        x = z.left;\r\n        y = z;\r\n    }\r\n    else {\r\n        y = leftest(z.right);\r\n        x = y.right;\r\n        // y's delta is no longer influenced by z's delta,\r\n        // but we don't want to walk the entire right-hand-side subtree of x.\r\n        // we therefore maintain z's delta in y, and adjust only x\r\n        x.start += y.delta;\r\n        x.end += y.delta;\r\n        x.delta += y.delta;\r\n        if (x.delta < -1073741824 /* MIN_SAFE_DELTA */ || x.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n        y.start += z.delta;\r\n        y.end += z.delta;\r\n        y.delta = z.delta;\r\n        if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n            T.requestNormalizeDelta = true;\r\n        }\r\n    }\r\n    if (y === T.root) {\r\n        T.root = x;\r\n        setNodeColor(x, 0 /* Black */);\r\n        z.detach();\r\n        resetSentinel();\r\n        recomputeMaxEnd(x);\r\n        T.root.parent = SENTINEL;\r\n        return;\r\n    }\r\n    let yWasRed = (getNodeColor(y) === 1 /* Red */);\r\n    if (y === y.parent.left) {\r\n        y.parent.left = x;\r\n    }\r\n    else {\r\n        y.parent.right = x;\r\n    }\r\n    if (y === z) {\r\n        x.parent = y.parent;\r\n    }\r\n    else {\r\n        if (y.parent === z) {\r\n            x.parent = y;\r\n        }\r\n        else {\r\n            x.parent = y.parent;\r\n        }\r\n        y.left = z.left;\r\n        y.right = z.right;\r\n        y.parent = z.parent;\r\n        setNodeColor(y, getNodeColor(z));\r\n        if (z === T.root) {\r\n            T.root = y;\r\n        }\r\n        else {\r\n            if (z === z.parent.left) {\r\n                z.parent.left = y;\r\n            }\r\n            else {\r\n                z.parent.right = y;\r\n            }\r\n        }\r\n        if (y.left !== SENTINEL) {\r\n            y.left.parent = y;\r\n        }\r\n        if (y.right !== SENTINEL) {\r\n            y.right.parent = y;\r\n        }\r\n    }\r\n    z.detach();\r\n    if (yWasRed) {\r\n        recomputeMaxEndWalkToRoot(x.parent);\r\n        if (y !== z) {\r\n            recomputeMaxEndWalkToRoot(y);\r\n            recomputeMaxEndWalkToRoot(y.parent);\r\n        }\r\n        resetSentinel();\r\n        return;\r\n    }\r\n    recomputeMaxEndWalkToRoot(x);\r\n    recomputeMaxEndWalkToRoot(x.parent);\r\n    if (y !== z) {\r\n        recomputeMaxEndWalkToRoot(y);\r\n        recomputeMaxEndWalkToRoot(y.parent);\r\n    }\r\n    // RB-DELETE-FIXUP\r\n    let w;\r\n    while (x !== T.root && getNodeColor(x) === 0 /* Black */) {\r\n        if (x === x.parent.left) {\r\n            w = x.parent.right;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                leftRotate(T, x.parent);\r\n                w = x.parent.right;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.right) === 0 /* Black */) {\r\n                    setNodeColor(w.left, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    rightRotate(T, w);\r\n                    w = x.parent.right;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.right, 0 /* Black */);\r\n                leftRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n        else {\r\n            w = x.parent.left;\r\n            if (getNodeColor(w) === 1 /* Red */) {\r\n                setNodeColor(w, 0 /* Black */);\r\n                setNodeColor(x.parent, 1 /* Red */);\r\n                rightRotate(T, x.parent);\r\n                w = x.parent.left;\r\n            }\r\n            if (getNodeColor(w.left) === 0 /* Black */ && getNodeColor(w.right) === 0 /* Black */) {\r\n                setNodeColor(w, 1 /* Red */);\r\n                x = x.parent;\r\n            }\r\n            else {\r\n                if (getNodeColor(w.left) === 0 /* Black */) {\r\n                    setNodeColor(w.right, 0 /* Black */);\r\n                    setNodeColor(w, 1 /* Red */);\r\n                    leftRotate(T, w);\r\n                    w = x.parent.left;\r\n                }\r\n                setNodeColor(w, getNodeColor(x.parent));\r\n                setNodeColor(x.parent, 0 /* Black */);\r\n                setNodeColor(w.left, 0 /* Black */);\r\n                rightRotate(T, x.parent);\r\n                x = T.root;\r\n            }\r\n        }\r\n    }\r\n    setNodeColor(x, 0 /* Black */);\r\n    resetSentinel();\r\n}\r\nfunction leftest(node) {\r\n    while (node.left !== SENTINEL) {\r\n        node = node.left;\r\n    }\r\n    return node;\r\n}\r\nfunction resetSentinel() {\r\n    SENTINEL.parent = SENTINEL;\r\n    SENTINEL.delta = 0; // optional\r\n    SENTINEL.start = 0; // optional\r\n    SENTINEL.end = 0; // optional\r\n}\r\n//#endregion\r\n//#region Rotations\r\nfunction leftRotate(T, x) {\r\n    const y = x.right; // set y.\r\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start += x.delta;\r\n    y.end += x.delta;\r\n    x.right = y.left; // turn y's left subtree into x's right subtree.\r\n    if (y.left !== SENTINEL) {\r\n        y.left.parent = x;\r\n    }\r\n    y.parent = x.parent; // link x's parent to y.\r\n    if (x.parent === SENTINEL) {\r\n        T.root = y;\r\n    }\r\n    else if (x === x.parent.left) {\r\n        x.parent.left = y;\r\n    }\r\n    else {\r\n        x.parent.right = y;\r\n    }\r\n    y.left = x; // put x on y's left.\r\n    x.parent = y;\r\n    recomputeMaxEnd(x);\r\n    recomputeMaxEnd(y);\r\n}\r\nfunction rightRotate(T, y) {\r\n    const x = y.left;\r\n    y.delta -= x.delta;\r\n    if (y.delta < -1073741824 /* MIN_SAFE_DELTA */ || y.delta > 1073741824 /* MAX_SAFE_DELTA */) {\r\n        T.requestNormalizeDelta = true;\r\n    }\r\n    y.start -= x.delta;\r\n    y.end -= x.delta;\r\n    y.left = x.right;\r\n    if (x.right !== SENTINEL) {\r\n        x.right.parent = y;\r\n    }\r\n    x.parent = y.parent;\r\n    if (y.parent === SENTINEL) {\r\n        T.root = x;\r\n    }\r\n    else if (y === y.parent.right) {\r\n        y.parent.right = x;\r\n    }\r\n    else {\r\n        y.parent.left = x;\r\n    }\r\n    x.right = y;\r\n    y.parent = x;\r\n    recomputeMaxEnd(y);\r\n    recomputeMaxEnd(x);\r\n}\r\n//#endregion\r\n//#region max end computation\r\nfunction computeMaxEnd(node) {\r\n    let maxEnd = node.end;\r\n    if (node.left !== SENTINEL) {\r\n        const leftMaxEnd = node.left.maxEnd;\r\n        if (leftMaxEnd > maxEnd) {\r\n            maxEnd = leftMaxEnd;\r\n        }\r\n    }\r\n    if (node.right !== SENTINEL) {\r\n        const rightMaxEnd = node.right.maxEnd + node.delta;\r\n        if (rightMaxEnd > maxEnd) {\r\n            maxEnd = rightMaxEnd;\r\n        }\r\n    }\r\n    return maxEnd;\r\n}\r\nexport function recomputeMaxEnd(node) {\r\n    node.maxEnd = computeMaxEnd(node);\r\n}\r\nfunction recomputeMaxEndWalkToRoot(node) {\r\n    while (node !== SENTINEL) {\r\n        const maxEnd = computeMaxEnd(node);\r\n        if (node.maxEnd === maxEnd) {\r\n            // no need to go further\r\n            return;\r\n        }\r\n        node.maxEnd = maxEnd;\r\n        node = node.parent;\r\n    }\r\n}\r\n//#endregion\r\n//#region utils\r\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\r\n    if (aStart === bStart) {\r\n        return aEnd - bEnd;\r\n    }\r\n    return aStart - bStart;\r\n}\r\n//#endregion\r\n"]},"metadata":{},"sourceType":"module"}