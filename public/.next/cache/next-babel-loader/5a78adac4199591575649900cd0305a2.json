{"ast":null,"code":"import _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/controller/cursorAtomicMoveOperations.js';\nexport var PointerHandlerLastRenderData = function PointerHandlerLastRenderData(lastViewCursorsRenderData, lastTextareaPosition) {\n  _classCallCheck(this, PointerHandlerLastRenderData);\n\n  this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n  this.lastTextareaPosition = lastTextareaPosition;\n};\nexport var MouseTarget = /*#__PURE__*/function () {\n  function MouseTarget(element, type) {\n    var mouseColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var range = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var detail = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n    _classCallCheck(this, MouseTarget);\n\n    this.element = element;\n    this.type = type;\n    this.mouseColumn = mouseColumn;\n    this.position = position;\n\n    if (!range && position) {\n      range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n    }\n\n    this.range = range;\n    this.detail = detail;\n  }\n\n  _createClass(MouseTarget, [{\n    key: \"toString\",\n    value: function toString() {\n      return MouseTarget.toString(this);\n    }\n  }], [{\n    key: \"_typeToString\",\n    value: function _typeToString(type) {\n      if (type === 1\n      /* TEXTAREA */\n      ) {\n          return 'TEXTAREA';\n        }\n\n      if (type === 2\n      /* GUTTER_GLYPH_MARGIN */\n      ) {\n          return 'GUTTER_GLYPH_MARGIN';\n        }\n\n      if (type === 3\n      /* GUTTER_LINE_NUMBERS */\n      ) {\n          return 'GUTTER_LINE_NUMBERS';\n        }\n\n      if (type === 4\n      /* GUTTER_LINE_DECORATIONS */\n      ) {\n          return 'GUTTER_LINE_DECORATIONS';\n        }\n\n      if (type === 5\n      /* GUTTER_VIEW_ZONE */\n      ) {\n          return 'GUTTER_VIEW_ZONE';\n        }\n\n      if (type === 6\n      /* CONTENT_TEXT */\n      ) {\n          return 'CONTENT_TEXT';\n        }\n\n      if (type === 7\n      /* CONTENT_EMPTY */\n      ) {\n          return 'CONTENT_EMPTY';\n        }\n\n      if (type === 8\n      /* CONTENT_VIEW_ZONE */\n      ) {\n          return 'CONTENT_VIEW_ZONE';\n        }\n\n      if (type === 9\n      /* CONTENT_WIDGET */\n      ) {\n          return 'CONTENT_WIDGET';\n        }\n\n      if (type === 10\n      /* OVERVIEW_RULER */\n      ) {\n          return 'OVERVIEW_RULER';\n        }\n\n      if (type === 11\n      /* SCROLLBAR */\n      ) {\n          return 'SCROLLBAR';\n        }\n\n      if (type === 12\n      /* OVERLAY_WIDGET */\n      ) {\n          return 'OVERLAY_WIDGET';\n        }\n\n      return 'UNKNOWN';\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(target) {\n      return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\n    }\n  }]);\n\n  return MouseTarget;\n}();\n\nvar ElementPath = /*#__PURE__*/function () {\n  function ElementPath() {\n    _classCallCheck(this, ElementPath);\n  }\n\n  _createClass(ElementPath, null, [{\n    key: \"isTextArea\",\n    value: function isTextArea(path) {\n      return path.length === 2 && path[0] === 3\n      /* OverflowGuard */\n      && path[1] === 6\n      /* TextArea */\n      ;\n    }\n  }, {\n    key: \"isChildOfViewLines\",\n    value: function isChildOfViewLines(path) {\n      return path.length >= 4 && path[0] === 3\n      /* OverflowGuard */\n      && path[3] === 7\n      /* ViewLines */\n      ;\n    }\n  }, {\n    key: \"isStrictChildOfViewLines\",\n    value: function isStrictChildOfViewLines(path) {\n      return path.length > 4 && path[0] === 3\n      /* OverflowGuard */\n      && path[3] === 7\n      /* ViewLines */\n      ;\n    }\n  }, {\n    key: \"isChildOfScrollableElement\",\n    value: function isChildOfScrollableElement(path) {\n      return path.length >= 2 && path[0] === 3\n      /* OverflowGuard */\n      && path[1] === 5\n      /* ScrollableElement */\n      ;\n    }\n  }, {\n    key: \"isChildOfMinimap\",\n    value: function isChildOfMinimap(path) {\n      return path.length >= 2 && path[0] === 3\n      /* OverflowGuard */\n      && path[1] === 8\n      /* Minimap */\n      ;\n    }\n  }, {\n    key: \"isChildOfContentWidgets\",\n    value: function isChildOfContentWidgets(path) {\n      return path.length >= 4 && path[0] === 3\n      /* OverflowGuard */\n      && path[3] === 1\n      /* ContentWidgets */\n      ;\n    }\n  }, {\n    key: \"isChildOfOverflowingContentWidgets\",\n    value: function isChildOfOverflowingContentWidgets(path) {\n      return path.length >= 1 && path[0] === 2\n      /* OverflowingContentWidgets */\n      ;\n    }\n  }, {\n    key: \"isChildOfOverlayWidgets\",\n    value: function isChildOfOverlayWidgets(path) {\n      return path.length >= 2 && path[0] === 3\n      /* OverflowGuard */\n      && path[1] === 4\n      /* OverlayWidgets */\n      ;\n    }\n  }]);\n\n  return ElementPath;\n}();\n\nexport var HitTestContext = /*#__PURE__*/function () {\n  function HitTestContext(context, viewHelper, lastRenderData) {\n    _classCallCheck(this, HitTestContext);\n\n    this.model = context.model;\n    var options = context.configuration.options;\n    this.layoutInfo = options.get(124\n    /* layoutInfo */\n    );\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.lineHeight = options.get(53\n    /* lineHeight */\n    );\n    this.stickyTabStops = options.get(99\n    /* stickyTabStops */\n    );\n    this.typicalHalfwidthCharacterWidth = options.get(38\n    /* fontInfo */\n    ).typicalHalfwidthCharacterWidth;\n    this.lastRenderData = lastRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  _createClass(HitTestContext, [{\n    key: \"getZoneAtCoord\",\n    value: function getZoneAtCoord(mouseVerticalOffset) {\n      return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n  }, {\n    key: \"getFullLineRangeAtCoord\",\n    value: function getFullLineRangeAtCoord(mouseVerticalOffset) {\n      if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n        // Below the last line\n        var _lineNumber = this._context.model.getLineCount();\n\n        var _maxLineColumn = this._context.model.getLineMaxColumn(_lineNumber);\n\n        return {\n          range: new EditorRange(_lineNumber, _maxLineColumn, _lineNumber, _maxLineColumn),\n          isAfterLines: true\n        };\n      }\n\n      var lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n\n      var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\n\n      return {\n        range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n        isAfterLines: false\n      };\n    }\n  }, {\n    key: \"getLineNumberAtVerticalOffset\",\n    value: function getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n      return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isAfterLines\",\n    value: function isAfterLines(mouseVerticalOffset) {\n      return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isInTopPadding\",\n    value: function isInTopPadding(mouseVerticalOffset) {\n      return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n  }, {\n    key: \"isInBottomPadding\",\n    value: function isInBottomPadding(mouseVerticalOffset) {\n      return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n  }, {\n    key: \"getVerticalOffsetForLineNumber\",\n    value: function getVerticalOffsetForLineNumber(lineNumber) {\n      return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n  }, {\n    key: \"findAttribute\",\n    value: function findAttribute(element, attr) {\n      return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(lineNumber) {\n      return this._viewHelper.getLineWidth(lineNumber);\n    }\n  }, {\n    key: \"visibleRangeForPosition\",\n    value: function visibleRangeForPosition(lineNumber, column) {\n      return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n  }, {\n    key: \"getPositionFromDOMInfo\",\n    value: function getPositionFromDOMInfo(spanNode, offset) {\n      return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n  }, {\n    key: \"getCurrentScrollTop\",\n    value: function getCurrentScrollTop() {\n      return this._context.viewLayout.getCurrentScrollTop();\n    }\n  }, {\n    key: \"getCurrentScrollLeft\",\n    value: function getCurrentScrollLeft() {\n      return this._context.viewLayout.getCurrentScrollLeft();\n    }\n  }], [{\n    key: \"getZoneAtCoord\",\n    value: function getZoneAtCoord(context, mouseVerticalOffset) {\n      // The target is either a view zone or the empty space after the last view-line\n      var viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n\n      if (viewZoneWhitespace) {\n        var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n        var lineCount = context.model.getLineCount();\n        var positionBefore = null;\n        var position;\n        var positionAfter = null;\n\n        if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n          // There are more lines after this view zone\n          positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n        }\n\n        if (viewZoneWhitespace.afterLineNumber > 0) {\n          // There are more lines above this view zone\n          positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n        }\n\n        if (positionAfter === null) {\n          position = positionBefore;\n        } else if (positionBefore === null) {\n          position = positionAfter;\n        } else if (mouseVerticalOffset < viewZoneMiddle) {\n          position = positionBefore;\n        } else {\n          position = positionAfter;\n        }\n\n        return {\n          viewZoneId: viewZoneWhitespace.id,\n          afterLineNumber: viewZoneWhitespace.afterLineNumber,\n          positionBefore: positionBefore,\n          positionAfter: positionAfter,\n          position: position\n        };\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_findAttribute\",\n    value: function _findAttribute(element, attr, stopAt) {\n      while (element && element !== document.body) {\n        if (element.hasAttribute && element.hasAttribute(attr)) {\n          return element.getAttribute(attr);\n        }\n\n        if (element === stopAt) {\n          return null;\n        }\n\n        element = element.parentNode;\n      }\n\n      return null;\n    }\n  }]);\n\n  return HitTestContext;\n}();\n\nvar BareHitTestRequest = function BareHitTestRequest(ctx, editorPos, pos) {\n  _classCallCheck(this, BareHitTestRequest);\n\n  this.editorPos = editorPos;\n  this.pos = pos;\n  this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\n  this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\n  this.isInMarginArea = pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft;\n  this.isInContentArea = !this.isInMarginArea;\n  this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n};\n\nvar HitTestRequest = /*#__PURE__*/function (_BareHitTestRequest) {\n  _inherits(HitTestRequest, _BareHitTestRequest);\n\n  var _super = _createSuper(HitTestRequest);\n\n  function HitTestRequest(ctx, editorPos, pos, target) {\n    var _this;\n\n    _classCallCheck(this, HitTestRequest);\n\n    _this = _super.call(this, ctx, editorPos, pos);\n    _this._ctx = ctx;\n\n    if (target) {\n      _this.target = target;\n      _this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\n    } else {\n      _this.target = null;\n      _this.targetPath = new Uint8Array(0);\n    }\n\n    return _this;\n  }\n\n  _createClass(HitTestRequest, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"pos(\".concat(this.pos.x, \",\").concat(this.pos.y, \"), editorPos(\").concat(this.editorPos.x, \",\").concat(this.editorPos.y, \"), mouseVerticalOffset: \").concat(this.mouseVerticalOffset, \", mouseContentHorizontalOffset: \").concat(this.mouseContentHorizontalOffset, \"\\n\\ttarget: \").concat(this.target ? this.target.outerHTML : null);\n    }\n  }, {\n    key: \"fulfill\",\n    value: function fulfill(type) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var range = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var mouseColumn = this.mouseColumn;\n\n      if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\n        // Most likely, the line contains foreign decorations...\n        mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\n      }\n\n      return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\n    }\n  }, {\n    key: \"withTarget\",\n    value: function withTarget(target) {\n      return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\n    }\n  }]);\n\n  return HitTestRequest;\n}(BareHitTestRequest);\n\nvar EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\n\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\n\nexport var MouseTargetFactory = /*#__PURE__*/function () {\n  function MouseTargetFactory(context, viewHelper) {\n    _classCallCheck(this, MouseTargetFactory);\n\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n\n  _createClass(MouseTargetFactory, [{\n    key: \"mouseTargetIsWidget\",\n    value: function mouseTargetIsWidget(e) {\n      var t = e.target;\n      var path = PartFingerprints.collect(t, this._viewHelper.viewDomNode); // Is it a content widget?\n\n      if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n        return true;\n      } // Is it an overlay widget?\n\n\n      if (ElementPath.isChildOfOverlayWidgets(path)) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"createMouseTarget\",\n    value: function createMouseTarget(lastRenderData, editorPos, pos, target) {\n      var ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n      var request = new HitTestRequest(ctx, editorPos, pos, target);\n\n      try {\n        var r = MouseTargetFactory._createMouseTarget(ctx, request, false); // console.log(r.toString());\n\n\n        return r;\n      } catch (err) {\n        // console.log(err);\n        return request.fulfill(0\n        /* UNKNOWN */\n        );\n      }\n    }\n  }, {\n    key: \"getMouseColumn\",\n    value: function getMouseColumn(editorPos, pos) {\n      var options = this._context.configuration.options;\n      var layoutInfo = options.get(124\n      /* layoutInfo */\n      );\n      var mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\n      return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(38\n      /* fontInfo */\n      ).typicalHalfwidthCharacterWidth);\n    }\n  }], [{\n    key: \"_createMouseTarget\",\n    value: function _createMouseTarget(ctx, request, domHitTestExecuted) {\n      // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n      // First ensure the request has a target\n      if (request.target === null) {\n        if (domHitTestExecuted) {\n          // Still no target... and we have already executed hit test...\n          return request.fulfill(0\n          /* UNKNOWN */\n          );\n        }\n\n        var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n        if (hitTestResult.position) {\n          return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n        }\n\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n      } // we know for a fact that request.target is not null\n\n\n      var resolvedRequest = request;\n      var result = null;\n      result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n      result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\n      result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n      return result || request.fulfill(0\n      /* UNKNOWN */\n      );\n    }\n  }, {\n    key: \"_hitTestContentWidget\",\n    value: function _hitTestContentWidget(ctx, request) {\n      // Is it a content widget?\n      if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n        var widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n        if (widgetId) {\n          return request.fulfill(9\n          /* CONTENT_WIDGET */\n          , null, null, widgetId);\n        } else {\n          return request.fulfill(0\n          /* UNKNOWN */\n          );\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestOverlayWidget\",\n    value: function _hitTestOverlayWidget(ctx, request) {\n      // Is it an overlay widget?\n      if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\n        var widgetId = ctx.findAttribute(request.target, 'widgetId');\n\n        if (widgetId) {\n          return request.fulfill(12\n          /* OVERLAY_WIDGET */\n          , null, null, widgetId);\n        } else {\n          return request.fulfill(0\n          /* UNKNOWN */\n          );\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewCursor\",\n    value: function _hitTestViewCursor(ctx, request) {\n      if (request.target) {\n        // Check if we've hit a painted cursor\n        var lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n\n        var _iterator = _createForOfIteratorHelper(lastViewCursorsRenderData),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var d = _step.value;\n\n            if (request.target === d.domNode) {\n              return request.fulfill(6\n              /* CONTENT_TEXT */\n              , d.position);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (request.isInContentArea) {\n        // Edge has a bug when hit-testing the exact position of a cursor,\n        // instead of returning the correct dom node, it returns the\n        // first or last rendered view line dom node, therefore help it out\n        // and first check if we are on top of a cursor\n        var _lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n        var mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n        var mouseVerticalOffset = request.mouseVerticalOffset;\n\n        var _iterator2 = _createForOfIteratorHelper(_lastViewCursorsRenderData),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _d = _step2.value;\n\n            if (mouseContentHorizontalOffset < _d.contentLeft) {\n              // mouse position is to the left of the cursor\n              continue;\n            }\n\n            if (mouseContentHorizontalOffset > _d.contentLeft + _d.width) {\n              // mouse position is to the right of the cursor\n              continue;\n            }\n\n            var cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(_d.position.lineNumber);\n\n            if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + _d.height) {\n              return request.fulfill(6\n              /* CONTENT_TEXT */\n              , _d.position);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewZone\",\n    value: function _hitTestViewZone(ctx, request) {\n      var viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n\n      if (viewZoneData) {\n        var mouseTargetType = request.isInContentArea ? 8\n        /* CONTENT_VIEW_ZONE */\n        : 5\n        /* GUTTER_VIEW_ZONE */\n        ;\n        return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestTextArea\",\n    value: function _hitTestTextArea(ctx, request) {\n      // Is it the textarea?\n      if (ElementPath.isTextArea(request.targetPath)) {\n        if (ctx.lastRenderData.lastTextareaPosition) {\n          return request.fulfill(6\n          /* CONTENT_TEXT */\n          , ctx.lastRenderData.lastTextareaPosition);\n        }\n\n        return request.fulfill(1\n        /* TEXTAREA */\n        , ctx.lastRenderData.lastTextareaPosition);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestMargin\",\n    value: function _hitTestMargin(ctx, request) {\n      if (request.isInMarginArea) {\n        var res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n        var pos = res.range.getStartPosition();\n        var offset = Math.abs(request.pos.x - request.editorPos.x);\n        var detail = {\n          isAfterLines: res.isAfterLines,\n          glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n          glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n          lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n          offsetX: offset\n        };\n        offset -= ctx.layoutInfo.glyphMarginLeft;\n\n        if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n          // On the glyph margin\n          return request.fulfill(2\n          /* GUTTER_GLYPH_MARGIN */\n          , pos, res.range, detail);\n        }\n\n        offset -= ctx.layoutInfo.glyphMarginWidth;\n\n        if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n          // On the line numbers\n          return request.fulfill(3\n          /* GUTTER_LINE_NUMBERS */\n          , pos, res.range, detail);\n        }\n\n        offset -= ctx.layoutInfo.lineNumbersWidth; // On the line decorations\n\n        return request.fulfill(4\n        /* GUTTER_LINE_DECORATIONS */\n        , pos, res.range, detail);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestViewLines\",\n    value: function _hitTestViewLines(ctx, request, domHitTestExecuted) {\n      if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n        return null;\n      }\n\n      if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n        return request.fulfill(7\n        /* CONTENT_EMPTY */\n        , new Position(1, 1), undefined, EMPTY_CONTENT_AFTER_LINES);\n      } // Check if it is below any lines and any view zones\n\n\n      if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n        // This most likely indicates it happened after the last view-line\n        var lineCount = ctx.model.getLineCount();\n        var maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\n        return request.fulfill(7\n        /* CONTENT_EMPTY */\n        , new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\n      }\n\n      if (domHitTestExecuted) {\n        // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n        // See https://github.com/microsoft/vscode/issues/46942\n        if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n          var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n\n          if (ctx.model.getLineLength(lineNumber) === 0) {\n            var _lineWidth = ctx.getLineWidth(lineNumber);\n\n            var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - _lineWidth);\n            return request.fulfill(7\n            /* CONTENT_EMPTY */\n            , new Position(lineNumber, 1), undefined, detail);\n          }\n\n          var lineWidth = ctx.getLineWidth(lineNumber);\n\n          if (request.mouseContentHorizontalOffset >= lineWidth) {\n            var _detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n\n            var pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\n            return request.fulfill(7\n            /* CONTENT_EMPTY */\n            , pos, undefined, _detail);\n          }\n        } // We have already executed hit test...\n\n\n        return request.fulfill(0\n        /* UNKNOWN */\n        );\n      }\n\n      var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\n\n      if (hitTestResult.position) {\n        return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\n      }\n\n      return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\n    }\n  }, {\n    key: \"_hitTestMinimap\",\n    value: function _hitTestMinimap(ctx, request) {\n      if (ElementPath.isChildOfMinimap(request.targetPath)) {\n        var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n        return request.fulfill(11\n        /* SCROLLBAR */\n        , new Position(possibleLineNumber, maxColumn));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestScrollbarSlider\",\n    value: function _hitTestScrollbarSlider(ctx, request) {\n      if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n        if (request.target && request.target.nodeType === 1) {\n          var className = request.target.className;\n\n          if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n            var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n            return request.fulfill(11\n            /* SCROLLBAR */\n            , new Position(possibleLineNumber, maxColumn));\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_hitTestScrollbar\",\n    value: function _hitTestScrollbar(ctx, request) {\n      // Is it the overview ruler?\n      // Is it a child of the scrollable element?\n      if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n        var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\n        return request.fulfill(11\n        /* SCROLLBAR */\n        , new Position(possibleLineNumber, maxColumn));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getMouseColumn\",\n    value: function _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n      if (mouseContentHorizontalOffset < 0) {\n        return 1;\n      }\n\n      var chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n      return chars + 1;\n    }\n  }, {\n    key: \"createMouseTargetFromHitTestPosition\",\n    value: function createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {\n      var pos = new Position(lineNumber, column);\n      var lineWidth = ctx.getLineWidth(lineNumber);\n\n      if (request.mouseContentHorizontalOffset > lineWidth) {\n        if (browser.isEdgeLegacy && pos.column === 1) {\n          // See https://github.com/microsoft/vscode/issues/10875\n          var _detail2 = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n\n          return request.fulfill(7\n          /* CONTENT_EMPTY */\n          , new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), undefined, _detail2);\n        }\n\n        var detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        return request.fulfill(7\n        /* CONTENT_EMPTY */\n        , pos, undefined, detail);\n      }\n\n      var visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n\n      if (!visibleRange) {\n        return request.fulfill(0\n        /* UNKNOWN */\n        , pos);\n      }\n\n      var columnHorizontalOffset = visibleRange.left;\n\n      if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\n        return request.fulfill(6\n        /* CONTENT_TEXT */\n        , pos);\n      }\n\n      var points = [];\n      points.push({\n        offset: visibleRange.left,\n        column: column\n      });\n\n      if (column > 1) {\n        var _visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n\n        if (_visibleRange) {\n          points.push({\n            offset: _visibleRange.left,\n            column: column - 1\n          });\n        }\n      }\n\n      var lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\n\n      if (column < lineMaxColumn) {\n        var _visibleRange2 = ctx.visibleRangeForPosition(lineNumber, column + 1);\n\n        if (_visibleRange2) {\n          points.push({\n            offset: _visibleRange2.left,\n            column: column + 1\n          });\n        }\n      }\n\n      points.sort(function (a, b) {\n        return a.offset - b.offset;\n      });\n\n      for (var i = 1; i < points.length; i++) {\n        var prev = points[i - 1];\n        var curr = points[i];\n\n        if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n          var rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n          return request.fulfill(6\n          /* CONTENT_TEXT */\n          , pos, rng);\n        }\n      }\n\n      return request.fulfill(6\n      /* CONTENT_TEXT */\n      , pos);\n    }\n    /**\r\n     * Most probably WebKit browsers and Edge\r\n     */\n\n  }, {\n    key: \"_doHitTestWithCaretRangeFromPoint\",\n    value: function _doHitTestWithCaretRangeFromPoint(ctx, request) {\n      // In Chrome, especially on Linux it is possible to click between lines,\n      // so try to adjust the `hity` below so that it lands in the center of a line\n      var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      var lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n      var lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\n      var adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n\n      if (adjustedPageY <= request.editorPos.y) {\n        adjustedPageY = request.editorPos.y + 1;\n      }\n\n      if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\n        adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\n      }\n\n      var adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n\n      var r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\n\n      if (r.position) {\n        return r;\n      } // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n\n\n      return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\n    }\n  }, {\n    key: \"_actualDoHitTestWithCaretRangeFromPoint\",\n    value: function _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n      var shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n      var range;\n\n      if (shadowRoot) {\n        if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n          range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n        } else {\n          range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n      } else {\n        range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\n      }\n\n      if (!range || !range.startContainer) {\n        return {\n          position: null,\n          hitTarget: null\n        };\n      } // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n\n\n      var startContainer = range.startContainer;\n      var hitTarget = null;\n\n      if (startContainer.nodeType === startContainer.TEXT_NODE) {\n        // startContainer is expected to be the token text\n        var parent1 = startContainer.parentNode; // expected to be the token span\n\n        var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n        var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n        var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n        if (parent3ClassName === ViewLine.CLASS_NAME) {\n          var p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\n          return {\n            position: p,\n            hitTarget: null\n          };\n        } else {\n          hitTarget = startContainer.parentNode;\n        }\n      } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n        // startContainer is expected to be the token span\n        var _parent = startContainer.parentNode; // expected to be the view line container span\n\n        var _parent2 = _parent ? _parent.parentNode : null; // expected to be the view line div\n\n\n        var parent2ClassName = _parent2 && _parent2.nodeType === _parent2.ELEMENT_NODE ? _parent2.className : null;\n\n        if (parent2ClassName === ViewLine.CLASS_NAME) {\n          var _p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\n\n          return {\n            position: _p,\n            hitTarget: null\n          };\n        } else {\n          hitTarget = startContainer;\n        }\n      }\n\n      return {\n        position: null,\n        hitTarget: hitTarget\n      };\n    }\n    /**\r\n     * Most probably Gecko\r\n     */\n\n  }, {\n    key: \"_doHitTestWithCaretPositionFromPoint\",\n    value: function _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n      var hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\n\n      if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n        // offsetNode is expected to be the token text\n        var parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n\n        var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n\n        var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n\n        var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n\n        if (parent3ClassName === ViewLine.CLASS_NAME) {\n          var p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\n          return {\n            position: p,\n            hitTarget: null\n          };\n        } else {\n          return {\n            position: null,\n            hitTarget: hitResult.offsetNode.parentNode\n          };\n        }\n      } // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n      // Some other times, it returns the `<span>` with the inline decoration\n\n\n      if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n        var _parent3 = hitResult.offsetNode.parentNode;\n        var parent1ClassName = _parent3 && _parent3.nodeType === _parent3.ELEMENT_NODE ? _parent3.className : null;\n\n        var _parent4 = _parent3 ? _parent3.parentNode : null;\n\n        var parent2ClassName = _parent4 && _parent4.nodeType === _parent4.ELEMENT_NODE ? _parent4.className : null;\n\n        if (parent1ClassName === ViewLine.CLASS_NAME) {\n          // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n          var tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n\n          if (tokenSpan) {\n            var _p2 = ctx.getPositionFromDOMInfo(tokenSpan, 0);\n\n            return {\n              position: _p2,\n              hitTarget: null\n            };\n          }\n        } else if (parent2ClassName === ViewLine.CLASS_NAME) {\n          // it returned the `<span>` with the inline decoration\n          var _p3 = ctx.getPositionFromDOMInfo(hitResult.offsetNode, 0);\n\n          return {\n            position: _p3,\n            hitTarget: null\n          };\n        }\n      }\n\n      return {\n        position: null,\n        hitTarget: hitResult.offsetNode\n      };\n    }\n    /**\r\n     * Most probably IE\r\n     */\n\n  }, {\n    key: \"_doHitTestWithMoveToPoint\",\n    value: function _doHitTestWithMoveToPoint(ctx, coords) {\n      var resultPosition = null;\n      var resultHitTarget = null;\n      var textRange = document.body.createTextRange();\n\n      try {\n        textRange.moveToPoint(coords.clientX, coords.clientY);\n      } catch (err) {\n        return {\n          position: null,\n          hitTarget: null\n        };\n      }\n\n      textRange.collapse(true); // Now, let's do our best to figure out what we hit :)\n\n      var parentElement = textRange ? textRange.parentElement() : null;\n      var parent1 = parentElement ? parentElement.parentNode : null;\n      var parent2 = parent1 ? parent1.parentNode : null;\n      var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';\n\n      if (parent2ClassName === ViewLine.CLASS_NAME) {\n        var rangeToContainEntireSpan = textRange.duplicate();\n        rangeToContainEntireSpan.moveToElementText(parentElement);\n        rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);\n        resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length); // Move range out of the span node, IE doesn't like having many ranges in\n        // the same spot and will act badly for lines containing dashes ('-')\n\n        rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);\n      } else {\n        // Looks like we've hit the hover or something foreign\n        resultHitTarget = parentElement;\n      } // Move range out of the span node, IE doesn't like having many ranges in\n      // the same spot and will act badly for lines containing dashes ('-')\n\n\n      textRange.moveToElementText(ctx.viewDomNode);\n      return {\n        position: resultPosition,\n        hitTarget: resultHitTarget\n      };\n    }\n  }, {\n    key: \"_snapToSoftTabBoundary\",\n    value: function _snapToSoftTabBoundary(position, viewModel) {\n      var lineContent = viewModel.getLineContent(position.lineNumber);\n\n      var _viewModel$getTextMod = viewModel.getTextModelOptions(),\n          tabSize = _viewModel$getTextMod.tabSize;\n\n      var newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2\n      /* Nearest */\n      );\n\n      if (newPosition !== -1) {\n        return new Position(position.lineNumber, newPosition + 1);\n      }\n\n      return position;\n    }\n  }, {\n    key: \"_doHitTest\",\n    value: function _doHitTest(ctx, request) {\n      // State of the art (18.10.2012):\n      // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)\n      // Gecko:\n      //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352\n      //    - however, they do give out rangeParent/rangeOffset properties on mouse events\n      // Webkit:\n      //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint\n      // IE:\n      //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx\n      // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy\n      //    - when hit testing the cursor it returns the first or the last line in the viewport\n      //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes\n      //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line\n      // Thank you browsers for making this so 'easy' :)\n      var result;\n\n      if (typeof document.caretRangeFromPoint === 'function') {\n        result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n      } else if (document.caretPositionFromPoint) {\n        result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\n      } else if (document.body.createTextRange) {\n        result = this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());\n      } else {\n        result = {\n          position: null,\n          hitTarget: null\n        };\n      } // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n\n\n      if (result.position && ctx.stickyTabStops) {\n        result.position = this._snapToSoftTabBoundary(result.position, ctx.model);\n      }\n\n      return result;\n    }\n  }]);\n\n  return MouseTargetFactory;\n}();\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\n  var range = document.createRange(); // Get the element under the point\n\n  var el = shadowRoot.elementFromPoint(x, y);\n\n  if (el !== null) {\n    // Get the last child of the element until its firstChild is a text node\n    // This assumes that the pointer is on the right of the line, out of the tokens\n    // and that we want to get the offset of the last token of the line\n    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n      el = el.lastChild;\n    } // Grab its rect\n\n\n    var rect = el.getBoundingClientRect(); // And its font\n\n    var font = window.getComputedStyle(el, null).getPropertyValue('font'); // And also its txt content\n\n    var text = el.innerText; // Position the pixel cursor at the left of the element\n\n    var pixelCursor = rect.left;\n    var offset = 0;\n    var step; // If the point is on the right of the box put the cursor after the last character\n\n    if (x > rect.left + rect.width) {\n      offset = text.length;\n    } else {\n      var charWidthReader = CharWidthReader.getInstance(); // Goes through all the characters of the innerText, and checks if the x of the point\n      // belongs to the character.\n\n      for (var i = 0; i < text.length + 1; i++) {\n        // The step is half the width of the character\n        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2; // Move to the center of the character\n\n        pixelCursor += step; // If the x of the point is smaller that the position of the cursor, the point is over that character\n\n        if (x < pixelCursor) {\n          offset = i;\n          break;\n        } // Move between the current character and the next\n\n\n        pixelCursor += step;\n      }\n    } // Creates a range with the text node of the element and set the offset found\n\n\n    range.setStart(el.firstChild, offset);\n    range.setEnd(el.firstChild, offset);\n  }\n\n  return range;\n}\n\nvar CharWidthReader = /*#__PURE__*/function () {\n  function CharWidthReader() {\n    _classCallCheck(this, CharWidthReader);\n\n    this._cache = {};\n    this._canvas = document.createElement('canvas');\n  }\n\n  _createClass(CharWidthReader, [{\n    key: \"getCharWidth\",\n    value: function getCharWidth(_char, font) {\n      var cacheKey = _char + font;\n\n      if (this._cache[cacheKey]) {\n        return this._cache[cacheKey];\n      }\n\n      var context = this._canvas.getContext('2d');\n\n      context.font = font;\n      var metrics = context.measureText(_char);\n      var width = metrics.width;\n      this._cache[cacheKey] = width;\n      return width;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!CharWidthReader._INSTANCE) {\n        CharWidthReader._INSTANCE = new CharWidthReader();\n      }\n\n      return CharWidthReader._INSTANCE;\n    }\n  }]);\n\n  return CharWidthReader;\n}();\n\nCharWidthReader._INSTANCE = null;","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js"],"names":["browser","PageCoordinates","PartFingerprints","ViewLine","Position","Range","EditorRange","CursorColumns","dom","AtomicTabMoveOperations","PointerHandlerLastRenderData","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","element","type","mouseColumn","position","range","detail","lineNumber","column","toString","target","_typeToString","ElementPath","path","length","HitTestContext","context","viewHelper","lastRenderData","model","options","configuration","layoutInfo","get","viewDomNode","lineHeight","stickyTabStops","typicalHalfwidthCharacterWidth","_context","_viewHelper","mouseVerticalOffset","getZoneAtCoord","viewLayout","isAfterLines","getLineCount","maxLineColumn","getLineMaxColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","getVerticalOffsetForLineNumber","attr","_findAttribute","getLineWidth","visibleRangeForPosition","spanNode","offset","getPositionFromDOMInfo","getCurrentScrollTop","getCurrentScrollLeft","viewZoneWhitespace","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","height","lineCount","positionBefore","positionAfter","afterLineNumber","viewZoneId","id","stopAt","document","body","hasAttribute","getAttribute","parentNode","BareHitTestRequest","ctx","editorPos","pos","Math","max","y","mouseContentHorizontalOffset","x","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_ctx","targetPath","collect","Uint8Array","outerHTML","visibleColumnFromColumn","getLineContent","getTextModelOptions","tabSize","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","e","t","isChildOfContentWidgets","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","request","r","_createMouseTarget","err","fulfill","domHitTestExecuted","hitTestResult","_doHitTest","createMouseTargetFromHitTestPosition","withTarget","hitTarget","resolvedRequest","result","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","findAttribute","d","domNode","width","cursorVerticalOffset","viewZoneData","mouseTargetType","isTextArea","res","getFullLineRangeAtCoord","getStartPosition","abs","glyphMarginWidth","lineNumbersWidth","offsetX","isChildOfViewLines","undefined","isStrictChildOfViewLines","getLineLength","lineWidth","isChildOfMinimap","possibleLineNumber","maxColumn","isChildOfScrollableElement","nodeType","className","test","chars","round","isEdgeLegacy","visibleRange","columnHorizontalOffset","left","points","push","lineMaxColumn","sort","a","b","i","prev","curr","rng","lineVerticalOffset","lineCenteredVerticalOffset","floor","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","toClientCoordinates","coords","shadowRoot","getShadowRoot","caretRangeFromPoint","shadowCaretRangeFromPoint","clientX","clientY","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","ELEMENT_NODE","CLASS_NAME","p","startOffset","parent2ClassName","textContent","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","min","resultPosition","resultHitTarget","textRange","createTextRange","moveToPoint","collapse","parentElement","rangeToContainEntireSpan","duplicate","moveToElementText","setEndPoint","text","viewModel","lineContent","newPosition","atomicPosition","_doHitTestWithCaretRangeFromPoint","_doHitTestWithCaretPositionFromPoint","_doHitTestWithMoveToPoint","_snapToSoftTabBoundary","createRange","el","elementFromPoint","firstChild","lastChild","rect","getBoundingClientRect","font","window","getComputedStyle","getPropertyValue","innerText","pixelCursor","step","charWidthReader","CharWidthReader","getInstance","getCharWidth","charAt","setStart","setEnd","_cache","_canvas","createElement","char","cacheKey","getContext","metrics","measureText","_INSTANCE"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as browser from '../../../base/browser/browser.js';\r\nimport { PageCoordinates } from '../editorDom.js';\r\nimport { PartFingerprints } from '../view/viewPart.js';\r\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range as EditorRange } from '../../common/core/range.js';\r\nimport { CursorColumns } from '../../common/controller/cursorCommon.js';\r\nimport * as dom from '../../../base/browser/dom.js';\r\nimport { AtomicTabMoveOperations } from '../../common/controller/cursorAtomicMoveOperations.js';\r\nexport class PointerHandlerLastRenderData {\r\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\r\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\r\n        this.lastTextareaPosition = lastTextareaPosition;\r\n    }\r\n}\r\nexport class MouseTarget {\r\n    constructor(element, type, mouseColumn = 0, position = null, range = null, detail = null) {\r\n        this.element = element;\r\n        this.type = type;\r\n        this.mouseColumn = mouseColumn;\r\n        this.position = position;\r\n        if (!range && position) {\r\n            range = new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\r\n        }\r\n        this.range = range;\r\n        this.detail = detail;\r\n    }\r\n    static _typeToString(type) {\r\n        if (type === 1 /* TEXTAREA */) {\r\n            return 'TEXTAREA';\r\n        }\r\n        if (type === 2 /* GUTTER_GLYPH_MARGIN */) {\r\n            return 'GUTTER_GLYPH_MARGIN';\r\n        }\r\n        if (type === 3 /* GUTTER_LINE_NUMBERS */) {\r\n            return 'GUTTER_LINE_NUMBERS';\r\n        }\r\n        if (type === 4 /* GUTTER_LINE_DECORATIONS */) {\r\n            return 'GUTTER_LINE_DECORATIONS';\r\n        }\r\n        if (type === 5 /* GUTTER_VIEW_ZONE */) {\r\n            return 'GUTTER_VIEW_ZONE';\r\n        }\r\n        if (type === 6 /* CONTENT_TEXT */) {\r\n            return 'CONTENT_TEXT';\r\n        }\r\n        if (type === 7 /* CONTENT_EMPTY */) {\r\n            return 'CONTENT_EMPTY';\r\n        }\r\n        if (type === 8 /* CONTENT_VIEW_ZONE */) {\r\n            return 'CONTENT_VIEW_ZONE';\r\n        }\r\n        if (type === 9 /* CONTENT_WIDGET */) {\r\n            return 'CONTENT_WIDGET';\r\n        }\r\n        if (type === 10 /* OVERVIEW_RULER */) {\r\n            return 'OVERVIEW_RULER';\r\n        }\r\n        if (type === 11 /* SCROLLBAR */) {\r\n            return 'SCROLLBAR';\r\n        }\r\n        if (type === 12 /* OVERLAY_WIDGET */) {\r\n            return 'OVERLAY_WIDGET';\r\n        }\r\n        return 'UNKNOWN';\r\n    }\r\n    static toString(target) {\r\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;\r\n    }\r\n    toString() {\r\n        return MouseTarget.toString(this);\r\n    }\r\n}\r\nclass ElementPath {\r\n    static isTextArea(path) {\r\n        return (path.length === 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 6 /* TextArea */);\r\n    }\r\n    static isChildOfViewLines(path) {\r\n        return (path.length >= 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 7 /* ViewLines */);\r\n    }\r\n    static isStrictChildOfViewLines(path) {\r\n        return (path.length > 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 7 /* ViewLines */);\r\n    }\r\n    static isChildOfScrollableElement(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 5 /* ScrollableElement */);\r\n    }\r\n    static isChildOfMinimap(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 8 /* Minimap */);\r\n    }\r\n    static isChildOfContentWidgets(path) {\r\n        return (path.length >= 4\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[3] === 1 /* ContentWidgets */);\r\n    }\r\n    static isChildOfOverflowingContentWidgets(path) {\r\n        return (path.length >= 1\r\n            && path[0] === 2 /* OverflowingContentWidgets */);\r\n    }\r\n    static isChildOfOverlayWidgets(path) {\r\n        return (path.length >= 2\r\n            && path[0] === 3 /* OverflowGuard */\r\n            && path[1] === 4 /* OverlayWidgets */);\r\n    }\r\n}\r\nexport class HitTestContext {\r\n    constructor(context, viewHelper, lastRenderData) {\r\n        this.model = context.model;\r\n        const options = context.configuration.options;\r\n        this.layoutInfo = options.get(124 /* layoutInfo */);\r\n        this.viewDomNode = viewHelper.viewDomNode;\r\n        this.lineHeight = options.get(53 /* lineHeight */);\r\n        this.stickyTabStops = options.get(99 /* stickyTabStops */);\r\n        this.typicalHalfwidthCharacterWidth = options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth;\r\n        this.lastRenderData = lastRenderData;\r\n        this._context = context;\r\n        this._viewHelper = viewHelper;\r\n    }\r\n    getZoneAtCoord(mouseVerticalOffset) {\r\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\r\n    }\r\n    static getZoneAtCoord(context, mouseVerticalOffset) {\r\n        // The target is either a view zone or the empty space after the last view-line\r\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\r\n        if (viewZoneWhitespace) {\r\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\r\n            const lineCount = context.model.getLineCount();\r\n            let positionBefore = null;\r\n            let position;\r\n            let positionAfter = null;\r\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\r\n                // There are more lines after this view zone\r\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\r\n            }\r\n            if (viewZoneWhitespace.afterLineNumber > 0) {\r\n                // There are more lines above this view zone\r\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\r\n            }\r\n            if (positionAfter === null) {\r\n                position = positionBefore;\r\n            }\r\n            else if (positionBefore === null) {\r\n                position = positionAfter;\r\n            }\r\n            else if (mouseVerticalOffset < viewZoneMiddle) {\r\n                position = positionBefore;\r\n            }\r\n            else {\r\n                position = positionAfter;\r\n            }\r\n            return {\r\n                viewZoneId: viewZoneWhitespace.id,\r\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\r\n                positionBefore: positionBefore,\r\n                positionAfter: positionAfter,\r\n                position: position\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\r\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\r\n            // Below the last line\r\n            const lineNumber = this._context.model.getLineCount();\r\n            const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\r\n            return {\r\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\r\n                isAfterLines: true\r\n            };\r\n        }\r\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\r\n        const maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);\r\n        return {\r\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\r\n            isAfterLines: false\r\n        };\r\n    }\r\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\r\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\r\n    }\r\n    isAfterLines(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\r\n    }\r\n    isInTopPadding(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\r\n    }\r\n    isInBottomPadding(mouseVerticalOffset) {\r\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\r\n    }\r\n    getVerticalOffsetForLineNumber(lineNumber) {\r\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\r\n    }\r\n    findAttribute(element, attr) {\r\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\r\n    }\r\n    static _findAttribute(element, attr, stopAt) {\r\n        while (element && element !== document.body) {\r\n            if (element.hasAttribute && element.hasAttribute(attr)) {\r\n                return element.getAttribute(attr);\r\n            }\r\n            if (element === stopAt) {\r\n                return null;\r\n            }\r\n            element = element.parentNode;\r\n        }\r\n        return null;\r\n    }\r\n    getLineWidth(lineNumber) {\r\n        return this._viewHelper.getLineWidth(lineNumber);\r\n    }\r\n    visibleRangeForPosition(lineNumber, column) {\r\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\r\n    }\r\n    getPositionFromDOMInfo(spanNode, offset) {\r\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\r\n    }\r\n    getCurrentScrollTop() {\r\n        return this._context.viewLayout.getCurrentScrollTop();\r\n    }\r\n    getCurrentScrollLeft() {\r\n        return this._context.viewLayout.getCurrentScrollLeft();\r\n    }\r\n}\r\nclass BareHitTestRequest {\r\n    constructor(ctx, editorPos, pos) {\r\n        this.editorPos = editorPos;\r\n        this.pos = pos;\r\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + pos.y - editorPos.y);\r\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;\r\n        this.isInMarginArea = (pos.x - editorPos.x < ctx.layoutInfo.contentLeft && pos.x - editorPos.x >= ctx.layoutInfo.glyphMarginLeft);\r\n        this.isInContentArea = !this.isInMarginArea;\r\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\r\n    }\r\n}\r\nclass HitTestRequest extends BareHitTestRequest {\r\n    constructor(ctx, editorPos, pos, target) {\r\n        super(ctx, editorPos, pos);\r\n        this._ctx = ctx;\r\n        if (target) {\r\n            this.target = target;\r\n            this.targetPath = PartFingerprints.collect(target, ctx.viewDomNode);\r\n        }\r\n        else {\r\n            this.target = null;\r\n            this.targetPath = new Uint8Array(0);\r\n        }\r\n    }\r\n    toString() {\r\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\r\n    }\r\n    fulfill(type, position = null, range = null, detail = null) {\r\n        let mouseColumn = this.mouseColumn;\r\n        if (position && position.column < this._ctx.model.getLineMaxColumn(position.lineNumber)) {\r\n            // Most likely, the line contains foreign decorations...\r\n            mouseColumn = CursorColumns.visibleColumnFromColumn(this._ctx.model.getLineContent(position.lineNumber), position.column, this._ctx.model.getTextModelOptions().tabSize) + 1;\r\n        }\r\n        return new MouseTarget(this.target, type, mouseColumn, position, range, detail);\r\n    }\r\n    withTarget(target) {\r\n        return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);\r\n    }\r\n}\r\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\r\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\r\n    return {\r\n        isAfterLines: false,\r\n        horizontalDistanceToText: horizontalDistanceToText\r\n    };\r\n}\r\nexport class MouseTargetFactory {\r\n    constructor(context, viewHelper) {\r\n        this._context = context;\r\n        this._viewHelper = viewHelper;\r\n    }\r\n    mouseTargetIsWidget(e) {\r\n        const t = e.target;\r\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\r\n        // Is it a content widget?\r\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\r\n            return true;\r\n        }\r\n        // Is it an overlay widget?\r\n        if (ElementPath.isChildOfOverlayWidgets(path)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    createMouseTarget(lastRenderData, editorPos, pos, target) {\r\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\r\n        const request = new HitTestRequest(ctx, editorPos, pos, target);\r\n        try {\r\n            const r = MouseTargetFactory._createMouseTarget(ctx, request, false);\r\n            // console.log(r.toString());\r\n            return r;\r\n        }\r\n        catch (err) {\r\n            // console.log(err);\r\n            return request.fulfill(0 /* UNKNOWN */);\r\n        }\r\n    }\r\n    static _createMouseTarget(ctx, request, domHitTestExecuted) {\r\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\r\n        // First ensure the request has a target\r\n        if (request.target === null) {\r\n            if (domHitTestExecuted) {\r\n                // Still no target... and we have already executed hit test...\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n            const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\r\n            if (hitTestResult.position) {\r\n                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\r\n            }\r\n            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\r\n        }\r\n        // we know for a fact that request.target is not null\r\n        const resolvedRequest = request;\r\n        let result = null;\r\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\r\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest, domHitTestExecuted);\r\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\r\n        return (result || request.fulfill(0 /* UNKNOWN */));\r\n    }\r\n    static _hitTestContentWidget(ctx, request) {\r\n        // Is it a content widget?\r\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\r\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\r\n            if (widgetId) {\r\n                return request.fulfill(9 /* CONTENT_WIDGET */, null, null, widgetId);\r\n            }\r\n            else {\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestOverlayWidget(ctx, request) {\r\n        // Is it an overlay widget?\r\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {\r\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\r\n            if (widgetId) {\r\n                return request.fulfill(12 /* OVERLAY_WIDGET */, null, null, widgetId);\r\n            }\r\n            else {\r\n                return request.fulfill(0 /* UNKNOWN */);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewCursor(ctx, request) {\r\n        if (request.target) {\r\n            // Check if we've hit a painted cursor\r\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\r\n            for (const d of lastViewCursorsRenderData) {\r\n                if (request.target === d.domNode) {\r\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\r\n                }\r\n            }\r\n        }\r\n        if (request.isInContentArea) {\r\n            // Edge has a bug when hit-testing the exact position of a cursor,\r\n            // instead of returning the correct dom node, it returns the\r\n            // first or last rendered view line dom node, therefore help it out\r\n            // and first check if we are on top of a cursor\r\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\r\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\r\n            const mouseVerticalOffset = request.mouseVerticalOffset;\r\n            for (const d of lastViewCursorsRenderData) {\r\n                if (mouseContentHorizontalOffset < d.contentLeft) {\r\n                    // mouse position is to the left of the cursor\r\n                    continue;\r\n                }\r\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\r\n                    // mouse position is to the right of the cursor\r\n                    continue;\r\n                }\r\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\r\n                if (cursorVerticalOffset <= mouseVerticalOffset\r\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\r\n                    return request.fulfill(6 /* CONTENT_TEXT */, d.position);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewZone(ctx, request) {\r\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\r\n        if (viewZoneData) {\r\n            const mouseTargetType = (request.isInContentArea ? 8 /* CONTENT_VIEW_ZONE */ : 5 /* GUTTER_VIEW_ZONE */);\r\n            return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestTextArea(ctx, request) {\r\n        // Is it the textarea?\r\n        if (ElementPath.isTextArea(request.targetPath)) {\r\n            if (ctx.lastRenderData.lastTextareaPosition) {\r\n                return request.fulfill(6 /* CONTENT_TEXT */, ctx.lastRenderData.lastTextareaPosition);\r\n            }\r\n            return request.fulfill(1 /* TEXTAREA */, ctx.lastRenderData.lastTextareaPosition);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestMargin(ctx, request) {\r\n        if (request.isInMarginArea) {\r\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\r\n            const pos = res.range.getStartPosition();\r\n            let offset = Math.abs(request.pos.x - request.editorPos.x);\r\n            const detail = {\r\n                isAfterLines: res.isAfterLines,\r\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\r\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\r\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\r\n                offsetX: offset\r\n            };\r\n            offset -= ctx.layoutInfo.glyphMarginLeft;\r\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\r\n                // On the glyph margin\r\n                return request.fulfill(2 /* GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\r\n            }\r\n            offset -= ctx.layoutInfo.glyphMarginWidth;\r\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\r\n                // On the line numbers\r\n                return request.fulfill(3 /* GUTTER_LINE_NUMBERS */, pos, res.range, detail);\r\n            }\r\n            offset -= ctx.layoutInfo.lineNumbersWidth;\r\n            // On the line decorations\r\n            return request.fulfill(4 /* GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestViewLines(ctx, request, domHitTestExecuted) {\r\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\r\n            return null;\r\n        }\r\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(1, 1), undefined, EMPTY_CONTENT_AFTER_LINES);\r\n        }\r\n        // Check if it is below any lines and any view zones\r\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\r\n            // This most likely indicates it happened after the last view-line\r\n            const lineCount = ctx.model.getLineCount();\r\n            const maxLineColumn = ctx.model.getLineMaxColumn(lineCount);\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineCount, maxLineColumn), undefined, EMPTY_CONTENT_AFTER_LINES);\r\n        }\r\n        if (domHitTestExecuted) {\r\n            // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\r\n            // See https://github.com/microsoft/vscode/issues/46942\r\n            if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\r\n                const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n                if (ctx.model.getLineLength(lineNumber) === 0) {\r\n                    const lineWidth = ctx.getLineWidth(lineNumber);\r\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                    return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, 1), undefined, detail);\r\n                }\r\n                const lineWidth = ctx.getLineWidth(lineNumber);\r\n                if (request.mouseContentHorizontalOffset >= lineWidth) {\r\n                    const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                    const pos = new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber));\r\n                    return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\r\n                }\r\n            }\r\n            // We have already executed hit test...\r\n            return request.fulfill(0 /* UNKNOWN */);\r\n        }\r\n        const hitTestResult = MouseTargetFactory._doHitTest(ctx, request);\r\n        if (hitTestResult.position) {\r\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);\r\n        }\r\n        return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);\r\n    }\r\n    static _hitTestMinimap(ctx, request) {\r\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\r\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestScrollbarSlider(ctx, request) {\r\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\r\n            if (request.target && request.target.nodeType === 1) {\r\n                const className = request.target.className;\r\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\r\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n                    const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n                    return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _hitTestScrollbar(ctx, request) {\r\n        // Is it the overview ruler?\r\n        // Is it a child of the scrollable element?\r\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\r\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n            const maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);\r\n            return request.fulfill(11 /* SCROLLBAR */, new Position(possibleLineNumber, maxColumn));\r\n        }\r\n        return null;\r\n    }\r\n    getMouseColumn(editorPos, pos) {\r\n        const options = this._context.configuration.options;\r\n        const layoutInfo = options.get(124 /* layoutInfo */);\r\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;\r\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(38 /* fontInfo */).typicalHalfwidthCharacterWidth);\r\n    }\r\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\r\n        if (mouseContentHorizontalOffset < 0) {\r\n            return 1;\r\n        }\r\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\r\n        return (chars + 1);\r\n    }\r\n    static createMouseTargetFromHitTestPosition(ctx, request, lineNumber, column) {\r\n        const pos = new Position(lineNumber, column);\r\n        const lineWidth = ctx.getLineWidth(lineNumber);\r\n        if (request.mouseContentHorizontalOffset > lineWidth) {\r\n            if (browser.isEdgeLegacy && pos.column === 1) {\r\n                // See https://github.com/microsoft/vscode/issues/10875\r\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n                return request.fulfill(7 /* CONTENT_EMPTY */, new Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)), undefined, detail);\r\n            }\r\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\r\n            return request.fulfill(7 /* CONTENT_EMPTY */, pos, undefined, detail);\r\n        }\r\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\r\n        if (!visibleRange) {\r\n            return request.fulfill(0 /* UNKNOWN */, pos);\r\n        }\r\n        const columnHorizontalOffset = visibleRange.left;\r\n        if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {\r\n            return request.fulfill(6 /* CONTENT_TEXT */, pos);\r\n        }\r\n        const points = [];\r\n        points.push({ offset: visibleRange.left, column: column });\r\n        if (column > 1) {\r\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\r\n            if (visibleRange) {\r\n                points.push({ offset: visibleRange.left, column: column - 1 });\r\n            }\r\n        }\r\n        const lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);\r\n        if (column < lineMaxColumn) {\r\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\r\n            if (visibleRange) {\r\n                points.push({ offset: visibleRange.left, column: column + 1 });\r\n            }\r\n        }\r\n        points.sort((a, b) => a.offset - b.offset);\r\n        for (let i = 1; i < points.length; i++) {\r\n            const prev = points[i - 1];\r\n            const curr = points[i];\r\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\r\n                const rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\r\n                return request.fulfill(6 /* CONTENT_TEXT */, pos, rng);\r\n            }\r\n        }\r\n        return request.fulfill(6 /* CONTENT_TEXT */, pos);\r\n    }\r\n    /**\r\n     * Most probably WebKit browsers and Edge\r\n     */\r\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\r\n        // In Chrome, especially on Linux it is possible to click between lines,\r\n        // so try to adjust the `hity` below so that it lands in the center of a line\r\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\r\n        const lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\r\n        const lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);\r\n        let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\r\n        if (adjustedPageY <= request.editorPos.y) {\r\n            adjustedPageY = request.editorPos.y + 1;\r\n        }\r\n        if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {\r\n            adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;\r\n        }\r\n        const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\r\n        const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());\r\n        if (r.position) {\r\n            return r;\r\n        }\r\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\r\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());\r\n    }\r\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\r\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\r\n        let range;\r\n        if (shadowRoot) {\r\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\r\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\r\n            }\r\n            else {\r\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\r\n            }\r\n        }\r\n        else {\r\n            range = document.caretRangeFromPoint(coords.clientX, coords.clientY);\r\n        }\r\n        if (!range || !range.startContainer) {\r\n            return {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\r\n        const startContainer = range.startContainer;\r\n        let hitTarget = null;\r\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\r\n            // startContainer is expected to be the token text\r\n            const parent1 = startContainer.parentNode; // expected to be the token span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\r\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\r\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\r\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                hitTarget = startContainer.parentNode;\r\n            }\r\n        }\r\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\r\n            // startContainer is expected to be the token span\r\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\r\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\r\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                hitTarget = startContainer;\r\n            }\r\n        }\r\n        return {\r\n            position: null,\r\n            hitTarget: hitTarget\r\n        };\r\n    }\r\n    /**\r\n     * Most probably Gecko\r\n     */\r\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\r\n        const hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);\r\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\r\n            // offsetNode is expected to be the token text\r\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\r\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\r\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\r\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\r\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\r\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    position: null,\r\n                    hitTarget: hitResult.offsetNode.parentNode\r\n                };\r\n            }\r\n        }\r\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\r\n        // Some other times, it returns the `<span>` with the inline decoration\r\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\r\n            const parent1 = hitResult.offsetNode.parentNode;\r\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\r\n            const parent2 = parent1 ? parent1.parentNode : null;\r\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\r\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\r\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\r\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\r\n                if (tokenSpan) {\r\n                    const p = ctx.getPositionFromDOMInfo(tokenSpan, 0);\r\n                    return {\r\n                        position: p,\r\n                        hitTarget: null\r\n                    };\r\n                }\r\n            }\r\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n                // it returned the `<span>` with the inline decoration\r\n                const p = ctx.getPositionFromDOMInfo(hitResult.offsetNode, 0);\r\n                return {\r\n                    position: p,\r\n                    hitTarget: null\r\n                };\r\n            }\r\n        }\r\n        return {\r\n            position: null,\r\n            hitTarget: hitResult.offsetNode\r\n        };\r\n    }\r\n    /**\r\n     * Most probably IE\r\n     */\r\n    static _doHitTestWithMoveToPoint(ctx, coords) {\r\n        let resultPosition = null;\r\n        let resultHitTarget = null;\r\n        const textRange = document.body.createTextRange();\r\n        try {\r\n            textRange.moveToPoint(coords.clientX, coords.clientY);\r\n        }\r\n        catch (err) {\r\n            return {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        textRange.collapse(true);\r\n        // Now, let's do our best to figure out what we hit :)\r\n        const parentElement = textRange ? textRange.parentElement() : null;\r\n        const parent1 = parentElement ? parentElement.parentNode : null;\r\n        const parent2 = parent1 ? parent1.parentNode : null;\r\n        const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';\r\n        if (parent2ClassName === ViewLine.CLASS_NAME) {\r\n            const rangeToContainEntireSpan = textRange.duplicate();\r\n            rangeToContainEntireSpan.moveToElementText(parentElement);\r\n            rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);\r\n            resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);\r\n            // Move range out of the span node, IE doesn't like having many ranges in\r\n            // the same spot and will act badly for lines containing dashes ('-')\r\n            rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);\r\n        }\r\n        else {\r\n            // Looks like we've hit the hover or something foreign\r\n            resultHitTarget = parentElement;\r\n        }\r\n        // Move range out of the span node, IE doesn't like having many ranges in\r\n        // the same spot and will act badly for lines containing dashes ('-')\r\n        textRange.moveToElementText(ctx.viewDomNode);\r\n        return {\r\n            position: resultPosition,\r\n            hitTarget: resultHitTarget\r\n        };\r\n    }\r\n    static _snapToSoftTabBoundary(position, viewModel) {\r\n        const lineContent = viewModel.getLineContent(position.lineNumber);\r\n        const { tabSize } = viewModel.getTextModelOptions();\r\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Nearest */);\r\n        if (newPosition !== -1) {\r\n            return new Position(position.lineNumber, newPosition + 1);\r\n        }\r\n        return position;\r\n    }\r\n    static _doHitTest(ctx, request) {\r\n        // State of the art (18.10.2012):\r\n        // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)\r\n        // Gecko:\r\n        //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352\r\n        //    - however, they do give out rangeParent/rangeOffset properties on mouse events\r\n        // Webkit:\r\n        //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint\r\n        // IE:\r\n        //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx\r\n        // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy\r\n        //    - when hit testing the cursor it returns the first or the last line in the viewport\r\n        //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes\r\n        //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line\r\n        // Thank you browsers for making this so 'easy' :)\r\n        let result;\r\n        if (typeof document.caretRangeFromPoint === 'function') {\r\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\r\n        }\r\n        else if (document.caretPositionFromPoint) {\r\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());\r\n        }\r\n        else if (document.body.createTextRange) {\r\n            result = this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());\r\n        }\r\n        else {\r\n            result = {\r\n                position: null,\r\n                hitTarget: null\r\n            };\r\n        }\r\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\r\n        if (result.position && ctx.stickyTabStops) {\r\n            result.position = this._snapToSoftTabBoundary(result.position, ctx.model);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexport function shadowCaretRangeFromPoint(shadowRoot, x, y) {\r\n    const range = document.createRange();\r\n    // Get the element under the point\r\n    let el = shadowRoot.elementFromPoint(x, y);\r\n    if (el !== null) {\r\n        // Get the last child of the element until its firstChild is a text node\r\n        // This assumes that the pointer is on the right of the line, out of the tokens\r\n        // and that we want to get the offset of the last token of the line\r\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\r\n            el = el.lastChild;\r\n        }\r\n        // Grab its rect\r\n        const rect = el.getBoundingClientRect();\r\n        // And its font\r\n        const font = window.getComputedStyle(el, null).getPropertyValue('font');\r\n        // And also its txt content\r\n        const text = el.innerText;\r\n        // Position the pixel cursor at the left of the element\r\n        let pixelCursor = rect.left;\r\n        let offset = 0;\r\n        let step;\r\n        // If the point is on the right of the box put the cursor after the last character\r\n        if (x > rect.left + rect.width) {\r\n            offset = text.length;\r\n        }\r\n        else {\r\n            const charWidthReader = CharWidthReader.getInstance();\r\n            // Goes through all the characters of the innerText, and checks if the x of the point\r\n            // belongs to the character.\r\n            for (let i = 0; i < text.length + 1; i++) {\r\n                // The step is half the width of the character\r\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\r\n                // Move to the center of the character\r\n                pixelCursor += step;\r\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\r\n                if (x < pixelCursor) {\r\n                    offset = i;\r\n                    break;\r\n                }\r\n                // Move between the current character and the next\r\n                pixelCursor += step;\r\n            }\r\n        }\r\n        // Creates a range with the text node of the element and set the offset found\r\n        range.setStart(el.firstChild, offset);\r\n        range.setEnd(el.firstChild, offset);\r\n    }\r\n    return range;\r\n}\r\nclass CharWidthReader {\r\n    constructor() {\r\n        this._cache = {};\r\n        this._canvas = document.createElement('canvas');\r\n    }\r\n    static getInstance() {\r\n        if (!CharWidthReader._INSTANCE) {\r\n            CharWidthReader._INSTANCE = new CharWidthReader();\r\n        }\r\n        return CharWidthReader._INSTANCE;\r\n    }\r\n    getCharWidth(char, font) {\r\n        const cacheKey = char + font;\r\n        if (this._cache[cacheKey]) {\r\n            return this._cache[cacheKey];\r\n        }\r\n        const context = this._canvas.getContext('2d');\r\n        context.font = font;\r\n        const metrics = context.measureText(char);\r\n        const width = metrics.width;\r\n        this._cache[cacheKey] = width;\r\n        return width;\r\n    }\r\n}\r\nCharWidthReader._INSTANCE = null;\r\n"]},"metadata":{},"sourceType":"module"}