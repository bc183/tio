{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n\nvar PendingChanges = /*#__PURE__*/function () {\n  function PendingChanges() {\n    _classCallCheck(this, PendingChanges);\n\n    this._hasPending = false;\n    this._inserts = [];\n    this._changes = [];\n    this._removes = [];\n  }\n\n  _createClass(PendingChanges, [{\n    key: \"insert\",\n    value: function insert(x) {\n      this._hasPending = true;\n\n      this._inserts.push(x);\n    }\n  }, {\n    key: \"change\",\n    value: function change(x) {\n      this._hasPending = true;\n\n      this._changes.push(x);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(x) {\n      this._hasPending = true;\n\n      this._removes.push(x);\n    }\n  }, {\n    key: \"mustCommit\",\n    value: function mustCommit() {\n      return this._hasPending;\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(linesLayout) {\n      if (!this._hasPending) {\n        return;\n      }\n\n      var inserts = this._inserts;\n      var changes = this._changes;\n      var removes = this._removes;\n      this._hasPending = false;\n      this._inserts = [];\n      this._changes = [];\n      this._removes = [];\n\n      linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n  }]);\n\n  return PendingChanges;\n}();\n\nexport var EditorWhitespace = function EditorWhitespace(id, afterLineNumber, ordinal, height, minWidth) {\n  _classCallCheck(this, EditorWhitespace);\n\n  this.id = id;\n  this.afterLineNumber = afterLineNumber;\n  this.ordinal = ordinal;\n  this.height = height;\n  this.minWidth = minWidth;\n  this.prefixSum = 0;\n};\n/**\r\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\r\n *\r\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\r\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\r\n */\n\nexport var LinesLayout = /*#__PURE__*/function () {\n  function LinesLayout(lineCount, lineHeight, paddingTop, paddingBottom) {\n    _classCallCheck(this, LinesLayout);\n\n    this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n    this._pendingChanges = new PendingChanges();\n    this._lastWhitespaceId = 0;\n    this._arr = [];\n    this._prefixSumValidIndex = -1;\n    this._minWidth = -1;\n    /* marker for not being computed */\n\n    this._lineCount = lineCount;\n    this._lineHeight = lineHeight;\n    this._paddingTop = paddingTop;\n    this._paddingBottom = paddingBottom;\n  }\n  /**\r\n   * Find the insertion index for a new value inside a sorted array of values.\r\n   * If the value is already present in the sorted array, the insertion index will be after the already existing value.\r\n   */\n\n\n  _createClass(LinesLayout, [{\n    key: \"setLineHeight\",\n\n    /**\r\n     * Change the height of a line in pixels.\r\n     */\n    value: function setLineHeight(lineHeight) {\n      this._checkPendingChanges();\n\n      this._lineHeight = lineHeight;\n    }\n    /**\r\n     * Changes the padding used to calculate vertical offsets.\r\n     */\n\n  }, {\n    key: \"setPadding\",\n    value: function setPadding(paddingTop, paddingBottom) {\n      this._paddingTop = paddingTop;\n      this._paddingBottom = paddingBottom;\n    }\n    /**\r\n     * Set the number of lines.\r\n     *\r\n     * @param lineCount New number of lines.\r\n     */\n\n  }, {\n    key: \"onFlushed\",\n    value: function onFlushed(lineCount) {\n      this._checkPendingChanges();\n\n      this._lineCount = lineCount;\n    }\n  }, {\n    key: \"changeWhitespace\",\n    value: function changeWhitespace(callback) {\n      var _this = this;\n\n      var hadAChange = false;\n\n      try {\n        var accessor = {\n          insertWhitespace: function insertWhitespace(afterLineNumber, ordinal, heightInPx, minWidth) {\n            hadAChange = true;\n            afterLineNumber = afterLineNumber | 0;\n            ordinal = ordinal | 0;\n            heightInPx = heightInPx | 0;\n            minWidth = minWidth | 0;\n            var id = _this._instanceId + ++_this._lastWhitespaceId;\n\n            _this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n\n            return id;\n          },\n          changeOneWhitespace: function changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n            hadAChange = true;\n            newAfterLineNumber = newAfterLineNumber | 0;\n            newHeight = newHeight | 0;\n\n            _this._pendingChanges.change({\n              id: id,\n              newAfterLineNumber: newAfterLineNumber,\n              newHeight: newHeight\n            });\n          },\n          removeWhitespace: function removeWhitespace(id) {\n            hadAChange = true;\n\n            _this._pendingChanges.remove({\n              id: id\n            });\n          }\n        };\n        callback(accessor);\n      } finally {\n        this._pendingChanges.commit(this);\n      }\n\n      return hadAChange;\n    }\n  }, {\n    key: \"_commitPendingChanges\",\n    value: function _commitPendingChanges(inserts, changes, removes) {\n      if (inserts.length > 0 || removes.length > 0) {\n        this._minWidth = -1;\n        /* marker for not being computed */\n      }\n\n      if (inserts.length + changes.length + removes.length <= 1) {\n        // when only one thing happened, handle it \"delicately\"\n        var _iterator = _createForOfIteratorHelper(inserts),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var insert = _step.value;\n\n            this._insertWhitespace(insert);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(changes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var change = _step2.value;\n\n            this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var _iterator3 = _createForOfIteratorHelper(removes),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var remove = _step3.value;\n\n            var index = this._findWhitespaceIndex(remove.id);\n\n            if (index === -1) {\n              continue;\n            }\n\n            this._removeWhitespace(index);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return;\n      } // simply rebuild the entire datastructure\n\n\n      var toRemove = new Set();\n\n      var _iterator4 = _createForOfIteratorHelper(removes),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _remove = _step4.value;\n          toRemove.add(_remove.id);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var toChange = new Map();\n\n      var _iterator5 = _createForOfIteratorHelper(changes),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _change2 = _step5.value;\n          toChange.set(_change2.id, _change2);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var applyRemoveAndChange = function applyRemoveAndChange(whitespaces) {\n        var result = [];\n\n        var _iterator6 = _createForOfIteratorHelper(whitespaces),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var whitespace = _step6.value;\n\n            if (toRemove.has(whitespace.id)) {\n              continue;\n            }\n\n            if (toChange.has(whitespace.id)) {\n              var _change = toChange.get(whitespace.id);\n\n              whitespace.afterLineNumber = _change.newAfterLineNumber;\n              whitespace.height = _change.newHeight;\n            }\n\n            result.push(whitespace);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return result;\n      };\n\n      var result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n      result.sort(function (a, b) {\n        if (a.afterLineNumber === b.afterLineNumber) {\n          return a.ordinal - b.ordinal;\n        }\n\n        return a.afterLineNumber - b.afterLineNumber;\n      });\n      this._arr = result;\n      this._prefixSumValidIndex = -1;\n    }\n  }, {\n    key: \"_checkPendingChanges\",\n    value: function _checkPendingChanges() {\n      if (this._pendingChanges.mustCommit()) {\n        this._pendingChanges.commit(this);\n      }\n    }\n  }, {\n    key: \"_insertWhitespace\",\n    value: function _insertWhitespace(whitespace) {\n      var insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n\n      this._arr.splice(insertIndex, 0, whitespace);\n\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n  }, {\n    key: \"_findWhitespaceIndex\",\n    value: function _findWhitespaceIndex(id) {\n      var arr = this._arr;\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i].id === id) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"_changeOneWhitespace\",\n    value: function _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n      var index = this._findWhitespaceIndex(id);\n\n      if (index === -1) {\n        return;\n      }\n\n      if (this._arr[index].height !== newHeight) {\n        this._arr[index].height = newHeight;\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n      }\n\n      if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n        // `afterLineNumber` changed for this whitespace\n        // Record old whitespace\n        var whitespace = this._arr[index]; // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n\n        this._removeWhitespace(index);\n\n        whitespace.afterLineNumber = newAfterLineNumber; // And add it again\n\n        this._insertWhitespace(whitespace);\n      }\n    }\n  }, {\n    key: \"_removeWhitespace\",\n    value: function _removeWhitespace(removeIndex) {\n      this._arr.splice(removeIndex, 1);\n\n      this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\r\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\r\n     *\r\n     * @param fromLineNumber The line number at which the deletion started, inclusive\r\n     * @param toLineNumber The line number at which the deletion ended, inclusive\r\n     */\n\n  }, {\n    key: \"onLinesDeleted\",\n    value: function onLinesDeleted(fromLineNumber, toLineNumber) {\n      this._checkPendingChanges();\n\n      fromLineNumber = fromLineNumber | 0;\n      toLineNumber = toLineNumber | 0;\n      this._lineCount -= toLineNumber - fromLineNumber + 1;\n\n      for (var i = 0, len = this._arr.length; i < len; i++) {\n        var afterLineNumber = this._arr[i].afterLineNumber;\n\n        if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n          // The line this whitespace was after has been deleted\n          //  => move whitespace to before first deleted line\n          this._arr[i].afterLineNumber = fromLineNumber - 1;\n        } else if (afterLineNumber > toLineNumber) {\n          // The line this whitespace was after has been moved up\n          //  => move whitespace up\n          this._arr[i].afterLineNumber -= toLineNumber - fromLineNumber + 1;\n        }\n      }\n    }\n    /**\r\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\r\n     *\r\n     * @param fromLineNumber The line number at which the insertion started, inclusive\r\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\r\n     */\n\n  }, {\n    key: \"onLinesInserted\",\n    value: function onLinesInserted(fromLineNumber, toLineNumber) {\n      this._checkPendingChanges();\n\n      fromLineNumber = fromLineNumber | 0;\n      toLineNumber = toLineNumber | 0;\n      this._lineCount += toLineNumber - fromLineNumber + 1;\n\n      for (var i = 0, len = this._arr.length; i < len; i++) {\n        var afterLineNumber = this._arr[i].afterLineNumber;\n\n        if (fromLineNumber <= afterLineNumber) {\n          this._arr[i].afterLineNumber += toLineNumber - fromLineNumber + 1;\n        }\n      }\n    }\n    /**\r\n     * Get the sum of all the whitespaces.\r\n     */\n\n  }, {\n    key: \"getWhitespacesTotalHeight\",\n    value: function getWhitespacesTotalHeight() {\n      this._checkPendingChanges();\n\n      if (this._arr.length === 0) {\n        return 0;\n      }\n\n      return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\r\n     * Return the sum of the heights of the whitespaces at [0..index].\r\n     * This includes the whitespace at `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\r\n     */\n\n  }, {\n    key: \"getWhitespacesAccumulatedHeight\",\n    value: function getWhitespacesAccumulatedHeight(index) {\n      this._checkPendingChanges();\n\n      index = index | 0;\n      var startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n\n      if (startIndex === 0) {\n        this._arr[0].prefixSum = this._arr[0].height;\n        startIndex++;\n      }\n\n      for (var i = startIndex; i <= index; i++) {\n        this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n      }\n\n      this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n      return this._arr[index].prefixSum;\n    }\n    /**\r\n     * Get the sum of heights for all objects.\r\n     *\r\n     * @return The sum of heights for all objects.\r\n     */\n\n  }, {\n    key: \"getLinesTotalHeight\",\n    value: function getLinesTotalHeight() {\n      this._checkPendingChanges();\n\n      var linesHeight = this._lineHeight * this._lineCount;\n      var whitespacesHeight = this.getWhitespacesTotalHeight();\n      return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\r\n     * Returns the accumulated height of whitespaces before the given line number.\r\n     *\r\n     * @param lineNumber The line number\r\n     */\n\n  }, {\n    key: \"getWhitespaceAccumulatedHeightBeforeLineNumber\",\n    value: function getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n      this._checkPendingChanges();\n\n      lineNumber = lineNumber | 0;\n\n      var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n      if (lastWhitespaceBeforeLineNumber === -1) {\n        return 0;\n      }\n\n      return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n  }, {\n    key: \"_findLastWhitespaceBeforeLineNumber\",\n    value: function _findLastWhitespaceBeforeLineNumber(lineNumber) {\n      lineNumber = lineNumber | 0; // Find the whitespace before line number\n\n      var arr = this._arr;\n      var low = 0;\n      var high = arr.length - 1;\n\n      while (low <= high) {\n        var delta = high - low | 0;\n        var halfDelta = delta / 2 | 0;\n        var mid = low + halfDelta | 0;\n\n        if (arr[mid].afterLineNumber < lineNumber) {\n          if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n            return mid;\n          } else {\n            low = mid + 1 | 0;\n          }\n        } else {\n          high = mid - 1 | 0;\n        }\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"_findFirstWhitespaceAfterLineNumber\",\n    value: function _findFirstWhitespaceAfterLineNumber(lineNumber) {\n      lineNumber = lineNumber | 0;\n\n      var lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n\n      var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n\n      if (firstWhitespaceAfterLineNumber < this._arr.length) {\n        return firstWhitespaceAfterLineNumber;\n      }\n\n      return -1;\n    }\n    /**\r\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\r\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\r\n     */\n\n  }, {\n    key: \"getFirstWhitespaceIndexAfterLineNumber\",\n    value: function getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n      this._checkPendingChanges();\n\n      lineNumber = lineNumber | 0;\n      return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\r\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\r\n     *\r\n     * @param lineNumber The line number\r\n     * @return The sum of heights for all objects above `lineNumber`.\r\n     */\n\n  }, {\n    key: \"getVerticalOffsetForLineNumber\",\n    value: function getVerticalOffsetForLineNumber(lineNumber) {\n      this._checkPendingChanges();\n\n      lineNumber = lineNumber | 0;\n      var previousLinesHeight;\n\n      if (lineNumber > 1) {\n        previousLinesHeight = this._lineHeight * (lineNumber - 1);\n      } else {\n        previousLinesHeight = 0;\n      }\n\n      var previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n      return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\r\n     * The maximum min width for all whitespaces.\r\n     */\n\n  }, {\n    key: \"getWhitespaceMinWidth\",\n    value: function getWhitespaceMinWidth() {\n      this._checkPendingChanges();\n\n      if (this._minWidth === -1) {\n        var minWidth = 0;\n\n        for (var i = 0, len = this._arr.length; i < len; i++) {\n          minWidth = Math.max(minWidth, this._arr[i].minWidth);\n        }\n\n        this._minWidth = minWidth;\n      }\n\n      return this._minWidth;\n    }\n    /**\r\n     * Check if `verticalOffset` is below all lines.\r\n     */\n\n  }, {\n    key: \"isAfterLines\",\n    value: function isAfterLines(verticalOffset) {\n      this._checkPendingChanges();\n\n      var totalHeight = this.getLinesTotalHeight();\n      return verticalOffset > totalHeight;\n    }\n  }, {\n    key: \"isInTopPadding\",\n    value: function isInTopPadding(verticalOffset) {\n      if (this._paddingTop === 0) {\n        return false;\n      }\n\n      this._checkPendingChanges();\n\n      return verticalOffset < this._paddingTop;\n    }\n  }, {\n    key: \"isInBottomPadding\",\n    value: function isInBottomPadding(verticalOffset) {\n      if (this._paddingBottom === 0) {\n        return false;\n      }\n\n      this._checkPendingChanges();\n\n      var totalHeight = this.getLinesTotalHeight();\n      return verticalOffset >= totalHeight - this._paddingBottom;\n    }\n    /**\r\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\r\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\r\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\r\n     *\r\n     * @param verticalOffset The vertical offset to search at.\r\n     * @return The line number at or after vertical offset `verticalOffset`.\r\n     */\n\n  }, {\n    key: \"getLineNumberAtOrAfterVerticalOffset\",\n    value: function getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n      this._checkPendingChanges();\n\n      verticalOffset = verticalOffset | 0;\n\n      if (verticalOffset < 0) {\n        return 1;\n      }\n\n      var linesCount = this._lineCount | 0;\n      var lineHeight = this._lineHeight;\n      var minLineNumber = 1;\n      var maxLineNumber = linesCount;\n\n      while (minLineNumber < maxLineNumber) {\n        var midLineNumber = (minLineNumber + maxLineNumber) / 2 | 0;\n        var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n\n        if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n          // vertical offset is after mid line number\n          minLineNumber = midLineNumber + 1;\n        } else if (verticalOffset >= midLineNumberVerticalOffset) {\n          // Hit\n          return midLineNumber;\n        } else {\n          // vertical offset is before mid line number, but mid line number could still be what we're searching for\n          maxLineNumber = midLineNumber;\n        }\n      }\n\n      if (minLineNumber > linesCount) {\n        return linesCount;\n      }\n\n      return minLineNumber;\n    }\n    /**\r\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\r\n     *\r\n     * @param verticalOffset1 The beginning of the viewport.\r\n     * @param verticalOffset2 The end of the viewport.\r\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\r\n     */\n\n  }, {\n    key: \"getLinesViewportData\",\n    value: function getLinesViewportData(verticalOffset1, verticalOffset2) {\n      this._checkPendingChanges();\n\n      verticalOffset1 = verticalOffset1 | 0;\n      verticalOffset2 = verticalOffset2 | 0;\n      var lineHeight = this._lineHeight; // Find first line number\n      // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n\n      var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n      var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n      var endLineNumber = this._lineCount | 0; // Also keep track of what whitespace we've got\n\n      var whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n      var whitespaceCount = this.getWhitespacesCount() | 0;\n      var currentWhitespaceHeight;\n      var currentWhitespaceAfterLineNumber;\n\n      if (whitespaceIndex === -1) {\n        whitespaceIndex = whitespaceCount;\n        currentWhitespaceAfterLineNumber = endLineNumber + 1;\n        currentWhitespaceHeight = 0;\n      } else {\n        currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n        currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n      }\n\n      var currentVerticalOffset = startLineNumberVerticalOffset;\n      var currentLineRelativeOffset = currentVerticalOffset; // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n\n      var STEP_SIZE = 500000;\n      var bigNumbersDelta = 0;\n\n      if (startLineNumberVerticalOffset >= STEP_SIZE) {\n        // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n        bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n        bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n        currentLineRelativeOffset -= bigNumbersDelta;\n      }\n\n      var linesOffsets = [];\n      var verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n      var centeredLineNumber = -1; // Figure out how far the lines go\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        if (centeredLineNumber === -1) {\n          var currentLineTop = currentVerticalOffset;\n          var currentLineBottom = currentVerticalOffset + lineHeight;\n\n          if (currentLineTop <= verticalCenter && verticalCenter < currentLineBottom || currentLineTop > verticalCenter) {\n            centeredLineNumber = lineNumber;\n          }\n        } // Count current line height in the vertical offsets\n\n\n        currentVerticalOffset += lineHeight;\n        linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset; // Next line starts immediately after this one\n\n        currentLineRelativeOffset += lineHeight;\n\n        while (currentWhitespaceAfterLineNumber === lineNumber) {\n          // Push down next line with the height of the current whitespace\n          currentLineRelativeOffset += currentWhitespaceHeight; // Count current whitespace in the vertical offsets\n\n          currentVerticalOffset += currentWhitespaceHeight;\n          whitespaceIndex++;\n\n          if (whitespaceIndex >= whitespaceCount) {\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n          } else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n          }\n        }\n\n        if (currentVerticalOffset >= verticalOffset2) {\n          // We have covered the entire viewport area, time to stop\n          endLineNumber = lineNumber;\n          break;\n        }\n      }\n\n      if (centeredLineNumber === -1) {\n        centeredLineNumber = endLineNumber;\n      }\n\n      var endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n      var completelyVisibleStartLineNumber = startLineNumber;\n      var completelyVisibleEndLineNumber = endLineNumber;\n\n      if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n        if (startLineNumberVerticalOffset < verticalOffset1) {\n          completelyVisibleStartLineNumber++;\n        }\n      }\n\n      if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n        if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n          completelyVisibleEndLineNumber--;\n        }\n      }\n\n      return {\n        bigNumbersDelta: bigNumbersDelta,\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        relativeVerticalOffset: linesOffsets,\n        centeredLineNumber: centeredLineNumber,\n        completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n        completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n      };\n    }\n  }, {\n    key: \"getVerticalOffsetForWhitespaceIndex\",\n    value: function getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n      this._checkPendingChanges();\n\n      whitespaceIndex = whitespaceIndex | 0;\n      var afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n      var previousLinesHeight;\n\n      if (afterLineNumber >= 1) {\n        previousLinesHeight = this._lineHeight * afterLineNumber;\n      } else {\n        previousLinesHeight = 0;\n      }\n\n      var previousWhitespacesHeight;\n\n      if (whitespaceIndex > 0) {\n        previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n      } else {\n        previousWhitespacesHeight = 0;\n      }\n\n      return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n  }, {\n    key: \"getWhitespaceIndexAtOrAfterVerticallOffset\",\n    value: function getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n      this._checkPendingChanges();\n\n      verticalOffset = verticalOffset | 0;\n      var minWhitespaceIndex = 0;\n      var maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n\n      if (maxWhitespaceIndex < 0) {\n        return -1;\n      } // Special case: nothing to be found\n\n\n      var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n      var maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n\n      if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n        return -1;\n      }\n\n      while (minWhitespaceIndex < maxWhitespaceIndex) {\n        var midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n        var midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n        var midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n\n        if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n          // vertical offset is after whitespace\n          minWhitespaceIndex = midWhitespaceIndex + 1;\n        } else if (verticalOffset >= midWhitespaceVerticalOffset) {\n          // Hit\n          return midWhitespaceIndex;\n        } else {\n          // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n          maxWhitespaceIndex = midWhitespaceIndex;\n        }\n      }\n\n      return minWhitespaceIndex;\n    }\n    /**\r\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\r\n     *\r\n     * @param verticalOffset The vertical offset.\r\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\r\n     */\n\n  }, {\n    key: \"getWhitespaceAtVerticalOffset\",\n    value: function getWhitespaceAtVerticalOffset(verticalOffset) {\n      this._checkPendingChanges();\n\n      verticalOffset = verticalOffset | 0;\n      var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n\n      if (candidateIndex < 0) {\n        return null;\n      }\n\n      if (candidateIndex >= this.getWhitespacesCount()) {\n        return null;\n      }\n\n      var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n\n      if (candidateTop > verticalOffset) {\n        return null;\n      }\n\n      var candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n      var candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n      var candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n      return {\n        id: candidateId,\n        afterLineNumber: candidateAfterLineNumber,\n        verticalOffset: candidateTop,\n        height: candidateHeight\n      };\n    }\n    /**\r\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\r\n     *\r\n     * @param verticalOffset1 The beginning of the viewport.\r\n     * @param verticalOffset2 The end of the viewport.\r\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\r\n     */\n\n  }, {\n    key: \"getWhitespaceViewportData\",\n    value: function getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n      this._checkPendingChanges();\n\n      verticalOffset1 = verticalOffset1 | 0;\n      verticalOffset2 = verticalOffset2 | 0;\n      var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n      var endIndex = this.getWhitespacesCount() - 1;\n\n      if (startIndex < 0) {\n        return [];\n      }\n\n      var result = [];\n\n      for (var i = startIndex; i <= endIndex; i++) {\n        var top = this.getVerticalOffsetForWhitespaceIndex(i);\n        var height = this.getHeightForWhitespaceIndex(i);\n\n        if (top >= verticalOffset2) {\n          break;\n        }\n\n        result.push({\n          id: this.getIdForWhitespaceIndex(i),\n          afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n          verticalOffset: top,\n          height: height\n        });\n      }\n\n      return result;\n    }\n    /**\r\n     * Get all whitespaces.\r\n     */\n\n  }, {\n    key: \"getWhitespaces\",\n    value: function getWhitespaces() {\n      this._checkPendingChanges();\n\n      return this._arr.slice(0);\n    }\n    /**\r\n     * The number of whitespaces.\r\n     */\n\n  }, {\n    key: \"getWhitespacesCount\",\n    value: function getWhitespacesCount() {\n      this._checkPendingChanges();\n\n      return this._arr.length;\n    }\n    /**\r\n     * Get the `id` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `id` of whitespace at `index`.\r\n     */\n\n  }, {\n    key: \"getIdForWhitespaceIndex\",\n    value: function getIdForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n\n      index = index | 0;\n      return this._arr[index].id;\n    }\n    /**\r\n     * Get the `afterLineNumber` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `afterLineNumber` of whitespace at `index`.\r\n     */\n\n  }, {\n    key: \"getAfterLineNumberForWhitespaceIndex\",\n    value: function getAfterLineNumberForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n\n      index = index | 0;\n      return this._arr[index].afterLineNumber;\n    }\n    /**\r\n     * Get the `height` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `height` of whitespace at `index`.\r\n     */\n\n  }, {\n    key: \"getHeightForWhitespaceIndex\",\n    value: function getHeightForWhitespaceIndex(index) {\n      this._checkPendingChanges();\n\n      index = index | 0;\n      return this._arr[index].height;\n    }\n  }], [{\n    key: \"findInsertionIndex\",\n    value: function findInsertionIndex(arr, afterLineNumber, ordinal) {\n      var low = 0;\n      var high = arr.length;\n\n      while (low < high) {\n        var mid = low + high >>> 1;\n\n        if (afterLineNumber === arr[mid].afterLineNumber) {\n          if (ordinal < arr[mid].ordinal) {\n            high = mid;\n          } else {\n            low = mid + 1;\n          }\n        } else if (afterLineNumber < arr[mid].afterLineNumber) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n\n      return low;\n    }\n  }]);\n\n  return LinesLayout;\n}();\nLinesLayout.INSTANCE_COUNT = 0;","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js"],"names":["strings","PendingChanges","_hasPending","_inserts","_changes","_removes","x","push","linesLayout","inserts","changes","removes","_commitPendingChanges","EditorWhitespace","id","afterLineNumber","ordinal","height","minWidth","prefixSum","LinesLayout","lineCount","lineHeight","paddingTop","paddingBottom","_instanceId","singleLetterHash","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_lineHeight","_paddingTop","_paddingBottom","_checkPendingChanges","callback","hadAChange","accessor","insertWhitespace","heightInPx","insert","changeOneWhitespace","newAfterLineNumber","newHeight","change","removeWhitespace","remove","commit","length","_insertWhitespace","_changeOneWhitespace","index","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","Map","set","applyRemoveAndChange","whitespaces","result","whitespace","has","get","concat","sort","a","b","mustCommit","insertIndex","findInsertionIndex","splice","Math","min","arr","i","len","removeIndex","fromLineNumber","toLineNumber","getWhitespacesAccumulatedHeight","startIndex","max","linesHeight","whitespacesHeight","getWhitespacesTotalHeight","lineNumber","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","low","high","delta","halfDelta","mid","firstWhitespaceAfterLineNumber","_findFirstWhitespaceAfterLineNumber","previousLinesHeight","previousWhitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","verticalOffset","totalHeight","getLinesTotalHeight","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getVerticalOffsetForLineNumber","verticalOffset1","verticalOffset2","startLineNumber","getLineNumberAtOrAfterVerticalOffset","startLineNumberVerticalOffset","endLineNumber","whitespaceIndex","getFirstWhitespaceIndexAfterLineNumber","whitespaceCount","getWhitespacesCount","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","bigNumbersDelta","floor","linesOffsets","verticalCenter","centeredLineNumber","currentLineTop","currentLineBottom","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","relativeVerticalOffset","minWhitespaceIndex","maxWhitespaceIndex","maxWhitespaceVerticalOffset","getVerticalOffsetForWhitespaceIndex","maxWhitespaceHeight","midWhitespaceIndex","midWhitespaceVerticalOffset","midWhitespaceHeight","candidateIndex","getWhitespaceIndexAtOrAfterVerticallOffset","candidateTop","candidateHeight","candidateId","getIdForWhitespaceIndex","candidateAfterLineNumber","endIndex","top","slice"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nclass PendingChanges {\r\n    constructor() {\r\n        this._hasPending = false;\r\n        this._inserts = [];\r\n        this._changes = [];\r\n        this._removes = [];\r\n    }\r\n    insert(x) {\r\n        this._hasPending = true;\r\n        this._inserts.push(x);\r\n    }\r\n    change(x) {\r\n        this._hasPending = true;\r\n        this._changes.push(x);\r\n    }\r\n    remove(x) {\r\n        this._hasPending = true;\r\n        this._removes.push(x);\r\n    }\r\n    mustCommit() {\r\n        return this._hasPending;\r\n    }\r\n    commit(linesLayout) {\r\n        if (!this._hasPending) {\r\n            return;\r\n        }\r\n        const inserts = this._inserts;\r\n        const changes = this._changes;\r\n        const removes = this._removes;\r\n        this._hasPending = false;\r\n        this._inserts = [];\r\n        this._changes = [];\r\n        this._removes = [];\r\n        linesLayout._commitPendingChanges(inserts, changes, removes);\r\n    }\r\n}\r\nexport class EditorWhitespace {\r\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\r\n        this.id = id;\r\n        this.afterLineNumber = afterLineNumber;\r\n        this.ordinal = ordinal;\r\n        this.height = height;\r\n        this.minWidth = minWidth;\r\n        this.prefixSum = 0;\r\n    }\r\n}\r\n/**\r\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\r\n *\r\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\r\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\r\n */\r\nexport class LinesLayout {\r\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\r\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\r\n        this._pendingChanges = new PendingChanges();\r\n        this._lastWhitespaceId = 0;\r\n        this._arr = [];\r\n        this._prefixSumValidIndex = -1;\r\n        this._minWidth = -1; /* marker for not being computed */\r\n        this._lineCount = lineCount;\r\n        this._lineHeight = lineHeight;\r\n        this._paddingTop = paddingTop;\r\n        this._paddingBottom = paddingBottom;\r\n    }\r\n    /**\r\n     * Find the insertion index for a new value inside a sorted array of values.\r\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\r\n     */\r\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\r\n        let low = 0;\r\n        let high = arr.length;\r\n        while (low < high) {\r\n            const mid = ((low + high) >>> 1);\r\n            if (afterLineNumber === arr[mid].afterLineNumber) {\r\n                if (ordinal < arr[mid].ordinal) {\r\n                    high = mid;\r\n                }\r\n                else {\r\n                    low = mid + 1;\r\n                }\r\n            }\r\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n    /**\r\n     * Change the height of a line in pixels.\r\n     */\r\n    setLineHeight(lineHeight) {\r\n        this._checkPendingChanges();\r\n        this._lineHeight = lineHeight;\r\n    }\r\n    /**\r\n     * Changes the padding used to calculate vertical offsets.\r\n     */\r\n    setPadding(paddingTop, paddingBottom) {\r\n        this._paddingTop = paddingTop;\r\n        this._paddingBottom = paddingBottom;\r\n    }\r\n    /**\r\n     * Set the number of lines.\r\n     *\r\n     * @param lineCount New number of lines.\r\n     */\r\n    onFlushed(lineCount) {\r\n        this._checkPendingChanges();\r\n        this._lineCount = lineCount;\r\n    }\r\n    changeWhitespace(callback) {\r\n        let hadAChange = false;\r\n        try {\r\n            const accessor = {\r\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\r\n                    hadAChange = true;\r\n                    afterLineNumber = afterLineNumber | 0;\r\n                    ordinal = ordinal | 0;\r\n                    heightInPx = heightInPx | 0;\r\n                    minWidth = minWidth | 0;\r\n                    const id = this._instanceId + (++this._lastWhitespaceId);\r\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\r\n                    return id;\r\n                },\r\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\r\n                    hadAChange = true;\r\n                    newAfterLineNumber = newAfterLineNumber | 0;\r\n                    newHeight = newHeight | 0;\r\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\r\n                },\r\n                removeWhitespace: (id) => {\r\n                    hadAChange = true;\r\n                    this._pendingChanges.remove({ id });\r\n                }\r\n            };\r\n            callback(accessor);\r\n        }\r\n        finally {\r\n            this._pendingChanges.commit(this);\r\n        }\r\n        return hadAChange;\r\n    }\r\n    _commitPendingChanges(inserts, changes, removes) {\r\n        if (inserts.length > 0 || removes.length > 0) {\r\n            this._minWidth = -1; /* marker for not being computed */\r\n        }\r\n        if (inserts.length + changes.length + removes.length <= 1) {\r\n            // when only one thing happened, handle it \"delicately\"\r\n            for (const insert of inserts) {\r\n                this._insertWhitespace(insert);\r\n            }\r\n            for (const change of changes) {\r\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\r\n            }\r\n            for (const remove of removes) {\r\n                const index = this._findWhitespaceIndex(remove.id);\r\n                if (index === -1) {\r\n                    continue;\r\n                }\r\n                this._removeWhitespace(index);\r\n            }\r\n            return;\r\n        }\r\n        // simply rebuild the entire datastructure\r\n        const toRemove = new Set();\r\n        for (const remove of removes) {\r\n            toRemove.add(remove.id);\r\n        }\r\n        const toChange = new Map();\r\n        for (const change of changes) {\r\n            toChange.set(change.id, change);\r\n        }\r\n        const applyRemoveAndChange = (whitespaces) => {\r\n            let result = [];\r\n            for (const whitespace of whitespaces) {\r\n                if (toRemove.has(whitespace.id)) {\r\n                    continue;\r\n                }\r\n                if (toChange.has(whitespace.id)) {\r\n                    const change = toChange.get(whitespace.id);\r\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\r\n                    whitespace.height = change.newHeight;\r\n                }\r\n                result.push(whitespace);\r\n            }\r\n            return result;\r\n        };\r\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\r\n        result.sort((a, b) => {\r\n            if (a.afterLineNumber === b.afterLineNumber) {\r\n                return a.ordinal - b.ordinal;\r\n            }\r\n            return a.afterLineNumber - b.afterLineNumber;\r\n        });\r\n        this._arr = result;\r\n        this._prefixSumValidIndex = -1;\r\n    }\r\n    _checkPendingChanges() {\r\n        if (this._pendingChanges.mustCommit()) {\r\n            this._pendingChanges.commit(this);\r\n        }\r\n    }\r\n    _insertWhitespace(whitespace) {\r\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\r\n        this._arr.splice(insertIndex, 0, whitespace);\r\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\r\n    }\r\n    _findWhitespaceIndex(id) {\r\n        const arr = this._arr;\r\n        for (let i = 0, len = arr.length; i < len; i++) {\r\n            if (arr[i].id === id) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\r\n        const index = this._findWhitespaceIndex(id);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        if (this._arr[index].height !== newHeight) {\r\n            this._arr[index].height = newHeight;\r\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\r\n        }\r\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\r\n            // `afterLineNumber` changed for this whitespace\r\n            // Record old whitespace\r\n            const whitespace = this._arr[index];\r\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\r\n            this._removeWhitespace(index);\r\n            whitespace.afterLineNumber = newAfterLineNumber;\r\n            // And add it again\r\n            this._insertWhitespace(whitespace);\r\n        }\r\n    }\r\n    _removeWhitespace(removeIndex) {\r\n        this._arr.splice(removeIndex, 1);\r\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\r\n    }\r\n    /**\r\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\r\n     *\r\n     * @param fromLineNumber The line number at which the deletion started, inclusive\r\n     * @param toLineNumber The line number at which the deletion ended, inclusive\r\n     */\r\n    onLinesDeleted(fromLineNumber, toLineNumber) {\r\n        this._checkPendingChanges();\r\n        fromLineNumber = fromLineNumber | 0;\r\n        toLineNumber = toLineNumber | 0;\r\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\r\n        for (let i = 0, len = this._arr.length; i < len; i++) {\r\n            const afterLineNumber = this._arr[i].afterLineNumber;\r\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\r\n                // The line this whitespace was after has been deleted\r\n                //  => move whitespace to before first deleted line\r\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\r\n            }\r\n            else if (afterLineNumber > toLineNumber) {\r\n                // The line this whitespace was after has been moved up\r\n                //  => move whitespace up\r\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\r\n     *\r\n     * @param fromLineNumber The line number at which the insertion started, inclusive\r\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\r\n     */\r\n    onLinesInserted(fromLineNumber, toLineNumber) {\r\n        this._checkPendingChanges();\r\n        fromLineNumber = fromLineNumber | 0;\r\n        toLineNumber = toLineNumber | 0;\r\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\r\n        for (let i = 0, len = this._arr.length; i < len; i++) {\r\n            const afterLineNumber = this._arr[i].afterLineNumber;\r\n            if (fromLineNumber <= afterLineNumber) {\r\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get the sum of all the whitespaces.\r\n     */\r\n    getWhitespacesTotalHeight() {\r\n        this._checkPendingChanges();\r\n        if (this._arr.length === 0) {\r\n            return 0;\r\n        }\r\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\r\n    }\r\n    /**\r\n     * Return the sum of the heights of the whitespaces at [0..index].\r\n     * This includes the whitespace at `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\r\n     */\r\n    getWhitespacesAccumulatedHeight(index) {\r\n        this._checkPendingChanges();\r\n        index = index | 0;\r\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\r\n        if (startIndex === 0) {\r\n            this._arr[0].prefixSum = this._arr[0].height;\r\n            startIndex++;\r\n        }\r\n        for (let i = startIndex; i <= index; i++) {\r\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\r\n        }\r\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\r\n        return this._arr[index].prefixSum;\r\n    }\r\n    /**\r\n     * Get the sum of heights for all objects.\r\n     *\r\n     * @return The sum of heights for all objects.\r\n     */\r\n    getLinesTotalHeight() {\r\n        this._checkPendingChanges();\r\n        const linesHeight = this._lineHeight * this._lineCount;\r\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\r\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\r\n    }\r\n    /**\r\n     * Returns the accumulated height of whitespaces before the given line number.\r\n     *\r\n     * @param lineNumber The line number\r\n     */\r\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\r\n        this._checkPendingChanges();\r\n        lineNumber = lineNumber | 0;\r\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\r\n        if (lastWhitespaceBeforeLineNumber === -1) {\r\n            return 0;\r\n        }\r\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\r\n    }\r\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\r\n        lineNumber = lineNumber | 0;\r\n        // Find the whitespace before line number\r\n        const arr = this._arr;\r\n        let low = 0;\r\n        let high = arr.length - 1;\r\n        while (low <= high) {\r\n            const delta = (high - low) | 0;\r\n            const halfDelta = (delta / 2) | 0;\r\n            const mid = (low + halfDelta) | 0;\r\n            if (arr[mid].afterLineNumber < lineNumber) {\r\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\r\n                    return mid;\r\n                }\r\n                else {\r\n                    low = (mid + 1) | 0;\r\n                }\r\n            }\r\n            else {\r\n                high = (mid - 1) | 0;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\r\n        lineNumber = lineNumber | 0;\r\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\r\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\r\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\r\n            return firstWhitespaceAfterLineNumber;\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\r\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\r\n     */\r\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\r\n        this._checkPendingChanges();\r\n        lineNumber = lineNumber | 0;\r\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\r\n    }\r\n    /**\r\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\r\n     *\r\n     * @param lineNumber The line number\r\n     * @return The sum of heights for all objects above `lineNumber`.\r\n     */\r\n    getVerticalOffsetForLineNumber(lineNumber) {\r\n        this._checkPendingChanges();\r\n        lineNumber = lineNumber | 0;\r\n        let previousLinesHeight;\r\n        if (lineNumber > 1) {\r\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\r\n        }\r\n        else {\r\n            previousLinesHeight = 0;\r\n        }\r\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\r\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\r\n    }\r\n    /**\r\n     * The maximum min width for all whitespaces.\r\n     */\r\n    getWhitespaceMinWidth() {\r\n        this._checkPendingChanges();\r\n        if (this._minWidth === -1) {\r\n            let minWidth = 0;\r\n            for (let i = 0, len = this._arr.length; i < len; i++) {\r\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\r\n            }\r\n            this._minWidth = minWidth;\r\n        }\r\n        return this._minWidth;\r\n    }\r\n    /**\r\n     * Check if `verticalOffset` is below all lines.\r\n     */\r\n    isAfterLines(verticalOffset) {\r\n        this._checkPendingChanges();\r\n        const totalHeight = this.getLinesTotalHeight();\r\n        return verticalOffset > totalHeight;\r\n    }\r\n    isInTopPadding(verticalOffset) {\r\n        if (this._paddingTop === 0) {\r\n            return false;\r\n        }\r\n        this._checkPendingChanges();\r\n        return (verticalOffset < this._paddingTop);\r\n    }\r\n    isInBottomPadding(verticalOffset) {\r\n        if (this._paddingBottom === 0) {\r\n            return false;\r\n        }\r\n        this._checkPendingChanges();\r\n        const totalHeight = this.getLinesTotalHeight();\r\n        return (verticalOffset >= totalHeight - this._paddingBottom);\r\n    }\r\n    /**\r\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\r\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\r\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\r\n     *\r\n     * @param verticalOffset The vertical offset to search at.\r\n     * @return The line number at or after vertical offset `verticalOffset`.\r\n     */\r\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\r\n        this._checkPendingChanges();\r\n        verticalOffset = verticalOffset | 0;\r\n        if (verticalOffset < 0) {\r\n            return 1;\r\n        }\r\n        const linesCount = this._lineCount | 0;\r\n        const lineHeight = this._lineHeight;\r\n        let minLineNumber = 1;\r\n        let maxLineNumber = linesCount;\r\n        while (minLineNumber < maxLineNumber) {\r\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\r\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\r\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\r\n                // vertical offset is after mid line number\r\n                minLineNumber = midLineNumber + 1;\r\n            }\r\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\r\n                // Hit\r\n                return midLineNumber;\r\n            }\r\n            else {\r\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\r\n                maxLineNumber = midLineNumber;\r\n            }\r\n        }\r\n        if (minLineNumber > linesCount) {\r\n            return linesCount;\r\n        }\r\n        return minLineNumber;\r\n    }\r\n    /**\r\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\r\n     *\r\n     * @param verticalOffset1 The beginning of the viewport.\r\n     * @param verticalOffset2 The end of the viewport.\r\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\r\n     */\r\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\r\n        this._checkPendingChanges();\r\n        verticalOffset1 = verticalOffset1 | 0;\r\n        verticalOffset2 = verticalOffset2 | 0;\r\n        const lineHeight = this._lineHeight;\r\n        // Find first line number\r\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\r\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\r\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\r\n        let endLineNumber = this._lineCount | 0;\r\n        // Also keep track of what whitespace we've got\r\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\r\n        const whitespaceCount = this.getWhitespacesCount() | 0;\r\n        let currentWhitespaceHeight;\r\n        let currentWhitespaceAfterLineNumber;\r\n        if (whitespaceIndex === -1) {\r\n            whitespaceIndex = whitespaceCount;\r\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\r\n            currentWhitespaceHeight = 0;\r\n        }\r\n        else {\r\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\r\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\r\n        }\r\n        let currentVerticalOffset = startLineNumberVerticalOffset;\r\n        let currentLineRelativeOffset = currentVerticalOffset;\r\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\r\n        const STEP_SIZE = 500000;\r\n        let bigNumbersDelta = 0;\r\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\r\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\r\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\r\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\r\n            currentLineRelativeOffset -= bigNumbersDelta;\r\n        }\r\n        const linesOffsets = [];\r\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\r\n        let centeredLineNumber = -1;\r\n        // Figure out how far the lines go\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            if (centeredLineNumber === -1) {\r\n                const currentLineTop = currentVerticalOffset;\r\n                const currentLineBottom = currentVerticalOffset + lineHeight;\r\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\r\n                    centeredLineNumber = lineNumber;\r\n                }\r\n            }\r\n            // Count current line height in the vertical offsets\r\n            currentVerticalOffset += lineHeight;\r\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\r\n            // Next line starts immediately after this one\r\n            currentLineRelativeOffset += lineHeight;\r\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\r\n                // Push down next line with the height of the current whitespace\r\n                currentLineRelativeOffset += currentWhitespaceHeight;\r\n                // Count current whitespace in the vertical offsets\r\n                currentVerticalOffset += currentWhitespaceHeight;\r\n                whitespaceIndex++;\r\n                if (whitespaceIndex >= whitespaceCount) {\r\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\r\n                }\r\n                else {\r\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\r\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\r\n                }\r\n            }\r\n            if (currentVerticalOffset >= verticalOffset2) {\r\n                // We have covered the entire viewport area, time to stop\r\n                endLineNumber = lineNumber;\r\n                break;\r\n            }\r\n        }\r\n        if (centeredLineNumber === -1) {\r\n            centeredLineNumber = endLineNumber;\r\n        }\r\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\r\n        let completelyVisibleStartLineNumber = startLineNumber;\r\n        let completelyVisibleEndLineNumber = endLineNumber;\r\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\r\n            if (startLineNumberVerticalOffset < verticalOffset1) {\r\n                completelyVisibleStartLineNumber++;\r\n            }\r\n        }\r\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\r\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\r\n                completelyVisibleEndLineNumber--;\r\n            }\r\n        }\r\n        return {\r\n            bigNumbersDelta: bigNumbersDelta,\r\n            startLineNumber: startLineNumber,\r\n            endLineNumber: endLineNumber,\r\n            relativeVerticalOffset: linesOffsets,\r\n            centeredLineNumber: centeredLineNumber,\r\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\r\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\r\n        };\r\n    }\r\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\r\n        this._checkPendingChanges();\r\n        whitespaceIndex = whitespaceIndex | 0;\r\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\r\n        let previousLinesHeight;\r\n        if (afterLineNumber >= 1) {\r\n            previousLinesHeight = this._lineHeight * afterLineNumber;\r\n        }\r\n        else {\r\n            previousLinesHeight = 0;\r\n        }\r\n        let previousWhitespacesHeight;\r\n        if (whitespaceIndex > 0) {\r\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\r\n        }\r\n        else {\r\n            previousWhitespacesHeight = 0;\r\n        }\r\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\r\n    }\r\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\r\n        this._checkPendingChanges();\r\n        verticalOffset = verticalOffset | 0;\r\n        let minWhitespaceIndex = 0;\r\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\r\n        if (maxWhitespaceIndex < 0) {\r\n            return -1;\r\n        }\r\n        // Special case: nothing to be found\r\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\r\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\r\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\r\n            return -1;\r\n        }\r\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\r\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\r\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\r\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\r\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\r\n                // vertical offset is after whitespace\r\n                minWhitespaceIndex = midWhitespaceIndex + 1;\r\n            }\r\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\r\n                // Hit\r\n                return midWhitespaceIndex;\r\n            }\r\n            else {\r\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\r\n                maxWhitespaceIndex = midWhitespaceIndex;\r\n            }\r\n        }\r\n        return minWhitespaceIndex;\r\n    }\r\n    /**\r\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\r\n     *\r\n     * @param verticalOffset The vertical offset.\r\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\r\n     */\r\n    getWhitespaceAtVerticalOffset(verticalOffset) {\r\n        this._checkPendingChanges();\r\n        verticalOffset = verticalOffset | 0;\r\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\r\n        if (candidateIndex < 0) {\r\n            return null;\r\n        }\r\n        if (candidateIndex >= this.getWhitespacesCount()) {\r\n            return null;\r\n        }\r\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\r\n        if (candidateTop > verticalOffset) {\r\n            return null;\r\n        }\r\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\r\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\r\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\r\n        return {\r\n            id: candidateId,\r\n            afterLineNumber: candidateAfterLineNumber,\r\n            verticalOffset: candidateTop,\r\n            height: candidateHeight\r\n        };\r\n    }\r\n    /**\r\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\r\n     *\r\n     * @param verticalOffset1 The beginning of the viewport.\r\n     * @param verticalOffset2 The end of the viewport.\r\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\r\n     */\r\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\r\n        this._checkPendingChanges();\r\n        verticalOffset1 = verticalOffset1 | 0;\r\n        verticalOffset2 = verticalOffset2 | 0;\r\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\r\n        const endIndex = this.getWhitespacesCount() - 1;\r\n        if (startIndex < 0) {\r\n            return [];\r\n        }\r\n        let result = [];\r\n        for (let i = startIndex; i <= endIndex; i++) {\r\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\r\n            const height = this.getHeightForWhitespaceIndex(i);\r\n            if (top >= verticalOffset2) {\r\n                break;\r\n            }\r\n            result.push({\r\n                id: this.getIdForWhitespaceIndex(i),\r\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\r\n                verticalOffset: top,\r\n                height: height\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Get all whitespaces.\r\n     */\r\n    getWhitespaces() {\r\n        this._checkPendingChanges();\r\n        return this._arr.slice(0);\r\n    }\r\n    /**\r\n     * The number of whitespaces.\r\n     */\r\n    getWhitespacesCount() {\r\n        this._checkPendingChanges();\r\n        return this._arr.length;\r\n    }\r\n    /**\r\n     * Get the `id` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `id` of whitespace at `index`.\r\n     */\r\n    getIdForWhitespaceIndex(index) {\r\n        this._checkPendingChanges();\r\n        index = index | 0;\r\n        return this._arr[index].id;\r\n    }\r\n    /**\r\n     * Get the `afterLineNumber` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `afterLineNumber` of whitespace at `index`.\r\n     */\r\n    getAfterLineNumberForWhitespaceIndex(index) {\r\n        this._checkPendingChanges();\r\n        index = index | 0;\r\n        return this._arr[index].afterLineNumber;\r\n    }\r\n    /**\r\n     * Get the `height` for whitespace at index `index`.\r\n     *\r\n     * @param index The index of the whitespace.\r\n     * @return `height` of whitespace at `index`.\r\n     */\r\n    getHeightForWhitespaceIndex(index) {\r\n        this._checkPendingChanges();\r\n        index = index | 0;\r\n        return this._arr[index].height;\r\n    }\r\n}\r\nLinesLayout.INSTANCE_COUNT = 0;\r\n"]},"metadata":{},"sourceType":"module"}