{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\nimport { dispose as _dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\n/**\r\n * A snapshot of the cursor and the model state\r\n */\n\nexport var CursorModelState = /*#__PURE__*/function () {\n  function CursorModelState(model, cursor) {\n    _classCallCheck(this, CursorModelState);\n\n    this.modelVersionId = model.getVersionId();\n    this.cursorState = cursor.getCursorStates();\n  }\n\n  _createClass(CursorModelState, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (!other) {\n        return false;\n      }\n\n      if (this.modelVersionId !== other.modelVersionId) {\n        return false;\n      }\n\n      if (this.cursorState.length !== other.cursorState.length) {\n        return false;\n      }\n\n      for (var i = 0, len = this.cursorState.length; i < len; i++) {\n        if (!this.cursorState[i].equals(other.cursorState[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return CursorModelState;\n}();\n\nvar AutoClosedAction = /*#__PURE__*/function () {\n  function AutoClosedAction(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n    _classCallCheck(this, AutoClosedAction);\n\n    this._model = model;\n    this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n    this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n  }\n\n  _createClass(AutoClosedAction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n      this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n  }, {\n    key: \"getAutoClosedCharactersRanges\",\n    value: function getAutoClosedCharactersRanges() {\n      var result = [];\n\n      for (var i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n        var decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n\n        if (decorationRange) {\n          result.push(decorationRange);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid(selections) {\n      var enclosingRanges = [];\n\n      for (var i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n        var decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n\n        if (decorationRange) {\n          enclosingRanges.push(decorationRange);\n\n          if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n            // Stop tracking if the range becomes multiline...\n            return false;\n          }\n        }\n      }\n\n      enclosingRanges.sort(Range.compareRangesUsingStarts);\n      selections.sort(Range.compareRangesUsingStarts);\n\n      for (var _i = 0; _i < selections.length; _i++) {\n        if (_i >= enclosingRanges.length) {\n          return false;\n        }\n\n        if (!enclosingRanges[_i].strictContainsRange(selections[_i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"getAllAutoClosedCharacters\",\n    value: function getAllAutoClosedCharacters(autoClosedActions) {\n      var autoClosedCharacters = [];\n\n      var _iterator = _createForOfIteratorHelper(autoClosedActions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var autoClosedAction = _step.value;\n          autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return autoClosedCharacters;\n    }\n  }]);\n\n  return AutoClosedAction;\n}();\n\nexport var Cursor = /*#__PURE__*/function (_Disposable) {\n  _inherits(Cursor, _Disposable);\n\n  var _super = _createSuper(Cursor);\n\n  function Cursor(model, viewModel, coordinatesConverter, cursorConfig) {\n    var _this;\n\n    _classCallCheck(this, Cursor);\n\n    _this = _super.call(this);\n    _this._model = model;\n    _this._knownModelVersionId = _this._model.getVersionId();\n    _this._viewModel = viewModel;\n    _this._coordinatesConverter = coordinatesConverter;\n    _this.context = new CursorContext(_this._model, _this._coordinatesConverter, cursorConfig);\n    _this._cursors = new CursorCollection(_this.context);\n    _this._hasFocus = false;\n    _this._isHandling = false;\n    _this._isDoingComposition = false;\n    _this._selectionsWhenCompositionStarted = null;\n    _this._columnSelectData = null;\n    _this._autoClosedActions = [];\n    _this._prevEditOperationType = 0\n    /* Other */\n    ;\n    return _this;\n  }\n\n  _createClass(Cursor, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._cursors.dispose();\n\n      this._autoClosedActions = _dispose(this._autoClosedActions);\n\n      _get(_getPrototypeOf(Cursor.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"updateConfiguration\",\n    value: function updateConfiguration(cursorConfig) {\n      this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\n\n      this._cursors.updateContext(this.context);\n    }\n  }, {\n    key: \"onLineMappingChanged\",\n    value: function onLineMappingChanged(eventsCollector) {\n      if (this._knownModelVersionId !== this._model.getVersionId()) {\n        // There are model change events that I didn't yet receive.\n        //\n        // This can happen when editing the model, and the view model receives the change events first,\n        // and the view model emits line mapping changed events, all before the cursor gets a chance to\n        // recover from markers.\n        //\n        // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n        return;\n      } // Ensure valid state\n\n\n      this.setStates(eventsCollector, 'viewModel', 0\n      /* NotSet */\n      , this.getCursorStates());\n    }\n  }, {\n    key: \"setHasFocus\",\n    value: function setHasFocus(hasFocus) {\n      this._hasFocus = hasFocus;\n    }\n  }, {\n    key: \"_validateAutoClosedActions\",\n    value: function _validateAutoClosedActions() {\n      if (this._autoClosedActions.length > 0) {\n        var selections = this._cursors.getSelections();\n\n        for (var i = 0; i < this._autoClosedActions.length; i++) {\n          var autoClosedAction = this._autoClosedActions[i];\n\n          if (!autoClosedAction.isValid(selections)) {\n            autoClosedAction.dispose();\n\n            this._autoClosedActions.splice(i, 1);\n\n            i--;\n          }\n        }\n      }\n    } // ------ some getters/setters\n\n  }, {\n    key: \"getPrimaryCursorState\",\n    value: function getPrimaryCursorState() {\n      return this._cursors.getPrimaryCursor();\n    }\n  }, {\n    key: \"getLastAddedCursorIndex\",\n    value: function getLastAddedCursorIndex() {\n      return this._cursors.getLastAddedCursorIndex();\n    }\n  }, {\n    key: \"getCursorStates\",\n    value: function getCursorStates() {\n      return this._cursors.getAll();\n    }\n  }, {\n    key: \"setStates\",\n    value: function setStates(eventsCollector, source, reason, states) {\n      var reachedMaxCursorCount = false;\n\n      if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\n        states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\n        reachedMaxCursorCount = true;\n      }\n\n      var oldState = new CursorModelState(this._model, this);\n\n      this._cursors.setStates(states);\n\n      this._cursors.normalize();\n\n      this._columnSelectData = null;\n\n      this._validateAutoClosedActions();\n\n      return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n  }, {\n    key: \"setCursorColumnSelectData\",\n    value: function setCursorColumnSelectData(columnSelectData) {\n      this._columnSelectData = columnSelectData;\n    }\n  }, {\n    key: \"revealPrimary\",\n    value: function revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\n      var viewPositions = this._cursors.getViewPositions();\n\n      if (viewPositions.length > 1) {\n        this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0\n        /* Simple */\n        , revealHorizontal, scrollType);\n\n        return;\n      } else {\n        var viewPosition = viewPositions[0];\n        var viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n        this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0\n        /* Simple */\n        , revealHorizontal, scrollType);\n      }\n    }\n  }, {\n    key: \"_revealPrimaryCursor\",\n    value: function _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\n      var viewPositions = this._cursors.getViewPositions();\n\n      if (viewPositions.length > 1) {\n        this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\n      } else {\n        var viewPosition = viewPositions[0];\n        var viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n\n        this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\n      }\n    }\n  }, {\n    key: \"_emitCursorRevealRange\",\n    value: function _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\n      eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\n    }\n  }, {\n    key: \"saveState\",\n    value: function saveState() {\n      var result = [];\n\n      var selections = this._cursors.getSelections();\n\n      for (var i = 0, len = selections.length; i < len; i++) {\n        var selection = selections[i];\n        result.push({\n          inSelectionMode: !selection.isEmpty(),\n          selectionStart: {\n            lineNumber: selection.selectionStartLineNumber,\n            column: selection.selectionStartColumn\n          },\n          position: {\n            lineNumber: selection.positionLineNumber,\n            column: selection.positionColumn\n          }\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"restoreState\",\n    value: function restoreState(eventsCollector, states) {\n      var desiredSelections = [];\n\n      for (var i = 0, len = states.length; i < len; i++) {\n        var state = states[i];\n        var positionLineNumber = 1;\n        var positionColumn = 1; // Avoid missing properties on the literal\n\n        if (state.position && state.position.lineNumber) {\n          positionLineNumber = state.position.lineNumber;\n        }\n\n        if (state.position && state.position.column) {\n          positionColumn = state.position.column;\n        }\n\n        var selectionStartLineNumber = positionLineNumber;\n        var selectionStartColumn = positionColumn; // Avoid missing properties on the literal\n\n        if (state.selectionStart && state.selectionStart.lineNumber) {\n          selectionStartLineNumber = state.selectionStart.lineNumber;\n        }\n\n        if (state.selectionStart && state.selectionStart.column) {\n          selectionStartColumn = state.selectionStart.column;\n        }\n\n        desiredSelections.push({\n          selectionStartLineNumber: selectionStartLineNumber,\n          selectionStartColumn: selectionStartColumn,\n          positionLineNumber: positionLineNumber,\n          positionColumn: positionColumn\n        });\n      }\n\n      this.setStates(eventsCollector, 'restoreState', 0\n      /* NotSet */\n      , CursorState.fromModelSelections(desiredSelections));\n      this.revealPrimary(eventsCollector, 'restoreState', true, 1\n      /* Immediate */\n      );\n    }\n  }, {\n    key: \"onModelContentChanged\",\n    value: function onModelContentChanged(eventsCollector, e) {\n      this._knownModelVersionId = e.versionId;\n\n      if (this._isHandling) {\n        return;\n      }\n\n      var hadFlushEvent = e.containsEvent(1\n      /* Flush */\n      );\n      this._prevEditOperationType = 0\n      /* Other */\n      ;\n\n      if (hadFlushEvent) {\n        // a model.setValue() was called\n        this._cursors.dispose();\n\n        this._cursors = new CursorCollection(this.context);\n\n        this._validateAutoClosedActions();\n\n        this._emitStateChangedIfNecessary(eventsCollector, 'model', 1\n        /* ContentFlush */\n        , null, false);\n      } else {\n        if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n          var cursorState = CursorState.fromModelSelections(e.resultingSelection);\n\n          if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5\n          /* Undo */\n          : e.isRedoing ? 6\n          /* Redo */\n          : 2\n          /* RecoverFromMarkers */\n          , cursorState)) {\n            this._revealPrimaryCursor(eventsCollector, 'modelChange', 0\n            /* Simple */\n            , true, 0\n            /* Smooth */\n            );\n          }\n        } else {\n          var selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n\n          this.setStates(eventsCollector, 'modelChange', 2\n          /* RecoverFromMarkers */\n          , CursorState.fromModelSelections(selectionsFromMarkers));\n        }\n      }\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n  }, {\n    key: \"getTopMostViewPosition\",\n    value: function getTopMostViewPosition() {\n      return this._cursors.getTopMostViewPosition();\n    }\n  }, {\n    key: \"getBottomMostViewPosition\",\n    value: function getBottomMostViewPosition() {\n      return this._cursors.getBottomMostViewPosition();\n    }\n  }, {\n    key: \"getCursorColumnSelectData\",\n    value: function getCursorColumnSelectData() {\n      if (this._columnSelectData) {\n        return this._columnSelectData;\n      }\n\n      var primaryCursor = this._cursors.getPrimaryCursor();\n\n      var viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n      var viewPosition = primaryCursor.viewState.position;\n      return {\n        isReal: false,\n        fromViewLineNumber: viewSelectionStart.lineNumber,\n        fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\n        toViewLineNumber: viewPosition.lineNumber,\n        toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition)\n      };\n    }\n  }, {\n    key: \"getSelections\",\n    value: function getSelections() {\n      return this._cursors.getSelections();\n    }\n  }, {\n    key: \"setSelections\",\n    value: function setSelections(eventsCollector, source, selections, reason) {\n      this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n  }, {\n    key: \"getPrevEditOperationType\",\n    value: function getPrevEditOperationType() {\n      return this._prevEditOperationType;\n    }\n  }, {\n    key: \"setPrevEditOperationType\",\n    value: function setPrevEditOperationType(type) {\n      this._prevEditOperationType = type;\n    } // ------ auxiliary handling logic\n\n  }, {\n    key: \"_pushAutoClosedAction\",\n    value: function _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n      var autoClosedCharactersDeltaDecorations = [];\n      var autoClosedEnclosingDeltaDecorations = [];\n\n      for (var i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n        autoClosedCharactersDeltaDecorations.push({\n          range: autoClosedCharactersRanges[i],\n          options: {\n            inlineClassName: 'auto-closed-character',\n            stickiness: 1\n            /* NeverGrowsWhenTypingAtEdges */\n\n          }\n        });\n        autoClosedEnclosingDeltaDecorations.push({\n          range: autoClosedEnclosingRanges[i],\n          options: {\n            stickiness: 1\n            /* NeverGrowsWhenTypingAtEdges */\n\n          }\n        });\n      }\n\n      var autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n\n      var autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n\n      this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n  }, {\n    key: \"_executeEditOperation\",\n    value: function _executeEditOperation(opResult) {\n      if (!opResult) {\n        // Nothing to execute\n        return;\n      }\n\n      if (opResult.shouldPushStackElementBefore) {\n        this._model.pushStackElement();\n      }\n\n      var result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n\n      if (result) {\n        // The commands were applied correctly\n        this._interpretCommandResult(result); // Check for auto-closing closed characters\n\n\n        var autoClosedCharactersRanges = [];\n        var autoClosedEnclosingRanges = [];\n\n        for (var i = 0; i < opResult.commands.length; i++) {\n          var command = opResult.commands[i];\n\n          if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n            autoClosedCharactersRanges.push(command.closeCharacterRange);\n            autoClosedEnclosingRanges.push(command.enclosingRange);\n          }\n        }\n\n        if (autoClosedCharactersRanges.length > 0) {\n          this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n\n        this._prevEditOperationType = opResult.type;\n      }\n\n      if (opResult.shouldPushStackElementAfter) {\n        this._model.pushStackElement();\n      }\n    }\n  }, {\n    key: \"_interpretCommandResult\",\n    value: function _interpretCommandResult(cursorState) {\n      if (!cursorState || cursorState.length === 0) {\n        cursorState = this._cursors.readSelectionFromMarkers();\n      }\n\n      this._columnSelectData = null;\n\n      this._cursors.setSelections(cursorState);\n\n      this._cursors.normalize();\n    } // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n\n  }, {\n    key: \"_emitStateChangedIfNecessary\",\n    value: function _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n      var newState = new CursorModelState(this._model, this);\n\n      if (newState.equals(oldState)) {\n        return false;\n      }\n\n      var selections = this._cursors.getSelections();\n\n      var viewSelections = this._cursors.getViewSelections(); // Let the view get the event first.\n\n\n      eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections)); // Only after the view has been notified, let the rest of the world know...\n\n      if (!oldState || oldState.cursorState.length !== newState.cursorState.length || newState.cursorState.some(function (newCursorState, i) {\n        return !newCursorState.modelState.equals(oldState.cursorState[i].modelState);\n      })) {\n        var oldSelections = oldState ? oldState.cursorState.map(function (s) {\n          return s.modelState.selection;\n        }) : null;\n        var oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n        eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n      }\n\n      return true;\n    } // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n\n  }, {\n    key: \"_findAutoClosingPairs\",\n    value: function _findAutoClosingPairs(edits) {\n      if (!edits.length) {\n        return null;\n      }\n\n      var indices = [];\n\n      for (var i = 0, len = edits.length; i < len; i++) {\n        var edit = edits[i];\n\n        if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n          return null;\n        }\n\n        var m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n\n        if (!m) {\n          return null;\n        }\n\n        var closeChar = m[1];\n        var autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n\n        if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n          return null;\n        }\n\n        var openChar = autoClosingPairsCandidates[0].open;\n        var closeCharIndex = edit.text.length - m[2].length - 1;\n        var openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n\n        if (openCharIndex === -1) {\n          return null;\n        }\n\n        indices.push([openCharIndex, closeCharIndex]);\n      }\n\n      return indices;\n    }\n  }, {\n    key: \"executeEdits\",\n    value: function executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n      var _this2 = this;\n\n      var autoClosingIndices = null;\n\n      if (source === 'snippet') {\n        autoClosingIndices = this._findAutoClosingPairs(edits);\n      }\n\n      if (autoClosingIndices) {\n        edits[0]._isTracked = true;\n      }\n\n      var autoClosedCharactersRanges = [];\n      var autoClosedEnclosingRanges = [];\n\n      var selections = this._model.pushEditOperations(this.getSelections(), edits, function (undoEdits) {\n        if (autoClosingIndices) {\n          for (var i = 0, len = autoClosingIndices.length; i < len; i++) {\n            var _autoClosingIndices$i = _slicedToArray(autoClosingIndices[i], 2),\n                openCharInnerIndex = _autoClosingIndices$i[0],\n                closeCharInnerIndex = _autoClosingIndices$i[1];\n\n            var undoEdit = undoEdits[i];\n            var lineNumber = undoEdit.range.startLineNumber;\n            var openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n            var closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n            autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n            autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n          }\n        }\n\n        var selections = cursorStateComputer(undoEdits);\n\n        if (selections) {\n          // Don't recover the selection from markers because\n          // we know what it should be.\n          _this2._isHandling = true;\n        }\n\n        return selections;\n      });\n\n      if (selections) {\n        this._isHandling = false;\n        this.setSelections(eventsCollector, source, selections, 0\n        /* NotSet */\n        );\n      }\n\n      if (autoClosedCharactersRanges.length > 0) {\n        this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n      }\n    }\n  }, {\n    key: \"_executeEdit\",\n    value: function _executeEdit(callback, eventsCollector, source)\n    /* NotSet */\n    {\n      var cursorChangeReason = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n      if (this.context.cursorConfig.readOnly) {\n        // we cannot edit when read only...\n        return;\n      }\n\n      var oldState = new CursorModelState(this._model, this);\n\n      this._cursors.stopTrackingSelections();\n\n      this._isHandling = true;\n\n      try {\n        this._cursors.ensureValidState();\n\n        callback();\n      } catch (err) {\n        onUnexpectedError(err);\n      }\n\n      this._isHandling = false;\n\n      this._cursors.startTrackingSelections();\n\n      this._validateAutoClosedActions();\n\n      if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n        this._revealPrimaryCursor(eventsCollector, source, 0\n        /* Simple */\n        , true, 0\n        /* Smooth */\n        );\n      }\n    }\n  }, {\n    key: \"setIsDoingComposition\",\n    value: function setIsDoingComposition(isDoingComposition) {\n      this._isDoingComposition = isDoingComposition;\n    }\n  }, {\n    key: \"startComposition\",\n    value: function startComposition(eventsCollector) {\n      this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n    }\n  }, {\n    key: \"endComposition\",\n    value: function endComposition(eventsCollector, source) {\n      var _this3 = this;\n\n      this._executeEdit(function () {\n        if (source === 'keyboard') {\n          // composition finishes, let's check if we need to auto complete if necessary.\n          var autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(_this3._autoClosedActions);\n\n          _this3._executeEditOperation(TypeOperations.compositionEndWithInterceptors(_this3._prevEditOperationType, _this3.context.cursorConfig, _this3._model, _this3._selectionsWhenCompositionStarted, _this3.getSelections(), autoClosedCharacters));\n\n          _this3._selectionsWhenCompositionStarted = null;\n        }\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"type\",\n    value: function type(eventsCollector, text, source) {\n      var _this4 = this;\n\n      this._executeEdit(function () {\n        if (source === 'keyboard') {\n          // If this event is coming straight from the keyboard, look for electric characters and enter\n          var len = text.length;\n          var offset = 0;\n\n          while (offset < len) {\n            var charLength = strings.nextCharLength(text, offset);\n            var chr = text.substr(offset, charLength); // Here we must interpret each typed character individually\n\n            var autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(_this4._autoClosedActions);\n\n            _this4._executeEditOperation(TypeOperations.typeWithInterceptors(_this4._isDoingComposition, _this4._prevEditOperationType, _this4.context.cursorConfig, _this4._model, _this4.getSelections(), autoClosedCharacters, chr));\n\n            offset += charLength;\n          }\n        } else {\n          _this4._executeEditOperation(TypeOperations.typeWithoutInterceptors(_this4._prevEditOperationType, _this4.context.cursorConfig, _this4._model, _this4.getSelections(), text));\n        }\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"replacePreviousChar\",\n    value: function replacePreviousChar(eventsCollector, text, replaceCharCnt, source) {\n      var _this5 = this;\n\n      this._executeEdit(function () {\n        _this5._executeEditOperation(TypeOperations.replacePreviousChar(_this5._prevEditOperationType, _this5.context.cursorConfig, _this5._model, _this5.getSelections(), text, replaceCharCnt));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"paste\",\n    value: function paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n      var _this6 = this;\n\n      this._executeEdit(function () {\n        _this6._executeEditOperation(TypeOperations.paste(_this6.context.cursorConfig, _this6._model, _this6.getSelections(), text, pasteOnNewLine, multicursorText || []));\n      }, eventsCollector, source, 4\n      /* Paste */\n      );\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(eventsCollector, source) {\n      var _this7 = this;\n\n      this._executeEdit(function () {\n        _this7._executeEditOperation(DeleteOperations.cut(_this7.context.cursorConfig, _this7._model, _this7.getSelections()));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(eventsCollector, command, source) {\n      var _this8 = this;\n\n      this._executeEdit(function () {\n        _this8._cursors.killSecondaryCursors();\n\n        _this8._executeEditOperation(new EditOperationResult(0\n        /* Other */\n        , [command], {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: false\n        }));\n      }, eventsCollector, source);\n    }\n  }, {\n    key: \"executeCommands\",\n    value: function executeCommands(eventsCollector, commands, source) {\n      var _this9 = this;\n\n      this._executeEdit(function () {\n        _this9._executeEditOperation(new EditOperationResult(0\n        /* Other */\n        , commands, {\n          shouldPushStackElementBefore: false,\n          shouldPushStackElementAfter: false\n        }));\n      }, eventsCollector, source);\n    }\n  }]);\n\n  return Cursor;\n}(Disposable);\nCursor.MAX_CURSOR_COUNT = 10000;\n\nvar CommandExecutor = /*#__PURE__*/function () {\n  function CommandExecutor() {\n    _classCallCheck(this, CommandExecutor);\n  }\n\n  _createClass(CommandExecutor, null, [{\n    key: \"executeCommands\",\n    value: function executeCommands(model, selectionsBefore, commands) {\n      var ctx = {\n        model: model,\n        selectionsBefore: selectionsBefore,\n        trackedRanges: [],\n        trackedRangesDirection: []\n      };\n\n      var result = this._innerExecuteCommands(ctx, commands);\n\n      for (var i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n        ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0\n        /* AlwaysGrowsWhenTypingAtEdges */\n        );\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_innerExecuteCommands\",\n    value: function _innerExecuteCommands(ctx, commands) {\n      if (this._arrayIsEmpty(commands)) {\n        return null;\n      }\n\n      var commandsData = this._getEditOperations(ctx, commands);\n\n      if (commandsData.operations.length === 0) {\n        return null;\n      }\n\n      var rawOperations = commandsData.operations;\n\n      var loserCursorsMap = this._getLoserCursorMap(rawOperations);\n\n      if (loserCursorsMap.hasOwnProperty('0')) {\n        // These commands are very messed up\n        console.warn('Ignoring commands');\n        return null;\n      } // Remove operations belonging to losing cursors\n\n\n      var filteredOperations = [];\n\n      for (var i = 0, len = rawOperations.length; i < len; i++) {\n        if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n          filteredOperations.push(rawOperations[i]);\n        }\n      } // TODO@Alex: find a better way to do this.\n      // give the hint that edit operations are tracked to the model\n\n\n      if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n        filteredOperations[0]._isTracked = true;\n      }\n\n      var selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, function (inverseEditOperations) {\n        var groupedInverseEditOperations = [];\n\n        for (var _i2 = 0; _i2 < ctx.selectionsBefore.length; _i2++) {\n          groupedInverseEditOperations[_i2] = [];\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(inverseEditOperations),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var op = _step2.value;\n\n            if (!op.identifier) {\n              // perhaps auto whitespace trim edits\n              continue;\n            }\n\n            groupedInverseEditOperations[op.identifier.major].push(op);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var minorBasedSorter = function minorBasedSorter(a, b) {\n          return a.identifier.minor - b.identifier.minor;\n        };\n\n        var cursorSelections = [];\n\n        var _loop = function _loop(_i3) {\n          if (groupedInverseEditOperations[_i3].length > 0) {\n            groupedInverseEditOperations[_i3].sort(minorBasedSorter);\n\n            cursorSelections[_i3] = commands[_i3].computeCursorState(ctx.model, {\n              getInverseEditOperations: function getInverseEditOperations() {\n                return groupedInverseEditOperations[_i3];\n              },\n              getTrackedSelection: function getTrackedSelection(id) {\n                var idx = parseInt(id, 10);\n\n                var range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n\n                if (ctx.trackedRangesDirection[idx] === 0\n                /* LTR */\n                ) {\n                    return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                  }\n\n                return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n              }\n            });\n          } else {\n            cursorSelections[_i3] = ctx.selectionsBefore[_i3];\n          }\n        };\n\n        for (var _i3 = 0; _i3 < ctx.selectionsBefore.length; _i3++) {\n          _loop(_i3);\n        }\n\n        return cursorSelections;\n      });\n\n      if (!selectionsAfter) {\n        selectionsAfter = ctx.selectionsBefore;\n      } // Extract losing cursors\n\n\n      var losingCursors = [];\n\n      for (var losingCursorIndex in loserCursorsMap) {\n        if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n          losingCursors.push(parseInt(losingCursorIndex, 10));\n        }\n      } // Sort losing cursors descending\n\n\n      losingCursors.sort(function (a, b) {\n        return b - a;\n      }); // Remove losing cursors\n\n      for (var _i4 = 0, _losingCursors = losingCursors; _i4 < _losingCursors.length; _i4++) {\n        var losingCursor = _losingCursors[_i4];\n        selectionsAfter.splice(losingCursor, 1);\n      }\n\n      return selectionsAfter;\n    }\n  }, {\n    key: \"_arrayIsEmpty\",\n    value: function _arrayIsEmpty(commands) {\n      for (var i = 0, len = commands.length; i < len; i++) {\n        if (commands[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_getEditOperations\",\n    value: function _getEditOperations(ctx, commands) {\n      var operations = [];\n      var hadTrackedEditOperation = false;\n\n      for (var i = 0, len = commands.length; i < len; i++) {\n        var command = commands[i];\n\n        if (command) {\n          var r = this._getEditOperationsFromCommand(ctx, i, command);\n\n          operations = operations.concat(r.operations);\n          hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n        }\n      }\n\n      return {\n        operations: operations,\n        hadTrackedEditOperation: hadTrackedEditOperation\n      };\n    }\n  }, {\n    key: \"_getEditOperationsFromCommand\",\n    value: function _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n      // This method acts as a transaction, if the command fails\n      // everything it has done is ignored\n      var operations = [];\n      var operationMinor = 0;\n\n      var addEditOperation = function addEditOperation(range, text) {\n        var forceMoveMarkers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (Range.isEmpty(range) && text === '') {\n          // This command wants to add a no-op => no thank you\n          return;\n        }\n\n        operations.push({\n          identifier: {\n            major: majorIdentifier,\n            minor: operationMinor++\n          },\n          range: range,\n          text: text,\n          forceMoveMarkers: forceMoveMarkers,\n          isAutoWhitespaceEdit: command.insertsAutoWhitespace\n        });\n      };\n\n      var hadTrackedEditOperation = false;\n\n      var addTrackedEditOperation = function addTrackedEditOperation(selection, text, forceMoveMarkers) {\n        hadTrackedEditOperation = true;\n        addEditOperation(selection, text, forceMoveMarkers);\n      };\n\n      var trackSelection = function trackSelection(_selection, trackPreviousOnEmpty) {\n        var selection = Selection.liftSelection(_selection);\n        var stickiness;\n\n        if (selection.isEmpty()) {\n          if (typeof trackPreviousOnEmpty === 'boolean') {\n            if (trackPreviousOnEmpty) {\n              stickiness = 2\n              /* GrowsOnlyWhenTypingBefore */\n              ;\n            } else {\n              stickiness = 3\n              /* GrowsOnlyWhenTypingAfter */\n              ;\n            }\n          } else {\n            // Try to lock it with surrounding text\n            var maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n\n            if (selection.startColumn === maxLineColumn) {\n              stickiness = 2\n              /* GrowsOnlyWhenTypingBefore */\n              ;\n            } else {\n              stickiness = 3\n              /* GrowsOnlyWhenTypingAfter */\n              ;\n            }\n          }\n        } else {\n          stickiness = 1\n          /* NeverGrowsWhenTypingAtEdges */\n          ;\n        }\n\n        var l = ctx.trackedRanges.length;\n\n        var id = ctx.model._setTrackedRange(null, selection, stickiness);\n\n        ctx.trackedRanges[l] = id;\n        ctx.trackedRangesDirection[l] = selection.getDirection();\n        return l.toString();\n      };\n\n      var editOperationBuilder = {\n        addEditOperation: addEditOperation,\n        addTrackedEditOperation: addTrackedEditOperation,\n        trackSelection: trackSelection\n      };\n\n      try {\n        command.getEditOperations(ctx.model, editOperationBuilder);\n      } catch (e) {\n        // TODO@Alex use notification service if this should be user facing\n        // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n        onUnexpectedError(e);\n        return {\n          operations: [],\n          hadTrackedEditOperation: false\n        };\n      }\n\n      return {\n        operations: operations,\n        hadTrackedEditOperation: hadTrackedEditOperation\n      };\n    }\n  }, {\n    key: \"_getLoserCursorMap\",\n    value: function _getLoserCursorMap(operations) {\n      // This is destructive on the array\n      operations = operations.slice(0); // Sort operations with last one first\n\n      operations.sort(function (a, b) {\n        // Note the minus!\n        return -Range.compareRangesUsingEnds(a.range, b.range);\n      }); // Operations can not overlap!\n\n      var loserCursorsMap = {};\n\n      for (var i = 1; i < operations.length; i++) {\n        var previousOp = operations[i - 1];\n        var currentOp = operations[i];\n\n        if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n          var loserMajor = void 0;\n\n          if (previousOp.identifier.major > currentOp.identifier.major) {\n            // previousOp loses the battle\n            loserMajor = previousOp.identifier.major;\n          } else {\n            loserMajor = currentOp.identifier.major;\n          }\n\n          loserCursorsMap[loserMajor.toString()] = true;\n\n          for (var j = 0; j < operations.length; j++) {\n            if (operations[j].identifier.major === loserMajor) {\n              operations.splice(j, 1);\n\n              if (j < i) {\n                i--;\n              }\n\n              j--;\n            }\n          }\n\n          if (i > 0) {\n            i--;\n          }\n        }\n      }\n\n      return loserCursorsMap;\n    }\n  }]);\n\n  return CommandExecutor;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/controller/cursor.js"],"names":["onUnexpectedError","strings","CursorCollection","CursorColumns","CursorContext","CursorState","EditOperationResult","DeleteOperations","TypeOperations","TypeWithAutoClosingCommand","Range","Selection","ViewCursorStateChangedEvent","ViewRevealRangeRequestEvent","dispose","Disposable","CursorStateChangedEvent","CursorModelState","model","cursor","modelVersionId","getVersionId","cursorState","getCursorStates","other","length","i","len","equals","AutoClosedAction","autoClosedCharactersDecorations","autoClosedEnclosingDecorations","_model","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","deltaDecorations","result","decorationRange","getDecorationRange","push","selections","enclosingRanges","startLineNumber","endLineNumber","sort","compareRangesUsingStarts","strictContainsRange","autoClosedActions","autoClosedCharacters","autoClosedAction","concat","getAutoClosedCharactersRanges","Cursor","viewModel","coordinatesConverter","cursorConfig","_knownModelVersionId","_viewModel","_coordinatesConverter","context","_cursors","_hasFocus","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateContext","eventsCollector","setStates","hasFocus","getSelections","isValid","splice","getPrimaryCursor","getLastAddedCursorIndex","getAll","source","reason","states","reachedMaxCursorCount","MAX_CURSOR_COUNT","slice","oldState","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","revealHorizontal","scrollType","viewPositions","getViewPositions","_emitCursorRevealRange","getViewSelections","viewPosition","viewRange","lineNumber","column","verticalType","viewSelections","emitViewEvent","selection","inSelectionMode","isEmpty","selectionStart","selectionStartLineNumber","selectionStartColumn","position","positionLineNumber","positionColumn","desiredSelections","state","fromModelSelections","revealPrimary","e","versionId","hadFlushEvent","containsEvent","resultingSelection","isUndoing","isRedoing","_revealPrimaryCursor","selectionsFromMarkers","readSelectionFromMarkers","modelState","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","viewSelectionStart","viewState","getStartPosition","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn2","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","range","options","inlineClassName","stickiness","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","some","newCursorState","oldSelections","map","s","oldModelVersionId","emitOutgoingEvent","edits","indices","edit","text","indexOf","m","match","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","get","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","startColumn","callback","cursorChangeReason","readOnly","stopTrackingSelections","ensureValidState","err","startTrackingSelections","isDoingComposition","_executeEdit","getAllAutoClosedCharacters","_executeEditOperation","compositionEndWithInterceptors","offset","charLength","nextCharLength","chr","substr","typeWithInterceptors","typeWithoutInterceptors","replaceCharCnt","replacePreviousChar","pasteOnNewLine","multicursorText","paste","cut","killSecondaryCursors","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_setTrackedRange","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","hasOwnProperty","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","a","b","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","_getTrackedRange","endColumn","losingCursors","losingCursorIndex","losingCursor","r","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","forceMoveMarkers","isAutoWhitespaceEdit","insertsAutoWhitespace","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getDirection","editOperationBuilder","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","isBefore","getEndPosition","loserMajor","j"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { CursorCollection } from './cursorCollection.js';\r\nimport { CursorColumns, CursorContext, CursorState, EditOperationResult } from './cursorCommon.js';\r\nimport { DeleteOperations } from './cursorDeleteOperations.js';\r\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../view/viewEvents.js';\r\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\r\nimport { CursorStateChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\r\n/**\r\n * A snapshot of the cursor and the model state\r\n */\r\nexport class CursorModelState {\r\n    constructor(model, cursor) {\r\n        this.modelVersionId = model.getVersionId();\r\n        this.cursorState = cursor.getCursorStates();\r\n    }\r\n    equals(other) {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        if (this.modelVersionId !== other.modelVersionId) {\r\n            return false;\r\n        }\r\n        if (this.cursorState.length !== other.cursorState.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\r\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nclass AutoClosedAction {\r\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\r\n        this._model = model;\r\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\r\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\r\n    }\r\n    static getAllAutoClosedCharacters(autoClosedActions) {\r\n        let autoClosedCharacters = [];\r\n        for (const autoClosedAction of autoClosedActions) {\r\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\r\n        }\r\n        return autoClosedCharacters;\r\n    }\r\n    dispose() {\r\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\r\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\r\n    }\r\n    getAutoClosedCharactersRanges() {\r\n        let result = [];\r\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\r\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\r\n            if (decorationRange) {\r\n                result.push(decorationRange);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    isValid(selections) {\r\n        let enclosingRanges = [];\r\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\r\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\r\n            if (decorationRange) {\r\n                enclosingRanges.push(decorationRange);\r\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\r\n                    // Stop tracking if the range becomes multiline...\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\r\n        selections.sort(Range.compareRangesUsingStarts);\r\n        for (let i = 0; i < selections.length; i++) {\r\n            if (i >= enclosingRanges.length) {\r\n                return false;\r\n            }\r\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport class Cursor extends Disposable {\r\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\r\n        super();\r\n        this._model = model;\r\n        this._knownModelVersionId = this._model.getVersionId();\r\n        this._viewModel = viewModel;\r\n        this._coordinatesConverter = coordinatesConverter;\r\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\r\n        this._cursors = new CursorCollection(this.context);\r\n        this._hasFocus = false;\r\n        this._isHandling = false;\r\n        this._isDoingComposition = false;\r\n        this._selectionsWhenCompositionStarted = null;\r\n        this._columnSelectData = null;\r\n        this._autoClosedActions = [];\r\n        this._prevEditOperationType = 0 /* Other */;\r\n    }\r\n    dispose() {\r\n        this._cursors.dispose();\r\n        this._autoClosedActions = dispose(this._autoClosedActions);\r\n        super.dispose();\r\n    }\r\n    updateConfiguration(cursorConfig) {\r\n        this.context = new CursorContext(this._model, this._coordinatesConverter, cursorConfig);\r\n        this._cursors.updateContext(this.context);\r\n    }\r\n    onLineMappingChanged(eventsCollector) {\r\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\r\n            // There are model change events that I didn't yet receive.\r\n            //\r\n            // This can happen when editing the model, and the view model receives the change events first,\r\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\r\n            // recover from markers.\r\n            //\r\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\r\n            return;\r\n        }\r\n        // Ensure valid state\r\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\r\n    }\r\n    setHasFocus(hasFocus) {\r\n        this._hasFocus = hasFocus;\r\n    }\r\n    _validateAutoClosedActions() {\r\n        if (this._autoClosedActions.length > 0) {\r\n            let selections = this._cursors.getSelections();\r\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\r\n                const autoClosedAction = this._autoClosedActions[i];\r\n                if (!autoClosedAction.isValid(selections)) {\r\n                    autoClosedAction.dispose();\r\n                    this._autoClosedActions.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // ------ some getters/setters\r\n    getPrimaryCursorState() {\r\n        return this._cursors.getPrimaryCursor();\r\n    }\r\n    getLastAddedCursorIndex() {\r\n        return this._cursors.getLastAddedCursorIndex();\r\n    }\r\n    getCursorStates() {\r\n        return this._cursors.getAll();\r\n    }\r\n    setStates(eventsCollector, source, reason, states) {\r\n        let reachedMaxCursorCount = false;\r\n        if (states !== null && states.length > Cursor.MAX_CURSOR_COUNT) {\r\n            states = states.slice(0, Cursor.MAX_CURSOR_COUNT);\r\n            reachedMaxCursorCount = true;\r\n        }\r\n        const oldState = new CursorModelState(this._model, this);\r\n        this._cursors.setStates(states);\r\n        this._cursors.normalize();\r\n        this._columnSelectData = null;\r\n        this._validateAutoClosedActions();\r\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\r\n    }\r\n    setCursorColumnSelectData(columnSelectData) {\r\n        this._columnSelectData = columnSelectData;\r\n    }\r\n    revealPrimary(eventsCollector, source, revealHorizontal, scrollType) {\r\n        const viewPositions = this._cursors.getViewPositions();\r\n        if (viewPositions.length > 1) {\r\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), 0 /* Simple */, revealHorizontal, scrollType);\r\n            return;\r\n        }\r\n        else {\r\n            const viewPosition = viewPositions[0];\r\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, 0 /* Simple */, revealHorizontal, scrollType);\r\n        }\r\n    }\r\n    _revealPrimaryCursor(eventsCollector, source, verticalType, revealHorizontal, scrollType) {\r\n        const viewPositions = this._cursors.getViewPositions();\r\n        if (viewPositions.length > 1) {\r\n            this._emitCursorRevealRange(eventsCollector, source, null, this._cursors.getViewSelections(), verticalType, revealHorizontal, scrollType);\r\n        }\r\n        else {\r\n            const viewPosition = viewPositions[0];\r\n            const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\r\n            this._emitCursorRevealRange(eventsCollector, source, viewRange, null, verticalType, revealHorizontal, scrollType);\r\n        }\r\n    }\r\n    _emitCursorRevealRange(eventsCollector, source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType) {\r\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, viewRange, viewSelections, verticalType, revealHorizontal, scrollType));\r\n    }\r\n    saveState() {\r\n        let result = [];\r\n        const selections = this._cursors.getSelections();\r\n        for (let i = 0, len = selections.length; i < len; i++) {\r\n            const selection = selections[i];\r\n            result.push({\r\n                inSelectionMode: !selection.isEmpty(),\r\n                selectionStart: {\r\n                    lineNumber: selection.selectionStartLineNumber,\r\n                    column: selection.selectionStartColumn,\r\n                },\r\n                position: {\r\n                    lineNumber: selection.positionLineNumber,\r\n                    column: selection.positionColumn,\r\n                }\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    restoreState(eventsCollector, states) {\r\n        let desiredSelections = [];\r\n        for (let i = 0, len = states.length; i < len; i++) {\r\n            const state = states[i];\r\n            let positionLineNumber = 1;\r\n            let positionColumn = 1;\r\n            // Avoid missing properties on the literal\r\n            if (state.position && state.position.lineNumber) {\r\n                positionLineNumber = state.position.lineNumber;\r\n            }\r\n            if (state.position && state.position.column) {\r\n                positionColumn = state.position.column;\r\n            }\r\n            let selectionStartLineNumber = positionLineNumber;\r\n            let selectionStartColumn = positionColumn;\r\n            // Avoid missing properties on the literal\r\n            if (state.selectionStart && state.selectionStart.lineNumber) {\r\n                selectionStartLineNumber = state.selectionStart.lineNumber;\r\n            }\r\n            if (state.selectionStart && state.selectionStart.column) {\r\n                selectionStartColumn = state.selectionStart.column;\r\n            }\r\n            desiredSelections.push({\r\n                selectionStartLineNumber: selectionStartLineNumber,\r\n                selectionStartColumn: selectionStartColumn,\r\n                positionLineNumber: positionLineNumber,\r\n                positionColumn: positionColumn\r\n            });\r\n        }\r\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\r\n        this.revealPrimary(eventsCollector, 'restoreState', true, 1 /* Immediate */);\r\n    }\r\n    onModelContentChanged(eventsCollector, e) {\r\n        this._knownModelVersionId = e.versionId;\r\n        if (this._isHandling) {\r\n            return;\r\n        }\r\n        const hadFlushEvent = e.containsEvent(1 /* Flush */);\r\n        this._prevEditOperationType = 0 /* Other */;\r\n        if (hadFlushEvent) {\r\n            // a model.setValue() was called\r\n            this._cursors.dispose();\r\n            this._cursors = new CursorCollection(this.context);\r\n            this._validateAutoClosedActions();\r\n            this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\r\n        }\r\n        else {\r\n            if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\r\n                const cursorState = CursorState.fromModelSelections(e.resultingSelection);\r\n                if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\r\n                    this._revealPrimaryCursor(eventsCollector, 'modelChange', 0 /* Simple */, true, 0 /* Smooth */);\r\n                }\r\n            }\r\n            else {\r\n                const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\r\n                this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\r\n            }\r\n        }\r\n    }\r\n    getSelection() {\r\n        return this._cursors.getPrimaryCursor().modelState.selection;\r\n    }\r\n    getTopMostViewPosition() {\r\n        return this._cursors.getTopMostViewPosition();\r\n    }\r\n    getBottomMostViewPosition() {\r\n        return this._cursors.getBottomMostViewPosition();\r\n    }\r\n    getCursorColumnSelectData() {\r\n        if (this._columnSelectData) {\r\n            return this._columnSelectData;\r\n        }\r\n        const primaryCursor = this._cursors.getPrimaryCursor();\r\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\r\n        const viewPosition = primaryCursor.viewState.position;\r\n        return {\r\n            isReal: false,\r\n            fromViewLineNumber: viewSelectionStart.lineNumber,\r\n            fromViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewSelectionStart),\r\n            toViewLineNumber: viewPosition.lineNumber,\r\n            toViewVisualColumn: CursorColumns.visibleColumnFromColumn2(this.context.cursorConfig, this._viewModel, viewPosition),\r\n        };\r\n    }\r\n    getSelections() {\r\n        return this._cursors.getSelections();\r\n    }\r\n    setSelections(eventsCollector, source, selections, reason) {\r\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\r\n    }\r\n    getPrevEditOperationType() {\r\n        return this._prevEditOperationType;\r\n    }\r\n    setPrevEditOperationType(type) {\r\n        this._prevEditOperationType = type;\r\n    }\r\n    // ------ auxiliary handling logic\r\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\r\n        let autoClosedCharactersDeltaDecorations = [];\r\n        let autoClosedEnclosingDeltaDecorations = [];\r\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\r\n            autoClosedCharactersDeltaDecorations.push({\r\n                range: autoClosedCharactersRanges[i],\r\n                options: {\r\n                    inlineClassName: 'auto-closed-character',\r\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\r\n                }\r\n            });\r\n            autoClosedEnclosingDeltaDecorations.push({\r\n                range: autoClosedEnclosingRanges[i],\r\n                options: {\r\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\r\n                }\r\n            });\r\n        }\r\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\r\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\r\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\r\n    }\r\n    _executeEditOperation(opResult) {\r\n        if (!opResult) {\r\n            // Nothing to execute\r\n            return;\r\n        }\r\n        if (opResult.shouldPushStackElementBefore) {\r\n            this._model.pushStackElement();\r\n        }\r\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\r\n        if (result) {\r\n            // The commands were applied correctly\r\n            this._interpretCommandResult(result);\r\n            // Check for auto-closing closed characters\r\n            let autoClosedCharactersRanges = [];\r\n            let autoClosedEnclosingRanges = [];\r\n            for (let i = 0; i < opResult.commands.length; i++) {\r\n                const command = opResult.commands[i];\r\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\r\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\r\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\r\n                }\r\n            }\r\n            if (autoClosedCharactersRanges.length > 0) {\r\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\r\n            }\r\n            this._prevEditOperationType = opResult.type;\r\n        }\r\n        if (opResult.shouldPushStackElementAfter) {\r\n            this._model.pushStackElement();\r\n        }\r\n    }\r\n    _interpretCommandResult(cursorState) {\r\n        if (!cursorState || cursorState.length === 0) {\r\n            cursorState = this._cursors.readSelectionFromMarkers();\r\n        }\r\n        this._columnSelectData = null;\r\n        this._cursors.setSelections(cursorState);\r\n        this._cursors.normalize();\r\n    }\r\n    // -----------------------------------------------------------------------------------------------------------\r\n    // ----- emitting events\r\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\r\n        const newState = new CursorModelState(this._model, this);\r\n        if (newState.equals(oldState)) {\r\n            return false;\r\n        }\r\n        const selections = this._cursors.getSelections();\r\n        const viewSelections = this._cursors.getViewSelections();\r\n        // Let the view get the event first.\r\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\r\n        // Only after the view has been notified, let the rest of the world know...\r\n        if (!oldState\r\n            || oldState.cursorState.length !== newState.cursorState.length\r\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\r\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\r\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\r\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\r\n        }\r\n        return true;\r\n    }\r\n    // -----------------------------------------------------------------------------------------------------------\r\n    // ----- handlers beyond this point\r\n    _findAutoClosingPairs(edits) {\r\n        if (!edits.length) {\r\n            return null;\r\n        }\r\n        let indices = [];\r\n        for (let i = 0, len = edits.length; i < len; i++) {\r\n            const edit = edits[i];\r\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\r\n                return null;\r\n            }\r\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\r\n            if (!m) {\r\n                return null;\r\n            }\r\n            const closeChar = m[1];\r\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\r\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\r\n                return null;\r\n            }\r\n            const openChar = autoClosingPairsCandidates[0].open;\r\n            const closeCharIndex = edit.text.length - m[2].length - 1;\r\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\r\n            if (openCharIndex === -1) {\r\n                return null;\r\n            }\r\n            indices.push([openCharIndex, closeCharIndex]);\r\n        }\r\n        return indices;\r\n    }\r\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\r\n        let autoClosingIndices = null;\r\n        if (source === 'snippet') {\r\n            autoClosingIndices = this._findAutoClosingPairs(edits);\r\n        }\r\n        if (autoClosingIndices) {\r\n            edits[0]._isTracked = true;\r\n        }\r\n        let autoClosedCharactersRanges = [];\r\n        let autoClosedEnclosingRanges = [];\r\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\r\n            if (autoClosingIndices) {\r\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\r\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\r\n                    const undoEdit = undoEdits[i];\r\n                    const lineNumber = undoEdit.range.startLineNumber;\r\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\r\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\r\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\r\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\r\n                }\r\n            }\r\n            const selections = cursorStateComputer(undoEdits);\r\n            if (selections) {\r\n                // Don't recover the selection from markers because\r\n                // we know what it should be.\r\n                this._isHandling = true;\r\n            }\r\n            return selections;\r\n        });\r\n        if (selections) {\r\n            this._isHandling = false;\r\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\r\n        }\r\n        if (autoClosedCharactersRanges.length > 0) {\r\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\r\n        }\r\n    }\r\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\r\n        if (this.context.cursorConfig.readOnly) {\r\n            // we cannot edit when read only...\r\n            return;\r\n        }\r\n        const oldState = new CursorModelState(this._model, this);\r\n        this._cursors.stopTrackingSelections();\r\n        this._isHandling = true;\r\n        try {\r\n            this._cursors.ensureValidState();\r\n            callback();\r\n        }\r\n        catch (err) {\r\n            onUnexpectedError(err);\r\n        }\r\n        this._isHandling = false;\r\n        this._cursors.startTrackingSelections();\r\n        this._validateAutoClosedActions();\r\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\r\n            this._revealPrimaryCursor(eventsCollector, source, 0 /* Simple */, true, 0 /* Smooth */);\r\n        }\r\n    }\r\n    setIsDoingComposition(isDoingComposition) {\r\n        this._isDoingComposition = isDoingComposition;\r\n    }\r\n    startComposition(eventsCollector) {\r\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\r\n    }\r\n    endComposition(eventsCollector, source) {\r\n        this._executeEdit(() => {\r\n            if (source === 'keyboard') {\r\n                // composition finishes, let's check if we need to auto complete if necessary.\r\n                const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\r\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), autoClosedCharacters));\r\n                this._selectionsWhenCompositionStarted = null;\r\n            }\r\n        }, eventsCollector, source);\r\n    }\r\n    type(eventsCollector, text, source) {\r\n        this._executeEdit(() => {\r\n            if (source === 'keyboard') {\r\n                // If this event is coming straight from the keyboard, look for electric characters and enter\r\n                const len = text.length;\r\n                let offset = 0;\r\n                while (offset < len) {\r\n                    const charLength = strings.nextCharLength(text, offset);\r\n                    const chr = text.substr(offset, charLength);\r\n                    // Here we must interpret each typed character individually\r\n                    const autoClosedCharacters = AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\r\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), autoClosedCharacters, chr));\r\n                    offset += charLength;\r\n                }\r\n            }\r\n            else {\r\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\r\n            }\r\n        }, eventsCollector, source);\r\n    }\r\n    replacePreviousChar(eventsCollector, text, replaceCharCnt, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(TypeOperations.replacePreviousChar(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replaceCharCnt));\r\n        }, eventsCollector, source);\r\n    }\r\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\r\n        }, eventsCollector, source, 4 /* Paste */);\r\n    }\r\n    cut(eventsCollector, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\r\n        }, eventsCollector, source);\r\n    }\r\n    executeCommand(eventsCollector, command, source) {\r\n        this._executeEdit(() => {\r\n            this._cursors.killSecondaryCursors();\r\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\r\n                shouldPushStackElementBefore: false,\r\n                shouldPushStackElementAfter: false\r\n            }));\r\n        }, eventsCollector, source);\r\n    }\r\n    executeCommands(eventsCollector, commands, source) {\r\n        this._executeEdit(() => {\r\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\r\n                shouldPushStackElementBefore: false,\r\n                shouldPushStackElementAfter: false\r\n            }));\r\n        }, eventsCollector, source);\r\n    }\r\n}\r\nCursor.MAX_CURSOR_COUNT = 10000;\r\nclass CommandExecutor {\r\n    static executeCommands(model, selectionsBefore, commands) {\r\n        const ctx = {\r\n            model: model,\r\n            selectionsBefore: selectionsBefore,\r\n            trackedRanges: [],\r\n            trackedRangesDirection: []\r\n        };\r\n        const result = this._innerExecuteCommands(ctx, commands);\r\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\r\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\r\n        }\r\n        return result;\r\n    }\r\n    static _innerExecuteCommands(ctx, commands) {\r\n        if (this._arrayIsEmpty(commands)) {\r\n            return null;\r\n        }\r\n        const commandsData = this._getEditOperations(ctx, commands);\r\n        if (commandsData.operations.length === 0) {\r\n            return null;\r\n        }\r\n        const rawOperations = commandsData.operations;\r\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\r\n        if (loserCursorsMap.hasOwnProperty('0')) {\r\n            // These commands are very messed up\r\n            console.warn('Ignoring commands');\r\n            return null;\r\n        }\r\n        // Remove operations belonging to losing cursors\r\n        let filteredOperations = [];\r\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\r\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\r\n                filteredOperations.push(rawOperations[i]);\r\n            }\r\n        }\r\n        // TODO@Alex: find a better way to do this.\r\n        // give the hint that edit operations are tracked to the model\r\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\r\n            filteredOperations[0]._isTracked = true;\r\n        }\r\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\r\n            let groupedInverseEditOperations = [];\r\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\r\n                groupedInverseEditOperations[i] = [];\r\n            }\r\n            for (const op of inverseEditOperations) {\r\n                if (!op.identifier) {\r\n                    // perhaps auto whitespace trim edits\r\n                    continue;\r\n                }\r\n                groupedInverseEditOperations[op.identifier.major].push(op);\r\n            }\r\n            const minorBasedSorter = (a, b) => {\r\n                return a.identifier.minor - b.identifier.minor;\r\n            };\r\n            let cursorSelections = [];\r\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\r\n                if (groupedInverseEditOperations[i].length > 0) {\r\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\r\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\r\n                        getInverseEditOperations: () => {\r\n                            return groupedInverseEditOperations[i];\r\n                        },\r\n                        getTrackedSelection: (id) => {\r\n                            const idx = parseInt(id, 10);\r\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\r\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\r\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n                            }\r\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    cursorSelections[i] = ctx.selectionsBefore[i];\r\n                }\r\n            }\r\n            return cursorSelections;\r\n        });\r\n        if (!selectionsAfter) {\r\n            selectionsAfter = ctx.selectionsBefore;\r\n        }\r\n        // Extract losing cursors\r\n        let losingCursors = [];\r\n        for (let losingCursorIndex in loserCursorsMap) {\r\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\r\n                losingCursors.push(parseInt(losingCursorIndex, 10));\r\n            }\r\n        }\r\n        // Sort losing cursors descending\r\n        losingCursors.sort((a, b) => {\r\n            return b - a;\r\n        });\r\n        // Remove losing cursors\r\n        for (const losingCursor of losingCursors) {\r\n            selectionsAfter.splice(losingCursor, 1);\r\n        }\r\n        return selectionsAfter;\r\n    }\r\n    static _arrayIsEmpty(commands) {\r\n        for (let i = 0, len = commands.length; i < len; i++) {\r\n            if (commands[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    static _getEditOperations(ctx, commands) {\r\n        let operations = [];\r\n        let hadTrackedEditOperation = false;\r\n        for (let i = 0, len = commands.length; i < len; i++) {\r\n            const command = commands[i];\r\n            if (command) {\r\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\r\n                operations = operations.concat(r.operations);\r\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\r\n            }\r\n        }\r\n        return {\r\n            operations: operations,\r\n            hadTrackedEditOperation: hadTrackedEditOperation\r\n        };\r\n    }\r\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\r\n        // This method acts as a transaction, if the command fails\r\n        // everything it has done is ignored\r\n        let operations = [];\r\n        let operationMinor = 0;\r\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\r\n            if (Range.isEmpty(range) && text === '') {\r\n                // This command wants to add a no-op => no thank you\r\n                return;\r\n            }\r\n            operations.push({\r\n                identifier: {\r\n                    major: majorIdentifier,\r\n                    minor: operationMinor++\r\n                },\r\n                range: range,\r\n                text: text,\r\n                forceMoveMarkers: forceMoveMarkers,\r\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\r\n            });\r\n        };\r\n        let hadTrackedEditOperation = false;\r\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\r\n            hadTrackedEditOperation = true;\r\n            addEditOperation(selection, text, forceMoveMarkers);\r\n        };\r\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\r\n            const selection = Selection.liftSelection(_selection);\r\n            let stickiness;\r\n            if (selection.isEmpty()) {\r\n                if (typeof trackPreviousOnEmpty === 'boolean') {\r\n                    if (trackPreviousOnEmpty) {\r\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\r\n                    }\r\n                    else {\r\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\r\n                    }\r\n                }\r\n                else {\r\n                    // Try to lock it with surrounding text\r\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\r\n                    if (selection.startColumn === maxLineColumn) {\r\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\r\n                    }\r\n                    else {\r\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\r\n            }\r\n            const l = ctx.trackedRanges.length;\r\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\r\n            ctx.trackedRanges[l] = id;\r\n            ctx.trackedRangesDirection[l] = selection.getDirection();\r\n            return l.toString();\r\n        };\r\n        const editOperationBuilder = {\r\n            addEditOperation: addEditOperation,\r\n            addTrackedEditOperation: addTrackedEditOperation,\r\n            trackSelection: trackSelection\r\n        };\r\n        try {\r\n            command.getEditOperations(ctx.model, editOperationBuilder);\r\n        }\r\n        catch (e) {\r\n            // TODO@Alex use notification service if this should be user facing\r\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\r\n            onUnexpectedError(e);\r\n            return {\r\n                operations: [],\r\n                hadTrackedEditOperation: false\r\n            };\r\n        }\r\n        return {\r\n            operations: operations,\r\n            hadTrackedEditOperation: hadTrackedEditOperation\r\n        };\r\n    }\r\n    static _getLoserCursorMap(operations) {\r\n        // This is destructive on the array\r\n        operations = operations.slice(0);\r\n        // Sort operations with last one first\r\n        operations.sort((a, b) => {\r\n            // Note the minus!\r\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\r\n        });\r\n        // Operations can not overlap!\r\n        let loserCursorsMap = {};\r\n        for (let i = 1; i < operations.length; i++) {\r\n            const previousOp = operations[i - 1];\r\n            const currentOp = operations[i];\r\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\r\n                let loserMajor;\r\n                if (previousOp.identifier.major > currentOp.identifier.major) {\r\n                    // previousOp loses the battle\r\n                    loserMajor = previousOp.identifier.major;\r\n                }\r\n                else {\r\n                    loserMajor = currentOp.identifier.major;\r\n                }\r\n                loserCursorsMap[loserMajor.toString()] = true;\r\n                for (let j = 0; j < operations.length; j++) {\r\n                    if (operations[j].identifier.major === loserMajor) {\r\n                        operations.splice(j, 1);\r\n                        if (j < i) {\r\n                            i--;\r\n                        }\r\n                        j--;\r\n                    }\r\n                }\r\n                if (i > 0) {\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n        return loserCursorsMap;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}