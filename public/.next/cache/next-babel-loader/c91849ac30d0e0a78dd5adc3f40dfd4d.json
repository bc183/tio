{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range } from '../../common/core/range.js';\nexport var _debugComposition = false;\nexport var TextAreaState = /*#__PURE__*/function () {\n  function TextAreaState(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\n    _classCallCheck(this, TextAreaState);\n\n    this.value = value;\n    this.selectionStart = selectionStart;\n    this.selectionEnd = selectionEnd;\n    this.selectionStartPosition = selectionStartPosition;\n    this.selectionEndPosition = selectionEndPosition;\n  }\n\n  _createClass(TextAreaState, [{\n    key: \"toString\",\n    value: function toString() {\n      return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\n    }\n  }, {\n    key: \"collapseSelection\",\n    value: function collapseSelection() {\n      return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\n    }\n  }, {\n    key: \"writeToTextArea\",\n    value: function writeToTextArea(reason, textArea, select) {\n      if (_debugComposition) {\n        console.log('writeToTextArea ' + reason + ': ' + this.toString());\n      }\n\n      textArea.setValue(reason, this.value);\n\n      if (select) {\n        textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\n      }\n    }\n  }, {\n    key: \"deduceEditorPosition\",\n    value: function deduceEditorPosition(offset) {\n      if (offset <= this.selectionStart) {\n        var str = this.value.substring(offset, this.selectionStart);\n        return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\n      }\n\n      if (offset >= this.selectionEnd) {\n        var _str = this.value.substring(this.selectionEnd, offset);\n\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, _str, 1);\n      }\n\n      var str1 = this.value.substring(this.selectionStart, offset);\n\n      if (str1.indexOf(String.fromCharCode(8230)) === -1) {\n        return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\n      }\n\n      var str2 = this.value.substring(offset, this.selectionEnd);\n      return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\n    }\n  }, {\n    key: \"_finishDeduceEditorPosition\",\n    value: function _finishDeduceEditorPosition(anchor, deltaText, signum) {\n      var lineFeedCnt = 0;\n      var lastLineFeedIndex = -1;\n\n      while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\n        lineFeedCnt++;\n      }\n\n      return [anchor, signum * deltaText.length, lineFeedCnt];\n    }\n  }], [{\n    key: \"readFromTextArea\",\n    value: function readFromTextArea(textArea) {\n      return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\n    }\n  }, {\n    key: \"selectedText\",\n    value: function selectedText(text) {\n      return new TextAreaState(text, 0, text.length, null, null);\n    }\n  }, {\n    key: \"deduceInput\",\n    value: function deduceInput(previousState, currentState, couldBeEmojiInput) {\n      if (!previousState) {\n        // This is the EMPTY state\n        return {\n          text: '',\n          replaceCharCnt: 0\n        };\n      }\n\n      if (_debugComposition) {\n        console.log('------------------------deduceInput');\n        console.log('PREVIOUS STATE: ' + previousState.toString());\n        console.log('CURRENT STATE: ' + currentState.toString());\n      }\n\n      var previousValue = previousState.value;\n      var previousSelectionStart = previousState.selectionStart;\n      var previousSelectionEnd = previousState.selectionEnd;\n      var currentValue = currentState.value;\n      var currentSelectionStart = currentState.selectionStart;\n      var currentSelectionEnd = currentState.selectionEnd; // Strip the previous suffix from the value (without interfering with the current selection)\n\n      var previousSuffix = previousValue.substring(previousSelectionEnd);\n      var currentSuffix = currentValue.substring(currentSelectionEnd);\n      var suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\n      currentValue = currentValue.substring(0, currentValue.length - suffixLength);\n      previousValue = previousValue.substring(0, previousValue.length - suffixLength);\n      var previousPrefix = previousValue.substring(0, previousSelectionStart);\n      var currentPrefix = currentValue.substring(0, currentSelectionStart);\n      var prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\n      currentValue = currentValue.substring(prefixLength);\n      previousValue = previousValue.substring(prefixLength);\n      currentSelectionStart -= prefixLength;\n      previousSelectionStart -= prefixLength;\n      currentSelectionEnd -= prefixLength;\n      previousSelectionEnd -= prefixLength;\n\n      if (_debugComposition) {\n        console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\n        console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\n      }\n\n      if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\n        // on OSX, emojis from the emoji picker are inserted at random locations\n        // the only hints we can use is that the selection is immediately after the inserted emoji\n        // and that none of the old text has been deleted\n        var potentialEmojiInput = null;\n\n        if (currentSelectionStart === currentValue.length) {\n          // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\n          if (currentValue.startsWith(previousValue)) {\n            // only if all of the old text is accounted for\n            potentialEmojiInput = currentValue.substring(previousValue.length);\n          }\n        } else {\n          // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\n          if (currentValue.endsWith(previousValue)) {\n            // only if all of the old text is accounted for\n            potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\n          }\n        }\n\n        if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\n          // now we check that this is indeed an emoji\n          // emojis can grow quite long, so a length check is of no help\n          // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ England\n          // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\n          // http://emojipedia.org/variation-selector-16/\n          // > An invisible codepoint which specifies that the preceding character\n          // > should be displayed with emoji presentation. Only required if the\n          // > preceding character defaults to text presentation.\n          if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\n            return {\n              text: potentialEmojiInput,\n              replaceCharCnt: 0\n            };\n          }\n        }\n      }\n\n      if (currentSelectionStart === currentSelectionEnd) {\n        // composition accept case (noticed in FF + Japanese)\n        // [blahblah] => blahblah|\n        if (previousValue === currentValue && previousSelectionStart === 0 && previousSelectionEnd === previousValue.length && currentSelectionStart === currentValue.length && currentValue.indexOf('\\n') === -1) {\n          if (strings.containsFullWidthCharacter(currentValue)) {\n            return {\n              text: '',\n              replaceCharCnt: 0\n            };\n          }\n        } // no current selection\n\n\n        var _replacePreviousCharacters = previousPrefix.length - prefixLength;\n\n        if (_debugComposition) {\n          console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\n        }\n\n        return {\n          text: currentValue,\n          replaceCharCnt: _replacePreviousCharacters\n        };\n      } // there is a current selection => composition case\n\n\n      var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\n      return {\n        text: currentValue,\n        replaceCharCnt: replacePreviousCharacters\n      };\n    }\n  }]);\n\n  return TextAreaState;\n}();\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\nexport var PagedScreenReaderStrategy = /*#__PURE__*/function () {\n  function PagedScreenReaderStrategy() {\n    _classCallCheck(this, PagedScreenReaderStrategy);\n  }\n\n  _createClass(PagedScreenReaderStrategy, null, [{\n    key: \"_getPageOfLine\",\n    value: function _getPageOfLine(lineNumber, linesPerPage) {\n      return Math.floor((lineNumber - 1) / linesPerPage);\n    }\n  }, {\n    key: \"_getRangeForPage\",\n    value: function _getRangeForPage(page, linesPerPage) {\n      var offset = page * linesPerPage;\n      var startLineNumber = offset + 1;\n      var endLineNumber = offset + linesPerPage;\n      return new Range(startLineNumber, 1, endLineNumber + 1, 1);\n    }\n  }, {\n    key: \"fromEditorSelection\",\n    value: function fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\n      var selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\n\n      var selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\n\n      var selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\n\n      var selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\n\n      var pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\n      var pretext = model.getValueInRange(pretextRange, 1\n      /* LF */\n      );\n      var lastLine = model.getLineCount();\n      var lastLineMaxColumn = model.getLineMaxColumn(lastLine);\n      var posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\n      var posttext = model.getValueInRange(posttextRange, 1\n      /* LF */\n      );\n      var text;\n\n      if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\n        // take full selection\n        text = model.getValueInRange(selection, 1\n        /* LF */\n        );\n      } else {\n        var selectionRange1 = selectionStartPageRange.intersectRanges(selection);\n        var selectionRange2 = selectionEndPageRange.intersectRanges(selection);\n        text = model.getValueInRange(selectionRange1, 1\n        /* LF */\n        ) + String.fromCharCode(8230) + model.getValueInRange(selectionRange2, 1\n        /* LF */\n        );\n      } // Chromium handles very poorly text even of a few thousand chars\n      // Cut text to avoid stalling the entire UI\n\n\n      if (trimLongText) {\n        var LIMIT_CHARS = 500;\n\n        if (pretext.length > LIMIT_CHARS) {\n          pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\n        }\n\n        if (posttext.length > LIMIT_CHARS) {\n          posttext = posttext.substring(0, LIMIT_CHARS);\n        }\n\n        if (text.length > 2 * LIMIT_CHARS) {\n          text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\n        }\n      }\n\n      return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\n    }\n  }]);\n\n  return PagedScreenReaderStrategy;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaState.js"],"names":["strings","Position","Range","_debugComposition","TextAreaState","value","selectionStart","selectionEnd","selectionStartPosition","selectionEndPosition","length","reason","textArea","select","console","log","toString","setValue","setSelectionRange","offset","str","substring","_finishDeduceEditorPosition","str1","indexOf","String","fromCharCode","str2","anchor","deltaText","signum","lineFeedCnt","lastLineFeedIndex","getValue","getSelectionStart","getSelectionEnd","text","previousState","currentState","couldBeEmojiInput","replaceCharCnt","previousValue","previousSelectionStart","previousSelectionEnd","currentValue","currentSelectionStart","currentSelectionEnd","previousSuffix","currentSuffix","suffixLength","commonSuffixLength","previousPrefix","currentPrefix","prefixLength","commonPrefixLength","potentialEmojiInput","startsWith","endsWith","test","containsEmoji","containsFullWidthCharacter","replacePreviousCharacters","EMPTY","PagedScreenReaderStrategy","lineNumber","linesPerPage","Math","floor","page","startLineNumber","endLineNumber","model","selection","trimLongText","selectionStartPage","_getPageOfLine","selectionStartPageRange","_getRangeForPage","selectionEndPage","selectionEndPageRange","pretextRange","intersectRanges","startColumn","pretext","getValueInRange","lastLine","getLineCount","lastLineMaxColumn","getLineMaxColumn","posttextRange","endColumn","posttext","selectionRange1","selectionRange2","LIMIT_CHARS"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA,OAAO,KAAKA,OAAZ,MAAyB,iCAAzB;AACA,SAASC,QAAT,QAAyB,+BAAzB;AACA,SAASC,KAAT,QAAsB,4BAAtB;AACA,OAAO,IAAMC,iBAAiB,GAAG,KAA1B;AACP,WAAaC,aAAb;AACI,yBAAYC,KAAZ,EAAmBC,cAAnB,EAAmCC,YAAnC,EAAiDC,sBAAjD,EAAyEC,oBAAzE,EAA+F;AAAA;;AAC3F,SAAKJ,KAAL,GAAaA,KAAb;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,oBAAL,GAA4BA,oBAA5B;AACH;;AAPL;AAAA;AAAA,+BAQe;AACP,aAAO,QAAQ,KAAKJ,KAAb,GAAqB,qBAArB,GAA6C,KAAKC,cAAlD,GAAmE,kBAAnE,GAAwF,KAAKC,YAA7F,GAA4G,GAAnH;AACH;AAVL;AAAA;AAAA,wCAcwB;AAChB,aAAO,IAAIH,aAAJ,CAAkB,KAAKC,KAAvB,EAA8B,KAAKA,KAAL,CAAWK,MAAzC,EAAiD,KAAKL,KAAL,CAAWK,MAA5D,EAAoE,IAApE,EAA0E,IAA1E,CAAP;AACH;AAhBL;AAAA;AAAA,oCAiBoBC,MAjBpB,EAiB4BC,QAjB5B,EAiBsCC,MAjBtC,EAiB8C;AACtC,UAAIV,iBAAJ,EAAuB;AACnBW,QAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBJ,MAArB,GAA8B,IAA9B,GAAqC,KAAKK,QAAL,EAAjD;AACH;;AACDJ,MAAAA,QAAQ,CAACK,QAAT,CAAkBN,MAAlB,EAA0B,KAAKN,KAA/B;;AACA,UAAIQ,MAAJ,EAAY;AACRD,QAAAA,QAAQ,CAACM,iBAAT,CAA2BP,MAA3B,EAAmC,KAAKL,cAAxC,EAAwD,KAAKC,YAA7D;AACH;AACJ;AAzBL;AAAA;AAAA,yCA0ByBY,MA1BzB,EA0BiC;AACzB,UAAIA,MAAM,IAAI,KAAKb,cAAnB,EAAmC;AAC/B,YAAMc,GAAG,GAAG,KAAKf,KAAL,CAAWgB,SAAX,CAAqBF,MAArB,EAA6B,KAAKb,cAAlC,CAAZ;AACA,eAAO,KAAKgB,2BAAL,CAAiC,KAAKd,sBAAtC,EAA8DY,GAA9D,EAAmE,CAAC,CAApE,CAAP;AACH;;AACD,UAAID,MAAM,IAAI,KAAKZ,YAAnB,EAAiC;AAC7B,YAAMa,IAAG,GAAG,KAAKf,KAAL,CAAWgB,SAAX,CAAqB,KAAKd,YAA1B,EAAwCY,MAAxC,CAAZ;;AACA,eAAO,KAAKG,2BAAL,CAAiC,KAAKb,oBAAtC,EAA4DW,IAA5D,EAAiE,CAAjE,CAAP;AACH;;AACD,UAAMG,IAAI,GAAG,KAAKlB,KAAL,CAAWgB,SAAX,CAAqB,KAAKf,cAA1B,EAA0Ca,MAA1C,CAAb;;AACA,UAAII,IAAI,CAACC,OAAL,CAAaC,MAAM,CAACC,YAAP,CAAoB,IAApB,CAAb,MAA4C,CAAC,CAAjD,EAAoD;AAChD,eAAO,KAAKJ,2BAAL,CAAiC,KAAKd,sBAAtC,EAA8De,IAA9D,EAAoE,CAApE,CAAP;AACH;;AACD,UAAMI,IAAI,GAAG,KAAKtB,KAAL,CAAWgB,SAAX,CAAqBF,MAArB,EAA6B,KAAKZ,YAAlC,CAAb;AACA,aAAO,KAAKe,2BAAL,CAAiC,KAAKb,oBAAtC,EAA4DkB,IAA5D,EAAkE,CAAC,CAAnE,CAAP;AACH;AAzCL;AAAA;AAAA,gDA0CgCC,MA1ChC,EA0CwCC,SA1CxC,EA0CmDC,MA1CnD,EA0C2D;AACnD,UAAIC,WAAW,GAAG,CAAlB;AACA,UAAIC,iBAAiB,GAAG,CAAC,CAAzB;;AACA,aAAO,CAACA,iBAAiB,GAAGH,SAAS,CAACL,OAAV,CAAkB,IAAlB,EAAwBQ,iBAAiB,GAAG,CAA5C,CAArB,MAAyE,CAAC,CAAjF,EAAoF;AAChFD,QAAAA,WAAW;AACd;;AACD,aAAO,CAACH,MAAD,EAASE,MAAM,GAAGD,SAAS,CAACnB,MAA5B,EAAoCqB,WAApC,CAAP;AACH;AAjDL;AAAA;AAAA,qCAW4BnB,QAX5B,EAWsC;AAC9B,aAAO,IAAIR,aAAJ,CAAkBQ,QAAQ,CAACqB,QAAT,EAAlB,EAAuCrB,QAAQ,CAACsB,iBAAT,EAAvC,EAAqEtB,QAAQ,CAACuB,eAAT,EAArE,EAAiG,IAAjG,EAAuG,IAAvG,CAAP;AACH;AAbL;AAAA;AAAA,iCAkDwBC,IAlDxB,EAkD8B;AACtB,aAAO,IAAIhC,aAAJ,CAAkBgC,IAAlB,EAAwB,CAAxB,EAA2BA,IAAI,CAAC1B,MAAhC,EAAwC,IAAxC,EAA8C,IAA9C,CAAP;AACH;AApDL;AAAA;AAAA,gCAqDuB2B,aArDvB,EAqDsCC,YArDtC,EAqDoDC,iBArDpD,EAqDuE;AAC/D,UAAI,CAACF,aAAL,EAAoB;AAChB;AACA,eAAO;AACHD,UAAAA,IAAI,EAAE,EADH;AAEHI,UAAAA,cAAc,EAAE;AAFb,SAAP;AAIH;;AACD,UAAIrC,iBAAJ,EAAuB;AACnBW,QAAAA,OAAO,CAACC,GAAR,CAAY,qCAAZ;AACAD,QAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBsB,aAAa,CAACrB,QAAd,EAAjC;AACAF,QAAAA,OAAO,CAACC,GAAR,CAAY,oBAAoBuB,YAAY,CAACtB,QAAb,EAAhC;AACH;;AACD,UAAIyB,aAAa,GAAGJ,aAAa,CAAChC,KAAlC;AACA,UAAIqC,sBAAsB,GAAGL,aAAa,CAAC/B,cAA3C;AACA,UAAIqC,oBAAoB,GAAGN,aAAa,CAAC9B,YAAzC;AACA,UAAIqC,YAAY,GAAGN,YAAY,CAACjC,KAAhC;AACA,UAAIwC,qBAAqB,GAAGP,YAAY,CAAChC,cAAzC;AACA,UAAIwC,mBAAmB,GAAGR,YAAY,CAAC/B,YAAvC,CAlB+D,CAmB/D;;AACA,UAAMwC,cAAc,GAAGN,aAAa,CAACpB,SAAd,CAAwBsB,oBAAxB,CAAvB;AACA,UAAMK,aAAa,GAAGJ,YAAY,CAACvB,SAAb,CAAuByB,mBAAvB,CAAtB;AACA,UAAMG,YAAY,GAAGjD,OAAO,CAACkD,kBAAR,CAA2BH,cAA3B,EAA2CC,aAA3C,CAArB;AACAJ,MAAAA,YAAY,GAAGA,YAAY,CAACvB,SAAb,CAAuB,CAAvB,EAA0BuB,YAAY,CAAClC,MAAb,GAAsBuC,YAAhD,CAAf;AACAR,MAAAA,aAAa,GAAGA,aAAa,CAACpB,SAAd,CAAwB,CAAxB,EAA2BoB,aAAa,CAAC/B,MAAd,GAAuBuC,YAAlD,CAAhB;AACA,UAAME,cAAc,GAAGV,aAAa,CAACpB,SAAd,CAAwB,CAAxB,EAA2BqB,sBAA3B,CAAvB;AACA,UAAMU,aAAa,GAAGR,YAAY,CAACvB,SAAb,CAAuB,CAAvB,EAA0BwB,qBAA1B,CAAtB;AACA,UAAMQ,YAAY,GAAGrD,OAAO,CAACsD,kBAAR,CAA2BH,cAA3B,EAA2CC,aAA3C,CAArB;AACAR,MAAAA,YAAY,GAAGA,YAAY,CAACvB,SAAb,CAAuBgC,YAAvB,CAAf;AACAZ,MAAAA,aAAa,GAAGA,aAAa,CAACpB,SAAd,CAAwBgC,YAAxB,CAAhB;AACAR,MAAAA,qBAAqB,IAAIQ,YAAzB;AACAX,MAAAA,sBAAsB,IAAIW,YAA1B;AACAP,MAAAA,mBAAmB,IAAIO,YAAvB;AACAV,MAAAA,oBAAoB,IAAIU,YAAxB;;AACA,UAAIlD,iBAAJ,EAAuB;AACnBW,QAAAA,OAAO,CAACC,GAAR,CAAY,oCAAoC0B,aAApC,GAAoD,qBAApD,GAA4EC,sBAA5E,GAAqG,kBAArG,GAA0HC,oBAAtI;AACA7B,QAAAA,OAAO,CAACC,GAAR,CAAY,mCAAmC6B,YAAnC,GAAkD,qBAAlD,GAA0EC,qBAA1E,GAAkG,kBAAlG,GAAuHC,mBAAnI;AACH;;AACD,UAAIP,iBAAiB,IAAIM,qBAAqB,KAAKC,mBAA/C,IAAsEL,aAAa,CAAC/B,MAAd,GAAuB,CAAjG,EAAoG;AAChG;AACA;AACA;AACA,YAAI6C,mBAAmB,GAAG,IAA1B;;AACA,YAAIV,qBAAqB,KAAKD,YAAY,CAAClC,MAA3C,EAAmD;AAC/C;AACA,cAAIkC,YAAY,CAACY,UAAb,CAAwBf,aAAxB,CAAJ,EAA4C;AACxC;AACAc,YAAAA,mBAAmB,GAAGX,YAAY,CAACvB,SAAb,CAAuBoB,aAAa,CAAC/B,MAArC,CAAtB;AACH;AACJ,SAND,MAOK;AACD;AACA,cAAIkC,YAAY,CAACa,QAAb,CAAsBhB,aAAtB,CAAJ,EAA0C;AACtC;AACAc,YAAAA,mBAAmB,GAAGX,YAAY,CAACvB,SAAb,CAAuB,CAAvB,EAA0BuB,YAAY,CAAClC,MAAb,GAAsB+B,aAAa,CAAC/B,MAA9D,CAAtB;AACH;AACJ;;AACD,YAAI6C,mBAAmB,KAAK,IAAxB,IAAgCA,mBAAmB,CAAC7C,MAApB,GAA6B,CAAjE,EAAoE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAI,SAASgD,IAAT,CAAcH,mBAAd,KAAsCvD,OAAO,CAAC2D,aAAR,CAAsBJ,mBAAtB,CAA1C,EAAsF;AAClF,mBAAO;AACHnB,cAAAA,IAAI,EAAEmB,mBADH;AAEHf,cAAAA,cAAc,EAAE;AAFb,aAAP;AAIH;AACJ;AACJ;;AACD,UAAIK,qBAAqB,KAAKC,mBAA9B,EAAmD;AAC/C;AACA;AACA,YAAIL,aAAa,KAAKG,YAAlB,IACGF,sBAAsB,KAAK,CAD9B,IAEGC,oBAAoB,KAAKF,aAAa,CAAC/B,MAF1C,IAGGmC,qBAAqB,KAAKD,YAAY,CAAClC,MAH1C,IAIGkC,YAAY,CAACpB,OAAb,CAAqB,IAArB,MAA+B,CAAC,CAJvC,EAI0C;AACtC,cAAIxB,OAAO,CAAC4D,0BAAR,CAAmChB,YAAnC,CAAJ,EAAsD;AAClD,mBAAO;AACHR,cAAAA,IAAI,EAAE,EADH;AAEHI,cAAAA,cAAc,EAAE;AAFb,aAAP;AAIH;AACJ,SAd8C,CAe/C;;;AACA,YAAMqB,0BAAyB,GAAIV,cAAc,CAACzC,MAAf,GAAwB2C,YAA3D;;AACA,YAAIlD,iBAAJ,EAAuB;AACnBW,UAAAA,OAAO,CAACC,GAAR,CAAY,uBAAuBoC,cAAc,CAACzC,MAAf,GAAwB2C,YAA/C,IAA+D,QAA3E;AACH;;AACD,eAAO;AACHjB,UAAAA,IAAI,EAAEQ,YADH;AAEHJ,UAAAA,cAAc,EAAEqB;AAFb,SAAP;AAIH,OAlG8D,CAmG/D;;;AACA,UAAMA,yBAAyB,GAAGlB,oBAAoB,GAAGD,sBAAzD;AACA,aAAO;AACHN,QAAAA,IAAI,EAAEQ,YADH;AAEHJ,QAAAA,cAAc,EAAEqB;AAFb,OAAP;AAIH;AA9JL;;AAAA;AAAA;AAgKAzD,aAAa,CAAC0D,KAAd,GAAsB,IAAI1D,aAAJ,CAAkB,EAAlB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,IAA5B,EAAkC,IAAlC,CAAtB;AACA,WAAa2D,yBAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mCAC0BC,UAD1B,EACsCC,YADtC,EACoD;AAC5C,aAAOC,IAAI,CAACC,KAAL,CAAW,CAACH,UAAU,GAAG,CAAd,IAAmBC,YAA9B,CAAP;AACH;AAHL;AAAA;AAAA,qCAI4BG,IAJ5B,EAIkCH,YAJlC,EAIgD;AACxC,UAAM9C,MAAM,GAAGiD,IAAI,GAAGH,YAAtB;AACA,UAAMI,eAAe,GAAGlD,MAAM,GAAG,CAAjC;AACA,UAAMmD,aAAa,GAAGnD,MAAM,GAAG8C,YAA/B;AACA,aAAO,IAAI/D,KAAJ,CAAUmE,eAAV,EAA2B,CAA3B,EAA8BC,aAAa,GAAG,CAA9C,EAAiD,CAAjD,CAAP;AACH;AATL;AAAA;AAAA,wCAU+BjC,aAV/B,EAU8CkC,KAV9C,EAUqDC,SAVrD,EAUgEP,YAVhE,EAU8EQ,YAV9E,EAU4F;AACpF,UAAMC,kBAAkB,GAAGX,yBAAyB,CAACY,cAA1B,CAAyCH,SAAS,CAACH,eAAnD,EAAoEJ,YAApE,CAA3B;;AACA,UAAMW,uBAAuB,GAAGb,yBAAyB,CAACc,gBAA1B,CAA2CH,kBAA3C,EAA+DT,YAA/D,CAAhC;;AACA,UAAMa,gBAAgB,GAAGf,yBAAyB,CAACY,cAA1B,CAAyCH,SAAS,CAACF,aAAnD,EAAkEL,YAAlE,CAAzB;;AACA,UAAMc,qBAAqB,GAAGhB,yBAAyB,CAACc,gBAA1B,CAA2CC,gBAA3C,EAA6Db,YAA7D,CAA9B;;AACA,UAAMe,YAAY,GAAGJ,uBAAuB,CAACK,eAAxB,CAAwC,IAAI/E,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgBsE,SAAS,CAACH,eAA1B,EAA2CG,SAAS,CAACU,WAArD,CAAxC,CAArB;AACA,UAAIC,OAAO,GAAGZ,KAAK,CAACa,eAAN,CAAsBJ,YAAtB,EAAoC;AAAE;AAAtC,OAAd;AACA,UAAMK,QAAQ,GAAGd,KAAK,CAACe,YAAN,EAAjB;AACA,UAAMC,iBAAiB,GAAGhB,KAAK,CAACiB,gBAAN,CAAuBH,QAAvB,CAA1B;AACA,UAAMI,aAAa,GAAGV,qBAAqB,CAACE,eAAtB,CAAsC,IAAI/E,KAAJ,CAAUsE,SAAS,CAACF,aAApB,EAAmCE,SAAS,CAACkB,SAA7C,EAAwDL,QAAxD,EAAkEE,iBAAlE,CAAtC,CAAtB;AACA,UAAII,QAAQ,GAAGpB,KAAK,CAACa,eAAN,CAAsBK,aAAtB,EAAqC;AAAE;AAAvC,OAAf;AACA,UAAIrD,IAAJ;;AACA,UAAIsC,kBAAkB,KAAKI,gBAAvB,IAA2CJ,kBAAkB,GAAG,CAArB,KAA2BI,gBAA1E,EAA4F;AACxF;AACA1C,QAAAA,IAAI,GAAGmC,KAAK,CAACa,eAAN,CAAsBZ,SAAtB,EAAiC;AAAE;AAAnC,SAAP;AACH,OAHD,MAIK;AACD,YAAMoB,eAAe,GAAGhB,uBAAuB,CAACK,eAAxB,CAAwCT,SAAxC,CAAxB;AACA,YAAMqB,eAAe,GAAGd,qBAAqB,CAACE,eAAtB,CAAsCT,SAAtC,CAAxB;AACApC,QAAAA,IAAI,GAAImC,KAAK,CAACa,eAAN,CAAsBQ,eAAtB,EAAuC;AAAE;AAAzC,YACFnE,MAAM,CAACC,YAAP,CAAoB,IAApB,CADE,GAEF6C,KAAK,CAACa,eAAN,CAAsBS,eAAtB,EAAuC;AAAE;AAAzC,SAFN;AAGH,OAtBmF,CAuBpF;AACA;;;AACA,UAAIpB,YAAJ,EAAkB;AACd,YAAMqB,WAAW,GAAG,GAApB;;AACA,YAAIX,OAAO,CAACzE,MAAR,GAAiBoF,WAArB,EAAkC;AAC9BX,UAAAA,OAAO,GAAGA,OAAO,CAAC9D,SAAR,CAAkB8D,OAAO,CAACzE,MAAR,GAAiBoF,WAAnC,EAAgDX,OAAO,CAACzE,MAAxD,CAAV;AACH;;AACD,YAAIiF,QAAQ,CAACjF,MAAT,GAAkBoF,WAAtB,EAAmC;AAC/BH,UAAAA,QAAQ,GAAGA,QAAQ,CAACtE,SAAT,CAAmB,CAAnB,EAAsByE,WAAtB,CAAX;AACH;;AACD,YAAI1D,IAAI,CAAC1B,MAAL,GAAc,IAAIoF,WAAtB,EAAmC;AAC/B1D,UAAAA,IAAI,GAAGA,IAAI,CAACf,SAAL,CAAe,CAAf,EAAkByE,WAAlB,IAAiCrE,MAAM,CAACC,YAAP,CAAoB,IAApB,CAAjC,GAA6DU,IAAI,CAACf,SAAL,CAAee,IAAI,CAAC1B,MAAL,GAAcoF,WAA7B,EAA0C1D,IAAI,CAAC1B,MAA/C,CAApE;AACH;AACJ;;AACD,aAAO,IAAIN,aAAJ,CAAkB+E,OAAO,GAAG/C,IAAV,GAAiBuD,QAAnC,EAA6CR,OAAO,CAACzE,MAArD,EAA6DyE,OAAO,CAACzE,MAAR,GAAiB0B,IAAI,CAAC1B,MAAnF,EAA2F,IAAIT,QAAJ,CAAauE,SAAS,CAACH,eAAvB,EAAwCG,SAAS,CAACU,WAAlD,CAA3F,EAA2J,IAAIjF,QAAJ,CAAauE,SAAS,CAACF,aAAvB,EAAsCE,SAAS,CAACkB,SAAhD,CAA3J,CAAP;AACH;AAhDL;;AAAA;AAAA","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Range } from '../../common/core/range.js';\r\nexport const _debugComposition = false;\r\nexport class TextAreaState {\r\n    constructor(value, selectionStart, selectionEnd, selectionStartPosition, selectionEndPosition) {\r\n        this.value = value;\r\n        this.selectionStart = selectionStart;\r\n        this.selectionEnd = selectionEnd;\r\n        this.selectionStartPosition = selectionStartPosition;\r\n        this.selectionEndPosition = selectionEndPosition;\r\n    }\r\n    toString() {\r\n        return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ']';\r\n    }\r\n    static readFromTextArea(textArea) {\r\n        return new TextAreaState(textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), null, null);\r\n    }\r\n    collapseSelection() {\r\n        return new TextAreaState(this.value, this.value.length, this.value.length, null, null);\r\n    }\r\n    writeToTextArea(reason, textArea, select) {\r\n        if (_debugComposition) {\r\n            console.log('writeToTextArea ' + reason + ': ' + this.toString());\r\n        }\r\n        textArea.setValue(reason, this.value);\r\n        if (select) {\r\n            textArea.setSelectionRange(reason, this.selectionStart, this.selectionEnd);\r\n        }\r\n    }\r\n    deduceEditorPosition(offset) {\r\n        if (offset <= this.selectionStart) {\r\n            const str = this.value.substring(offset, this.selectionStart);\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str, -1);\r\n        }\r\n        if (offset >= this.selectionEnd) {\r\n            const str = this.value.substring(this.selectionEnd, offset);\r\n            return this._finishDeduceEditorPosition(this.selectionEndPosition, str, 1);\r\n        }\r\n        const str1 = this.value.substring(this.selectionStart, offset);\r\n        if (str1.indexOf(String.fromCharCode(8230)) === -1) {\r\n            return this._finishDeduceEditorPosition(this.selectionStartPosition, str1, 1);\r\n        }\r\n        const str2 = this.value.substring(offset, this.selectionEnd);\r\n        return this._finishDeduceEditorPosition(this.selectionEndPosition, str2, -1);\r\n    }\r\n    _finishDeduceEditorPosition(anchor, deltaText, signum) {\r\n        let lineFeedCnt = 0;\r\n        let lastLineFeedIndex = -1;\r\n        while ((lastLineFeedIndex = deltaText.indexOf('\\n', lastLineFeedIndex + 1)) !== -1) {\r\n            lineFeedCnt++;\r\n        }\r\n        return [anchor, signum * deltaText.length, lineFeedCnt];\r\n    }\r\n    static selectedText(text) {\r\n        return new TextAreaState(text, 0, text.length, null, null);\r\n    }\r\n    static deduceInput(previousState, currentState, couldBeEmojiInput) {\r\n        if (!previousState) {\r\n            // This is the EMPTY state\r\n            return {\r\n                text: '',\r\n                replaceCharCnt: 0\r\n            };\r\n        }\r\n        if (_debugComposition) {\r\n            console.log('------------------------deduceInput');\r\n            console.log('PREVIOUS STATE: ' + previousState.toString());\r\n            console.log('CURRENT STATE: ' + currentState.toString());\r\n        }\r\n        let previousValue = previousState.value;\r\n        let previousSelectionStart = previousState.selectionStart;\r\n        let previousSelectionEnd = previousState.selectionEnd;\r\n        let currentValue = currentState.value;\r\n        let currentSelectionStart = currentState.selectionStart;\r\n        let currentSelectionEnd = currentState.selectionEnd;\r\n        // Strip the previous suffix from the value (without interfering with the current selection)\r\n        const previousSuffix = previousValue.substring(previousSelectionEnd);\r\n        const currentSuffix = currentValue.substring(currentSelectionEnd);\r\n        const suffixLength = strings.commonSuffixLength(previousSuffix, currentSuffix);\r\n        currentValue = currentValue.substring(0, currentValue.length - suffixLength);\r\n        previousValue = previousValue.substring(0, previousValue.length - suffixLength);\r\n        const previousPrefix = previousValue.substring(0, previousSelectionStart);\r\n        const currentPrefix = currentValue.substring(0, currentSelectionStart);\r\n        const prefixLength = strings.commonPrefixLength(previousPrefix, currentPrefix);\r\n        currentValue = currentValue.substring(prefixLength);\r\n        previousValue = previousValue.substring(prefixLength);\r\n        currentSelectionStart -= prefixLength;\r\n        previousSelectionStart -= prefixLength;\r\n        currentSelectionEnd -= prefixLength;\r\n        previousSelectionEnd -= prefixLength;\r\n        if (_debugComposition) {\r\n            console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);\r\n            console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);\r\n        }\r\n        if (couldBeEmojiInput && currentSelectionStart === currentSelectionEnd && previousValue.length > 0) {\r\n            // on OSX, emojis from the emoji picker are inserted at random locations\r\n            // the only hints we can use is that the selection is immediately after the inserted emoji\r\n            // and that none of the old text has been deleted\r\n            let potentialEmojiInput = null;\r\n            if (currentSelectionStart === currentValue.length) {\r\n                // emoji potentially inserted \"somewhere\" after the previous selection => it should appear at the end of `currentValue`\r\n                if (currentValue.startsWith(previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(previousValue.length);\r\n                }\r\n            }\r\n            else {\r\n                // emoji potentially inserted \"somewhere\" before the previous selection => it should appear at the start of `currentValue`\r\n                if (currentValue.endsWith(previousValue)) {\r\n                    // only if all of the old text is accounted for\r\n                    potentialEmojiInput = currentValue.substring(0, currentValue.length - previousValue.length);\r\n                }\r\n            }\r\n            if (potentialEmojiInput !== null && potentialEmojiInput.length > 0) {\r\n                // now we check that this is indeed an emoji\r\n                // emojis can grow quite long, so a length check is of no help\r\n                // e.g. 1F3F4 E0067 E0062 E0065 E006E E0067 E007F  ; fully-qualified     # ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ England\r\n                // Oftentimes, emojis use Variation Selector-16 (U+FE0F), so that is a good hint\r\n                // http://emojipedia.org/variation-selector-16/\r\n                // > An invisible codepoint which specifies that the preceding character\r\n                // > should be displayed with emoji presentation. Only required if the\r\n                // > preceding character defaults to text presentation.\r\n                if (/\\uFE0F/.test(potentialEmojiInput) || strings.containsEmoji(potentialEmojiInput)) {\r\n                    return {\r\n                        text: potentialEmojiInput,\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        if (currentSelectionStart === currentSelectionEnd) {\r\n            // composition accept case (noticed in FF + Japanese)\r\n            // [blahblah] => blahblah|\r\n            if (previousValue === currentValue\r\n                && previousSelectionStart === 0\r\n                && previousSelectionEnd === previousValue.length\r\n                && currentSelectionStart === currentValue.length\r\n                && currentValue.indexOf('\\n') === -1) {\r\n                if (strings.containsFullWidthCharacter(currentValue)) {\r\n                    return {\r\n                        text: '',\r\n                        replaceCharCnt: 0\r\n                    };\r\n                }\r\n            }\r\n            // no current selection\r\n            const replacePreviousCharacters = (previousPrefix.length - prefixLength);\r\n            if (_debugComposition) {\r\n                console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');\r\n            }\r\n            return {\r\n                text: currentValue,\r\n                replaceCharCnt: replacePreviousCharacters\r\n            };\r\n        }\r\n        // there is a current selection => composition case\r\n        const replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;\r\n        return {\r\n            text: currentValue,\r\n            replaceCharCnt: replacePreviousCharacters\r\n        };\r\n    }\r\n}\r\nTextAreaState.EMPTY = new TextAreaState('', 0, 0, null, null);\r\nexport class PagedScreenReaderStrategy {\r\n    static _getPageOfLine(lineNumber, linesPerPage) {\r\n        return Math.floor((lineNumber - 1) / linesPerPage);\r\n    }\r\n    static _getRangeForPage(page, linesPerPage) {\r\n        const offset = page * linesPerPage;\r\n        const startLineNumber = offset + 1;\r\n        const endLineNumber = offset + linesPerPage;\r\n        return new Range(startLineNumber, 1, endLineNumber + 1, 1);\r\n    }\r\n    static fromEditorSelection(previousState, model, selection, linesPerPage, trimLongText) {\r\n        const selectionStartPage = PagedScreenReaderStrategy._getPageOfLine(selection.startLineNumber, linesPerPage);\r\n        const selectionStartPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionStartPage, linesPerPage);\r\n        const selectionEndPage = PagedScreenReaderStrategy._getPageOfLine(selection.endLineNumber, linesPerPage);\r\n        const selectionEndPageRange = PagedScreenReaderStrategy._getRangeForPage(selectionEndPage, linesPerPage);\r\n        const pretextRange = selectionStartPageRange.intersectRanges(new Range(1, 1, selection.startLineNumber, selection.startColumn));\r\n        let pretext = model.getValueInRange(pretextRange, 1 /* LF */);\r\n        const lastLine = model.getLineCount();\r\n        const lastLineMaxColumn = model.getLineMaxColumn(lastLine);\r\n        const posttextRange = selectionEndPageRange.intersectRanges(new Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));\r\n        let posttext = model.getValueInRange(posttextRange, 1 /* LF */);\r\n        let text;\r\n        if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {\r\n            // take full selection\r\n            text = model.getValueInRange(selection, 1 /* LF */);\r\n        }\r\n        else {\r\n            const selectionRange1 = selectionStartPageRange.intersectRanges(selection);\r\n            const selectionRange2 = selectionEndPageRange.intersectRanges(selection);\r\n            text = (model.getValueInRange(selectionRange1, 1 /* LF */)\r\n                + String.fromCharCode(8230)\r\n                + model.getValueInRange(selectionRange2, 1 /* LF */));\r\n        }\r\n        // Chromium handles very poorly text even of a few thousand chars\r\n        // Cut text to avoid stalling the entire UI\r\n        if (trimLongText) {\r\n            const LIMIT_CHARS = 500;\r\n            if (pretext.length > LIMIT_CHARS) {\r\n                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);\r\n            }\r\n            if (posttext.length > LIMIT_CHARS) {\r\n                posttext = posttext.substring(0, LIMIT_CHARS);\r\n            }\r\n            if (text.length > 2 * LIMIT_CHARS) {\r\n                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);\r\n            }\r\n        }\r\n        return new TextAreaState(pretext + text + posttext, pretext.length, pretext.length + text.length, new Position(selection.startLineNumber, selection.startColumn), new Position(selection.endLineNumber, selection.endColumn));\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}