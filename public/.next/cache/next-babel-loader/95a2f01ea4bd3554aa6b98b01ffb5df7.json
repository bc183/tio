{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { matchesFuzzy } from './filters.js';\nimport { ltrim } from './strings.js';\nexport var iconStartMarker = '$(';\nvar escapeIconsRegex = /(\\\\)?\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)/gi;\nexport function escapeIcons(text) {\n  return text.replace(escapeIconsRegex, function (match, escaped) {\n    return escaped ? match : \"\\\\\".concat(match);\n  });\n}\nvar markdownEscapedIconsRegex = /\\\\\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)/gi;\nexport function markdownEscapeEscapedIcons(text) {\n  // Need to add an extra \\ for escaping in markdown\n  return text.replace(markdownEscapedIconsRegex, function (match) {\n    return \"\\\\\".concat(match);\n  });\n}\nvar stripIconsRegex = /(\\s)?(\\\\)?\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)(\\s)?/gi;\nexport function stripIcons(text) {\n  if (text.indexOf(iconStartMarker) === -1) {\n    return text;\n  }\n\n  return text.replace(stripIconsRegex, function (match, preWhitespace, escaped, postWhitespace) {\n    return escaped ? match : preWhitespace || postWhitespace || '';\n  });\n}\nexport function parseLabelWithIcons(text) {\n  var firstIconIndex = text.indexOf(iconStartMarker);\n\n  if (firstIconIndex === -1) {\n    return {\n      text: text\n    }; // return early if the word does not include an icon\n  }\n\n  return doParseLabelWithIcons(text, firstIconIndex);\n}\n\nfunction doParseLabelWithIcons(text, firstIconIndex) {\n  var iconOffsets = [];\n  var textWithoutIcons = '';\n\n  function appendChars(chars) {\n    if (chars) {\n      textWithoutIcons += chars;\n\n      var _iterator = _createForOfIteratorHelper(chars),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _ = _step.value;\n          iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n\n  var currentIconStart = -1;\n  var currentIconValue = '';\n  var iconsOffset = 0;\n\n  var _char;\n\n  var nextChar;\n  var offset = firstIconIndex;\n  var length = text.length; // Append all characters until the first icon\n\n  appendChars(text.substr(0, firstIconIndex)); // example: $(file-symlink-file) my cool $(other-icon) entry\n\n  while (offset < length) {\n    _char = text[offset];\n    nextChar = text[offset + 1]; // beginning of icon: some value $( <--\n\n    if (_char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\n      currentIconStart = offset; // if we had a previous potential icon value without\n      // the closing ')', it was actually not an icon and\n      // so we have to add it to the actual value\n\n      appendChars(currentIconValue);\n      currentIconValue = iconStartMarker;\n      offset++; // jump over '('\n    } // end of icon: some value $(some-icon) <--\n    else if (_char === ')' && currentIconStart !== -1) {\n        var currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\n\n        iconsOffset += currentIconLength;\n        currentIconStart = -1;\n        currentIconValue = '';\n      } // within icon\n      else if (currentIconStart !== -1) {\n          // Make sure this is a real icon name\n          if (/^[a-z0-9\\-]$/i.test(_char)) {\n            currentIconValue += _char;\n          } else {\n            // This is not a real icon, treat it as text\n            appendChars(currentIconValue);\n            currentIconStart = -1;\n            currentIconValue = '';\n          }\n        } // any value outside of icon\n        else {\n            appendChars(_char);\n          }\n\n    offset++;\n  } // if we had a previous potential icon value without\n  // the closing ')', it was actually not an icon and\n  // so we have to add it to the actual value\n\n\n  appendChars(currentIconValue);\n  return {\n    text: textWithoutIcons,\n    iconOffsets: iconOffsets\n  };\n}\n\nexport function matchesFuzzyIconAware(query, target) {\n  var enableSeparateSubstringMatching = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var text = target.text,\n      iconOffsets = target.iconOffsets; // Return early if there are no icon markers in the word to match against\n\n  if (!iconOffsets || iconOffsets.length === 0) {\n    return matchesFuzzy(query, text, enableSeparateSubstringMatching);\n  } // Trim the word to match against because it could have leading\n  // whitespace now if the word started with an icon\n\n\n  var wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\n  var leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length; // match on value without icon\n\n  var matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching); // Map matches back to offsets with icon and trimming\n\n  if (matches) {\n    var _iterator2 = _createForOfIteratorHelper(matches),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var match = _step2.value;\n        var iconOffset = iconOffsets[match.start + leadingWhitespaceOffset]\n        /* icon offsets at index */\n        + leadingWhitespaceOffset\n        /* overall leading whitespace offset */\n        ;\n        match.start += iconOffset;\n        match.end += iconOffset;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return matches;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/iconLabels.js"],"names":["matchesFuzzy","ltrim","iconStartMarker","escapeIconsRegex","escapeIcons","text","replace","match","escaped","markdownEscapedIconsRegex","markdownEscapeEscapedIcons","stripIconsRegex","stripIcons","indexOf","preWhitespace","postWhitespace","parseLabelWithIcons","firstIconIndex","doParseLabelWithIcons","iconOffsets","textWithoutIcons","appendChars","chars","_","push","iconsOffset","currentIconStart","currentIconValue","char","nextChar","offset","length","substr","currentIconLength","test","matchesFuzzyIconAware","query","target","enableSeparateSubstringMatching","wordToMatchAgainstWithoutIconsTrimmed","leadingWhitespaceOffset","matches","iconOffset","start","end"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { matchesFuzzy } from './filters.js';\r\nimport { ltrim } from './strings.js';\r\nexport const iconStartMarker = '$(';\r\nconst escapeIconsRegex = /(\\\\)?\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)/gi;\r\nexport function escapeIcons(text) {\r\n    return text.replace(escapeIconsRegex, (match, escaped) => escaped ? match : `\\\\${match}`);\r\n}\r\nconst markdownEscapedIconsRegex = /\\\\\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)/gi;\r\nexport function markdownEscapeEscapedIcons(text) {\r\n    // Need to add an extra \\ for escaping in markdown\r\n    return text.replace(markdownEscapedIconsRegex, match => `\\\\${match}`);\r\n}\r\nconst stripIconsRegex = /(\\s)?(\\\\)?\\$\\([a-z0-9\\-]+?(?:~[a-z0-9\\-]*?)?\\)(\\s)?/gi;\r\nexport function stripIcons(text) {\r\n    if (text.indexOf(iconStartMarker) === -1) {\r\n        return text;\r\n    }\r\n    return text.replace(stripIconsRegex, (match, preWhitespace, escaped, postWhitespace) => escaped ? match : preWhitespace || postWhitespace || '');\r\n}\r\nexport function parseLabelWithIcons(text) {\r\n    const firstIconIndex = text.indexOf(iconStartMarker);\r\n    if (firstIconIndex === -1) {\r\n        return { text }; // return early if the word does not include an icon\r\n    }\r\n    return doParseLabelWithIcons(text, firstIconIndex);\r\n}\r\nfunction doParseLabelWithIcons(text, firstIconIndex) {\r\n    const iconOffsets = [];\r\n    let textWithoutIcons = '';\r\n    function appendChars(chars) {\r\n        if (chars) {\r\n            textWithoutIcons += chars;\r\n            for (const _ of chars) {\r\n                iconOffsets.push(iconsOffset); // make sure to fill in icon offsets\r\n            }\r\n        }\r\n    }\r\n    let currentIconStart = -1;\r\n    let currentIconValue = '';\r\n    let iconsOffset = 0;\r\n    let char;\r\n    let nextChar;\r\n    let offset = firstIconIndex;\r\n    const length = text.length;\r\n    // Append all characters until the first icon\r\n    appendChars(text.substr(0, firstIconIndex));\r\n    // example: $(file-symlink-file) my cool $(other-icon) entry\r\n    while (offset < length) {\r\n        char = text[offset];\r\n        nextChar = text[offset + 1];\r\n        // beginning of icon: some value $( <--\r\n        if (char === iconStartMarker[0] && nextChar === iconStartMarker[1]) {\r\n            currentIconStart = offset;\r\n            // if we had a previous potential icon value without\r\n            // the closing ')', it was actually not an icon and\r\n            // so we have to add it to the actual value\r\n            appendChars(currentIconValue);\r\n            currentIconValue = iconStartMarker;\r\n            offset++; // jump over '('\r\n        }\r\n        // end of icon: some value $(some-icon) <--\r\n        else if (char === ')' && currentIconStart !== -1) {\r\n            const currentIconLength = offset - currentIconStart + 1; // +1 to include the closing ')'\r\n            iconsOffset += currentIconLength;\r\n            currentIconStart = -1;\r\n            currentIconValue = '';\r\n        }\r\n        // within icon\r\n        else if (currentIconStart !== -1) {\r\n            // Make sure this is a real icon name\r\n            if (/^[a-z0-9\\-]$/i.test(char)) {\r\n                currentIconValue += char;\r\n            }\r\n            else {\r\n                // This is not a real icon, treat it as text\r\n                appendChars(currentIconValue);\r\n                currentIconStart = -1;\r\n                currentIconValue = '';\r\n            }\r\n        }\r\n        // any value outside of icon\r\n        else {\r\n            appendChars(char);\r\n        }\r\n        offset++;\r\n    }\r\n    // if we had a previous potential icon value without\r\n    // the closing ')', it was actually not an icon and\r\n    // so we have to add it to the actual value\r\n    appendChars(currentIconValue);\r\n    return { text: textWithoutIcons, iconOffsets };\r\n}\r\nexport function matchesFuzzyIconAware(query, target, enableSeparateSubstringMatching = false) {\r\n    const { text, iconOffsets } = target;\r\n    // Return early if there are no icon markers in the word to match against\r\n    if (!iconOffsets || iconOffsets.length === 0) {\r\n        return matchesFuzzy(query, text, enableSeparateSubstringMatching);\r\n    }\r\n    // Trim the word to match against because it could have leading\r\n    // whitespace now if the word started with an icon\r\n    const wordToMatchAgainstWithoutIconsTrimmed = ltrim(text, ' ');\r\n    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutIconsTrimmed.length;\r\n    // match on value without icon\r\n    const matches = matchesFuzzy(query, wordToMatchAgainstWithoutIconsTrimmed, enableSeparateSubstringMatching);\r\n    // Map matches back to offsets with icon and trimming\r\n    if (matches) {\r\n        for (const match of matches) {\r\n            const iconOffset = iconOffsets[match.start + leadingWhitespaceOffset] /* icon offsets at index */ + leadingWhitespaceOffset /* overall leading whitespace offset */;\r\n            match.start += iconOffset;\r\n            match.end += iconOffset;\r\n        }\r\n    }\r\n    return matches;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}