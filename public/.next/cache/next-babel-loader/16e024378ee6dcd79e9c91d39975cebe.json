{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nexport var LineTokens = /*#__PURE__*/function () {\n  function LineTokens(tokens, text) {\n    _classCallCheck(this, LineTokens);\n\n    this._tokens = tokens;\n    this._tokensCount = this._tokens.length >>> 1;\n    this._text = text;\n  }\n\n  _createClass(LineTokens, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (other instanceof LineTokens) {\n        return this.slicedEquals(other, 0, this._tokensCount);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"slicedEquals\",\n    value: function slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n      if (this._text !== other._text) {\n        return false;\n      }\n\n      if (this._tokensCount !== other._tokensCount) {\n        return false;\n      }\n\n      var from = sliceFromTokenIndex << 1;\n      var to = from + (sliceTokenCount << 1);\n\n      for (var i = from; i < to; i++) {\n        if (this._tokens[i] !== other._tokens[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent() {\n      return this._text;\n    }\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this._tokensCount;\n    }\n  }, {\n    key: \"getStartOffset\",\n    value: function getStartOffset(tokenIndex) {\n      if (tokenIndex > 0) {\n        return this._tokens[tokenIndex - 1 << 1];\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return metadata;\n    }\n  }, {\n    key: \"getLanguageId\",\n    value: function getLanguageId(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getLanguageId(metadata);\n    }\n  }, {\n    key: \"getStandardTokenType\",\n    value: function getStandardTokenType(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getTokenType(metadata);\n    }\n  }, {\n    key: \"getForeground\",\n    value: function getForeground(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getForeground(metadata);\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(tokenIndex) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n  }, {\n    key: \"getInlineStyle\",\n    value: function getInlineStyle(tokenIndex, colorMap) {\n      var metadata = this._tokens[(tokenIndex << 1) + 1];\n      return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n  }, {\n    key: \"getEndOffset\",\n    value: function getEndOffset(tokenIndex) {\n      return this._tokens[tokenIndex << 1];\n    }\n    /**\r\n     * Find the token containing offset `offset`.\r\n     * @param offset The search offset\r\n     * @return The index of the token containing the offset.\r\n     */\n\n  }, {\n    key: \"findTokenIndexAtOffset\",\n    value: function findTokenIndexAtOffset(offset) {\n      return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate() {\n      return this;\n    }\n  }, {\n    key: \"sliceAndInflate\",\n    value: function sliceAndInflate(startOffset, endOffset, deltaOffset) {\n      return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n  }], [{\n    key: \"convertToEndOffset\",\n    value: function convertToEndOffset(tokens, lineTextLength) {\n      var tokenCount = tokens.length >>> 1;\n      var lastTokenIndex = tokenCount - 1;\n\n      for (var tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n        tokens[tokenIndex << 1] = tokens[tokenIndex + 1 << 1];\n      }\n\n      tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n  }, {\n    key: \"findIndexInTokensArray\",\n    value: function findIndexInTokensArray(tokens, desiredIndex) {\n      if (tokens.length <= 2) {\n        return 0;\n      }\n\n      var low = 0;\n      var high = (tokens.length >>> 1) - 1;\n\n      while (low < high) {\n        var mid = low + Math.floor((high - low) / 2);\n        var endOffset = tokens[mid << 1];\n\n        if (endOffset === desiredIndex) {\n          return mid + 1;\n        } else if (endOffset < desiredIndex) {\n          low = mid + 1;\n        } else if (endOffset > desiredIndex) {\n          high = mid;\n        }\n      }\n\n      return low;\n    }\n  }]);\n\n  return LineTokens;\n}();\nexport var SlicedLineTokens = /*#__PURE__*/function () {\n  function SlicedLineTokens(source, startOffset, endOffset, deltaOffset) {\n    _classCallCheck(this, SlicedLineTokens);\n\n    this._source = source;\n    this._startOffset = startOffset;\n    this._endOffset = endOffset;\n    this._deltaOffset = deltaOffset;\n    this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n    this._tokensCount = 0;\n\n    for (var i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n      var tokenStartOffset = source.getStartOffset(i);\n\n      if (tokenStartOffset >= endOffset) {\n        break;\n      }\n\n      this._tokensCount++;\n    }\n  }\n\n  _createClass(SlicedLineTokens, [{\n    key: \"equals\",\n    value: function equals(other) {\n      if (other instanceof SlicedLineTokens) {\n        return this._startOffset === other._startOffset && this._endOffset === other._endOffset && this._deltaOffset === other._deltaOffset && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getCount\",\n    value: function getCount() {\n      return this._tokensCount;\n    }\n  }, {\n    key: \"getForeground\",\n    value: function getForeground(tokenIndex) {\n      return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getEndOffset\",\n    value: function getEndOffset(tokenIndex) {\n      var tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\n      return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(tokenIndex) {\n      return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n  }, {\n    key: \"getInlineStyle\",\n    value: function getInlineStyle(tokenIndex, colorMap) {\n      return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n  }, {\n    key: \"findTokenIndexAtOffset\",\n    value: function findTokenIndexAtOffset(offset) {\n      return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n  }]);\n\n  return SlicedLineTokens;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js"],"names":["TokenMetadata","LineTokens","tokens","text","_tokens","_tokensCount","length","_text","other","slicedEquals","sliceFromTokenIndex","sliceTokenCount","from","to","i","tokenIndex","metadata","getLanguageId","getTokenType","getForeground","getClassNameFromMetadata","colorMap","getInlineStyleFromMetadata","offset","findIndexInTokensArray","startOffset","endOffset","deltaOffset","SlicedLineTokens","lineTextLength","tokenCount","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","findTokenIndexAtOffset","len","getCount","tokenStartOffset","getStartOffset","tokenEndOffset","getEndOffset","min","getClassName","getInlineStyle"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TokenMetadata } from '../modes.js';\r\nexport class LineTokens {\r\n    constructor(tokens, text) {\r\n        this._tokens = tokens;\r\n        this._tokensCount = (this._tokens.length >>> 1);\r\n        this._text = text;\r\n    }\r\n    equals(other) {\r\n        if (other instanceof LineTokens) {\r\n            return this.slicedEquals(other, 0, this._tokensCount);\r\n        }\r\n        return false;\r\n    }\r\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\r\n        if (this._text !== other._text) {\r\n            return false;\r\n        }\r\n        if (this._tokensCount !== other._tokensCount) {\r\n            return false;\r\n        }\r\n        const from = (sliceFromTokenIndex << 1);\r\n        const to = from + (sliceTokenCount << 1);\r\n        for (let i = from; i < to; i++) {\r\n            if (this._tokens[i] !== other._tokens[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getLineContent() {\r\n        return this._text;\r\n    }\r\n    getCount() {\r\n        return this._tokensCount;\r\n    }\r\n    getStartOffset(tokenIndex) {\r\n        if (tokenIndex > 0) {\r\n            return this._tokens[(tokenIndex - 1) << 1];\r\n        }\r\n        return 0;\r\n    }\r\n    getMetadata(tokenIndex) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return metadata;\r\n    }\r\n    getLanguageId(tokenIndex) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getLanguageId(metadata);\r\n    }\r\n    getStandardTokenType(tokenIndex) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getTokenType(metadata);\r\n    }\r\n    getForeground(tokenIndex) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getForeground(metadata);\r\n    }\r\n    getClassName(tokenIndex) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getClassNameFromMetadata(metadata);\r\n    }\r\n    getInlineStyle(tokenIndex, colorMap) {\r\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\r\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\r\n    }\r\n    getEndOffset(tokenIndex) {\r\n        return this._tokens[tokenIndex << 1];\r\n    }\r\n    /**\r\n     * Find the token containing offset `offset`.\r\n     * @param offset The search offset\r\n     * @return The index of the token containing the offset.\r\n     */\r\n    findTokenIndexAtOffset(offset) {\r\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\r\n    }\r\n    inflate() {\r\n        return this;\r\n    }\r\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\r\n        return new SlicedLineTokens(this, startOffset, endOffset, deltaOffset);\r\n    }\r\n    static convertToEndOffset(tokens, lineTextLength) {\r\n        const tokenCount = (tokens.length >>> 1);\r\n        const lastTokenIndex = tokenCount - 1;\r\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\r\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\r\n        }\r\n        tokens[lastTokenIndex << 1] = lineTextLength;\r\n    }\r\n    static findIndexInTokensArray(tokens, desiredIndex) {\r\n        if (tokens.length <= 2) {\r\n            return 0;\r\n        }\r\n        let low = 0;\r\n        let high = (tokens.length >>> 1) - 1;\r\n        while (low < high) {\r\n            const mid = low + Math.floor((high - low) / 2);\r\n            const endOffset = tokens[(mid << 1)];\r\n            if (endOffset === desiredIndex) {\r\n                return mid + 1;\r\n            }\r\n            else if (endOffset < desiredIndex) {\r\n                low = mid + 1;\r\n            }\r\n            else if (endOffset > desiredIndex) {\r\n                high = mid;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n}\r\nexport class SlicedLineTokens {\r\n    constructor(source, startOffset, endOffset, deltaOffset) {\r\n        this._source = source;\r\n        this._startOffset = startOffset;\r\n        this._endOffset = endOffset;\r\n        this._deltaOffset = deltaOffset;\r\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\r\n        this._tokensCount = 0;\r\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\r\n            const tokenStartOffset = source.getStartOffset(i);\r\n            if (tokenStartOffset >= endOffset) {\r\n                break;\r\n            }\r\n            this._tokensCount++;\r\n        }\r\n    }\r\n    equals(other) {\r\n        if (other instanceof SlicedLineTokens) {\r\n            return (this._startOffset === other._startOffset\r\n                && this._endOffset === other._endOffset\r\n                && this._deltaOffset === other._deltaOffset\r\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\r\n        }\r\n        return false;\r\n    }\r\n    getCount() {\r\n        return this._tokensCount;\r\n    }\r\n    getForeground(tokenIndex) {\r\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\r\n    }\r\n    getEndOffset(tokenIndex) {\r\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\r\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\r\n    }\r\n    getClassName(tokenIndex) {\r\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\r\n    }\r\n    getInlineStyle(tokenIndex, colorMap) {\r\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\r\n    }\r\n    findTokenIndexAtOffset(offset) {\r\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}