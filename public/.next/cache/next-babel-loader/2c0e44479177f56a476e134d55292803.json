{"ast":null,"code":"import _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { Iterable } from './iterator.js';\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\n\nvar TRACK_DISPOSABLES = false;\nvar disposableTracker = null;\n\nif (TRACK_DISPOSABLES) {\n  var __is_disposable_tracked__ = '__is_disposable_tracked__';\n  disposableTracker = new ( /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n    }\n\n    _createClass(_class, [{\n      key: \"trackDisposable\",\n      value: function trackDisposable(x) {\n        var stack = new Error('Potentially leaked disposable').stack;\n        setTimeout(function () {\n          if (!x[__is_disposable_tracked__]) {\n            console.log(stack);\n          }\n        }, 3000);\n      }\n    }, {\n      key: \"markTracked\",\n      value: function markTracked(x) {\n        if (x && x !== Disposable.None) {\n          try {\n            x[__is_disposable_tracked__] = true;\n          } catch (_a) {// noop\n          }\n        }\n      }\n    }]);\n\n    return _class;\n  }())();\n}\n\nfunction markTracked(x) {\n  if (!disposableTracker) {\n    return;\n  }\n\n  disposableTracker.markTracked(x);\n}\n\nexport function trackDisposable(x) {\n  if (!disposableTracker) {\n    return x;\n  }\n\n  disposableTracker.trackDisposable(x);\n  return x;\n}\nexport var MultiDisposeError = /*#__PURE__*/function (_Error) {\n  _inherits(MultiDisposeError, _Error);\n\n  var _super = _createSuper(MultiDisposeError);\n\n  function MultiDisposeError(errors) {\n    var _this;\n\n    _classCallCheck(this, MultiDisposeError);\n\n    _this = _super.call(this, \"Encounter errors while disposing of store. Errors: [\".concat(errors.join(', '), \"]\"));\n    _this.errors = errors;\n    return _this;\n  }\n\n  return MultiDisposeError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nexport function isDisposable(thing) {\n  return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n  if (Iterable.is(arg)) {\n    var errors = [];\n\n    var _iterator = _createForOfIteratorHelper(arg),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var d = _step.value;\n\n        if (d) {\n          markTracked(d);\n\n          try {\n            d.dispose();\n          } catch (e) {\n            errors.push(e);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new MultiDisposeError(errors);\n    }\n\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    markTracked(arg);\n    arg.dispose();\n    return arg;\n  }\n}\nexport function combinedDisposable() {\n  for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {\n    disposables[_key] = arguments[_key];\n  }\n\n  disposables.forEach(markTracked);\n  return toDisposable(function () {\n    return dispose(disposables);\n  });\n}\nexport function toDisposable(fn) {\n  var self = trackDisposable({\n    dispose: function dispose() {\n      markTracked(self);\n      fn();\n    }\n  });\n  return self;\n}\nexport var DisposableStore = /*#__PURE__*/function () {\n  function DisposableStore() {\n    _classCallCheck(this, DisposableStore);\n\n    this._toDispose = new Set();\n    this._isDisposed = false;\n  }\n  /**\r\n   * Dispose of all registered disposables and mark this object as disposed.\r\n   *\r\n   * Any future disposables added to this object will be disposed of on `add`.\r\n   */\n\n\n  _createClass(DisposableStore, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this._isDisposed) {\n        return;\n      }\n\n      markTracked(this);\n      this._isDisposed = true;\n      this.clear();\n    }\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      try {\n        dispose(this._toDispose.values());\n      } finally {\n        this._toDispose.clear();\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(t) {\n      if (!t) {\n        return t;\n      }\n\n      if (t === this) {\n        throw new Error('Cannot register a disposable on itself!');\n      }\n\n      markTracked(t);\n\n      if (this._isDisposed) {\n        if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n          console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n        }\n      } else {\n        this._toDispose.add(t);\n      }\n\n      return t;\n    }\n  }]);\n\n  return DisposableStore;\n}();\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport var Disposable = /*#__PURE__*/function () {\n  function Disposable() {\n    _classCallCheck(this, Disposable);\n\n    this._store = new DisposableStore();\n    trackDisposable(this);\n  }\n\n  _createClass(Disposable, [{\n    key: \"dispose\",\n    value: function dispose() {\n      markTracked(this);\n\n      this._store.dispose();\n    }\n  }, {\n    key: \"_register\",\n    value: function _register(t) {\n      if (t === this) {\n        throw new Error('Cannot register a disposable on itself!');\n      }\n\n      return this._store.add(t);\n    }\n  }]);\n\n  return Disposable;\n}();\nDisposable.None = Object.freeze({\n  dispose: function dispose() {}\n});\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\n\nexport var MutableDisposable = /*#__PURE__*/function () {\n  function MutableDisposable() {\n    _classCallCheck(this, MutableDisposable);\n\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n\n  _createClass(MutableDisposable, [{\n    key: \"clear\",\n    value: function clear() {\n      this.value = undefined;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._isDisposed = true;\n      markTracked(this);\n\n      if (this._value) {\n        this._value.dispose();\n      }\n\n      this._value = undefined;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._isDisposed ? undefined : this._value;\n    },\n    set: function set(value) {\n      if (this._isDisposed || value === this._value) {\n        return;\n      }\n\n      if (this._value) {\n        this._value.dispose();\n      }\n\n      if (value) {\n        markTracked(value);\n      }\n\n      this._value = value;\n    }\n  }]);\n\n  return MutableDisposable;\n}();\nexport var ImmortalReference = /*#__PURE__*/function () {\n  function ImmortalReference(object) {\n    _classCallCheck(this, ImmortalReference);\n\n    this.object = object;\n  }\n\n  _createClass(ImmortalReference, [{\n    key: \"dispose\",\n    value: function dispose() {}\n  }]);\n\n  return ImmortalReference;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js"],"names":["Iterable","TRACK_DISPOSABLES","disposableTracker","__is_disposable_tracked__","x","stack","Error","setTimeout","console","log","Disposable","None","_a","markTracked","trackDisposable","MultiDisposeError","errors","join","isDisposable","thing","dispose","length","arg","is","d","e","push","Array","isArray","combinedDisposable","disposables","forEach","toDisposable","fn","self","DisposableStore","_toDispose","Set","_isDisposed","clear","values","t","DISABLE_DISPOSED_WARNING","warn","add","_store","Object","freeze","MutableDisposable","value","undefined","_value","ImmortalReference","object"],"mappings":"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","sourcesContent":["import { Iterable } from './iterator.js';\r\n/**\r\n * Enables logging of potentially leaked disposables.\r\n *\r\n * A disposable is considered leaked if it is not disposed or not registered as the child of\r\n * another disposable. This tracking is very simple an only works for classes that either\r\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\r\n */\r\nconst TRACK_DISPOSABLES = false;\r\nlet disposableTracker = null;\r\nif (TRACK_DISPOSABLES) {\r\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\r\n    disposableTracker = new class {\r\n        trackDisposable(x) {\r\n            const stack = new Error('Potentially leaked disposable').stack;\r\n            setTimeout(() => {\r\n                if (!x[__is_disposable_tracked__]) {\r\n                    console.log(stack);\r\n                }\r\n            }, 3000);\r\n        }\r\n        markTracked(x) {\r\n            if (x && x !== Disposable.None) {\r\n                try {\r\n                    x[__is_disposable_tracked__] = true;\r\n                }\r\n                catch (_a) {\r\n                    // noop\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction markTracked(x) {\r\n    if (!disposableTracker) {\r\n        return;\r\n    }\r\n    disposableTracker.markTracked(x);\r\n}\r\nexport function trackDisposable(x) {\r\n    if (!disposableTracker) {\r\n        return x;\r\n    }\r\n    disposableTracker.trackDisposable(x);\r\n    return x;\r\n}\r\nexport class MultiDisposeError extends Error {\r\n    constructor(errors) {\r\n        super(`Encounter errors while disposing of store. Errors: [${errors.join(', ')}]`);\r\n        this.errors = errors;\r\n    }\r\n}\r\nexport function isDisposable(thing) {\r\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\r\n}\r\nexport function dispose(arg) {\r\n    if (Iterable.is(arg)) {\r\n        let errors = [];\r\n        for (const d of arg) {\r\n            if (d) {\r\n                markTracked(d);\r\n                try {\r\n                    d.dispose();\r\n                }\r\n                catch (e) {\r\n                    errors.push(e);\r\n                }\r\n            }\r\n        }\r\n        if (errors.length === 1) {\r\n            throw errors[0];\r\n        }\r\n        else if (errors.length > 1) {\r\n            throw new MultiDisposeError(errors);\r\n        }\r\n        return Array.isArray(arg) ? [] : arg;\r\n    }\r\n    else if (arg) {\r\n        markTracked(arg);\r\n        arg.dispose();\r\n        return arg;\r\n    }\r\n}\r\nexport function combinedDisposable(...disposables) {\r\n    disposables.forEach(markTracked);\r\n    return toDisposable(() => dispose(disposables));\r\n}\r\nexport function toDisposable(fn) {\r\n    const self = trackDisposable({\r\n        dispose: () => {\r\n            markTracked(self);\r\n            fn();\r\n        }\r\n    });\r\n    return self;\r\n}\r\nexport class DisposableStore {\r\n    constructor() {\r\n        this._toDispose = new Set();\r\n        this._isDisposed = false;\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables and mark this object as disposed.\r\n     *\r\n     * Any future disposables added to this object will be disposed of on `add`.\r\n     */\r\n    dispose() {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        markTracked(this);\r\n        this._isDisposed = true;\r\n        this.clear();\r\n    }\r\n    /**\r\n     * Dispose of all registered disposables but do not mark this object as disposed.\r\n     */\r\n    clear() {\r\n        try {\r\n            dispose(this._toDispose.values());\r\n        }\r\n        finally {\r\n            this._toDispose.clear();\r\n        }\r\n    }\r\n    add(t) {\r\n        if (!t) {\r\n            return t;\r\n        }\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        markTracked(t);\r\n        if (this._isDisposed) {\r\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\r\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\r\n            }\r\n        }\r\n        else {\r\n            this._toDispose.add(t);\r\n        }\r\n        return t;\r\n    }\r\n}\r\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\r\nexport class Disposable {\r\n    constructor() {\r\n        this._store = new DisposableStore();\r\n        trackDisposable(this);\r\n    }\r\n    dispose() {\r\n        markTracked(this);\r\n        this._store.dispose();\r\n    }\r\n    _register(t) {\r\n        if (t === this) {\r\n            throw new Error('Cannot register a disposable on itself!');\r\n        }\r\n        return this._store.add(t);\r\n    }\r\n}\r\nDisposable.None = Object.freeze({ dispose() { } });\r\n/**\r\n * Manages the lifecycle of a disposable value that may be changed.\r\n *\r\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\r\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\r\n */\r\nexport class MutableDisposable {\r\n    constructor() {\r\n        this._isDisposed = false;\r\n        trackDisposable(this);\r\n    }\r\n    get value() {\r\n        return this._isDisposed ? undefined : this._value;\r\n    }\r\n    set value(value) {\r\n        if (this._isDisposed || value === this._value) {\r\n            return;\r\n        }\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        if (value) {\r\n            markTracked(value);\r\n        }\r\n        this._value = value;\r\n    }\r\n    clear() {\r\n        this.value = undefined;\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        markTracked(this);\r\n        if (this._value) {\r\n            this._value.dispose();\r\n        }\r\n        this._value = undefined;\r\n    }\r\n}\r\nexport class ImmortalReference {\r\n    constructor(object) {\r\n        this.object = object;\r\n    }\r\n    dispose() { }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}