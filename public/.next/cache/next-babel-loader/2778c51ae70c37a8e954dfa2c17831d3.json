{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { EditOperation } from '../../common/core/editOperation.js';\nimport { Range } from '../../common/core/range.js';\nexport var FormattingEdit = /*#__PURE__*/function () {\n  function FormattingEdit() {\n    _classCallCheck(this, FormattingEdit);\n  }\n\n  _createClass(FormattingEdit, null, [{\n    key: \"_handleEolEdits\",\n    value: function _handleEolEdits(editor, edits) {\n      var newEol = undefined;\n      var singleEdits = [];\n\n      var _iterator = _createForOfIteratorHelper(edits),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var edit = _step.value;\n\n          if (typeof edit.eol === 'number') {\n            newEol = edit.eol;\n          }\n\n          if (edit.range && typeof edit.text === 'string') {\n            singleEdits.push(edit);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (typeof newEol === 'number') {\n        if (editor.hasModel()) {\n          editor.getModel().pushEOL(newEol);\n        }\n      }\n\n      return singleEdits;\n    }\n  }, {\n    key: \"_isFullModelReplaceEdit\",\n    value: function _isFullModelReplaceEdit(editor, edit) {\n      if (!editor.hasModel()) {\n        return false;\n      }\n\n      var model = editor.getModel();\n      var editRange = model.validateRange(edit.range);\n      var fullModelRange = model.getFullModelRange();\n      return fullModelRange.equalsRange(editRange);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(editor, _edits, addUndoStops) {\n      if (addUndoStops) {\n        editor.pushUndoStop();\n      }\n\n      var edits = FormattingEdit._handleEolEdits(editor, _edits);\n\n      if (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor, edits[0])) {\n        // We use replace semantics and hope that markers stay put...\n        editor.executeEdits('formatEditsCommand', edits.map(function (edit) {\n          return EditOperation.replace(Range.lift(edit.range), edit.text);\n        }));\n      } else {\n        editor.executeEdits('formatEditsCommand', edits.map(function (edit) {\n          return EditOperation.replaceMove(Range.lift(edit.range), edit.text);\n        }));\n      }\n\n      if (addUndoStops) {\n        editor.pushUndoStop();\n      }\n    }\n  }]);\n\n  return FormattingEdit;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/contrib/format/formattingEdit.js"],"names":["EditOperation","Range","FormattingEdit","editor","edits","newEol","undefined","singleEdits","edit","eol","range","text","push","hasModel","getModel","pushEOL","model","editRange","validateRange","fullModelRange","getFullModelRange","equalsRange","_edits","addUndoStops","pushUndoStop","_handleEolEdits","length","_isFullModelReplaceEdit","executeEdits","map","replace","lift","replaceMove"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA,SAASA,aAAT,QAA8B,oCAA9B;AACA,SAASC,KAAT,QAAsB,4BAAtB;AACA,WAAaC,cAAb;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,oCAC2BC,MAD3B,EACmCC,KADnC,EAC0C;AAClC,UAAIC,MAAM,GAAGC,SAAb;AACA,UAAIC,WAAW,GAAG,EAAlB;;AAFkC,iDAGjBH,KAHiB;AAAA;;AAAA;AAGlC,4DAAwB;AAAA,cAAfI,IAAe;;AACpB,cAAI,OAAOA,IAAI,CAACC,GAAZ,KAAoB,QAAxB,EAAkC;AAC9BJ,YAAAA,MAAM,GAAGG,IAAI,CAACC,GAAd;AACH;;AACD,cAAID,IAAI,CAACE,KAAL,IAAc,OAAOF,IAAI,CAACG,IAAZ,KAAqB,QAAvC,EAAiD;AAC7CJ,YAAAA,WAAW,CAACK,IAAZ,CAAiBJ,IAAjB;AACH;AACJ;AAViC;AAAA;AAAA;AAAA;AAAA;;AAWlC,UAAI,OAAOH,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,YAAIF,MAAM,CAACU,QAAP,EAAJ,EAAuB;AACnBV,UAAAA,MAAM,CAACW,QAAP,GAAkBC,OAAlB,CAA0BV,MAA1B;AACH;AACJ;;AACD,aAAOE,WAAP;AACH;AAlBL;AAAA;AAAA,4CAmBmCJ,MAnBnC,EAmB2CK,IAnB3C,EAmBiD;AACzC,UAAI,CAACL,MAAM,CAACU,QAAP,EAAL,EAAwB;AACpB,eAAO,KAAP;AACH;;AACD,UAAMG,KAAK,GAAGb,MAAM,CAACW,QAAP,EAAd;AACA,UAAMG,SAAS,GAAGD,KAAK,CAACE,aAAN,CAAoBV,IAAI,CAACE,KAAzB,CAAlB;AACA,UAAMS,cAAc,GAAGH,KAAK,CAACI,iBAAN,EAAvB;AACA,aAAOD,cAAc,CAACE,WAAf,CAA2BJ,SAA3B,CAAP;AACH;AA3BL;AAAA;AAAA,4BA4BmBd,MA5BnB,EA4B2BmB,MA5B3B,EA4BmCC,YA5BnC,EA4BiD;AACzC,UAAIA,YAAJ,EAAkB;AACdpB,QAAAA,MAAM,CAACqB,YAAP;AACH;;AACD,UAAMpB,KAAK,GAAGF,cAAc,CAACuB,eAAf,CAA+BtB,MAA/B,EAAuCmB,MAAvC,CAAd;;AACA,UAAIlB,KAAK,CAACsB,MAAN,KAAiB,CAAjB,IAAsBxB,cAAc,CAACyB,uBAAf,CAAuCxB,MAAvC,EAA+CC,KAAK,CAAC,CAAD,CAApD,CAA1B,EAAoF;AAChF;AACAD,QAAAA,MAAM,CAACyB,YAAP,CAAoB,oBAApB,EAA0CxB,KAAK,CAACyB,GAAN,CAAU,UAAArB,IAAI;AAAA,iBAAIR,aAAa,CAAC8B,OAAd,CAAsB7B,KAAK,CAAC8B,IAAN,CAAWvB,IAAI,CAACE,KAAhB,CAAtB,EAA8CF,IAAI,CAACG,IAAnD,CAAJ;AAAA,SAAd,CAA1C;AACH,OAHD,MAIK;AACDR,QAAAA,MAAM,CAACyB,YAAP,CAAoB,oBAApB,EAA0CxB,KAAK,CAACyB,GAAN,CAAU,UAAArB,IAAI;AAAA,iBAAIR,aAAa,CAACgC,WAAd,CAA0B/B,KAAK,CAAC8B,IAAN,CAAWvB,IAAI,CAACE,KAAhB,CAA1B,EAAkDF,IAAI,CAACG,IAAvD,CAAJ;AAAA,SAAd,CAA1C;AACH;;AACD,UAAIY,YAAJ,EAAkB;AACdpB,QAAAA,MAAM,CAACqB,YAAP;AACH;AACJ;AA3CL;;AAAA;AAAA","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { EditOperation } from '../../common/core/editOperation.js';\r\nimport { Range } from '../../common/core/range.js';\r\nexport class FormattingEdit {\r\n    static _handleEolEdits(editor, edits) {\r\n        let newEol = undefined;\r\n        let singleEdits = [];\r\n        for (let edit of edits) {\r\n            if (typeof edit.eol === 'number') {\r\n                newEol = edit.eol;\r\n            }\r\n            if (edit.range && typeof edit.text === 'string') {\r\n                singleEdits.push(edit);\r\n            }\r\n        }\r\n        if (typeof newEol === 'number') {\r\n            if (editor.hasModel()) {\r\n                editor.getModel().pushEOL(newEol);\r\n            }\r\n        }\r\n        return singleEdits;\r\n    }\r\n    static _isFullModelReplaceEdit(editor, edit) {\r\n        if (!editor.hasModel()) {\r\n            return false;\r\n        }\r\n        const model = editor.getModel();\r\n        const editRange = model.validateRange(edit.range);\r\n        const fullModelRange = model.getFullModelRange();\r\n        return fullModelRange.equalsRange(editRange);\r\n    }\r\n    static execute(editor, _edits, addUndoStops) {\r\n        if (addUndoStops) {\r\n            editor.pushUndoStop();\r\n        }\r\n        const edits = FormattingEdit._handleEolEdits(editor, _edits);\r\n        if (edits.length === 1 && FormattingEdit._isFullModelReplaceEdit(editor, edits[0])) {\r\n            // We use replace semantics and hope that markers stay put...\r\n            editor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)));\r\n        }\r\n        else {\r\n            editor.executeEdits('formatEditsCommand', edits.map(edit => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));\r\n        }\r\n        if (addUndoStops) {\r\n            editor.pushUndoStop();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}