{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _assertThisInitialized from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport * as model from '../model.js';\nimport { EditStack } from './editStack.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { getWordAtText } from './wordHelper.js';\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\nimport { ignoreBracketsInToken } from '../modes/supports.js';\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\nimport { Color } from '../../../base/common/color.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\n\nfunction createTextBufferBuilder() {\n  return new PieceTreeTextBufferBuilder();\n}\n\nexport function createTextBufferFactory(text) {\n  var builder = createTextBufferBuilder();\n  builder.acceptChunk(text);\n  return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n  var factory = typeof value === 'string' ? createTextBufferFactory(value) : value;\n  return factory.create(defaultEOL);\n}\nvar MODEL_ID = 0;\nvar LIMIT_FIND_COUNT = 999;\nexport var LONG_LINE_BOUNDARY = 10000;\n\nvar TextModelSnapshot = /*#__PURE__*/function () {\n  function TextModelSnapshot(source) {\n    _classCallCheck(this, TextModelSnapshot);\n\n    this._source = source;\n    this._eos = false;\n  }\n\n  _createClass(TextModelSnapshot, [{\n    key: \"read\",\n    value: function read() {\n      if (this._eos) {\n        return null;\n      }\n\n      var result = [],\n          resultCnt = 0,\n          resultLength = 0;\n\n      do {\n        var tmp = this._source.read();\n\n        if (tmp === null) {\n          // end-of-stream\n          this._eos = true;\n\n          if (resultCnt === 0) {\n            return null;\n          } else {\n            return result.join('');\n          }\n        }\n\n        if (tmp.length > 0) {\n          result[resultCnt++] = tmp;\n          resultLength += tmp.length;\n        }\n\n        if (resultLength >= 64 * 1024) {\n          return result.join('');\n        }\n      } while (true);\n    }\n  }]);\n\n  return TextModelSnapshot;\n}();\n\nvar invalidFunc = function invalidFunc() {\n  throw new Error(\"Invalid change accessor\");\n};\n\nvar BracketSearchCanceled = function BracketSearchCanceled() {\n  _classCallCheck(this, BracketSearchCanceled);\n\n  this._searchCanceledBrand = undefined;\n};\n\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\n\nfunction stripBracketSearchCanceled(result) {\n  if (result instanceof BracketSearchCanceled) {\n    return null;\n  }\n\n  return result;\n}\n\nexport var TextModel = /*#__PURE__*/function (_Disposable) {\n  _inherits(TextModel, _Disposable);\n\n  var _super = _createSuper(TextModel);\n\n  //#endregion\n  function TextModel(source, creationOptions, languageIdentifier) {\n    var _this;\n\n    var associatedResource = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var undoRedoService = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, TextModel);\n\n    _this = _super.call(this); //#region Events\n\n    _this._onWillDispose = _this._register(new Emitter());\n    _this.onWillDispose = _this._onWillDispose.event;\n    _this._onDidChangeDecorations = _this._register(new DidChangeDecorationsEmitter());\n    _this.onDidChangeDecorations = _this._onDidChangeDecorations.event;\n    _this._onDidChangeLanguage = _this._register(new Emitter());\n    _this.onDidChangeLanguage = _this._onDidChangeLanguage.event;\n    _this._onDidChangeLanguageConfiguration = _this._register(new Emitter());\n    _this.onDidChangeLanguageConfiguration = _this._onDidChangeLanguageConfiguration.event;\n    _this._onDidChangeTokens = _this._register(new Emitter());\n    _this.onDidChangeTokens = _this._onDidChangeTokens.event;\n    _this._onDidChangeOptions = _this._register(new Emitter());\n    _this.onDidChangeOptions = _this._onDidChangeOptions.event;\n    _this._onDidChangeAttached = _this._register(new Emitter());\n    _this.onDidChangeAttached = _this._onDidChangeAttached.event;\n    _this._eventEmitter = _this._register(new DidChangeContentEmitter()); // Generate a new unique model id\n\n    MODEL_ID++;\n    _this.id = '$model' + MODEL_ID;\n    _this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n\n    if (typeof associatedResource === 'undefined' || associatedResource === null) {\n      _this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n    } else {\n      _this._associatedResource = associatedResource;\n    }\n\n    _this._undoRedoService = undoRedoService;\n    _this._attachedEditorCount = 0;\n\n    var _createTextBuffer = createTextBuffer(source, creationOptions.defaultEOL),\n        textBuffer = _createTextBuffer.textBuffer,\n        disposable = _createTextBuffer.disposable;\n\n    _this._buffer = textBuffer;\n    _this._bufferDisposable = disposable;\n    _this._options = TextModel.resolveOptions(_this._buffer, creationOptions);\n\n    var bufferLineCount = _this._buffer.getLineCount();\n\n    var bufferTextLength = _this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, _this._buffer.getLineLength(bufferLineCount) + 1), 0\n    /* TextDefined */\n    ); // !!! Make a decision in the ctor and permanently respect this decision !!!\n    // If a model is too large at construction time, it will never get tokenized,\n    // under no circumstances.\n\n\n    if (creationOptions.largeFileOptimizations) {\n      _this._isTooLargeForTokenization = bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD || bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD;\n    } else {\n      _this._isTooLargeForTokenization = false;\n    }\n\n    _this._isTooLargeForSyncing = bufferTextLength > TextModel.MODEL_SYNC_LIMIT;\n    _this._versionId = 1;\n    _this._alternativeVersionId = 1;\n    _this._initialUndoRedoSnapshot = null;\n    _this._isDisposed = false;\n    _this._isDisposing = false;\n    _this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\n    _this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange(function (e) {\n      if (e.languageIdentifier.id === _this._languageIdentifier.id) {\n        _this._onDidChangeLanguageConfiguration.fire({});\n      }\n    });\n    _this._instanceId = strings.singleLetterHash(MODEL_ID);\n    _this._lastDecorationId = 0;\n    _this._decorations = Object.create(null);\n    _this._decorationsTree = new DecorationsTrees();\n    _this._commandManager = new EditStack(_assertThisInitialized(_this), undoRedoService);\n    _this._isUndoing = false;\n    _this._isRedoing = false;\n    _this._trimAutoWhitespaceLines = null;\n    _this._tokens = new TokensStore();\n    _this._tokens2 = new TokensStore2();\n    _this._tokenization = new TextModelTokenization(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(TextModel, [{\n    key: \"onDidChangeRawContentFast\",\n    value: function onDidChangeRawContentFast(listener) {\n      return this._eventEmitter.fastEvent(function (e) {\n        return listener(e.rawContentChangedEvent);\n      });\n    }\n  }, {\n    key: \"onDidChangeContentFast\",\n    value: function onDidChangeContentFast(listener) {\n      return this._eventEmitter.fastEvent(function (e) {\n        return listener(e.contentChangedEvent);\n      });\n    }\n  }, {\n    key: \"onDidChangeContent\",\n    value: function onDidChangeContent(listener) {\n      return this._eventEmitter.slowEvent(function (e) {\n        return listener(e.contentChangedEvent);\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._isDisposing = true;\n\n      this._onWillDispose.fire();\n\n      this._languageRegistryListener.dispose();\n\n      this._tokenization.dispose();\n\n      this._isDisposed = true;\n\n      _get(_getPrototypeOf(TextModel.prototype), \"dispose\", this).call(this);\n\n      this._bufferDisposable.dispose();\n\n      this._isDisposing = false; // Manually release reference to previous text buffer to avoid large leaks\n      // in case someone leaks a TextModel reference\n\n      var emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n      emptyDisposedTextBuffer.dispose();\n      this._buffer = emptyDisposedTextBuffer;\n    }\n  }, {\n    key: \"_assertNotDisposed\",\n    value: function _assertNotDisposed() {\n      if (this._isDisposed) {\n        throw new Error('Model is disposed!');\n      }\n    }\n  }, {\n    key: \"_emitContentChangedEvent\",\n    value: function _emitContentChangedEvent(rawChange, change) {\n      if (this._isDisposing) {\n        // Do not confuse listeners by emitting any event after disposing\n        return;\n      }\n\n      this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this._assertNotDisposed();\n\n      if (value === null) {\n        // There's nothing to do\n        return;\n      }\n\n      var _createTextBuffer2 = createTextBuffer(value, this._options.defaultEOL),\n          textBuffer = _createTextBuffer2.textBuffer,\n          disposable = _createTextBuffer2.disposable;\n\n      this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n  }, {\n    key: \"_createContentChanged2\",\n    value: function _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n      return {\n        changes: [{\n          range: range,\n          rangeOffset: rangeOffset,\n          rangeLength: rangeLength,\n          text: text\n        }],\n        eol: this._buffer.getEOL(),\n        versionId: this.getVersionId(),\n        isUndoing: isUndoing,\n        isRedoing: isRedoing,\n        isFlush: isFlush\n      };\n    }\n  }, {\n    key: \"_setValueFromTextBuffer\",\n    value: function _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n      this._assertNotDisposed();\n\n      var oldFullModelRange = this.getFullModelRange();\n      var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n      var endLineNumber = this.getLineCount();\n      var endColumn = this.getLineMaxColumn(endLineNumber);\n      this._buffer = textBuffer;\n\n      this._bufferDisposable.dispose();\n\n      this._bufferDisposable = textBufferDisposable;\n\n      this._increaseVersionId(); // Flush all tokens\n\n\n      this._tokens.flush();\n\n      this._tokens2.flush(); // Destroy all my decorations\n\n\n      this._decorations = Object.create(null);\n      this._decorationsTree = new DecorationsTrees(); // Destroy my edit history and settings\n\n      this._commandManager.clear();\n\n      this._trimAutoWhitespaceLines = null;\n\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawFlush()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n  }, {\n    key: \"setEOL\",\n    value: function setEOL(eol) {\n      this._assertNotDisposed();\n\n      var newEOL = eol === 1\n      /* CRLF */\n      ? '\\r\\n' : '\\n';\n\n      if (this._buffer.getEOL() === newEOL) {\n        // Nothing to do\n        return;\n      }\n\n      var oldFullModelRange = this.getFullModelRange();\n      var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n      var endLineNumber = this.getLineCount();\n      var endColumn = this.getLineMaxColumn(endLineNumber);\n\n      this._onBeforeEOLChange();\n\n      this._buffer.setEOL(newEOL);\n\n      this._increaseVersionId();\n\n      this._onAfterEOLChange();\n\n      this._emitContentChangedEvent(new ModelRawContentChangedEvent([new ModelRawEOLChanged()], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n  }, {\n    key: \"_onBeforeEOLChange\",\n    value: function _onBeforeEOLChange() {\n      // Ensure all decorations get their `range` set.\n      var versionId = this.getVersionId();\n\n      var allDecorations = this._decorationsTree.search(0, false, false, versionId);\n\n      this._ensureNodesHaveRanges(allDecorations);\n    }\n  }, {\n    key: \"_onAfterEOLChange\",\n    value: function _onAfterEOLChange() {\n      // Transform back `range` to offsets\n      var versionId = this.getVersionId();\n\n      var allDecorations = this._decorationsTree.collectNodesPostOrder();\n\n      for (var i = 0, len = allDecorations.length; i < len; i++) {\n        var node = allDecorations[i];\n        var delta = node.cachedAbsoluteStart - node.start;\n\n        var startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\n\n        var endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\n\n        node.cachedAbsoluteStart = startOffset;\n        node.cachedAbsoluteEnd = endOffset;\n        node.cachedVersionId = versionId;\n        node.start = startOffset - delta;\n        node.end = endOffset - delta;\n        recomputeMaxEnd(node);\n      }\n    }\n  }, {\n    key: \"onBeforeAttached\",\n    value: function onBeforeAttached() {\n      this._attachedEditorCount++;\n\n      if (this._attachedEditorCount === 1) {\n        this._onDidChangeAttached.fire(undefined);\n      }\n    }\n  }, {\n    key: \"onBeforeDetached\",\n    value: function onBeforeDetached() {\n      this._attachedEditorCount--;\n\n      if (this._attachedEditorCount === 0) {\n        this._onDidChangeAttached.fire(undefined);\n      }\n    }\n  }, {\n    key: \"isAttachedToEditor\",\n    value: function isAttachedToEditor() {\n      return this._attachedEditorCount > 0;\n    }\n  }, {\n    key: \"getAttachedEditorCount\",\n    value: function getAttachedEditorCount() {\n      return this._attachedEditorCount;\n    }\n  }, {\n    key: \"isTooLargeForSyncing\",\n    value: function isTooLargeForSyncing() {\n      return this._isTooLargeForSyncing;\n    }\n  }, {\n    key: \"isTooLargeForTokenization\",\n    value: function isTooLargeForTokenization() {\n      return this._isTooLargeForTokenization;\n    }\n  }, {\n    key: \"isDisposed\",\n    value: function isDisposed() {\n      return this._isDisposed;\n    }\n  }, {\n    key: \"isDominatedByLongLines\",\n    value: function isDominatedByLongLines() {\n      this._assertNotDisposed();\n\n      if (this.isTooLargeForTokenization()) {\n        // Cannot word wrap huge files anyways, so it doesn't really matter\n        return false;\n      }\n\n      var smallLineCharCount = 0;\n      var longLineCharCount = 0;\n\n      var lineCount = this._buffer.getLineCount();\n\n      for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n        var lineLength = this._buffer.getLineLength(lineNumber);\n\n        if (lineLength >= LONG_LINE_BOUNDARY) {\n          longLineCharCount += lineLength;\n        } else {\n          smallLineCharCount += lineLength;\n        }\n      }\n\n      return longLineCharCount > smallLineCharCount;\n    }\n  }, {\n    key: \"getOptions\",\n    //#region Options\n    value: function getOptions() {\n      this._assertNotDisposed();\n\n      return this._options;\n    }\n  }, {\n    key: \"getFormattingOptions\",\n    value: function getFormattingOptions() {\n      return {\n        tabSize: this._options.indentSize,\n        insertSpaces: this._options.insertSpaces\n      };\n    }\n  }, {\n    key: \"updateOptions\",\n    value: function updateOptions(_newOpts) {\n      this._assertNotDisposed();\n\n      var tabSize = typeof _newOpts.tabSize !== 'undefined' ? _newOpts.tabSize : this._options.tabSize;\n      var indentSize = typeof _newOpts.indentSize !== 'undefined' ? _newOpts.indentSize : this._options.indentSize;\n      var insertSpaces = typeof _newOpts.insertSpaces !== 'undefined' ? _newOpts.insertSpaces : this._options.insertSpaces;\n      var trimAutoWhitespace = typeof _newOpts.trimAutoWhitespace !== 'undefined' ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n      var newOpts = new model.TextModelResolvedOptions({\n        tabSize: tabSize,\n        indentSize: indentSize,\n        insertSpaces: insertSpaces,\n        defaultEOL: this._options.defaultEOL,\n        trimAutoWhitespace: trimAutoWhitespace\n      });\n\n      if (this._options.equals(newOpts)) {\n        return;\n      }\n\n      var e = this._options.createChangeEvent(newOpts);\n\n      this._options = newOpts;\n\n      this._onDidChangeOptions.fire(e);\n    }\n  }, {\n    key: \"detectIndentation\",\n    value: function detectIndentation(defaultInsertSpaces, defaultTabSize) {\n      this._assertNotDisposed();\n\n      var guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n      this.updateOptions({\n        insertSpaces: guessedIndentation.insertSpaces,\n        tabSize: guessedIndentation.tabSize,\n        indentSize: guessedIndentation.tabSize // TODO@Alex: guess indentSize independent of tabSize\n\n      });\n    }\n  }, {\n    key: \"normalizeIndentation\",\n    value: function normalizeIndentation(str) {\n      this._assertNotDisposed();\n\n      return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    } //#endregion\n    //#region Reading\n\n  }, {\n    key: \"getVersionId\",\n    value: function getVersionId() {\n      this._assertNotDisposed();\n\n      return this._versionId;\n    }\n  }, {\n    key: \"mightContainRTL\",\n    value: function mightContainRTL() {\n      return this._buffer.mightContainRTL();\n    }\n  }, {\n    key: \"mightContainUnusualLineTerminators\",\n    value: function mightContainUnusualLineTerminators() {\n      return this._buffer.mightContainUnusualLineTerminators();\n    }\n  }, {\n    key: \"removeUnusualLineTerminators\",\n    value: function removeUnusualLineTerminators() {\n      var selections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      );\n\n      this._buffer.resetMightContainUnusualLineTerminators();\n\n      this.pushEditOperations(selections, matches.map(function (m) {\n        return {\n          range: m.range,\n          text: null\n        };\n      }), function () {\n        return null;\n      });\n    }\n  }, {\n    key: \"mightContainNonBasicASCII\",\n    value: function mightContainNonBasicASCII() {\n      return this._buffer.mightContainNonBasicASCII();\n    }\n  }, {\n    key: \"getAlternativeVersionId\",\n    value: function getAlternativeVersionId() {\n      this._assertNotDisposed();\n\n      return this._alternativeVersionId;\n    }\n  }, {\n    key: \"getInitialUndoRedoSnapshot\",\n    value: function getInitialUndoRedoSnapshot() {\n      this._assertNotDisposed();\n\n      return this._initialUndoRedoSnapshot;\n    }\n  }, {\n    key: \"getOffsetAt\",\n    value: function getOffsetAt(rawPosition) {\n      this._assertNotDisposed();\n\n      var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0\n      /* Relaxed */\n      );\n\n      return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n  }, {\n    key: \"getPositionAt\",\n    value: function getPositionAt(rawOffset) {\n      this._assertNotDisposed();\n\n      var offset = Math.min(this._buffer.getLength(), Math.max(0, rawOffset));\n      return this._buffer.getPositionAt(offset);\n    }\n  }, {\n    key: \"_increaseVersionId\",\n    value: function _increaseVersionId() {\n      this._versionId = this._versionId + 1;\n      this._alternativeVersionId = this._versionId;\n    }\n  }, {\n    key: \"_overwriteVersionId\",\n    value: function _overwriteVersionId(versionId) {\n      this._versionId = versionId;\n    }\n  }, {\n    key: \"_overwriteAlternativeVersionId\",\n    value: function _overwriteAlternativeVersionId(newAlternativeVersionId) {\n      this._alternativeVersionId = newAlternativeVersionId;\n    }\n  }, {\n    key: \"_overwriteInitialUndoRedoSnapshot\",\n    value: function _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n      this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(eol) {\n      var preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._assertNotDisposed();\n\n      var fullModelRange = this.getFullModelRange();\n      var fullModelValue = this.getValueInRange(fullModelRange, eol);\n\n      if (preserveBOM) {\n        return this._buffer.getBOM() + fullModelValue;\n      }\n\n      return fullModelValue;\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot() {\n      var preserveBOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n  }, {\n    key: \"getValueLength\",\n    value: function getValueLength(eol) {\n      var preserveBOM = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._assertNotDisposed();\n\n      var fullModelRange = this.getFullModelRange();\n      var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n\n      if (preserveBOM) {\n        return this._buffer.getBOM().length + fullModelValue;\n      }\n\n      return fullModelValue;\n    }\n  }, {\n    key: \"getValueInRange\",\n    value: function getValueInRange(rawRange)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this._assertNotDisposed();\n\n      return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n  }, {\n    key: \"getValueLengthInRange\",\n    value: function getValueLengthInRange(rawRange)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this._assertNotDisposed();\n\n      return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n  }, {\n    key: \"getCharacterCountInRange\",\n    value: function getCharacterCountInRange(rawRange)\n    /* TextDefined */\n    {\n      var eol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this._assertNotDisposed();\n\n      return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      this._assertNotDisposed();\n\n      return this._buffer.getLineCount();\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      this._assertNotDisposed();\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._buffer.getLineContent(lineNumber);\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(lineNumber) {\n      this._assertNotDisposed();\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._buffer.getLineLength(lineNumber);\n    }\n  }, {\n    key: \"getLinesContent\",\n    value: function getLinesContent() {\n      this._assertNotDisposed();\n\n      return this._buffer.getLinesContent();\n    }\n  }, {\n    key: \"getEOL\",\n    value: function getEOL() {\n      this._assertNotDisposed();\n\n      return this._buffer.getEOL();\n    }\n  }, {\n    key: \"getEndOfLineSequence\",\n    value: function getEndOfLineSequence() {\n      this._assertNotDisposed();\n\n      return this._buffer.getEOL() === '\\n' ? 0\n      /* LF */\n      : 1\n      /* CRLF */\n      ;\n    }\n  }, {\n    key: \"getLineMinColumn\",\n    value: function getLineMinColumn(lineNumber) {\n      this._assertNotDisposed();\n\n      return 1;\n    }\n  }, {\n    key: \"getLineMaxColumn\",\n    value: function getLineMaxColumn(lineNumber) {\n      this._assertNotDisposed();\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._buffer.getLineLength(lineNumber) + 1;\n    }\n  }, {\n    key: \"getLineFirstNonWhitespaceColumn\",\n    value: function getLineFirstNonWhitespaceColumn(lineNumber) {\n      this._assertNotDisposed();\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n  }, {\n    key: \"getLineLastNonWhitespaceColumn\",\n    value: function getLineLastNonWhitespaceColumn(lineNumber) {\n      this._assertNotDisposed();\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\r\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\r\n     * Will try to not allocate if possible.\r\n     */\n\n  }, {\n    key: \"_validateRangeRelaxedNoAllocations\",\n    value: function _validateRangeRelaxedNoAllocations(range) {\n      var linesCount = this._buffer.getLineCount();\n\n      var initialStartLineNumber = range.startLineNumber;\n      var initialStartColumn = range.startColumn;\n      var startLineNumber;\n      var startColumn;\n\n      if (initialStartLineNumber < 1) {\n        startLineNumber = 1;\n        startColumn = 1;\n      } else if (initialStartLineNumber > linesCount) {\n        startLineNumber = linesCount;\n        startColumn = this.getLineMaxColumn(startLineNumber);\n      } else {\n        startLineNumber = initialStartLineNumber | 0;\n\n        if (initialStartColumn <= 1) {\n          startColumn = 1;\n        } else {\n          var maxColumn = this.getLineMaxColumn(startLineNumber);\n\n          if (initialStartColumn >= maxColumn) {\n            startColumn = maxColumn;\n          } else {\n            startColumn = initialStartColumn | 0;\n          }\n        }\n      }\n\n      var initialEndLineNumber = range.endLineNumber;\n      var initialEndColumn = range.endColumn;\n      var endLineNumber;\n      var endColumn;\n\n      if (initialEndLineNumber < 1) {\n        endLineNumber = 1;\n        endColumn = 1;\n      } else if (initialEndLineNumber > linesCount) {\n        endLineNumber = linesCount;\n        endColumn = this.getLineMaxColumn(endLineNumber);\n      } else {\n        endLineNumber = initialEndLineNumber | 0;\n\n        if (initialEndColumn <= 1) {\n          endColumn = 1;\n        } else {\n          var _maxColumn = this.getLineMaxColumn(endLineNumber);\n\n          if (initialEndColumn >= _maxColumn) {\n            endColumn = _maxColumn;\n          } else {\n            endColumn = initialEndColumn | 0;\n          }\n        }\n      }\n\n      if (initialStartLineNumber === startLineNumber && initialStartColumn === startColumn && initialEndLineNumber === endLineNumber && initialEndColumn === endColumn && range instanceof Range && !(range instanceof Selection)) {\n        return range;\n      }\n\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n  }, {\n    key: \"_isValidPosition\",\n    value: function _isValidPosition(lineNumber, column, validationType) {\n      if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n        return false;\n      }\n\n      if (isNaN(lineNumber) || isNaN(column)) {\n        return false;\n      }\n\n      if (lineNumber < 1 || column < 1) {\n        return false;\n      }\n\n      if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n        return false;\n      }\n\n      var lineCount = this._buffer.getLineCount();\n\n      if (lineNumber > lineCount) {\n        return false;\n      }\n\n      if (column === 1) {\n        return true;\n      }\n\n      var maxColumn = this.getLineMaxColumn(lineNumber);\n\n      if (column > maxColumn) {\n        return false;\n      }\n\n      if (validationType === 1\n      /* SurrogatePairs */\n      ) {\n          // !!At this point, column > 1\n          var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n          if (strings.isHighSurrogate(charCodeBefore)) {\n            return false;\n          }\n        }\n\n      return true;\n    }\n  }, {\n    key: \"_validatePosition\",\n    value: function _validatePosition(_lineNumber, _column, validationType) {\n      var lineNumber = Math.floor(typeof _lineNumber === 'number' && !isNaN(_lineNumber) ? _lineNumber : 1);\n      var column = Math.floor(typeof _column === 'number' && !isNaN(_column) ? _column : 1);\n\n      var lineCount = this._buffer.getLineCount();\n\n      if (lineNumber < 1) {\n        return new Position(1, 1);\n      }\n\n      if (lineNumber > lineCount) {\n        return new Position(lineCount, this.getLineMaxColumn(lineCount));\n      }\n\n      if (column <= 1) {\n        return new Position(lineNumber, 1);\n      }\n\n      var maxColumn = this.getLineMaxColumn(lineNumber);\n\n      if (column >= maxColumn) {\n        return new Position(lineNumber, maxColumn);\n      }\n\n      if (validationType === 1\n      /* SurrogatePairs */\n      ) {\n          // If the position would end up in the middle of a high-low surrogate pair,\n          // we move it to before the pair\n          // !!At this point, column > 1\n          var charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n\n          if (strings.isHighSurrogate(charCodeBefore)) {\n            return new Position(lineNumber, column - 1);\n          }\n        }\n\n      return new Position(lineNumber, column);\n    }\n  }, {\n    key: \"validatePosition\",\n    value: function validatePosition(position) {\n      var validationType = 1\n      /* SurrogatePairs */\n      ;\n\n      this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n      if (position instanceof Position) {\n        if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n          return position;\n        }\n      }\n\n      return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n  }, {\n    key: \"_isValidRange\",\n    value: function _isValidRange(range, validationType) {\n      var startLineNumber = range.startLineNumber;\n      var startColumn = range.startColumn;\n      var endLineNumber = range.endLineNumber;\n      var endColumn = range.endColumn;\n\n      if (!this._isValidPosition(startLineNumber, startColumn, 0\n      /* Relaxed */\n      )) {\n        return false;\n      }\n\n      if (!this._isValidPosition(endLineNumber, endColumn, 0\n      /* Relaxed */\n      )) {\n        return false;\n      }\n\n      if (validationType === 1\n      /* SurrogatePairs */\n      ) {\n          var charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n          var charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n          var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n          var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n          if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n            return true;\n          }\n\n          return false;\n        }\n\n      return true;\n    }\n  }, {\n    key: \"validateRange\",\n    value: function validateRange(_range) {\n      var validationType = 1\n      /* SurrogatePairs */\n      ;\n\n      this._assertNotDisposed(); // Avoid object allocation and cover most likely case\n\n\n      if (_range instanceof Range && !(_range instanceof Selection)) {\n        if (this._isValidRange(_range, validationType)) {\n          return _range;\n        }\n      }\n\n      var start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0\n      /* Relaxed */\n      );\n\n      var end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0\n      /* Relaxed */\n      );\n\n      var startLineNumber = start.lineNumber;\n      var startColumn = start.column;\n      var endLineNumber = end.lineNumber;\n      var endColumn = end.column;\n\n      if (validationType === 1\n      /* SurrogatePairs */\n      ) {\n          var charCodeBeforeStart = startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0;\n          var charCodeBeforeEnd = endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0;\n          var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n          var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n\n          if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n          }\n\n          if (startLineNumber === endLineNumber && startColumn === endColumn) {\n            // do not expand a collapsed range, simply move it to a valid location\n            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n          }\n\n          if (startInsideSurrogatePair && endInsideSurrogatePair) {\n            // expand range at both ends\n            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n          }\n\n          if (startInsideSurrogatePair) {\n            // only expand range at the start\n            return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n          } // only expand range at the end\n\n\n          return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n\n      return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n  }, {\n    key: \"modifyPosition\",\n    value: function modifyPosition(rawPosition, offset) {\n      this._assertNotDisposed();\n\n      var candidate = this.getOffsetAt(rawPosition) + offset;\n      return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n  }, {\n    key: \"getFullModelRange\",\n    value: function getFullModelRange() {\n      this._assertNotDisposed();\n\n      var lineCount = this.getLineCount();\n      return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n  }, {\n    key: \"findMatchesLineByLine\",\n    value: function findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n      return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n  }, {\n    key: \"findMatches\",\n    value: function findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches) {\n      var _this2 = this;\n\n      var limitResultCount = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : LIMIT_FIND_COUNT;\n\n      this._assertNotDisposed();\n\n      var searchRanges = null;\n\n      if (rawSearchScope !== null) {\n        if (!Array.isArray(rawSearchScope)) {\n          rawSearchScope = [rawSearchScope];\n        }\n\n        if (rawSearchScope.every(function (searchScope) {\n          return Range.isIRange(searchScope);\n        })) {\n          searchRanges = rawSearchScope.map(function (searchScope) {\n            return _this2.validateRange(searchScope);\n          });\n        }\n      }\n\n      if (searchRanges === null) {\n        searchRanges = [this.getFullModelRange()];\n      }\n\n      searchRanges = searchRanges.sort(function (d1, d2) {\n        return d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn;\n      });\n      var uniqueSearchRanges = [];\n      uniqueSearchRanges.push(searchRanges.reduce(function (prev, curr) {\n        if (Range.areIntersecting(prev, curr)) {\n          return prev.plusRange(curr);\n        }\n\n        uniqueSearchRanges.push(prev);\n        return curr;\n      }));\n      var matchMapper;\n\n      if (!isRegex && searchString.indexOf('\\n') < 0) {\n        // not regex, not multi line\n        var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n        var searchData = searchParams.parseSearchRequest();\n\n        if (!searchData) {\n          return [];\n        }\n\n        matchMapper = function matchMapper(searchRange) {\n          return _this2.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        };\n      } else {\n        matchMapper = function matchMapper(searchRange) {\n          return TextModelSearch.findMatches(_this2, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        };\n      }\n\n      return uniqueSearchRanges.map(matchMapper).reduce(function (arr, matches) {\n        return arr.concat(matches);\n      }, []);\n    }\n  }, {\n    key: \"findNextMatch\",\n    value: function findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n      this._assertNotDisposed();\n\n      var searchStart = this.validatePosition(rawSearchStart);\n\n      if (!isRegex && searchString.indexOf('\\n') < 0) {\n        var searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n        var searchData = searchParams.parseSearchRequest();\n\n        if (!searchData) {\n          return null;\n        }\n\n        var lineCount = this.getLineCount();\n        var searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n        var ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n        TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n\n        if (ret.length > 0) {\n          return ret[0];\n        }\n\n        searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n        ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n\n        if (ret.length > 0) {\n          return ret[0];\n        }\n\n        return null;\n      }\n\n      return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n  }, {\n    key: \"findPreviousMatch\",\n    value: function findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n      this._assertNotDisposed();\n\n      var searchStart = this.validatePosition(rawSearchStart);\n      return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    } //#endregion\n    //#region Editing\n\n  }, {\n    key: \"pushStackElement\",\n    value: function pushStackElement() {\n      this._commandManager.pushStackElement();\n    }\n  }, {\n    key: \"popStackElement\",\n    value: function popStackElement() {\n      this._commandManager.popStackElement();\n    }\n  }, {\n    key: \"pushEOL\",\n    value: function pushEOL(eol) {\n      var currentEOL = this.getEOL() === '\\n' ? 0\n      /* LF */\n      : 1\n      /* CRLF */\n      ;\n\n      if (currentEOL === eol) {\n        return;\n      }\n\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        this._eventEmitter.beginDeferredEmit();\n\n        if (this._initialUndoRedoSnapshot === null) {\n          this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n\n        this._commandManager.pushEOL(eol);\n      } finally {\n        this._eventEmitter.endDeferredEmit();\n\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"_validateEditOperation\",\n    value: function _validateEditOperation(rawOperation) {\n      if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n        return rawOperation;\n      }\n\n      return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n  }, {\n    key: \"_validateEditOperations\",\n    value: function _validateEditOperations(rawOperations) {\n      var result = [];\n\n      for (var i = 0, len = rawOperations.length; i < len; i++) {\n        result[i] = this._validateEditOperation(rawOperations[i]);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"pushEditOperations\",\n    value: function pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        this._eventEmitter.beginDeferredEmit();\n\n        return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n      } finally {\n        this._eventEmitter.endDeferredEmit();\n\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"_pushEditOperations\",\n    value: function _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n      var _this3 = this;\n\n      if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n        // Go through each saved line number and insert a trim whitespace edit\n        // if it is safe to do so (no conflicts with other edits).\n        var incomingEdits = editOperations.map(function (op) {\n          return {\n            range: _this3.validateRange(op.range),\n            text: op.text\n          };\n        }); // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n        // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n\n        var editsAreNearCursors = true;\n\n        if (beforeCursorState) {\n          for (var i = 0, len = beforeCursorState.length; i < len; i++) {\n            var sel = beforeCursorState[i];\n            var foundEditNearSel = false;\n\n            for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n              var editRange = incomingEdits[j].range;\n              var selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n              var selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n\n              if (!selIsAbove && !selIsBelow) {\n                foundEditNearSel = true;\n                break;\n              }\n            }\n\n            if (!foundEditNearSel) {\n              editsAreNearCursors = false;\n              break;\n            }\n          }\n        }\n\n        if (editsAreNearCursors) {\n          for (var _i = 0, _len = this._trimAutoWhitespaceLines.length; _i < _len; _i++) {\n            var trimLineNumber = this._trimAutoWhitespaceLines[_i];\n            var maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n            var allowTrimLine = true;\n\n            for (var _j = 0, _lenJ = incomingEdits.length; _j < _lenJ; _j++) {\n              var _editRange = incomingEdits[_j].range;\n              var editText = incomingEdits[_j].text;\n\n              if (trimLineNumber < _editRange.startLineNumber || trimLineNumber > _editRange.endLineNumber) {\n                // `trimLine` is completely outside this edit\n                continue;\n              } // At this point:\n              //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n\n\n              if (trimLineNumber === _editRange.startLineNumber && _editRange.startColumn === maxLineColumn && _editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                // This edit inserts a new line (and maybe other text) after `trimLine`\n                continue;\n              }\n\n              if (trimLineNumber === _editRange.startLineNumber && _editRange.startColumn === 1 && _editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                // This edit inserts a new line (and maybe other text) before `trimLine`\n                continue;\n              } // Looks like we can't trim this line as it would interfere with an incoming edit\n\n\n              allowTrimLine = false;\n              break;\n            }\n\n            if (allowTrimLine) {\n              var trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n              editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n            }\n          }\n        }\n\n        this._trimAutoWhitespaceLines = null;\n      }\n\n      if (this._initialUndoRedoSnapshot === null) {\n        this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n      }\n\n      return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n  }, {\n    key: \"_applyUndo\",\n    value: function _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n      var _this4 = this;\n\n      var edits = changes.map(function (change) {\n        var rangeStart = _this4.getPositionAt(change.newPosition);\n\n        var rangeEnd = _this4.getPositionAt(change.newEnd);\n\n        return {\n          range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n          text: change.oldText\n        };\n      });\n\n      this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n  }, {\n    key: \"_applyRedo\",\n    value: function _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n      var _this5 = this;\n\n      var edits = changes.map(function (change) {\n        var rangeStart = _this5.getPositionAt(change.oldPosition);\n\n        var rangeEnd = _this5.getPositionAt(change.oldEnd);\n\n        return {\n          range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n          text: change.newText\n        };\n      });\n\n      this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n  }, {\n    key: \"_applyUndoRedoEdits\",\n    value: function _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        this._eventEmitter.beginDeferredEmit();\n\n        this._isUndoing = isUndoing;\n        this._isRedoing = isRedoing;\n        this.applyEdits(edits, false);\n        this.setEOL(eol);\n\n        this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n      } finally {\n        this._isUndoing = false;\n        this._isRedoing = false;\n\n        this._eventEmitter.endDeferredEmit(resultingSelection);\n\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(rawOperations) {\n      var computeUndoEdits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        this._eventEmitter.beginDeferredEmit();\n\n        var operations = this._validateEditOperations(rawOperations);\n\n        return this._doApplyEdits(operations, computeUndoEdits);\n      } finally {\n        this._eventEmitter.endDeferredEmit();\n\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"_doApplyEdits\",\n    value: function _doApplyEdits(rawOperations, computeUndoEdits) {\n      var oldLineCount = this._buffer.getLineCount();\n\n      var result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n\n      var newLineCount = this._buffer.getLineCount();\n\n      var contentChanges = result.changes;\n      this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n\n      if (contentChanges.length !== 0) {\n        var rawContentChanges = [];\n        var lineCount = oldLineCount;\n\n        for (var i = 0, len = contentChanges.length; i < len; i++) {\n          var change = contentChanges[i];\n\n          var _countEOL = countEOL(change.text),\n              _countEOL2 = _slicedToArray(_countEOL, 3),\n              eolCount = _countEOL2[0],\n              firstLineLength = _countEOL2[1],\n              lastLineLength = _countEOL2[2];\n\n          this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\n\n          this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0\n          /* Null */\n          );\n\n          this._onDidChangeDecorations.fire();\n\n          this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n\n          var startLineNumber = change.range.startLineNumber;\n          var endLineNumber = change.range.endLineNumber;\n          var deletingLinesCnt = endLineNumber - startLineNumber;\n          var insertingLinesCnt = eolCount;\n          var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n          var changeLineCountDelta = insertingLinesCnt - deletingLinesCnt;\n\n          for (var j = editingLinesCnt; j >= 0; j--) {\n            var editLineNumber = startLineNumber + j;\n            var currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\n            rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\n          }\n\n          if (editingLinesCnt < deletingLinesCnt) {\n            // Must delete some lines\n            var spliceStartLineNumber = startLineNumber + editingLinesCnt;\n            rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n          }\n\n          if (editingLinesCnt < insertingLinesCnt) {\n            // Must insert some lines\n            var spliceLineNumber = startLineNumber + editingLinesCnt;\n            var cnt = insertingLinesCnt - editingLinesCnt;\n            var fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n            var newLines = [];\n\n            for (var _i2 = 0; _i2 < cnt; _i2++) {\n              var lineNumber = fromLineNumber + _i2;\n              newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\n            }\n\n            rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\n          }\n\n          lineCount += changeLineCountDelta;\n        }\n\n        this._increaseVersionId();\n\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n          changes: contentChanges,\n          eol: this._buffer.getEOL(),\n          versionId: this.getVersionId(),\n          isUndoing: this._isUndoing,\n          isRedoing: this._isRedoing,\n          isFlush: false\n        });\n      }\n\n      return result.reverseEdits === null ? undefined : result.reverseEdits;\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      return this._undoRedoService.undo(this.uri);\n    }\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      return this._undoRedoService.canUndo(this.uri);\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      return this._undoRedoService.redo(this.uri);\n    }\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      return this._undoRedoService.canRedo(this.uri);\n    } //#endregion\n    //#region Decorations\n\n  }, {\n    key: \"changeDecorations\",\n    value: function changeDecorations(callback) {\n      var ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      this._assertNotDisposed();\n\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        return this._changeDecorations(ownerId, callback);\n      } finally {\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"_changeDecorations\",\n    value: function _changeDecorations(ownerId, callback) {\n      var _this6 = this;\n\n      var changeAccessor = {\n        addDecoration: function addDecoration(range, options) {\n          return _this6._deltaDecorationsImpl(ownerId, [], [{\n            range: range,\n            options: options\n          }])[0];\n        },\n        changeDecoration: function changeDecoration(id, newRange) {\n          _this6._changeDecorationImpl(id, newRange);\n        },\n        changeDecorationOptions: function changeDecorationOptions(id, options) {\n          _this6._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n        },\n        removeDecoration: function removeDecoration(id) {\n          _this6._deltaDecorationsImpl(ownerId, [id], []);\n        },\n        deltaDecorations: function deltaDecorations(oldDecorations, newDecorations) {\n          if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n          }\n\n          return _this6._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n      };\n      var result = null;\n\n      try {\n        result = callback(changeAccessor);\n      } catch (e) {\n        onUnexpectedError(e);\n      } // Invalidate change accessor\n\n\n      changeAccessor.addDecoration = invalidFunc;\n      changeAccessor.changeDecoration = invalidFunc;\n      changeAccessor.changeDecorationOptions = invalidFunc;\n      changeAccessor.removeDecoration = invalidFunc;\n      changeAccessor.deltaDecorations = invalidFunc;\n      return result;\n    }\n  }, {\n    key: \"deltaDecorations\",\n    value: function deltaDecorations(oldDecorations, newDecorations) {\n      var ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      this._assertNotDisposed();\n\n      if (!oldDecorations) {\n        oldDecorations = [];\n      }\n\n      if (oldDecorations.length === 0 && newDecorations.length === 0) {\n        // nothing to do\n        return [];\n      }\n\n      try {\n        this._onDidChangeDecorations.beginDeferredEmit();\n\n        return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n      } finally {\n        this._onDidChangeDecorations.endDeferredEmit();\n      }\n    }\n  }, {\n    key: \"_getTrackedRange\",\n    value: function _getTrackedRange(id) {\n      return this.getDecorationRange(id);\n    }\n  }, {\n    key: \"_setTrackedRange\",\n    value: function _setTrackedRange(id, newRange, newStickiness) {\n      var node = id ? this._decorations[id] : null;\n\n      if (!node) {\n        if (!newRange) {\n          // node doesn't exist, the request is to delete => nothing to do\n          return null;\n        } // node doesn't exist, the request is to set => add the tracked range\n\n\n        return this._deltaDecorationsImpl(0, [], [{\n          range: newRange,\n          options: TRACKED_RANGE_OPTIONS[newStickiness]\n        }])[0];\n      }\n\n      if (!newRange) {\n        // node exists, the request is to delete => delete node\n        this._decorationsTree[\"delete\"](node);\n\n        delete this._decorations[node.id];\n        return null;\n      } // node exists, the request is to set => change the tracked range and its options\n\n\n      var range = this._validateRangeRelaxedNoAllocations(newRange);\n\n      var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n      var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n      this._decorationsTree[\"delete\"](node);\n\n      node.reset(this.getVersionId(), startOffset, endOffset, range);\n      node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n\n      this._decorationsTree.insert(node);\n\n      return node.id;\n    }\n  }, {\n    key: \"removeAllDecorationsWithOwnerId\",\n    value: function removeAllDecorationsWithOwnerId(ownerId) {\n      if (this._isDisposed) {\n        return;\n      }\n\n      var nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n\n        this._decorationsTree[\"delete\"](node);\n\n        delete this._decorations[node.id];\n      }\n    }\n  }, {\n    key: \"getDecorationOptions\",\n    value: function getDecorationOptions(decorationId) {\n      var node = this._decorations[decorationId];\n\n      if (!node) {\n        return null;\n      }\n\n      return node.options;\n    }\n  }, {\n    key: \"getDecorationRange\",\n    value: function getDecorationRange(decorationId) {\n      var node = this._decorations[decorationId];\n\n      if (!node) {\n        return null;\n      }\n\n      var versionId = this.getVersionId();\n\n      if (node.cachedVersionId !== versionId) {\n        this._decorationsTree.resolveNode(node, versionId);\n      }\n\n      if (node.range === null) {\n        node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n      }\n\n      return node.range;\n    }\n  }, {\n    key: \"getLineDecorations\",\n    value: function getLineDecorations(lineNumber) {\n      var ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        return [];\n      }\n\n      return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n  }, {\n    key: \"getLinesDecorations\",\n    value: function getLinesDecorations(_startLineNumber, _endLineNumber) {\n      var ownerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var filterOutValidation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var lineCount = this.getLineCount();\n      var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n      var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n      var endColumn = this.getLineMaxColumn(endLineNumber);\n      return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\n    }\n  }, {\n    key: \"getDecorationsInRange\",\n    value: function getDecorationsInRange(range) {\n      var ownerId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var filterOutValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var validatedRange = this.validateRange(range);\n      return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n    }\n  }, {\n    key: \"getOverviewRulerDecorations\",\n    value: function getOverviewRulerDecorations() {\n      var ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var versionId = this.getVersionId();\n\n      var result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\n\n      return this._ensureNodesHaveRanges(result);\n    }\n  }, {\n    key: \"getAllDecorations\",\n    value: function getAllDecorations() {\n      var ownerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var filterOutValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var versionId = this.getVersionId();\n\n      var result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\n\n      return this._ensureNodesHaveRanges(result);\n    }\n  }, {\n    key: \"_getDecorationsInRange\",\n    value: function _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n      var startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n\n      var endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n\n      var versionId = this.getVersionId();\n\n      var result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\n\n      return this._ensureNodesHaveRanges(result);\n    }\n  }, {\n    key: \"_ensureNodesHaveRanges\",\n    value: function _ensureNodesHaveRanges(nodes) {\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i];\n\n        if (node.range === null) {\n          node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"_getRangeAt\",\n    value: function _getRangeAt(start, end) {\n      return this._buffer.getRangeAt(start, end - start);\n    }\n  }, {\n    key: \"_changeDecorationImpl\",\n    value: function _changeDecorationImpl(decorationId, _range) {\n      var node = this._decorations[decorationId];\n\n      if (!node) {\n        return;\n      }\n\n      var range = this._validateRangeRelaxedNoAllocations(_range);\n\n      var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n      var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n      this._decorationsTree[\"delete\"](node);\n\n      node.reset(this.getVersionId(), startOffset, endOffset, range);\n\n      this._decorationsTree.insert(node);\n\n      this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n    }\n  }, {\n    key: \"_changeDecorationOptionsImpl\",\n    value: function _changeDecorationOptionsImpl(decorationId, options) {\n      var node = this._decorations[decorationId];\n\n      if (!node) {\n        return;\n      }\n\n      var nodeWasInOverviewRuler = node.options.overviewRuler && node.options.overviewRuler.color ? true : false;\n      var nodeIsInOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n\n      this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n\n      this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n      if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n        // Delete + Insert due to an overview ruler status change\n        this._decorationsTree[\"delete\"](node);\n\n        node.setOptions(options);\n\n        this._decorationsTree.insert(node);\n      } else {\n        node.setOptions(options);\n      }\n    }\n  }, {\n    key: \"_deltaDecorationsImpl\",\n    value: function _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n      var versionId = this.getVersionId();\n      var oldDecorationsLen = oldDecorationsIds.length;\n      var oldDecorationIndex = 0;\n      var newDecorationsLen = newDecorations.length;\n      var newDecorationIndex = 0;\n      var result = new Array(newDecorationsLen);\n\n      while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n        var node = null;\n\n        if (oldDecorationIndex < oldDecorationsLen) {\n          // (1) get ourselves an old node\n          do {\n            node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n          } while (!node && oldDecorationIndex < oldDecorationsLen); // (2) remove the node from the tree (if it exists)\n\n\n          if (node) {\n            this._decorationsTree[\"delete\"](node);\n\n            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n          }\n        }\n\n        if (newDecorationIndex < newDecorationsLen) {\n          // (3) create a new node if necessary\n          if (!node) {\n            var internalDecorationId = ++this._lastDecorationId;\n            var decorationId = \"\".concat(this._instanceId, \";\").concat(internalDecorationId);\n            node = new IntervalNode(decorationId, 0, 0);\n            this._decorations[decorationId] = node;\n          } // (4) initialize node\n\n\n          var newDecoration = newDecorations[newDecorationIndex];\n\n          var range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n\n          var options = _normalizeOptions(newDecoration.options);\n\n          var startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n\n          var endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n\n          node.ownerId = ownerId;\n          node.reset(versionId, startOffset, endOffset, range);\n          node.setOptions(options);\n\n          this._onDidChangeDecorations.checkAffectedAndFire(options);\n\n          this._decorationsTree.insert(node);\n\n          result[newDecorationIndex] = node.id;\n          newDecorationIndex++;\n        } else {\n          if (node) {\n            delete this._decorations[node.id];\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"setTokens\",\n    value: function setTokens(tokens) {\n      if (tokens.length === 0) {\n        return;\n      }\n\n      var ranges = [];\n\n      for (var i = 0, len = tokens.length; i < len; i++) {\n        var element = tokens[i];\n        var minChangedLineNumber = 0;\n        var maxChangedLineNumber = 0;\n        var hasChange = false;\n\n        for (var j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\n          var lineNumber = element.startLineNumber + j;\n\n          if (hasChange) {\n            this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\n\n            maxChangedLineNumber = lineNumber;\n          } else {\n            var lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\n\n            if (lineHasChange) {\n              hasChange = true;\n              minChangedLineNumber = lineNumber;\n              maxChangedLineNumber = lineNumber;\n            }\n          }\n        }\n\n        if (hasChange) {\n          ranges.push({\n            fromLineNumber: minChangedLineNumber,\n            toLineNumber: maxChangedLineNumber\n          });\n        }\n      }\n\n      if (ranges.length > 0) {\n        this._emitModelTokensChangedEvent({\n          tokenizationSupportChanged: false,\n          semanticTokensApplied: false,\n          ranges: ranges\n        });\n      }\n    }\n  }, {\n    key: \"setSemanticTokens\",\n    value: function setSemanticTokens(tokens, isComplete) {\n      this._tokens2.set(tokens, isComplete);\n\n      this._emitModelTokensChangedEvent({\n        tokenizationSupportChanged: false,\n        semanticTokensApplied: tokens !== null,\n        ranges: [{\n          fromLineNumber: 1,\n          toLineNumber: this.getLineCount()\n        }]\n      });\n    }\n  }, {\n    key: \"hasCompleteSemanticTokens\",\n    value: function hasCompleteSemanticTokens() {\n      return this._tokens2.isComplete();\n    }\n  }, {\n    key: \"hasSomeSemanticTokens\",\n    value: function hasSomeSemanticTokens() {\n      return !this._tokens2.isEmpty();\n    }\n  }, {\n    key: \"setPartialSemanticTokens\",\n    value: function setPartialSemanticTokens(range, tokens) {\n      if (this.hasCompleteSemanticTokens()) {\n        return;\n      }\n\n      var changedRange = this._tokens2.setPartial(range, tokens);\n\n      this._emitModelTokensChangedEvent({\n        tokenizationSupportChanged: false,\n        semanticTokensApplied: true,\n        ranges: [{\n          fromLineNumber: changedRange.startLineNumber,\n          toLineNumber: changedRange.endLineNumber\n        }]\n      });\n    }\n  }, {\n    key: \"tokenizeViewport\",\n    value: function tokenizeViewport(startLineNumber, endLineNumber) {\n      startLineNumber = Math.max(1, startLineNumber);\n      endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\n\n      this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n  }, {\n    key: \"clearTokens\",\n    value: function clearTokens() {\n      this._tokens.flush();\n\n      this._emitModelTokensChangedEvent({\n        tokenizationSupportChanged: true,\n        semanticTokensApplied: false,\n        ranges: [{\n          fromLineNumber: 1,\n          toLineNumber: this._buffer.getLineCount()\n        }]\n      });\n    }\n  }, {\n    key: \"_emitModelTokensChangedEvent\",\n    value: function _emitModelTokensChangedEvent(e) {\n      if (!this._isDisposing) {\n        this._onDidChangeTokens.fire(e);\n      }\n    }\n  }, {\n    key: \"resetTokenization\",\n    value: function resetTokenization() {\n      this._tokenization.reset();\n    }\n  }, {\n    key: \"forceTokenization\",\n    value: function forceTokenization(lineNumber) {\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      this._tokenization.forceTokenization(lineNumber);\n    }\n  }, {\n    key: \"isCheapToTokenize\",\n    value: function isCheapToTokenize(lineNumber) {\n      return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n  }, {\n    key: \"tokenizeIfCheap\",\n    value: function tokenizeIfCheap(lineNumber) {\n      if (this.isCheapToTokenize(lineNumber)) {\n        this.forceTokenization(lineNumber);\n      }\n    }\n  }, {\n    key: \"getLineTokens\",\n    value: function getLineTokens(lineNumber) {\n      if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      return this._getLineTokens(lineNumber);\n    }\n  }, {\n    key: \"_getLineTokens\",\n    value: function _getLineTokens(lineNumber) {\n      var lineText = this.getLineContent(lineNumber);\n\n      var syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\n\n      return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\n    }\n  }, {\n    key: \"getLanguageIdentifier\",\n    value: function getLanguageIdentifier() {\n      return this._languageIdentifier;\n    }\n  }, {\n    key: \"getModeId\",\n    value: function getModeId() {\n      return this._languageIdentifier.language;\n    }\n  }, {\n    key: \"setMode\",\n    value: function setMode(languageIdentifier) {\n      if (this._languageIdentifier.id === languageIdentifier.id) {\n        // There's nothing to do\n        return;\n      }\n\n      var e = {\n        oldLanguage: this._languageIdentifier.language,\n        newLanguage: languageIdentifier.language\n      };\n      this._languageIdentifier = languageIdentifier;\n\n      this._onDidChangeLanguage.fire(e);\n\n      this._onDidChangeLanguageConfiguration.fire({});\n    }\n  }, {\n    key: \"getLanguageIdAtPosition\",\n    value: function getLanguageIdAtPosition(lineNumber, column) {\n      var position = this.validatePosition(new Position(lineNumber, column));\n      var lineTokens = this.getLineTokens(position.lineNumber);\n      return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    } // Having tokens allows implementing additional helper methods\n\n  }, {\n    key: \"getWordAtPosition\",\n    value: function getWordAtPosition(_position) {\n      this._assertNotDisposed();\n\n      var position = this.validatePosition(_position);\n      var lineContent = this.getLineContent(position.lineNumber);\n\n      var lineTokens = this._getLineTokens(position.lineNumber);\n\n      var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1); // (1). First try checking right biased word\n\n      var _TextModel$_findLangu = TextModel._findLanguageBoundaries(lineTokens, tokenIndex),\n          _TextModel$_findLangu2 = _slicedToArray(_TextModel$_findLangu, 2),\n          rbStartOffset = _TextModel$_findLangu2[0],\n          rbEndOffset = _TextModel$_findLangu2[1];\n\n      var rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset); // Make sure the result touches the original passed in position\n\n      if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n        return rightBiasedWord;\n      } // (2). Else, if we were at a language boundary, check the left biased word\n\n\n      if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n        // edge case, where `position` sits between two tokens belonging to two different languages\n        var _TextModel$_findLangu3 = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1),\n            _TextModel$_findLangu4 = _slicedToArray(_TextModel$_findLangu3, 2),\n            lbStartOffset = _TextModel$_findLangu4[0],\n            lbEndOffset = _TextModel$_findLangu4[1];\n\n        var leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset); // Make sure the result touches the original passed in position\n\n        if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n          return leftBiasedWord;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getWordUntilPosition\",\n    value: function getWordUntilPosition(position) {\n      var wordAtPosition = this.getWordAtPosition(position);\n\n      if (!wordAtPosition) {\n        return {\n          word: '',\n          startColumn: position.column,\n          endColumn: position.column\n        };\n      }\n\n      return {\n        word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n        startColumn: wordAtPosition.startColumn,\n        endColumn: position.column\n      };\n    }\n  }, {\n    key: \"findMatchingBracketUp\",\n    value: function findMatchingBracketUp(_bracket, _position) {\n      var bracket = _bracket.toLowerCase();\n\n      var position = this.validatePosition(_position);\n\n      var lineTokens = this._getLineTokens(position.lineNumber);\n\n      var languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n      var bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n\n      if (!bracketsSupport) {\n        return null;\n      }\n\n      var data = bracketsSupport.textIsBracket[bracket];\n\n      if (!data) {\n        return null;\n      }\n\n      return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\n    }\n  }, {\n    key: \"matchBracket\",\n    value: function matchBracket(position) {\n      return this._matchBracket(this.validatePosition(position));\n    }\n  }, {\n    key: \"_matchBracket\",\n    value: function _matchBracket(position) {\n      var lineNumber = position.lineNumber;\n\n      var lineTokens = this._getLineTokens(lineNumber);\n\n      var tokenCount = lineTokens.getCount();\n\n      var lineText = this._buffer.getLineContent(lineNumber);\n\n      var tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\n      if (tokenIndex < 0) {\n        return null;\n      }\n\n      var currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex)); // check that the token is not to be ignored\n\n      if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n        // limit search to not go before `maxBracketLength`\n        var searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);\n\n        for (var i = tokenIndex - 1; i >= 0; i--) {\n          var tokenEndOffset = lineTokens.getEndOffset(i);\n\n          if (tokenEndOffset <= searchStartOffset) {\n            break;\n          }\n\n          if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\n            searchStartOffset = tokenEndOffset;\n          }\n        } // limit search to not go after `maxBracketLength`\n\n\n        var searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength); // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n        // `bestResult` will contain the most right-side result\n\n        var bestResult = null;\n\n        while (true) {\n          var foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (!foundBracket) {\n            // there are no more brackets in this text\n            break;\n          } // check that we didn't hit a bracket too far away from position\n\n\n          if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n            var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n\n            var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\n\n            if (r) {\n              if (r instanceof BracketSearchCanceled) {\n                return null;\n              }\n\n              bestResult = r;\n            }\n          }\n\n          searchStartOffset = foundBracket.endColumn - 1;\n        }\n\n        if (bestResult) {\n          return bestResult;\n        }\n      } // If position is in between two tokens, try also looking in the previous token\n\n\n      if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n        var prevTokenIndex = tokenIndex - 1;\n        var prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex)); // check that previous token is not to be ignored\n\n        if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n          // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\n          var _searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);\n\n          var _searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);\n\n          for (var _i3 = prevTokenIndex + 1; _i3 < tokenCount; _i3++) {\n            var tokenStartOffset = lineTokens.getStartOffset(_i3);\n\n            if (tokenStartOffset >= _searchEndOffset) {\n              break;\n            }\n\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(_i3))) {\n              _searchEndOffset = tokenStartOffset;\n            }\n          }\n\n          var _foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, _searchStartOffset, _searchEndOffset); // check that we didn't hit a bracket too far away from position\n\n\n          if (_foundBracket && _foundBracket.startColumn <= position.column && position.column <= _foundBracket.endColumn) {\n            var _foundBracketText = lineText.substring(_foundBracket.startColumn - 1, _foundBracket.endColumn - 1).toLowerCase();\n\n            var _r = this._matchFoundBracket(_foundBracket, prevModeBrackets.textIsBracket[_foundBracketText], prevModeBrackets.textIsOpenBracket[_foundBracketText], null);\n\n            if (_r) {\n              if (_r instanceof BracketSearchCanceled) {\n                return null;\n              }\n\n              return _r;\n            }\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_matchFoundBracket\",\n    value: function _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n      if (!data) {\n        return null;\n      }\n\n      var matched = isOpen ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate) : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate);\n\n      if (!matched) {\n        return null;\n      }\n\n      if (matched instanceof BracketSearchCanceled) {\n        return matched;\n      }\n\n      return [foundBracket, matched];\n    }\n  }, {\n    key: \"_findMatchingBracketUp\",\n    value: function _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n      // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n      var languageId = bracket.languageIdentifier.id;\n      var reversedBracketRegex = bracket.reversedRegex;\n      var count = -1;\n      var totalCallCount = 0;\n\n      var searchPrevMatchingBracketInRange = function searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n\n          var r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (!r) {\n            break;\n          }\n\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n          if (bracket.isOpen(hitText)) {\n            count++;\n          } else if (bracket.isClose(hitText)) {\n            count--;\n          }\n\n          if (count === 0) {\n            return r;\n          }\n\n          searchEndOffset = r.startColumn - 1;\n        }\n\n        return null;\n      };\n\n      for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n        var lineTokens = this._getLineTokens(lineNumber);\n\n        var tokenCount = lineTokens.getCount();\n\n        var lineText = this._buffer.getLineContent(lineNumber);\n\n        var tokenIndex = tokenCount - 1;\n        var searchStartOffset = lineText.length;\n        var searchEndOffset = lineText.length;\n\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n        }\n\n        var prevSearchInToken = true;\n\n        for (; tokenIndex >= 0; tokenIndex--) {\n          var searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchStartOffset\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (r) {\n                return r;\n              }\n            }\n          }\n\n          prevSearchInToken = searchInToken;\n        }\n\n        if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r2 = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (_r2) {\n            return _r2;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_findMatchingBracketDown\",\n    value: function _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n      // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n      var languageId = bracket.languageIdentifier.id;\n      var bracketRegex = bracket.forwardRegex;\n      var count = 1;\n      var totalCallCount = 0;\n\n      var searchNextMatchingBracketInRange = function searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n\n          var r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (!r) {\n            break;\n          }\n\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n\n          if (bracket.isOpen(hitText)) {\n            count++;\n          } else if (bracket.isClose(hitText)) {\n            count--;\n          }\n\n          if (count === 0) {\n            return r;\n          }\n\n          searchStartOffset = r.endColumn - 1;\n        }\n\n        return null;\n      };\n\n      var lineCount = this.getLineCount();\n\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this._getLineTokens(lineNumber);\n\n        var tokenCount = lineTokens.getCount();\n\n        var lineText = this._buffer.getLineContent(lineNumber);\n\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n        }\n\n        var prevSearchInToken = true;\n\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var searchInToken = lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (r) {\n                return r;\n              }\n            }\n          }\n\n          prevSearchInToken = searchInToken;\n        }\n\n        if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r3 = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (_r3) {\n            return _r3;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findPrevBracket\",\n    value: function findPrevBracket(_position) {\n      var position = this.validatePosition(_position);\n      var languageId = -1;\n      var modeBrackets = null;\n\n      for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n        var lineTokens = this._getLineTokens(lineNumber);\n\n        var tokenCount = lineTokens.getCount();\n\n        var lineText = this._buffer.getLineContent(lineNumber);\n\n        var tokenIndex = tokenCount - 1;\n        var searchStartOffset = lineText.length;\n        var searchEndOffset = lineText.length;\n\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          }\n        }\n\n        var prevSearchInToken = true;\n\n        for (; tokenIndex >= 0; tokenIndex--) {\n          var _tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== _tokenLanguageId) {\n            // language id change!\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (r) {\n                return this._toFoundBracket(modeBrackets, r);\n              }\n\n              prevSearchInToken = false;\n            }\n\n            languageId = _tokenLanguageId;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          }\n\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchStartOffset\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r4 = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (_r4) {\n                return this._toFoundBracket(modeBrackets, _r4);\n              }\n            }\n          }\n\n          prevSearchInToken = searchInToken;\n        }\n\n        if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r5 = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (_r5) {\n            return this._toFoundBracket(modeBrackets, _r5);\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findNextBracket\",\n    value: function findNextBracket(_position) {\n      var position = this.validatePosition(_position);\n      var lineCount = this.getLineCount();\n      var languageId = -1;\n      var modeBrackets = null;\n\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this._getLineTokens(lineNumber);\n\n        var tokenCount = lineTokens.getCount();\n\n        var lineText = this._buffer.getLineContent(lineNumber);\n\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          }\n        }\n\n        var prevSearchInToken = true;\n\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var _tokenLanguageId2 = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== _tokenLanguageId2) {\n            // language id change!\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (r) {\n                return this._toFoundBracket(modeBrackets, r);\n              }\n\n              prevSearchInToken = false;\n            }\n\n            languageId = _tokenLanguageId2;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n          }\n\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r6 = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (_r6) {\n                return this._toFoundBracket(modeBrackets, _r6);\n              }\n            }\n          }\n\n          prevSearchInToken = searchInToken;\n        }\n\n        if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r7 = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (_r7) {\n            return this._toFoundBracket(modeBrackets, _r7);\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findEnclosingBrackets\",\n    value: function findEnclosingBrackets(_position, maxDuration) {\n      var _this7 = this;\n\n      var continueSearchPredicate;\n\n      if (typeof maxDuration === 'undefined') {\n        continueSearchPredicate = null;\n      } else {\n        var startTime = Date.now();\n\n        continueSearchPredicate = function continueSearchPredicate() {\n          return Date.now() - startTime <= maxDuration;\n        };\n      }\n\n      var position = this.validatePosition(_position);\n      var lineCount = this.getLineCount();\n      var savedCounts = new Map();\n      var counts = [];\n\n      var resetCounts = function resetCounts(languageId, modeBrackets) {\n        if (!savedCounts.has(languageId)) {\n          var tmp = [];\n\n          for (var i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n            tmp[i] = 0;\n          }\n\n          savedCounts.set(languageId, tmp);\n        }\n\n        counts = savedCounts.get(languageId);\n      };\n\n      var totalCallCount = 0;\n\n      var searchInRange = function searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) {\n        while (true) {\n          if (continueSearchPredicate && ++totalCallCount % 100 === 0 && !continueSearchPredicate()) {\n            return BracketSearchCanceled.INSTANCE;\n          }\n\n          var r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (!r) {\n            break;\n          }\n\n          var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n          var bracket = modeBrackets.textIsBracket[hitText];\n\n          if (bracket) {\n            if (bracket.isOpen(hitText)) {\n              counts[bracket.index]++;\n            } else if (bracket.isClose(hitText)) {\n              counts[bracket.index]--;\n            }\n\n            if (counts[bracket.index] === -1) {\n              return _this7._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n            }\n          }\n\n          searchStartOffset = r.endColumn - 1;\n        }\n\n        return null;\n      };\n\n      var languageId = -1;\n      var modeBrackets = null;\n\n      for (var lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n        var lineTokens = this._getLineTokens(lineNumber);\n\n        var tokenCount = lineTokens.getCount();\n\n        var lineText = this._buffer.getLineContent(lineNumber);\n\n        var tokenIndex = 0;\n        var searchStartOffset = 0;\n        var searchEndOffset = 0;\n\n        if (lineNumber === position.lineNumber) {\n          tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n          searchStartOffset = position.column - 1;\n          searchEndOffset = position.column - 1;\n          var tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== tokenLanguageId) {\n            languageId = tokenLanguageId;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n            resetCounts(languageId, modeBrackets);\n          }\n        }\n\n        var prevSearchInToken = true;\n\n        for (; tokenIndex < tokenCount; tokenIndex++) {\n          var _tokenLanguageId3 = lineTokens.getLanguageId(tokenIndex);\n\n          if (languageId !== _tokenLanguageId3) {\n            // language id change!\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (r) {\n                return stripBracketSearchCanceled(r);\n              }\n\n              prevSearchInToken = false;\n            }\n\n            languageId = _tokenLanguageId3;\n            modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\n            resetCounts(languageId, modeBrackets);\n          }\n\n          var searchInToken = !!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex));\n\n          if (searchInToken) {\n            // this token should be searched\n            if (prevSearchInToken) {\n              // the previous token should be searched, simply extend searchEndOffset\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            } else {\n              // the previous token should not be searched\n              searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n              searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n            }\n          } else {\n            // this token should not be searched\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n              var _r8 = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n              if (_r8) {\n                return stripBracketSearchCanceled(_r8);\n              }\n            }\n          }\n\n          prevSearchInToken = searchInToken;\n        }\n\n        if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n          var _r9 = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n\n          if (_r9) {\n            return stripBracketSearchCanceled(_r9);\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_toFoundBracket\",\n    value: function _toFoundBracket(modeBrackets, r) {\n      if (!r) {\n        return null;\n      }\n\n      var text = this.getValueInRange(r);\n      text = text.toLowerCase();\n      var data = modeBrackets.textIsBracket[text];\n\n      if (!data) {\n        return null;\n      }\n\n      return {\n        range: r,\n        open: data.open,\n        close: data.close,\n        isOpen: modeBrackets.textIsOpenBracket[text]\n      };\n    }\n    /**\r\n     * Returns:\r\n     *  - -1 => the line consists of whitespace\r\n     *  - otherwise => the indent level is returned value\r\n     */\n\n  }, {\n    key: \"_computeIndentLevel\",\n    value: function _computeIndentLevel(lineIndex) {\n      return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\n    }\n  }, {\n    key: \"getActiveIndentGuide\",\n    value: function getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n      var _this8 = this;\n\n      this._assertNotDisposed();\n\n      var lineCount = this.getLineCount();\n\n      if (lineNumber < 1 || lineNumber > lineCount) {\n        throw new Error('Illegal value for lineNumber');\n      }\n\n      var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n      var offSide = Boolean(foldingRules && foldingRules.offSide);\n      var up_aboveContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var up_aboveContentLineIndent = -1;\n      var up_belowContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var up_belowContentLineIndent = -1;\n\n      var up_resolveIndents = function up_resolveIndents(lineNumber) {\n        if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\n          up_aboveContentLineIndex = -1;\n          up_aboveContentLineIndent = -1; // must find previous line with content\n\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var _indent = _this8._computeIndentLevel(lineIndex);\n\n            if (_indent >= 0) {\n              up_aboveContentLineIndex = lineIndex;\n              up_aboveContentLineIndent = _indent;\n              break;\n            }\n          }\n        }\n\n        if (up_belowContentLineIndex === -2) {\n          up_belowContentLineIndex = -1;\n          up_belowContentLineIndent = -1; // must find next line with content\n\n          for (var _lineIndex = lineNumber; _lineIndex < lineCount; _lineIndex++) {\n            var _indent2 = _this8._computeIndentLevel(_lineIndex);\n\n            if (_indent2 >= 0) {\n              up_belowContentLineIndex = _lineIndex;\n              up_belowContentLineIndent = _indent2;\n              break;\n            }\n          }\n        }\n      };\n\n      var down_aboveContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var down_aboveContentLineIndent = -1;\n      var down_belowContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var down_belowContentLineIndent = -1;\n\n      var down_resolveIndents = function down_resolveIndents(lineNumber) {\n        if (down_aboveContentLineIndex === -2) {\n          down_aboveContentLineIndex = -1;\n          down_aboveContentLineIndent = -1; // must find previous line with content\n\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var _indent3 = _this8._computeIndentLevel(lineIndex);\n\n            if (_indent3 >= 0) {\n              down_aboveContentLineIndex = lineIndex;\n              down_aboveContentLineIndent = _indent3;\n              break;\n            }\n          }\n        }\n\n        if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\n          down_belowContentLineIndex = -1;\n          down_belowContentLineIndent = -1; // must find next line with content\n\n          for (var _lineIndex2 = lineNumber; _lineIndex2 < lineCount; _lineIndex2++) {\n            var _indent4 = _this8._computeIndentLevel(_lineIndex2);\n\n            if (_indent4 >= 0) {\n              down_belowContentLineIndex = _lineIndex2;\n              down_belowContentLineIndent = _indent4;\n              break;\n            }\n          }\n        }\n      };\n\n      var startLineNumber = 0;\n      var goUp = true;\n      var endLineNumber = 0;\n      var goDown = true;\n      var indent = 0;\n      var initialIndent = 0;\n\n      for (var distance = 0; goUp || goDown; distance++) {\n        var upLineNumber = lineNumber - distance;\n        var downLineNumber = lineNumber + distance;\n\n        if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n          goUp = false;\n        }\n\n        if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n          goDown = false;\n        }\n\n        if (distance > 50000) {\n          // stop processing\n          goUp = false;\n          goDown = false;\n        }\n\n        var upLineIndentLevel = -1;\n\n        if (goUp) {\n          // compute indent level going up\n          var currentIndent = this._computeIndentLevel(upLineNumber - 1);\n\n          if (currentIndent >= 0) {\n            // This line has content (besides whitespace)\n            // Use the line's indent\n            up_belowContentLineIndex = upLineNumber - 1;\n            up_belowContentLineIndent = currentIndent;\n            upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\n          } else {\n            up_resolveIndents(upLineNumber);\n            upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n          }\n        }\n\n        var downLineIndentLevel = -1;\n\n        if (goDown) {\n          // compute indent level going down\n          var _currentIndent = this._computeIndentLevel(downLineNumber - 1);\n\n          if (_currentIndent >= 0) {\n            // This line has content (besides whitespace)\n            // Use the line's indent\n            down_aboveContentLineIndex = downLineNumber - 1;\n            down_aboveContentLineIndent = _currentIndent;\n            downLineIndentLevel = Math.ceil(_currentIndent / this._options.indentSize);\n          } else {\n            down_resolveIndents(downLineNumber);\n            downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n          }\n        }\n\n        if (distance === 0) {\n          initialIndent = upLineIndentLevel;\n          continue;\n        }\n\n        if (distance === 1) {\n          if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\n            // This is the beginning of a scope, we have special handling here, since we want the\n            // child scope indent to be active, not the parent scope\n            goUp = false;\n            startLineNumber = downLineNumber;\n            endLineNumber = downLineNumber;\n            indent = downLineIndentLevel;\n            continue;\n          }\n\n          if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\n            // This is the end of a scope, just like above\n            goDown = false;\n            startLineNumber = upLineNumber;\n            endLineNumber = upLineNumber;\n            indent = upLineIndentLevel;\n            continue;\n          }\n\n          startLineNumber = lineNumber;\n          endLineNumber = lineNumber;\n          indent = initialIndent;\n\n          if (indent === 0) {\n            // No need to continue\n            return {\n              startLineNumber: startLineNumber,\n              endLineNumber: endLineNumber,\n              indent: indent\n            };\n          }\n        }\n\n        if (goUp) {\n          if (upLineIndentLevel >= indent) {\n            startLineNumber = upLineNumber;\n          } else {\n            goUp = false;\n          }\n        }\n\n        if (goDown) {\n          if (downLineIndentLevel >= indent) {\n            endLineNumber = downLineNumber;\n          } else {\n            goDown = false;\n          }\n        }\n      }\n\n      return {\n        startLineNumber: startLineNumber,\n        endLineNumber: endLineNumber,\n        indent: indent\n      };\n    }\n  }, {\n    key: \"getLinesIndentGuides\",\n    value: function getLinesIndentGuides(startLineNumber, endLineNumber) {\n      this._assertNotDisposed();\n\n      var lineCount = this.getLineCount();\n\n      if (startLineNumber < 1 || startLineNumber > lineCount) {\n        throw new Error('Illegal value for startLineNumber');\n      }\n\n      if (endLineNumber < 1 || endLineNumber > lineCount) {\n        throw new Error('Illegal value for endLineNumber');\n      }\n\n      var foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\n      var offSide = Boolean(foldingRules && foldingRules.offSide);\n      var result = new Array(endLineNumber - startLineNumber + 1);\n      var aboveContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var aboveContentLineIndent = -1;\n      var belowContentLineIndex = -2;\n      /* -2 is a marker for not having computed it */\n\n      var belowContentLineIndent = -1;\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var resultIndex = lineNumber - startLineNumber;\n\n        var currentIndent = this._computeIndentLevel(lineNumber - 1);\n\n        if (currentIndent >= 0) {\n          // This line has content (besides whitespace)\n          // Use the line's indent\n          aboveContentLineIndex = lineNumber - 1;\n          aboveContentLineIndent = currentIndent;\n          result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\n          continue;\n        }\n\n        if (aboveContentLineIndex === -2) {\n          aboveContentLineIndex = -1;\n          aboveContentLineIndent = -1; // must find previous line with content\n\n          for (var lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n            var indent = this._computeIndentLevel(lineIndex);\n\n            if (indent >= 0) {\n              aboveContentLineIndex = lineIndex;\n              aboveContentLineIndent = indent;\n              break;\n            }\n          }\n        }\n\n        if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n          belowContentLineIndex = -1;\n          belowContentLineIndent = -1; // must find next line with content\n\n          for (var _lineIndex3 = lineNumber; _lineIndex3 < lineCount; _lineIndex3++) {\n            var _indent5 = this._computeIndentLevel(_lineIndex3);\n\n            if (_indent5 >= 0) {\n              belowContentLineIndex = _lineIndex3;\n              belowContentLineIndent = _indent5;\n              break;\n            }\n          }\n        }\n\n        result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getIndentLevelForWhitespaceLine\",\n    value: function _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n      if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n        // At the top or bottom of the file\n        return 0;\n      } else if (aboveContentLineIndent < belowContentLineIndent) {\n        // we are inside the region above\n        return 1 + Math.floor(aboveContentLineIndent / this._options.indentSize);\n      } else if (aboveContentLineIndent === belowContentLineIndent) {\n        // we are in between two regions\n        return Math.ceil(belowContentLineIndent / this._options.indentSize);\n      } else {\n        if (offSide) {\n          // same level as region below\n          return Math.ceil(belowContentLineIndent / this._options.indentSize);\n        } else {\n          // we are inside the region that ends below\n          return 1 + Math.floor(belowContentLineIndent / this._options.indentSize);\n        }\n      }\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this._associatedResource;\n    }\n  }], [{\n    key: \"resolveOptions\",\n    value: function resolveOptions(textBuffer, options) {\n      if (options.detectIndentation) {\n        var guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n        return new model.TextModelResolvedOptions({\n          tabSize: guessedIndentation.tabSize,\n          indentSize: guessedIndentation.tabSize,\n          insertSpaces: guessedIndentation.insertSpaces,\n          trimAutoWhitespace: options.trimAutoWhitespace,\n          defaultEOL: options.defaultEOL\n        });\n      }\n\n      return new model.TextModelResolvedOptions({\n        tabSize: options.tabSize,\n        indentSize: options.indentSize,\n        insertSpaces: options.insertSpaces,\n        trimAutoWhitespace: options.trimAutoWhitespace,\n        defaultEOL: options.defaultEOL\n      });\n    }\n  }, {\n    key: \"_normalizeIndentationFromWhitespace\",\n    value: function _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n      var spacesCnt = 0;\n\n      for (var i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n          spacesCnt += indentSize;\n        } else {\n          spacesCnt++;\n        }\n      }\n\n      var result = '';\n\n      if (!insertSpaces) {\n        var tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n\n        for (var _i4 = 0; _i4 < tabsCnt; _i4++) {\n          result += '\\t';\n        }\n      }\n\n      for (var _i5 = 0; _i5 < spacesCnt; _i5++) {\n        result += ' ';\n      }\n\n      return result;\n    }\n  }, {\n    key: \"normalizeIndentation\",\n    value: function normalizeIndentation(str, indentSize, insertSpaces) {\n      var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n\n      if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n      }\n\n      return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n    }\n  }, {\n    key: \"_findLanguageBoundaries\",\n    value: function _findLanguageBoundaries(lineTokens, tokenIndex) {\n      var languageId = lineTokens.getLanguageId(tokenIndex); // go left until a different language is hit\n\n      var startOffset = 0;\n\n      for (var i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n        startOffset = lineTokens.getStartOffset(i);\n      } // go right until a different language is hit\n\n\n      var endOffset = lineTokens.getLineContent().length;\n\n      for (var _i6 = tokenIndex, tokenCount = lineTokens.getCount(); _i6 < tokenCount && lineTokens.getLanguageId(_i6) === languageId; _i6++) {\n        endOffset = lineTokens.getEndOffset(_i6);\n      }\n\n      return [startOffset, endOffset];\n    }\n  }, {\n    key: \"computeIndentLevel\",\n    value: function computeIndentLevel(line, tabSize) {\n      var indent = 0;\n      var i = 0;\n      var len = line.length;\n\n      while (i < len) {\n        var chCode = line.charCodeAt(i);\n\n        if (chCode === 32\n        /* Space */\n        ) {\n            indent++;\n          } else if (chCode === 9\n        /* Tab */\n        ) {\n            indent = indent - indent % tabSize + tabSize;\n          } else {\n          break;\n        }\n\n        i++;\n      }\n\n      if (i === len) {\n        return -1; // line only consists of whitespace\n      }\n\n      return indent;\n    }\n  }]);\n\n  return TextModel;\n}(Disposable);\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\n\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\n\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\n\nTextModel.DEFAULT_CREATION_OPTIONS = {\n  isForSimpleWidget: false,\n  tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n  indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n  insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n  detectIndentation: false,\n  defaultEOL: 1\n  /* LF */\n  ,\n  trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n  largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations\n}; //#region Decorations\n\nvar DecorationsTrees = /*#__PURE__*/function () {\n  function DecorationsTrees() {\n    _classCallCheck(this, DecorationsTrees);\n\n    this._decorationsTree0 = new IntervalTree();\n    this._decorationsTree1 = new IntervalTree();\n  }\n\n  _createClass(DecorationsTrees, [{\n    key: \"intervalSearch\",\n    value: function intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n      var r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n      var r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n\n      return r0.concat(r1);\n    }\n  }, {\n    key: \"search\",\n    value: function search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n      if (overviewRulerOnly) {\n        return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n      } else {\n        var r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n        var r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n\n        return r0.concat(r1);\n      }\n    }\n  }, {\n    key: \"collectNodesFromOwner\",\n    value: function collectNodesFromOwner(ownerId) {\n      var r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n\n      var r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n\n      return r0.concat(r1);\n    }\n  }, {\n    key: \"collectNodesPostOrder\",\n    value: function collectNodesPostOrder() {\n      var r0 = this._decorationsTree0.collectNodesPostOrder();\n\n      var r1 = this._decorationsTree1.collectNodesPostOrder();\n\n      return r0.concat(r1);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(node) {\n      if (getNodeIsInOverviewRuler(node)) {\n        this._decorationsTree1.insert(node);\n      } else {\n        this._decorationsTree0.insert(node);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(node) {\n      if (getNodeIsInOverviewRuler(node)) {\n        this._decorationsTree1[\"delete\"](node);\n      } else {\n        this._decorationsTree0[\"delete\"](node);\n      }\n    }\n  }, {\n    key: \"resolveNode\",\n    value: function resolveNode(node, cachedVersionId) {\n      if (getNodeIsInOverviewRuler(node)) {\n        this._decorationsTree1.resolveNode(node, cachedVersionId);\n      } else {\n        this._decorationsTree0.resolveNode(node, cachedVersionId);\n      }\n    }\n  }, {\n    key: \"acceptReplace\",\n    value: function acceptReplace(offset, length, textLength, forceMoveMarkers) {\n      this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n\n      this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n  }]);\n\n  return DecorationsTrees;\n}();\n\nfunction cleanClassName(className) {\n  return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\n\nvar DecorationOptions = function DecorationOptions(options) {\n  _classCallCheck(this, DecorationOptions);\n\n  this.color = options.color || '';\n  this.darkColor = options.darkColor || '';\n};\n\nexport var ModelDecorationOverviewRulerOptions = /*#__PURE__*/function (_DecorationOptions) {\n  _inherits(ModelDecorationOverviewRulerOptions, _DecorationOptions);\n\n  var _super2 = _createSuper(ModelDecorationOverviewRulerOptions);\n\n  function ModelDecorationOverviewRulerOptions(options) {\n    var _this9;\n\n    _classCallCheck(this, ModelDecorationOverviewRulerOptions);\n\n    _this9 = _super2.call(this, options);\n    _this9._resolvedColor = null;\n    _this9.position = typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center;\n    return _this9;\n  }\n\n  _createClass(ModelDecorationOverviewRulerOptions, [{\n    key: \"getColor\",\n    value: function getColor(theme) {\n      if (!this._resolvedColor) {\n        if (theme.type !== 'light' && this.darkColor) {\n          this._resolvedColor = this._resolveColor(this.darkColor, theme);\n        } else {\n          this._resolvedColor = this._resolveColor(this.color, theme);\n        }\n      }\n\n      return this._resolvedColor;\n    }\n  }, {\n    key: \"invalidateCachedColor\",\n    value: function invalidateCachedColor() {\n      this._resolvedColor = null;\n    }\n  }, {\n    key: \"_resolveColor\",\n    value: function _resolveColor(color, theme) {\n      if (typeof color === 'string') {\n        return color;\n      }\n\n      var c = color ? theme.getColor(color.id) : null;\n\n      if (!c) {\n        return '';\n      }\n\n      return c.toString();\n    }\n  }]);\n\n  return ModelDecorationOverviewRulerOptions;\n}(DecorationOptions);\nexport var ModelDecorationMinimapOptions = /*#__PURE__*/function (_DecorationOptions2) {\n  _inherits(ModelDecorationMinimapOptions, _DecorationOptions2);\n\n  var _super3 = _createSuper(ModelDecorationMinimapOptions);\n\n  function ModelDecorationMinimapOptions(options) {\n    var _this10;\n\n    _classCallCheck(this, ModelDecorationMinimapOptions);\n\n    _this10 = _super3.call(this, options);\n    _this10.position = options.position;\n    return _this10;\n  }\n\n  _createClass(ModelDecorationMinimapOptions, [{\n    key: \"getColor\",\n    value: function getColor(theme) {\n      if (!this._resolvedColor) {\n        if (theme.type !== 'light' && this.darkColor) {\n          this._resolvedColor = this._resolveColor(this.darkColor, theme);\n        } else {\n          this._resolvedColor = this._resolveColor(this.color, theme);\n        }\n      }\n\n      return this._resolvedColor;\n    }\n  }, {\n    key: \"invalidateCachedColor\",\n    value: function invalidateCachedColor() {\n      this._resolvedColor = undefined;\n    }\n  }, {\n    key: \"_resolveColor\",\n    value: function _resolveColor(color, theme) {\n      if (typeof color === 'string') {\n        return Color.fromHex(color);\n      }\n\n      return theme.getColor(color.id);\n    }\n  }]);\n\n  return ModelDecorationMinimapOptions;\n}(DecorationOptions);\nexport var ModelDecorationOptions = /*#__PURE__*/function () {\n  function ModelDecorationOptions(options) {\n    _classCallCheck(this, ModelDecorationOptions);\n\n    this.stickiness = options.stickiness || 0\n    /* AlwaysGrowsWhenTypingAtEdges */\n    ;\n    this.zIndex = options.zIndex || 0;\n    this.className = options.className ? cleanClassName(options.className) : null;\n    this.hoverMessage = options.hoverMessage || null;\n    this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n    this.isWholeLine = options.isWholeLine || false;\n    this.showIfCollapsed = options.showIfCollapsed || false;\n    this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n    this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n    this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n    this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n    this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n    this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n    this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n    this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n    this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n    this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n    this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n  }\n\n  _createClass(ModelDecorationOptions, null, [{\n    key: \"register\",\n    value: function register(options) {\n      return new ModelDecorationOptions(options);\n    }\n  }, {\n    key: \"createDynamic\",\n    value: function createDynamic(options) {\n      return new ModelDecorationOptions(options);\n    }\n  }]);\n\n  return ModelDecorationOptions;\n}();\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\n/**\r\n * The order carefully matches the values of the enum.\r\n */\n\nvar TRACKED_RANGE_OPTIONS = [ModelDecorationOptions.register({\n  stickiness: 0\n  /* AlwaysGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  stickiness: 1\n  /* NeverGrowsWhenTypingAtEdges */\n\n}), ModelDecorationOptions.register({\n  stickiness: 2\n  /* GrowsOnlyWhenTypingBefore */\n\n}), ModelDecorationOptions.register({\n  stickiness: 3\n  /* GrowsOnlyWhenTypingAfter */\n\n})];\n\nfunction _normalizeOptions(options) {\n  if (options instanceof ModelDecorationOptions) {\n    return options;\n  }\n\n  return ModelDecorationOptions.createDynamic(options);\n}\n\nexport var DidChangeDecorationsEmitter = /*#__PURE__*/function (_Disposable2) {\n  _inherits(DidChangeDecorationsEmitter, _Disposable2);\n\n  var _super4 = _createSuper(DidChangeDecorationsEmitter);\n\n  function DidChangeDecorationsEmitter() {\n    var _this11;\n\n    _classCallCheck(this, DidChangeDecorationsEmitter);\n\n    _this11 = _super4.call(this);\n    _this11._actual = _this11._register(new Emitter());\n    _this11.event = _this11._actual.event;\n    _this11._deferredCnt = 0;\n    _this11._shouldFire = false;\n    _this11._affectsMinimap = false;\n    _this11._affectsOverviewRuler = false;\n    return _this11;\n  }\n\n  _createClass(DidChangeDecorationsEmitter, [{\n    key: \"beginDeferredEmit\",\n    value: function beginDeferredEmit() {\n      this._deferredCnt++;\n    }\n  }, {\n    key: \"endDeferredEmit\",\n    value: function endDeferredEmit() {\n      this._deferredCnt--;\n\n      if (this._deferredCnt === 0) {\n        if (this._shouldFire) {\n          var event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler\n          };\n          this._shouldFire = false;\n          this._affectsMinimap = false;\n          this._affectsOverviewRuler = false;\n\n          this._actual.fire(event);\n        }\n      }\n    }\n  }, {\n    key: \"checkAffectedAndFire\",\n    value: function checkAffectedAndFire(options) {\n      if (!this._affectsMinimap) {\n        this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n      }\n\n      if (!this._affectsOverviewRuler) {\n        this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n      }\n\n      this._shouldFire = true;\n    }\n  }, {\n    key: \"fire\",\n    value: function fire() {\n      this._affectsMinimap = true;\n      this._affectsOverviewRuler = true;\n      this._shouldFire = true;\n    }\n  }]);\n\n  return DidChangeDecorationsEmitter;\n}(Disposable); //#endregion\n\nexport var DidChangeContentEmitter = /*#__PURE__*/function (_Disposable3) {\n  _inherits(DidChangeContentEmitter, _Disposable3);\n\n  var _super5 = _createSuper(DidChangeContentEmitter);\n\n  function DidChangeContentEmitter() {\n    var _this12;\n\n    _classCallCheck(this, DidChangeContentEmitter);\n\n    _this12 = _super5.call(this);\n    /**\r\n     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\r\n     */\n\n    _this12._fastEmitter = _this12._register(new Emitter());\n    _this12.fastEvent = _this12._fastEmitter.event;\n    _this12._slowEmitter = _this12._register(new Emitter());\n    _this12.slowEvent = _this12._slowEmitter.event;\n    _this12._deferredCnt = 0;\n    _this12._deferredEvent = null;\n    return _this12;\n  }\n\n  _createClass(DidChangeContentEmitter, [{\n    key: \"beginDeferredEmit\",\n    value: function beginDeferredEmit() {\n      this._deferredCnt++;\n    }\n  }, {\n    key: \"endDeferredEmit\",\n    value: function endDeferredEmit() {\n      var resultingSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this._deferredCnt--;\n\n      if (this._deferredCnt === 0) {\n        if (this._deferredEvent !== null) {\n          this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n          var e = this._deferredEvent;\n          this._deferredEvent = null;\n\n          this._fastEmitter.fire(e);\n\n          this._slowEmitter.fire(e);\n        }\n      }\n    }\n  }, {\n    key: \"fire\",\n    value: function fire(e) {\n      if (this._deferredCnt > 0) {\n        if (this._deferredEvent) {\n          this._deferredEvent = this._deferredEvent.merge(e);\n        } else {\n          this._deferredEvent = e;\n        }\n\n        return;\n      }\n\n      this._fastEmitter.fire(e);\n\n      this._slowEmitter.fire(e);\n    }\n  }]);\n\n  return DidChangeContentEmitter;\n}(Disposable);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js"],"names":["onUnexpectedError","Emitter","Disposable","strings","URI","EDITOR_MODEL_DEFAULTS","Position","Range","Selection","model","EditStack","guessIndentation","IntervalNode","IntervalTree","getNodeIsInOverviewRuler","recomputeMaxEnd","PieceTreeTextBufferBuilder","InternalModelContentChangeEvent","ModelRawContentChangedEvent","ModelRawEOLChanged","ModelRawFlush","ModelRawLineChanged","ModelRawLinesDeleted","ModelRawLinesInserted","SearchParams","TextModelSearch","TextModelTokenization","getWordAtText","LanguageConfigurationRegistry","NULL_LANGUAGE_IDENTIFIER","ignoreBracketsInToken","BracketsUtils","TokensStore","countEOL","TokensStore2","Color","PieceTreeTextBuffer","createTextBufferBuilder","createTextBufferFactory","text","builder","acceptChunk","finish","createTextBuffer","value","defaultEOL","factory","create","MODEL_ID","LIMIT_FIND_COUNT","LONG_LINE_BOUNDARY","TextModelSnapshot","source","_source","_eos","result","resultCnt","resultLength","tmp","read","join","length","invalidFunc","Error","BracketSearchCanceled","_searchCanceledBrand","undefined","INSTANCE","stripBracketSearchCanceled","TextModel","creationOptions","languageIdentifier","associatedResource","undoRedoService","_onWillDispose","_register","onWillDispose","event","_onDidChangeDecorations","DidChangeDecorationsEmitter","onDidChangeDecorations","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_eventEmitter","DidChangeContentEmitter","id","isForSimpleWidget","_associatedResource","parse","_undoRedoService","_attachedEditorCount","textBuffer","disposable","_buffer","_bufferDisposable","_options","resolveOptions","bufferLineCount","getLineCount","bufferTextLength","getValueLengthInRange","getLineLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_isDisposed","_isDisposing","_languageIdentifier","_languageRegistryListener","onDidChange","e","fire","_instanceId","singleLetterHash","_lastDecorationId","_decorations","Object","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","_tokens","_tokens2","_tokenization","listener","fastEvent","rawContentChangedEvent","contentChangedEvent","slowEvent","dispose","emptyDisposedTextBuffer","rawChange","change","_assertNotDisposed","_setValueFromTextBuffer","range","rangeOffset","rangeLength","isUndoing","isRedoing","isFlush","changes","eol","getEOL","versionId","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","endLineNumber","endColumn","getLineMaxColumn","_increaseVersionId","flush","clear","_emitContentChangedEvent","_createContentChanged2","getValue","newEOL","_onBeforeEOLChange","setEOL","_onAfterEOLChange","allDecorations","search","_ensureNodesHaveRanges","collectNodesPostOrder","i","len","node","delta","cachedAbsoluteStart","start","startOffset","getOffsetAt","startLineNumber","startColumn","endOffset","cachedAbsoluteEnd","cachedVersionId","end","isTooLargeForTokenization","smallLineCharCount","longLineCharCount","lineCount","lineNumber","lineLength","tabSize","indentSize","insertSpaces","_newOpts","trimAutoWhitespace","newOpts","TextModelResolvedOptions","equals","createChangeEvent","defaultInsertSpaces","defaultTabSize","guessedIndentation","updateOptions","str","normalizeIndentation","mightContainRTL","mightContainUnusualLineTerminators","selections","matches","findMatches","UNUSUAL_LINE_TERMINATORS","resetMightContainUnusualLineTerminators","pushEditOperations","map","m","mightContainNonBasicASCII","rawPosition","position","_validatePosition","column","rawOffset","offset","Math","min","getLength","max","getPositionAt","newAlternativeVersionId","newInitialUndoRedoSnapshot","preserveBOM","fullModelRange","fullModelValue","getValueInRange","getBOM","createSnapshot","rawRange","validateRange","getCharacterCountInRange","getLineContent","getLinesContent","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","linesCount","initialStartLineNumber","initialStartColumn","maxColumn","initialEndLineNumber","initialEndColumn","validationType","isNaN","charCodeBefore","getLineCharCode","isHighSurrogate","_lineNumber","_column","floor","_isValidPosition","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","_isValidRange","candidate","searchRange","searchData","captureMatches","limitResultCount","findMatchesLineByLine","searchString","rawSearchScope","isRegex","matchCase","wordSeparators","searchRanges","Array","isArray","every","searchScope","isIRange","sort","d1","d2","uniqueSearchRanges","push","reduce","prev","curr","areIntersecting","plusRange","matchMapper","indexOf","searchParams","parseSearchRequest","arr","concat","rawSearchStart","searchStart","validatePosition","ret","findNextMatch","findPreviousMatch","pushStackElement","popStackElement","currentEOL","beginDeferredEmit","uri","pushEOL","endDeferredEmit","rawOperation","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","rawOperations","_validateEditOperation","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","_validateEditOperations","incomingEdits","op","editsAreNearCursors","sel","foundEditNearSel","j","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","isEmpty","charAt","trimRange","pushEditOperation","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","rangeEnd","newEnd","oldText","_applyUndoRedoEdits","oldPosition","oldEnd","newText","applyEdits","_overwriteAlternativeVersionId","computeUndoEdits","operations","_doApplyEdits","oldLineCount","newLineCount","contentChanges","trimAutoWhitespaceLineNumbers","rawContentChanges","eolCount","firstLineLength","lastLineLength","acceptEdit","charCodeAt","acceptReplace","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","editLineNumber","currentEditLineNumber","spliceStartLineNumber","spliceLineNumber","cnt","fromLineNumber","newLines","reverseEdits","undo","canUndo","redo","canRedo","callback","ownerId","_changeDecorations","changeAccessor","addDecoration","options","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","getDecorationRange","newStickiness","TRACKED_RANGE_OPTIONS","_validateRangeRelaxedNoAllocations","reset","setOptions","insert","nodes","collectNodesFromOwner","decorationId","resolveNode","_getRangeAt","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","_getDecorationsInRange","validatedRange","filterRange","filterOwnerId","intervalSearch","getRangeAt","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","color","nodeIsInOverviewRuler","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","tokens","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","setTokens","lineHasChange","toLineNumber","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","isComplete","set","hasCompleteSemanticTokens","changedRange","setPartial","tokenizeViewport","forceTokenization","isCheapToTokenize","_getLineTokens","lineText","syntacticTokens","getTokens","addSemanticTokens","language","oldLanguage","newLanguage","lineTokens","getLineTokens","getLanguageId","findTokenIndexAtOffset","_position","lineContent","tokenIndex","_findLanguageBoundaries","rbStartOffset","rbEndOffset","rightBiasedWord","getWordDefinition","substring","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","getWordAtPosition","word","substr","_bracket","bracket","toLowerCase","languageId","bracketsSupport","getBracketsSupport","data","textIsBracket","_findMatchingBracketUp","_matchBracket","tokenCount","getCount","currentModeBrackets","getStandardTokenType","searchStartOffset","maxBracketLength","tokenEndOffset","getEndOffset","searchEndOffset","bestResult","foundBracket","findNextBracketInRange","forwardRegex","foundBracketText","r","_matchFoundBracket","textIsOpenBracket","getStartOffset","prevTokenIndex","prevModeBrackets","tokenStartOffset","findPrevBracketInRange","reversedRegex","isOpen","continueSearchPredicate","matched","_findMatchingBracketDown","getEndPosition","getStartPosition","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","modeBrackets","tokenLanguageId","_toFoundBracket","maxDuration","startTime","Date","now","savedCounts","Map","counts","resetCounts","has","brackets","get","searchInRange","index","open","close","lineIndex","computeIndentLevel","minLineNumber","maxLineNumber","foldingRules","getFoldingRules","offSide","Boolean","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","indent","_computeIndentLevel","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","detectIndentation","spacesCnt","tabsCnt","firstNonWhitespaceIndex","_normalizeIndentationFromWhitespace","line","chCode","DEFAULT_CREATION_OPTIONS","_decorationsTree0","_decorationsTree1","r0","r1","overviewRulerOnly","textLength","cleanClassName","className","replace","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","OverviewRulerLane","Center","theme","type","_resolveColor","c","getColor","toString","ModelDecorationMinimapOptions","fromHex","ModelDecorationOptions","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","showIfCollapsed","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","inlineClassName","inlineClassNameAffectsLetterSpacing","beforeContentClassName","afterContentClassName","EMPTY","register","createDynamic","_actual","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","_fastEmitter","_slowEmitter","_deferredEvent","merge"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { URI } from '../../../base/common/uri.js';\r\nimport { EDITOR_MODEL_DEFAULTS } from '../config/editorOptions.js';\r\nimport { Position } from '../core/position.js';\r\nimport { Range } from '../core/range.js';\r\nimport { Selection } from '../core/selection.js';\r\nimport * as model from '../model.js';\r\nimport { EditStack } from './editStack.js';\r\nimport { guessIndentation } from './indentationGuesser.js';\r\nimport { IntervalNode, IntervalTree, getNodeIsInOverviewRuler, recomputeMaxEnd } from './intervalTree.js';\r\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\r\nimport { InternalModelContentChangeEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from './textModelEvents.js';\r\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\r\nimport { TextModelTokenization } from './textModelTokens.js';\r\nimport { getWordAtText } from './wordHelper.js';\r\nimport { LanguageConfigurationRegistry } from '../modes/languageConfigurationRegistry.js';\r\nimport { NULL_LANGUAGE_IDENTIFIER } from '../modes/nullMode.js';\r\nimport { ignoreBracketsInToken } from '../modes/supports.js';\r\nimport { BracketsUtils } from '../modes/supports/richEditBrackets.js';\r\nimport { TokensStore, countEOL, TokensStore2 } from './tokensStore.js';\r\nimport { Color } from '../../../base/common/color.js';\r\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\r\nfunction createTextBufferBuilder() {\r\n    return new PieceTreeTextBufferBuilder();\r\n}\r\nexport function createTextBufferFactory(text) {\r\n    const builder = createTextBufferBuilder();\r\n    builder.acceptChunk(text);\r\n    return builder.finish();\r\n}\r\nexport function createTextBuffer(value, defaultEOL) {\r\n    const factory = (typeof value === 'string' ? createTextBufferFactory(value) : value);\r\n    return factory.create(defaultEOL);\r\n}\r\nlet MODEL_ID = 0;\r\nconst LIMIT_FIND_COUNT = 999;\r\nexport const LONG_LINE_BOUNDARY = 10000;\r\nclass TextModelSnapshot {\r\n    constructor(source) {\r\n        this._source = source;\r\n        this._eos = false;\r\n    }\r\n    read() {\r\n        if (this._eos) {\r\n            return null;\r\n        }\r\n        let result = [], resultCnt = 0, resultLength = 0;\r\n        do {\r\n            let tmp = this._source.read();\r\n            if (tmp === null) {\r\n                // end-of-stream\r\n                this._eos = true;\r\n                if (resultCnt === 0) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    return result.join('');\r\n                }\r\n            }\r\n            if (tmp.length > 0) {\r\n                result[resultCnt++] = tmp;\r\n                resultLength += tmp.length;\r\n            }\r\n            if (resultLength >= 64 * 1024) {\r\n                return result.join('');\r\n            }\r\n        } while (true);\r\n    }\r\n}\r\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\r\nclass BracketSearchCanceled {\r\n    constructor() {\r\n        this._searchCanceledBrand = undefined;\r\n    }\r\n}\r\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\r\nfunction stripBracketSearchCanceled(result) {\r\n    if (result instanceof BracketSearchCanceled) {\r\n        return null;\r\n    }\r\n    return result;\r\n}\r\nexport class TextModel extends Disposable {\r\n    //#endregion\r\n    constructor(source, creationOptions, languageIdentifier, associatedResource = null, undoRedoService) {\r\n        super();\r\n        //#region Events\r\n        this._onWillDispose = this._register(new Emitter());\r\n        this.onWillDispose = this._onWillDispose.event;\r\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter());\r\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\r\n        this._onDidChangeLanguage = this._register(new Emitter());\r\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\r\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\r\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\r\n        this._onDidChangeTokens = this._register(new Emitter());\r\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\r\n        this._onDidChangeOptions = this._register(new Emitter());\r\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\r\n        this._onDidChangeAttached = this._register(new Emitter());\r\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\r\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\r\n        // Generate a new unique model id\r\n        MODEL_ID++;\r\n        this.id = '$model' + MODEL_ID;\r\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\r\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\r\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\r\n        }\r\n        else {\r\n            this._associatedResource = associatedResource;\r\n        }\r\n        this._undoRedoService = undoRedoService;\r\n        this._attachedEditorCount = 0;\r\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\r\n        this._buffer = textBuffer;\r\n        this._bufferDisposable = disposable;\r\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\r\n        const bufferLineCount = this._buffer.getLineCount();\r\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* TextDefined */);\r\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\r\n        // If a model is too large at construction time, it will never get tokenized,\r\n        // under no circumstances.\r\n        if (creationOptions.largeFileOptimizations) {\r\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\r\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\r\n        }\r\n        else {\r\n            this._isTooLargeForTokenization = false;\r\n        }\r\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\r\n        this._versionId = 1;\r\n        this._alternativeVersionId = 1;\r\n        this._initialUndoRedoSnapshot = null;\r\n        this._isDisposed = false;\r\n        this._isDisposing = false;\r\n        this._languageIdentifier = languageIdentifier || NULL_LANGUAGE_IDENTIFIER;\r\n        this._languageRegistryListener = LanguageConfigurationRegistry.onDidChange((e) => {\r\n            if (e.languageIdentifier.id === this._languageIdentifier.id) {\r\n                this._onDidChangeLanguageConfiguration.fire({});\r\n            }\r\n        });\r\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\r\n        this._lastDecorationId = 0;\r\n        this._decorations = Object.create(null);\r\n        this._decorationsTree = new DecorationsTrees();\r\n        this._commandManager = new EditStack(this, undoRedoService);\r\n        this._isUndoing = false;\r\n        this._isRedoing = false;\r\n        this._trimAutoWhitespaceLines = null;\r\n        this._tokens = new TokensStore();\r\n        this._tokens2 = new TokensStore2();\r\n        this._tokenization = new TextModelTokenization(this);\r\n    }\r\n    static resolveOptions(textBuffer, options) {\r\n        if (options.detectIndentation) {\r\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\r\n            return new model.TextModelResolvedOptions({\r\n                tabSize: guessedIndentation.tabSize,\r\n                indentSize: guessedIndentation.tabSize,\r\n                insertSpaces: guessedIndentation.insertSpaces,\r\n                trimAutoWhitespace: options.trimAutoWhitespace,\r\n                defaultEOL: options.defaultEOL\r\n            });\r\n        }\r\n        return new model.TextModelResolvedOptions({\r\n            tabSize: options.tabSize,\r\n            indentSize: options.indentSize,\r\n            insertSpaces: options.insertSpaces,\r\n            trimAutoWhitespace: options.trimAutoWhitespace,\r\n            defaultEOL: options.defaultEOL\r\n        });\r\n    }\r\n    onDidChangeRawContentFast(listener) {\r\n        return this._eventEmitter.fastEvent((e) => listener(e.rawContentChangedEvent));\r\n    }\r\n    onDidChangeContentFast(listener) {\r\n        return this._eventEmitter.fastEvent((e) => listener(e.contentChangedEvent));\r\n    }\r\n    onDidChangeContent(listener) {\r\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\r\n    }\r\n    dispose() {\r\n        this._isDisposing = true;\r\n        this._onWillDispose.fire();\r\n        this._languageRegistryListener.dispose();\r\n        this._tokenization.dispose();\r\n        this._isDisposed = true;\r\n        super.dispose();\r\n        this._bufferDisposable.dispose();\r\n        this._isDisposing = false;\r\n        // Manually release reference to previous text buffer to avoid large leaks\r\n        // in case someone leaks a TextModel reference\r\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\r\n        emptyDisposedTextBuffer.dispose();\r\n        this._buffer = emptyDisposedTextBuffer;\r\n    }\r\n    _assertNotDisposed() {\r\n        if (this._isDisposed) {\r\n            throw new Error('Model is disposed!');\r\n        }\r\n    }\r\n    _emitContentChangedEvent(rawChange, change) {\r\n        if (this._isDisposing) {\r\n            // Do not confuse listeners by emitting any event after disposing\r\n            return;\r\n        }\r\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\r\n    }\r\n    setValue(value) {\r\n        this._assertNotDisposed();\r\n        if (value === null) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\r\n        this._setValueFromTextBuffer(textBuffer, disposable);\r\n    }\r\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\r\n        return {\r\n            changes: [{\r\n                    range: range,\r\n                    rangeOffset: rangeOffset,\r\n                    rangeLength: rangeLength,\r\n                    text: text,\r\n                }],\r\n            eol: this._buffer.getEOL(),\r\n            versionId: this.getVersionId(),\r\n            isUndoing: isUndoing,\r\n            isRedoing: isRedoing,\r\n            isFlush: isFlush\r\n        };\r\n    }\r\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\r\n        this._assertNotDisposed();\r\n        const oldFullModelRange = this.getFullModelRange();\r\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        const endLineNumber = this.getLineCount();\r\n        const endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._buffer = textBuffer;\r\n        this._bufferDisposable.dispose();\r\n        this._bufferDisposable = textBufferDisposable;\r\n        this._increaseVersionId();\r\n        // Flush all tokens\r\n        this._tokens.flush();\r\n        this._tokens2.flush();\r\n        // Destroy all my decorations\r\n        this._decorations = Object.create(null);\r\n        this._decorationsTree = new DecorationsTrees();\r\n        // Destroy my edit history and settings\r\n        this._commandManager.clear();\r\n        this._trimAutoWhitespaceLines = null;\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawFlush()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\r\n    }\r\n    setEOL(eol) {\r\n        this._assertNotDisposed();\r\n        const newEOL = (eol === 1 /* CRLF */ ? '\\r\\n' : '\\n');\r\n        if (this._buffer.getEOL() === newEOL) {\r\n            // Nothing to do\r\n            return;\r\n        }\r\n        const oldFullModelRange = this.getFullModelRange();\r\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\r\n        const endLineNumber = this.getLineCount();\r\n        const endColumn = this.getLineMaxColumn(endLineNumber);\r\n        this._onBeforeEOLChange();\r\n        this._buffer.setEOL(newEOL);\r\n        this._increaseVersionId();\r\n        this._onAfterEOLChange();\r\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\r\n            new ModelRawEOLChanged()\r\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\r\n    }\r\n    _onBeforeEOLChange() {\r\n        // Ensure all decorations get their `range` set.\r\n        const versionId = this.getVersionId();\r\n        const allDecorations = this._decorationsTree.search(0, false, false, versionId);\r\n        this._ensureNodesHaveRanges(allDecorations);\r\n    }\r\n    _onAfterEOLChange() {\r\n        // Transform back `range` to offsets\r\n        const versionId = this.getVersionId();\r\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\r\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\r\n            const node = allDecorations[i];\r\n            const delta = node.cachedAbsoluteStart - node.start;\r\n            const startOffset = this._buffer.getOffsetAt(node.range.startLineNumber, node.range.startColumn);\r\n            const endOffset = this._buffer.getOffsetAt(node.range.endLineNumber, node.range.endColumn);\r\n            node.cachedAbsoluteStart = startOffset;\r\n            node.cachedAbsoluteEnd = endOffset;\r\n            node.cachedVersionId = versionId;\r\n            node.start = startOffset - delta;\r\n            node.end = endOffset - delta;\r\n            recomputeMaxEnd(node);\r\n        }\r\n    }\r\n    onBeforeAttached() {\r\n        this._attachedEditorCount++;\r\n        if (this._attachedEditorCount === 1) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    }\r\n    onBeforeDetached() {\r\n        this._attachedEditorCount--;\r\n        if (this._attachedEditorCount === 0) {\r\n            this._onDidChangeAttached.fire(undefined);\r\n        }\r\n    }\r\n    isAttachedToEditor() {\r\n        return this._attachedEditorCount > 0;\r\n    }\r\n    getAttachedEditorCount() {\r\n        return this._attachedEditorCount;\r\n    }\r\n    isTooLargeForSyncing() {\r\n        return this._isTooLargeForSyncing;\r\n    }\r\n    isTooLargeForTokenization() {\r\n        return this._isTooLargeForTokenization;\r\n    }\r\n    isDisposed() {\r\n        return this._isDisposed;\r\n    }\r\n    isDominatedByLongLines() {\r\n        this._assertNotDisposed();\r\n        if (this.isTooLargeForTokenization()) {\r\n            // Cannot word wrap huge files anyways, so it doesn't really matter\r\n            return false;\r\n        }\r\n        let smallLineCharCount = 0;\r\n        let longLineCharCount = 0;\r\n        const lineCount = this._buffer.getLineCount();\r\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\r\n            const lineLength = this._buffer.getLineLength(lineNumber);\r\n            if (lineLength >= LONG_LINE_BOUNDARY) {\r\n                longLineCharCount += lineLength;\r\n            }\r\n            else {\r\n                smallLineCharCount += lineLength;\r\n            }\r\n        }\r\n        return (longLineCharCount > smallLineCharCount);\r\n    }\r\n    get uri() {\r\n        return this._associatedResource;\r\n    }\r\n    //#region Options\r\n    getOptions() {\r\n        this._assertNotDisposed();\r\n        return this._options;\r\n    }\r\n    getFormattingOptions() {\r\n        return {\r\n            tabSize: this._options.indentSize,\r\n            insertSpaces: this._options.insertSpaces\r\n        };\r\n    }\r\n    updateOptions(_newOpts) {\r\n        this._assertNotDisposed();\r\n        let tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\r\n        let indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\r\n        let insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\r\n        let trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\r\n        let newOpts = new model.TextModelResolvedOptions({\r\n            tabSize: tabSize,\r\n            indentSize: indentSize,\r\n            insertSpaces: insertSpaces,\r\n            defaultEOL: this._options.defaultEOL,\r\n            trimAutoWhitespace: trimAutoWhitespace\r\n        });\r\n        if (this._options.equals(newOpts)) {\r\n            return;\r\n        }\r\n        let e = this._options.createChangeEvent(newOpts);\r\n        this._options = newOpts;\r\n        this._onDidChangeOptions.fire(e);\r\n    }\r\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\r\n        this._assertNotDisposed();\r\n        let guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\r\n        this.updateOptions({\r\n            insertSpaces: guessedIndentation.insertSpaces,\r\n            tabSize: guessedIndentation.tabSize,\r\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\r\n        });\r\n    }\r\n    static _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\r\n        let spacesCnt = 0;\r\n        for (let i = 0; i < str.length; i++) {\r\n            if (str.charAt(i) === '\\t') {\r\n                spacesCnt += indentSize;\r\n            }\r\n            else {\r\n                spacesCnt++;\r\n            }\r\n        }\r\n        let result = '';\r\n        if (!insertSpaces) {\r\n            let tabsCnt = Math.floor(spacesCnt / indentSize);\r\n            spacesCnt = spacesCnt % indentSize;\r\n            for (let i = 0; i < tabsCnt; i++) {\r\n                result += '\\t';\r\n            }\r\n        }\r\n        for (let i = 0; i < spacesCnt; i++) {\r\n            result += ' ';\r\n        }\r\n        return result;\r\n    }\r\n    static normalizeIndentation(str, indentSize, insertSpaces) {\r\n        let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\r\n        if (firstNonWhitespaceIndex === -1) {\r\n            firstNonWhitespaceIndex = str.length;\r\n        }\r\n        return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\r\n    }\r\n    normalizeIndentation(str) {\r\n        this._assertNotDisposed();\r\n        return TextModel.normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\r\n    }\r\n    //#endregion\r\n    //#region Reading\r\n    getVersionId() {\r\n        this._assertNotDisposed();\r\n        return this._versionId;\r\n    }\r\n    mightContainRTL() {\r\n        return this._buffer.mightContainRTL();\r\n    }\r\n    mightContainUnusualLineTerminators() {\r\n        return this._buffer.mightContainUnusualLineTerminators();\r\n    }\r\n    removeUnusualLineTerminators(selections = null) {\r\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\r\n        this._buffer.resetMightContainUnusualLineTerminators();\r\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\r\n    }\r\n    mightContainNonBasicASCII() {\r\n        return this._buffer.mightContainNonBasicASCII();\r\n    }\r\n    getAlternativeVersionId() {\r\n        this._assertNotDisposed();\r\n        return this._alternativeVersionId;\r\n    }\r\n    getInitialUndoRedoSnapshot() {\r\n        this._assertNotDisposed();\r\n        return this._initialUndoRedoSnapshot;\r\n    }\r\n    getOffsetAt(rawPosition) {\r\n        this._assertNotDisposed();\r\n        let position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* Relaxed */);\r\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\r\n    }\r\n    getPositionAt(rawOffset) {\r\n        this._assertNotDisposed();\r\n        let offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\r\n        return this._buffer.getPositionAt(offset);\r\n    }\r\n    _increaseVersionId() {\r\n        this._versionId = this._versionId + 1;\r\n        this._alternativeVersionId = this._versionId;\r\n    }\r\n    _overwriteVersionId(versionId) {\r\n        this._versionId = versionId;\r\n    }\r\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\r\n        this._alternativeVersionId = newAlternativeVersionId;\r\n    }\r\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\r\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\r\n    }\r\n    getValue(eol, preserveBOM = false) {\r\n        this._assertNotDisposed();\r\n        const fullModelRange = this.getFullModelRange();\r\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM() + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    }\r\n    createSnapshot(preserveBOM = false) {\r\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\r\n    }\r\n    getValueLength(eol, preserveBOM = false) {\r\n        this._assertNotDisposed();\r\n        const fullModelRange = this.getFullModelRange();\r\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\r\n        if (preserveBOM) {\r\n            return this._buffer.getBOM().length + fullModelValue;\r\n        }\r\n        return fullModelValue;\r\n    }\r\n    getValueInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getValueLengthInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getCharacterCountInRange(rawRange, eol = 0 /* TextDefined */) {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\r\n    }\r\n    getLineCount() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLineCount();\r\n    }\r\n    getLineContent(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineContent(lineNumber);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber);\r\n    }\r\n    getLinesContent() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getLinesContent();\r\n    }\r\n    getEOL() {\r\n        this._assertNotDisposed();\r\n        return this._buffer.getEOL();\r\n    }\r\n    getEndOfLineSequence() {\r\n        this._assertNotDisposed();\r\n        return (this._buffer.getEOL() === '\\n'\r\n            ? 0 /* LF */\r\n            : 1 /* CRLF */);\r\n    }\r\n    getLineMinColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        return 1;\r\n    }\r\n    getLineMaxColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLength(lineNumber) + 1;\r\n    }\r\n    getLineFirstNonWhitespaceColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\r\n    }\r\n    getLineLastNonWhitespaceColumn(lineNumber) {\r\n        this._assertNotDisposed();\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\r\n    }\r\n    /**\r\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\r\n     * Will try to not allocate if possible.\r\n     */\r\n    _validateRangeRelaxedNoAllocations(range) {\r\n        const linesCount = this._buffer.getLineCount();\r\n        const initialStartLineNumber = range.startLineNumber;\r\n        const initialStartColumn = range.startColumn;\r\n        let startLineNumber;\r\n        let startColumn;\r\n        if (initialStartLineNumber < 1) {\r\n            startLineNumber = 1;\r\n            startColumn = 1;\r\n        }\r\n        else if (initialStartLineNumber > linesCount) {\r\n            startLineNumber = linesCount;\r\n            startColumn = this.getLineMaxColumn(startLineNumber);\r\n        }\r\n        else {\r\n            startLineNumber = initialStartLineNumber | 0;\r\n            if (initialStartColumn <= 1) {\r\n                startColumn = 1;\r\n            }\r\n            else {\r\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\r\n                if (initialStartColumn >= maxColumn) {\r\n                    startColumn = maxColumn;\r\n                }\r\n                else {\r\n                    startColumn = initialStartColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        const initialEndLineNumber = range.endLineNumber;\r\n        const initialEndColumn = range.endColumn;\r\n        let endLineNumber;\r\n        let endColumn;\r\n        if (initialEndLineNumber < 1) {\r\n            endLineNumber = 1;\r\n            endColumn = 1;\r\n        }\r\n        else if (initialEndLineNumber > linesCount) {\r\n            endLineNumber = linesCount;\r\n            endColumn = this.getLineMaxColumn(endLineNumber);\r\n        }\r\n        else {\r\n            endLineNumber = initialEndLineNumber | 0;\r\n            if (initialEndColumn <= 1) {\r\n                endColumn = 1;\r\n            }\r\n            else {\r\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\r\n                if (initialEndColumn >= maxColumn) {\r\n                    endColumn = maxColumn;\r\n                }\r\n                else {\r\n                    endColumn = initialEndColumn | 0;\r\n                }\r\n            }\r\n        }\r\n        if (initialStartLineNumber === startLineNumber\r\n            && initialStartColumn === startColumn\r\n            && initialEndLineNumber === endLineNumber\r\n            && initialEndColumn === endColumn\r\n            && range instanceof Range\r\n            && !(range instanceof Selection)) {\r\n            return range;\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    _isValidPosition(lineNumber, column, validationType) {\r\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\r\n            return false;\r\n        }\r\n        if (isNaN(lineNumber) || isNaN(column)) {\r\n            return false;\r\n        }\r\n        if (lineNumber < 1 || column < 1) {\r\n            return false;\r\n        }\r\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\r\n            return false;\r\n        }\r\n        const lineCount = this._buffer.getLineCount();\r\n        if (lineNumber > lineCount) {\r\n            return false;\r\n        }\r\n        if (column === 1) {\r\n            return true;\r\n        }\r\n        const maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column > maxColumn) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // !!At this point, column > 1\r\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _validatePosition(_lineNumber, _column, validationType) {\r\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\r\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\r\n        const lineCount = this._buffer.getLineCount();\r\n        if (lineNumber < 1) {\r\n            return new Position(1, 1);\r\n        }\r\n        if (lineNumber > lineCount) {\r\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\r\n        }\r\n        if (column <= 1) {\r\n            return new Position(lineNumber, 1);\r\n        }\r\n        const maxColumn = this.getLineMaxColumn(lineNumber);\r\n        if (column >= maxColumn) {\r\n            return new Position(lineNumber, maxColumn);\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            // If the position would end up in the middle of a high-low surrogate pair,\r\n            // we move it to before the pair\r\n            // !!At this point, column > 1\r\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\r\n            if (strings.isHighSurrogate(charCodeBefore)) {\r\n                return new Position(lineNumber, column - 1);\r\n            }\r\n        }\r\n        return new Position(lineNumber, column);\r\n    }\r\n    validatePosition(position) {\r\n        const validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if (position instanceof Position) {\r\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\r\n                return position;\r\n            }\r\n        }\r\n        return this._validatePosition(position.lineNumber, position.column, validationType);\r\n    }\r\n    _isValidRange(range, validationType) {\r\n        const startLineNumber = range.startLineNumber;\r\n        const startColumn = range.startColumn;\r\n        const endLineNumber = range.endLineNumber;\r\n        const endColumn = range.endColumn;\r\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* Relaxed */)) {\r\n            return false;\r\n        }\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    validateRange(_range) {\r\n        const validationType = 1 /* SurrogatePairs */;\r\n        this._assertNotDisposed();\r\n        // Avoid object allocation and cover most likely case\r\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\r\n            if (this._isValidRange(_range, validationType)) {\r\n                return _range;\r\n            }\r\n        }\r\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* Relaxed */);\r\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* Relaxed */);\r\n        const startLineNumber = start.lineNumber;\r\n        const startColumn = start.column;\r\n        const endLineNumber = end.lineNumber;\r\n        const endColumn = end.column;\r\n        if (validationType === 1 /* SurrogatePairs */) {\r\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\r\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\r\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\r\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\r\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\r\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n            }\r\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\r\n                // do not expand a collapsed range, simply move it to a valid location\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\r\n            }\r\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\r\n                // expand range at both ends\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\r\n            }\r\n            if (startInsideSurrogatePair) {\r\n                // only expand range at the start\r\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\r\n            }\r\n            // only expand range at the end\r\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\r\n        }\r\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n    }\r\n    modifyPosition(rawPosition, offset) {\r\n        this._assertNotDisposed();\r\n        let candidate = this.getOffsetAt(rawPosition) + offset;\r\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\r\n    }\r\n    getFullModelRange() {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\r\n    }\r\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\r\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n    }\r\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\r\n        this._assertNotDisposed();\r\n        let searchRanges = null;\r\n        if (rawSearchScope !== null) {\r\n            if (!Array.isArray(rawSearchScope)) {\r\n                rawSearchScope = [rawSearchScope];\r\n            }\r\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\r\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\r\n            }\r\n        }\r\n        if (searchRanges === null) {\r\n            searchRanges = [this.getFullModelRange()];\r\n        }\r\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\r\n        const uniqueSearchRanges = [];\r\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\r\n            if (Range.areIntersecting(prev, curr)) {\r\n                return prev.plusRange(curr);\r\n            }\r\n            uniqueSearchRanges.push(prev);\r\n            return curr;\r\n        }));\r\n        let matchMapper;\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            // not regex, not multi line\r\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            const searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return [];\r\n            }\r\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\r\n        }\r\n        else {\r\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\r\n        }\r\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\r\n    }\r\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        const searchStart = this.validatePosition(rawSearchStart);\r\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\r\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\r\n            const searchData = searchParams.parseSearchRequest();\r\n            if (!searchData) {\r\n                return null;\r\n            }\r\n            const lineCount = this.getLineCount();\r\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\r\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\r\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\r\n            if (ret.length > 0) {\r\n                return ret[0];\r\n            }\r\n            return null;\r\n        }\r\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    }\r\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\r\n        this._assertNotDisposed();\r\n        const searchStart = this.validatePosition(rawSearchStart);\r\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\r\n    }\r\n    //#endregion\r\n    //#region Editing\r\n    pushStackElement() {\r\n        this._commandManager.pushStackElement();\r\n    }\r\n    popStackElement() {\r\n        this._commandManager.popStackElement();\r\n    }\r\n    pushEOL(eol) {\r\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* LF */ : 1 /* CRLF */);\r\n        if (currentEOL === eol) {\r\n            return;\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            if (this._initialUndoRedoSnapshot === null) {\r\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\r\n            }\r\n            this._commandManager.pushEOL(eol);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _validateEditOperation(rawOperation) {\r\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\r\n            return rawOperation;\r\n        }\r\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\r\n    }\r\n    _validateEditOperations(rawOperations) {\r\n        const result = [];\r\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\r\n            result[i] = this._validateEditOperation(rawOperations[i]);\r\n        }\r\n        return result;\r\n    }\r\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\r\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\r\n            // Go through each saved line number and insert a trim whitespace edit\r\n            // if it is safe to do so (no conflicts with other edits).\r\n            let incomingEdits = editOperations.map((op) => {\r\n                return {\r\n                    range: this.validateRange(op.range),\r\n                    text: op.text\r\n                };\r\n            });\r\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\r\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\r\n            let editsAreNearCursors = true;\r\n            if (beforeCursorState) {\r\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\r\n                    let sel = beforeCursorState[i];\r\n                    let foundEditNearSel = false;\r\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                        let editRange = incomingEdits[j].range;\r\n                        let selIsAbove = editRange.startLineNumber > sel.endLineNumber;\r\n                        let selIsBelow = sel.startLineNumber > editRange.endLineNumber;\r\n                        if (!selIsAbove && !selIsBelow) {\r\n                            foundEditNearSel = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!foundEditNearSel) {\r\n                        editsAreNearCursors = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (editsAreNearCursors) {\r\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\r\n                    let trimLineNumber = this._trimAutoWhitespaceLines[i];\r\n                    let maxLineColumn = this.getLineMaxColumn(trimLineNumber);\r\n                    let allowTrimLine = true;\r\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\r\n                        let editRange = incomingEdits[j].range;\r\n                        let editText = incomingEdits[j].text;\r\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\r\n                            // `trimLine` is completely outside this edit\r\n                            continue;\r\n                        }\r\n                        // At this point:\r\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\r\n                            continue;\r\n                        }\r\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\r\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\r\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\r\n                            continue;\r\n                        }\r\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\r\n                        allowTrimLine = false;\r\n                        break;\r\n                    }\r\n                    if (allowTrimLine) {\r\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\r\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\r\n                    }\r\n                }\r\n            }\r\n            this._trimAutoWhitespaceLines = null;\r\n        }\r\n        if (this._initialUndoRedoSnapshot === null) {\r\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\r\n        }\r\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\r\n    }\r\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\r\n        const edits = changes.map((change) => {\r\n            const rangeStart = this.getPositionAt(change.newPosition);\r\n            const rangeEnd = this.getPositionAt(change.newEnd);\r\n            return {\r\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\r\n                text: change.oldText\r\n            };\r\n        });\r\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\r\n    }\r\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\r\n        const edits = changes.map((change) => {\r\n            const rangeStart = this.getPositionAt(change.oldPosition);\r\n            const rangeEnd = this.getPositionAt(change.oldEnd);\r\n            return {\r\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\r\n                text: change.newText\r\n            };\r\n        });\r\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\r\n    }\r\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            this._isUndoing = isUndoing;\r\n            this._isRedoing = isRedoing;\r\n            this.applyEdits(edits, false);\r\n            this.setEOL(eol);\r\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\r\n        }\r\n        finally {\r\n            this._isUndoing = false;\r\n            this._isRedoing = false;\r\n            this._eventEmitter.endDeferredEmit(resultingSelection);\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    applyEdits(rawOperations, computeUndoEdits = false) {\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            this._eventEmitter.beginDeferredEmit();\r\n            const operations = this._validateEditOperations(rawOperations);\r\n            return this._doApplyEdits(operations, computeUndoEdits);\r\n        }\r\n        finally {\r\n            this._eventEmitter.endDeferredEmit();\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _doApplyEdits(rawOperations, computeUndoEdits) {\r\n        const oldLineCount = this._buffer.getLineCount();\r\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\r\n        const newLineCount = this._buffer.getLineCount();\r\n        const contentChanges = result.changes;\r\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\r\n        if (contentChanges.length !== 0) {\r\n            let rawContentChanges = [];\r\n            let lineCount = oldLineCount;\r\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\r\n                const change = contentChanges[i];\r\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\r\n                this._tokens.acceptEdit(change.range, eolCount, firstLineLength);\r\n                this._tokens2.acceptEdit(change.range, eolCount, firstLineLength, lastLineLength, change.text.length > 0 ? change.text.charCodeAt(0) : 0 /* Null */);\r\n                this._onDidChangeDecorations.fire();\r\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\r\n                const startLineNumber = change.range.startLineNumber;\r\n                const endLineNumber = change.range.endLineNumber;\r\n                const deletingLinesCnt = endLineNumber - startLineNumber;\r\n                const insertingLinesCnt = eolCount;\r\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\r\n                for (let j = editingLinesCnt; j >= 0; j--) {\r\n                    const editLineNumber = startLineNumber + j;\r\n                    const currentEditLineNumber = newLineCount - lineCount - changeLineCountDelta + editLineNumber;\r\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber)));\r\n                }\r\n                if (editingLinesCnt < deletingLinesCnt) {\r\n                    // Must delete some lines\r\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\r\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\r\n                }\r\n                if (editingLinesCnt < insertingLinesCnt) {\r\n                    // Must insert some lines\r\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\r\n                    const cnt = insertingLinesCnt - editingLinesCnt;\r\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\r\n                    let newLines = [];\r\n                    for (let i = 0; i < cnt; i++) {\r\n                        let lineNumber = fromLineNumber + i;\r\n                        newLines[lineNumber - fromLineNumber] = this.getLineContent(lineNumber);\r\n                    }\r\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines));\r\n                }\r\n                lineCount += changeLineCountDelta;\r\n            }\r\n            this._increaseVersionId();\r\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\r\n                changes: contentChanges,\r\n                eol: this._buffer.getEOL(),\r\n                versionId: this.getVersionId(),\r\n                isUndoing: this._isUndoing,\r\n                isRedoing: this._isRedoing,\r\n                isFlush: false\r\n            });\r\n        }\r\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\r\n    }\r\n    undo() {\r\n        return this._undoRedoService.undo(this.uri);\r\n    }\r\n    canUndo() {\r\n        return this._undoRedoService.canUndo(this.uri);\r\n    }\r\n    redo() {\r\n        return this._undoRedoService.redo(this.uri);\r\n    }\r\n    canRedo() {\r\n        return this._undoRedoService.canRedo(this.uri);\r\n    }\r\n    //#endregion\r\n    //#region Decorations\r\n    changeDecorations(callback, ownerId = 0) {\r\n        this._assertNotDisposed();\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            return this._changeDecorations(ownerId, callback);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _changeDecorations(ownerId, callback) {\r\n        let changeAccessor = {\r\n            addDecoration: (range, options) => {\r\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\r\n            },\r\n            changeDecoration: (id, newRange) => {\r\n                this._changeDecorationImpl(id, newRange);\r\n            },\r\n            changeDecorationOptions: (id, options) => {\r\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\r\n            },\r\n            removeDecoration: (id) => {\r\n                this._deltaDecorationsImpl(ownerId, [id], []);\r\n            },\r\n            deltaDecorations: (oldDecorations, newDecorations) => {\r\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n                    // nothing to do\r\n                    return [];\r\n                }\r\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n            }\r\n        };\r\n        let result = null;\r\n        try {\r\n            result = callback(changeAccessor);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n        // Invalidate change accessor\r\n        changeAccessor.addDecoration = invalidFunc;\r\n        changeAccessor.changeDecoration = invalidFunc;\r\n        changeAccessor.changeDecorationOptions = invalidFunc;\r\n        changeAccessor.removeDecoration = invalidFunc;\r\n        changeAccessor.deltaDecorations = invalidFunc;\r\n        return result;\r\n    }\r\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\r\n        this._assertNotDisposed();\r\n        if (!oldDecorations) {\r\n            oldDecorations = [];\r\n        }\r\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\r\n            // nothing to do\r\n            return [];\r\n        }\r\n        try {\r\n            this._onDidChangeDecorations.beginDeferredEmit();\r\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\r\n        }\r\n        finally {\r\n            this._onDidChangeDecorations.endDeferredEmit();\r\n        }\r\n    }\r\n    _getTrackedRange(id) {\r\n        return this.getDecorationRange(id);\r\n    }\r\n    _setTrackedRange(id, newRange, newStickiness) {\r\n        const node = (id ? this._decorations[id] : null);\r\n        if (!node) {\r\n            if (!newRange) {\r\n                // node doesn't exist, the request is to delete => nothing to do\r\n                return null;\r\n            }\r\n            // node doesn't exist, the request is to set => add the tracked range\r\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\r\n        }\r\n        if (!newRange) {\r\n            // node exists, the request is to delete => delete node\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n            return null;\r\n        }\r\n        // node exists, the request is to set => change the tracked range and its options\r\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\r\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\r\n        this._decorationsTree.insert(node);\r\n        return node.id;\r\n    }\r\n    removeAllDecorationsWithOwnerId(ownerId) {\r\n        if (this._isDisposed) {\r\n            return;\r\n        }\r\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\r\n        for (let i = 0, len = nodes.length; i < len; i++) {\r\n            const node = nodes[i];\r\n            this._decorationsTree.delete(node);\r\n            delete this._decorations[node.id];\r\n        }\r\n    }\r\n    getDecorationOptions(decorationId) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        return node.options;\r\n    }\r\n    getDecorationRange(decorationId) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        const versionId = this.getVersionId();\r\n        if (node.cachedVersionId !== versionId) {\r\n            this._decorationsTree.resolveNode(node, versionId);\r\n        }\r\n        if (node.range === null) {\r\n            node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n        }\r\n        return node.range;\r\n    }\r\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            return [];\r\n        }\r\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\r\n    }\r\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\r\n        let lineCount = this.getLineCount();\r\n        let startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\r\n        let endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\r\n        let endColumn = this.getLineMaxColumn(endLineNumber);\r\n        return this._getDecorationsInRange(new Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);\r\n    }\r\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\r\n        let validatedRange = this.validateRange(range);\r\n        return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\r\n    }\r\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, true, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.search(ownerId, filterOutValidation, false, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\r\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\r\n        const versionId = this.getVersionId();\r\n        const result = this._decorationsTree.intervalSearch(startOffset, endOffset, filterOwnerId, filterOutValidation, versionId);\r\n        return this._ensureNodesHaveRanges(result);\r\n    }\r\n    _ensureNodesHaveRanges(nodes) {\r\n        for (let i = 0, len = nodes.length; i < len; i++) {\r\n            const node = nodes[i];\r\n            if (node.range === null) {\r\n                node.range = this._getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n    _getRangeAt(start, end) {\r\n        return this._buffer.getRangeAt(start, end - start);\r\n    }\r\n    _changeDecorationImpl(decorationId, _range) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        const range = this._validateRangeRelaxedNoAllocations(_range);\r\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n        this._decorationsTree.delete(node);\r\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\r\n        this._decorationsTree.insert(node);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n    }\r\n    _changeDecorationOptionsImpl(decorationId, options) {\r\n        const node = this._decorations[decorationId];\r\n        if (!node) {\r\n            return;\r\n        }\r\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\r\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\r\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\r\n            // Delete + Insert due to an overview ruler status change\r\n            this._decorationsTree.delete(node);\r\n            node.setOptions(options);\r\n            this._decorationsTree.insert(node);\r\n        }\r\n        else {\r\n            node.setOptions(options);\r\n        }\r\n    }\r\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\r\n        const versionId = this.getVersionId();\r\n        const oldDecorationsLen = oldDecorationsIds.length;\r\n        let oldDecorationIndex = 0;\r\n        const newDecorationsLen = newDecorations.length;\r\n        let newDecorationIndex = 0;\r\n        let result = new Array(newDecorationsLen);\r\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\r\n            let node = null;\r\n            if (oldDecorationIndex < oldDecorationsLen) {\r\n                // (1) get ourselves an old node\r\n                do {\r\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\r\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\r\n                // (2) remove the node from the tree (if it exists)\r\n                if (node) {\r\n                    this._decorationsTree.delete(node);\r\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\r\n                }\r\n            }\r\n            if (newDecorationIndex < newDecorationsLen) {\r\n                // (3) create a new node if necessary\r\n                if (!node) {\r\n                    const internalDecorationId = (++this._lastDecorationId);\r\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\r\n                    node = new IntervalNode(decorationId, 0, 0);\r\n                    this._decorations[decorationId] = node;\r\n                }\r\n                // (4) initialize node\r\n                const newDecoration = newDecorations[newDecorationIndex];\r\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\r\n                const options = _normalizeOptions(newDecoration.options);\r\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\r\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\r\n                node.ownerId = ownerId;\r\n                node.reset(versionId, startOffset, endOffset, range);\r\n                node.setOptions(options);\r\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\r\n                this._decorationsTree.insert(node);\r\n                result[newDecorationIndex] = node.id;\r\n                newDecorationIndex++;\r\n            }\r\n            else {\r\n                if (node) {\r\n                    delete this._decorations[node.id];\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    setTokens(tokens) {\r\n        if (tokens.length === 0) {\r\n            return;\r\n        }\r\n        let ranges = [];\r\n        for (let i = 0, len = tokens.length; i < len; i++) {\r\n            const element = tokens[i];\r\n            let minChangedLineNumber = 0;\r\n            let maxChangedLineNumber = 0;\r\n            let hasChange = false;\r\n            for (let j = 0, lenJ = element.tokens.length; j < lenJ; j++) {\r\n                const lineNumber = element.startLineNumber + j;\r\n                if (hasChange) {\r\n                    this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], false);\r\n                    maxChangedLineNumber = lineNumber;\r\n                }\r\n                else {\r\n                    const lineHasChange = this._tokens.setTokens(this._languageIdentifier.id, lineNumber - 1, this._buffer.getLineLength(lineNumber), element.tokens[j], true);\r\n                    if (lineHasChange) {\r\n                        hasChange = true;\r\n                        minChangedLineNumber = lineNumber;\r\n                        maxChangedLineNumber = lineNumber;\r\n                    }\r\n                }\r\n            }\r\n            if (hasChange) {\r\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber });\r\n            }\r\n        }\r\n        if (ranges.length > 0) {\r\n            this._emitModelTokensChangedEvent({\r\n                tokenizationSupportChanged: false,\r\n                semanticTokensApplied: false,\r\n                ranges: ranges\r\n            });\r\n        }\r\n    }\r\n    setSemanticTokens(tokens, isComplete) {\r\n        this._tokens2.set(tokens, isComplete);\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            semanticTokensApplied: tokens !== null,\r\n            ranges: [{ fromLineNumber: 1, toLineNumber: this.getLineCount() }]\r\n        });\r\n    }\r\n    hasCompleteSemanticTokens() {\r\n        return this._tokens2.isComplete();\r\n    }\r\n    hasSomeSemanticTokens() {\r\n        return !this._tokens2.isEmpty();\r\n    }\r\n    setPartialSemanticTokens(range, tokens) {\r\n        if (this.hasCompleteSemanticTokens()) {\r\n            return;\r\n        }\r\n        const changedRange = this._tokens2.setPartial(range, tokens);\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: false,\r\n            semanticTokensApplied: true,\r\n            ranges: [{ fromLineNumber: changedRange.startLineNumber, toLineNumber: changedRange.endLineNumber }]\r\n        });\r\n    }\r\n    tokenizeViewport(startLineNumber, endLineNumber) {\r\n        startLineNumber = Math.max(1, startLineNumber);\r\n        endLineNumber = Math.min(this._buffer.getLineCount(), endLineNumber);\r\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\r\n    }\r\n    clearTokens() {\r\n        this._tokens.flush();\r\n        this._emitModelTokensChangedEvent({\r\n            tokenizationSupportChanged: true,\r\n            semanticTokensApplied: false,\r\n            ranges: [{\r\n                    fromLineNumber: 1,\r\n                    toLineNumber: this._buffer.getLineCount()\r\n                }]\r\n        });\r\n    }\r\n    _emitModelTokensChangedEvent(e) {\r\n        if (!this._isDisposing) {\r\n            this._onDidChangeTokens.fire(e);\r\n        }\r\n    }\r\n    resetTokenization() {\r\n        this._tokenization.reset();\r\n    }\r\n    forceTokenization(lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        this._tokenization.forceTokenization(lineNumber);\r\n    }\r\n    isCheapToTokenize(lineNumber) {\r\n        return this._tokenization.isCheapToTokenize(lineNumber);\r\n    }\r\n    tokenizeIfCheap(lineNumber) {\r\n        if (this.isCheapToTokenize(lineNumber)) {\r\n            this.forceTokenization(lineNumber);\r\n        }\r\n    }\r\n    getLineTokens(lineNumber) {\r\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        return this._getLineTokens(lineNumber);\r\n    }\r\n    _getLineTokens(lineNumber) {\r\n        const lineText = this.getLineContent(lineNumber);\r\n        const syntacticTokens = this._tokens.getTokens(this._languageIdentifier.id, lineNumber - 1, lineText);\r\n        return this._tokens2.addSemanticTokens(lineNumber, syntacticTokens);\r\n    }\r\n    getLanguageIdentifier() {\r\n        return this._languageIdentifier;\r\n    }\r\n    getModeId() {\r\n        return this._languageIdentifier.language;\r\n    }\r\n    setMode(languageIdentifier) {\r\n        if (this._languageIdentifier.id === languageIdentifier.id) {\r\n            // There's nothing to do\r\n            return;\r\n        }\r\n        let e = {\r\n            oldLanguage: this._languageIdentifier.language,\r\n            newLanguage: languageIdentifier.language\r\n        };\r\n        this._languageIdentifier = languageIdentifier;\r\n        this._onDidChangeLanguage.fire(e);\r\n        this._onDidChangeLanguageConfiguration.fire({});\r\n    }\r\n    getLanguageIdAtPosition(lineNumber, column) {\r\n        const position = this.validatePosition(new Position(lineNumber, column));\r\n        const lineTokens = this.getLineTokens(position.lineNumber);\r\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n    }\r\n    // Having tokens allows implementing additional helper methods\r\n    getWordAtPosition(_position) {\r\n        this._assertNotDisposed();\r\n        const position = this.validatePosition(_position);\r\n        const lineContent = this.getLineContent(position.lineNumber);\r\n        const lineTokens = this._getLineTokens(position.lineNumber);\r\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        // (1). First try checking right biased word\r\n        const [rbStartOffset, rbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex);\r\n        const rightBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex)), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\r\n        // Make sure the result touches the original passed in position\r\n        if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\r\n            return rightBiasedWord;\r\n        }\r\n        // (2). Else, if we were at a language boundary, check the left biased word\r\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\r\n            // edge case, where `position` sits between two tokens belonging to two different languages\r\n            const [lbStartOffset, lbEndOffset] = TextModel._findLanguageBoundaries(lineTokens, tokenIndex - 1);\r\n            const leftBiasedWord = getWordAtText(position.column, LanguageConfigurationRegistry.getWordDefinition(lineTokens.getLanguageId(tokenIndex - 1)), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\r\n            // Make sure the result touches the original passed in position\r\n            if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\r\n                return leftBiasedWord;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\r\n        const languageId = lineTokens.getLanguageId(tokenIndex);\r\n        // go left until a different language is hit\r\n        let startOffset = 0;\r\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\r\n            startOffset = lineTokens.getStartOffset(i);\r\n        }\r\n        // go right until a different language is hit\r\n        let endOffset = lineTokens.getLineContent().length;\r\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\r\n            endOffset = lineTokens.getEndOffset(i);\r\n        }\r\n        return [startOffset, endOffset];\r\n    }\r\n    getWordUntilPosition(position) {\r\n        const wordAtPosition = this.getWordAtPosition(position);\r\n        if (!wordAtPosition) {\r\n            return {\r\n                word: '',\r\n                startColumn: position.column,\r\n                endColumn: position.column\r\n            };\r\n        }\r\n        return {\r\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\r\n            startColumn: wordAtPosition.startColumn,\r\n            endColumn: position.column\r\n        };\r\n    }\r\n    findMatchingBracketUp(_bracket, _position) {\r\n        let bracket = _bracket.toLowerCase();\r\n        let position = this.validatePosition(_position);\r\n        let lineTokens = this._getLineTokens(position.lineNumber);\r\n        let languageId = lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\r\n        let bracketsSupport = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n        if (!bracketsSupport) {\r\n            return null;\r\n        }\r\n        let data = bracketsSupport.textIsBracket[bracket];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, null));\r\n    }\r\n    matchBracket(position) {\r\n        return this._matchBracket(this.validatePosition(position));\r\n    }\r\n    _matchBracket(position) {\r\n        const lineNumber = position.lineNumber;\r\n        const lineTokens = this._getLineTokens(lineNumber);\r\n        const tokenCount = lineTokens.getCount();\r\n        const lineText = this._buffer.getLineContent(lineNumber);\r\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n        if (tokenIndex < 0) {\r\n            return null;\r\n        }\r\n        const currentModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(tokenIndex));\r\n        // check that the token is not to be ignored\r\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\r\n            // limit search to not go before `maxBracketLength`\r\n            let searchStartOffset = Math.max(0, position.column - 1 - currentModeBrackets.maxBracketLength);\r\n            for (let i = tokenIndex - 1; i >= 0; i--) {\r\n                const tokenEndOffset = lineTokens.getEndOffset(i);\r\n                if (tokenEndOffset <= searchStartOffset) {\r\n                    break;\r\n                }\r\n                if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                    searchStartOffset = tokenEndOffset;\r\n                }\r\n            }\r\n            // limit search to not go after `maxBracketLength`\r\n            const searchEndOffset = Math.min(lineText.length, position.column - 1 + currentModeBrackets.maxBracketLength);\r\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\r\n            // `bestResult` will contain the most right-side result\r\n            let bestResult = null;\r\n            while (true) {\r\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!foundBracket) {\r\n                    // there are no more brackets in this text\r\n                    break;\r\n                }\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], null);\r\n                    if (r) {\r\n                        if (r instanceof BracketSearchCanceled) {\r\n                            return null;\r\n                        }\r\n                        bestResult = r;\r\n                    }\r\n                }\r\n                searchStartOffset = foundBracket.endColumn - 1;\r\n            }\r\n            if (bestResult) {\r\n                return bestResult;\r\n            }\r\n        }\r\n        // If position is in between two tokens, try also looking in the previous token\r\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\r\n            const prevTokenIndex = tokenIndex - 1;\r\n            const prevModeBrackets = LanguageConfigurationRegistry.getBracketsSupport(lineTokens.getLanguageId(prevTokenIndex));\r\n            // check that previous token is not to be ignored\r\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\r\n                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`\r\n                const searchStartOffset = Math.max(0, position.column - 1 - prevModeBrackets.maxBracketLength);\r\n                let searchEndOffset = Math.min(lineText.length, position.column - 1 + prevModeBrackets.maxBracketLength);\r\n                for (let i = prevTokenIndex + 1; i < tokenCount; i++) {\r\n                    const tokenStartOffset = lineTokens.getStartOffset(i);\r\n                    if (tokenStartOffset >= searchEndOffset) {\r\n                        break;\r\n                    }\r\n                    if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i))) {\r\n                        searchEndOffset = tokenStartOffset;\r\n                    }\r\n                }\r\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                // check that we didn't hit a bracket too far away from position\r\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\r\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\r\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], null);\r\n                    if (r) {\r\n                        if (r instanceof BracketSearchCanceled) {\r\n                            return null;\r\n                        }\r\n                        return r;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        const matched = (isOpen\r\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\r\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\r\n        if (!matched) {\r\n            return null;\r\n        }\r\n        if (matched instanceof BracketSearchCanceled) {\r\n            return matched;\r\n        }\r\n        return [foundBracket, matched];\r\n    }\r\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\r\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        const languageId = bracket.languageIdentifier.id;\r\n        const reversedBracketRegex = bracket.reversedRegex;\r\n        let count = -1;\r\n        let totalCallCount = 0;\r\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchEndOffset = r.startColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = tokenCount - 1;\r\n            let searchStartOffset = lineText.length;\r\n            let searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\r\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\r\n        const languageId = bracket.languageIdentifier.id;\r\n        const bracketRegex = bracket.forwardRegex;\r\n        let count = 1;\r\n        let totalCallCount = 0;\r\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                if (bracket.isOpen(hitText)) {\r\n                    count++;\r\n                }\r\n                else if (bracket.isClose(hitText)) {\r\n                    count--;\r\n                }\r\n                if (count === 0) {\r\n                    return r;\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        const lineCount = this.getLineCount();\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return r;\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findPrevBracket(_position) {\r\n        const position = this.validatePosition(_position);\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = tokenCount - 1;\r\n            let searchStartOffset = lineText.length;\r\n            let searchEndOffset = lineText.length;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex >= 0; tokenIndex--) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchStartOffset\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findNextBracket(_position) {\r\n        const position = this.validatePosition(_position);\r\n        const lineCount = this.getLineCount();\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return this._toFoundBracket(modeBrackets, r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return this._toFoundBracket(modeBrackets, r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    findEnclosingBrackets(_position, maxDuration) {\r\n        let continueSearchPredicate;\r\n        if (typeof maxDuration === 'undefined') {\r\n            continueSearchPredicate = null;\r\n        }\r\n        else {\r\n            const startTime = Date.now();\r\n            continueSearchPredicate = () => {\r\n                return (Date.now() - startTime <= maxDuration);\r\n            };\r\n        }\r\n        const position = this.validatePosition(_position);\r\n        const lineCount = this.getLineCount();\r\n        const savedCounts = new Map();\r\n        let counts = [];\r\n        const resetCounts = (languageId, modeBrackets) => {\r\n            if (!savedCounts.has(languageId)) {\r\n                let tmp = [];\r\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\r\n                    tmp[i] = 0;\r\n                }\r\n                savedCounts.set(languageId, tmp);\r\n            }\r\n            counts = savedCounts.get(languageId);\r\n        };\r\n        let totalCallCount = 0;\r\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\r\n            while (true) {\r\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\r\n                    return BracketSearchCanceled.INSTANCE;\r\n                }\r\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (!r) {\r\n                    break;\r\n                }\r\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\r\n                const bracket = modeBrackets.textIsBracket[hitText];\r\n                if (bracket) {\r\n                    if (bracket.isOpen(hitText)) {\r\n                        counts[bracket.index]++;\r\n                    }\r\n                    else if (bracket.isClose(hitText)) {\r\n                        counts[bracket.index]--;\r\n                    }\r\n                    if (counts[bracket.index] === -1) {\r\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\r\n                    }\r\n                }\r\n                searchStartOffset = r.endColumn - 1;\r\n            }\r\n            return null;\r\n        };\r\n        let languageId = -1;\r\n        let modeBrackets = null;\r\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\r\n            const lineTokens = this._getLineTokens(lineNumber);\r\n            const tokenCount = lineTokens.getCount();\r\n            const lineText = this._buffer.getLineContent(lineNumber);\r\n            let tokenIndex = 0;\r\n            let searchStartOffset = 0;\r\n            let searchEndOffset = 0;\r\n            if (lineNumber === position.lineNumber) {\r\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\r\n                searchStartOffset = position.column - 1;\r\n                searchEndOffset = position.column - 1;\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n            }\r\n            let prevSearchInToken = true;\r\n            for (; tokenIndex < tokenCount; tokenIndex++) {\r\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\r\n                if (languageId !== tokenLanguageId) {\r\n                    // language id change!\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return stripBracketSearchCanceled(r);\r\n                        }\r\n                        prevSearchInToken = false;\r\n                    }\r\n                    languageId = tokenLanguageId;\r\n                    modeBrackets = LanguageConfigurationRegistry.getBracketsSupport(languageId);\r\n                    resetCounts(languageId, modeBrackets);\r\n                }\r\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\r\n                if (searchInToken) {\r\n                    // this token should be searched\r\n                    if (prevSearchInToken) {\r\n                        // the previous token should be searched, simply extend searchEndOffset\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                    else {\r\n                        // the previous token should not be searched\r\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\r\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\r\n                    }\r\n                }\r\n                else {\r\n                    // this token should not be searched\r\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                        if (r) {\r\n                            return stripBracketSearchCanceled(r);\r\n                        }\r\n                    }\r\n                }\r\n                prevSearchInToken = searchInToken;\r\n            }\r\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\r\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\r\n                if (r) {\r\n                    return stripBracketSearchCanceled(r);\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _toFoundBracket(modeBrackets, r) {\r\n        if (!r) {\r\n            return null;\r\n        }\r\n        let text = this.getValueInRange(r);\r\n        text = text.toLowerCase();\r\n        let data = modeBrackets.textIsBracket[text];\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        return {\r\n            range: r,\r\n            open: data.open,\r\n            close: data.close,\r\n            isOpen: modeBrackets.textIsOpenBracket[text]\r\n        };\r\n    }\r\n    /**\r\n     * Returns:\r\n     *  - -1 => the line consists of whitespace\r\n     *  - otherwise => the indent level is returned value\r\n     */\r\n    static computeIndentLevel(line, tabSize) {\r\n        let indent = 0;\r\n        let i = 0;\r\n        let len = line.length;\r\n        while (i < len) {\r\n            let chCode = line.charCodeAt(i);\r\n            if (chCode === 32 /* Space */) {\r\n                indent++;\r\n            }\r\n            else if (chCode === 9 /* Tab */) {\r\n                indent = indent - indent % tabSize + tabSize;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        if (i === len) {\r\n            return -1; // line only consists of whitespace\r\n        }\r\n        return indent;\r\n    }\r\n    _computeIndentLevel(lineIndex) {\r\n        return TextModel.computeIndentLevel(this._buffer.getLineContent(lineIndex + 1), this._options.tabSize);\r\n    }\r\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        if (lineNumber < 1 || lineNumber > lineCount) {\r\n            throw new Error('Illegal value for lineNumber');\r\n        }\r\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let up_aboveContentLineIndent = -1;\r\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let up_belowContentLineIndent = -1;\r\n        const up_resolveIndents = (lineNumber) => {\r\n            if (up_aboveContentLineIndex !== -1 && (up_aboveContentLineIndex === -2 || up_aboveContentLineIndex > lineNumber - 1)) {\r\n                up_aboveContentLineIndex = -1;\r\n                up_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        up_aboveContentLineIndex = lineIndex;\r\n                        up_aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (up_belowContentLineIndex === -2) {\r\n                up_belowContentLineIndex = -1;\r\n                up_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        up_belowContentLineIndex = lineIndex;\r\n                        up_belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let down_aboveContentLineIndent = -1;\r\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let down_belowContentLineIndent = -1;\r\n        const down_resolveIndents = (lineNumber) => {\r\n            if (down_aboveContentLineIndex === -2) {\r\n                down_aboveContentLineIndex = -1;\r\n                down_aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        down_aboveContentLineIndex = lineIndex;\r\n                        down_aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (down_belowContentLineIndex !== -1 && (down_belowContentLineIndex === -2 || down_belowContentLineIndex < lineNumber - 1)) {\r\n                down_belowContentLineIndex = -1;\r\n                down_belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        down_belowContentLineIndex = lineIndex;\r\n                        down_belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        let startLineNumber = 0;\r\n        let goUp = true;\r\n        let endLineNumber = 0;\r\n        let goDown = true;\r\n        let indent = 0;\r\n        let initialIndent = 0;\r\n        for (let distance = 0; goUp || goDown; distance++) {\r\n            const upLineNumber = lineNumber - distance;\r\n            const downLineNumber = lineNumber + distance;\r\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\r\n                goUp = false;\r\n            }\r\n            if (distance > 1 && (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\r\n                goDown = false;\r\n            }\r\n            if (distance > 50000) {\r\n                // stop processing\r\n                goUp = false;\r\n                goDown = false;\r\n            }\r\n            let upLineIndentLevel = -1;\r\n            if (goUp) {\r\n                // compute indent level going up\r\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    up_belowContentLineIndex = upLineNumber - 1;\r\n                    up_belowContentLineIndent = currentIndent;\r\n                    upLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    up_resolveIndents(upLineNumber);\r\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\r\n                }\r\n            }\r\n            let downLineIndentLevel = -1;\r\n            if (goDown) {\r\n                // compute indent level going down\r\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\r\n                if (currentIndent >= 0) {\r\n                    // This line has content (besides whitespace)\r\n                    // Use the line's indent\r\n                    down_aboveContentLineIndex = downLineNumber - 1;\r\n                    down_aboveContentLineIndent = currentIndent;\r\n                    downLineIndentLevel = Math.ceil(currentIndent / this._options.indentSize);\r\n                }\r\n                else {\r\n                    down_resolveIndents(downLineNumber);\r\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\r\n                }\r\n            }\r\n            if (distance === 0) {\r\n                initialIndent = upLineIndentLevel;\r\n                continue;\r\n            }\r\n            if (distance === 1) {\r\n                if (downLineNumber <= lineCount && downLineIndentLevel >= 0 && initialIndent + 1 === downLineIndentLevel) {\r\n                    // This is the beginning of a scope, we have special handling here, since we want the\r\n                    // child scope indent to be active, not the parent scope\r\n                    goUp = false;\r\n                    startLineNumber = downLineNumber;\r\n                    endLineNumber = downLineNumber;\r\n                    indent = downLineIndentLevel;\r\n                    continue;\r\n                }\r\n                if (upLineNumber >= 1 && upLineIndentLevel >= 0 && upLineIndentLevel - 1 === initialIndent) {\r\n                    // This is the end of a scope, just like above\r\n                    goDown = false;\r\n                    startLineNumber = upLineNumber;\r\n                    endLineNumber = upLineNumber;\r\n                    indent = upLineIndentLevel;\r\n                    continue;\r\n                }\r\n                startLineNumber = lineNumber;\r\n                endLineNumber = lineNumber;\r\n                indent = initialIndent;\r\n                if (indent === 0) {\r\n                    // No need to continue\r\n                    return { startLineNumber, endLineNumber, indent };\r\n                }\r\n            }\r\n            if (goUp) {\r\n                if (upLineIndentLevel >= indent) {\r\n                    startLineNumber = upLineNumber;\r\n                }\r\n                else {\r\n                    goUp = false;\r\n                }\r\n            }\r\n            if (goDown) {\r\n                if (downLineIndentLevel >= indent) {\r\n                    endLineNumber = downLineNumber;\r\n                }\r\n                else {\r\n                    goDown = false;\r\n                }\r\n            }\r\n        }\r\n        return { startLineNumber, endLineNumber, indent };\r\n    }\r\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\r\n        this._assertNotDisposed();\r\n        const lineCount = this.getLineCount();\r\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\r\n            throw new Error('Illegal value for startLineNumber');\r\n        }\r\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\r\n            throw new Error('Illegal value for endLineNumber');\r\n        }\r\n        const foldingRules = LanguageConfigurationRegistry.getFoldingRules(this._languageIdentifier.id);\r\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\r\n        let result = new Array(endLineNumber - startLineNumber + 1);\r\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let aboveContentLineIndent = -1;\r\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\r\n        let belowContentLineIndent = -1;\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            let resultIndex = lineNumber - startLineNumber;\r\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\r\n            if (currentIndent >= 0) {\r\n                // This line has content (besides whitespace)\r\n                // Use the line's indent\r\n                aboveContentLineIndex = lineNumber - 1;\r\n                aboveContentLineIndent = currentIndent;\r\n                result[resultIndex] = Math.ceil(currentIndent / this._options.indentSize);\r\n                continue;\r\n            }\r\n            if (aboveContentLineIndex === -2) {\r\n                aboveContentLineIndex = -1;\r\n                aboveContentLineIndent = -1;\r\n                // must find previous line with content\r\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        aboveContentLineIndex = lineIndex;\r\n                        aboveContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (belowContentLineIndex !== -1 && (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\r\n                belowContentLineIndex = -1;\r\n                belowContentLineIndent = -1;\r\n                // must find next line with content\r\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\r\n                    let indent = this._computeIndentLevel(lineIndex);\r\n                    if (indent >= 0) {\r\n                        belowContentLineIndex = lineIndex;\r\n                        belowContentLineIndent = indent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\r\n        }\r\n        return result;\r\n    }\r\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\r\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\r\n            // At the top or bottom of the file\r\n            return 0;\r\n        }\r\n        else if (aboveContentLineIndent < belowContentLineIndent) {\r\n            // we are inside the region above\r\n            return (1 + Math.floor(aboveContentLineIndent / this._options.indentSize));\r\n        }\r\n        else if (aboveContentLineIndent === belowContentLineIndent) {\r\n            // we are in between two regions\r\n            return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n        }\r\n        else {\r\n            if (offSide) {\r\n                // same level as region below\r\n                return Math.ceil(belowContentLineIndent / this._options.indentSize);\r\n            }\r\n            else {\r\n                // we are inside the region that ends below\r\n                return (1 + Math.floor(belowContentLineIndent / this._options.indentSize));\r\n            }\r\n        }\r\n    }\r\n}\r\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\r\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\r\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\r\nTextModel.DEFAULT_CREATION_OPTIONS = {\r\n    isForSimpleWidget: false,\r\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\r\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\r\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\r\n    detectIndentation: false,\r\n    defaultEOL: 1 /* LF */,\r\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\r\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\r\n};\r\n//#region Decorations\r\nclass DecorationsTrees {\r\n    constructor() {\r\n        this._decorationsTree0 = new IntervalTree();\r\n        this._decorationsTree1 = new IntervalTree();\r\n    }\r\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\r\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\r\n        return r0.concat(r1);\r\n    }\r\n    search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\r\n        if (overviewRulerOnly) {\r\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n        }\r\n        else {\r\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\r\n            return r0.concat(r1);\r\n        }\r\n    }\r\n    collectNodesFromOwner(ownerId) {\r\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\r\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\r\n        return r0.concat(r1);\r\n    }\r\n    collectNodesPostOrder() {\r\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\r\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\r\n        return r0.concat(r1);\r\n    }\r\n    insert(node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.insert(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.insert(node);\r\n        }\r\n    }\r\n    delete(node) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.delete(node);\r\n        }\r\n        else {\r\n            this._decorationsTree0.delete(node);\r\n        }\r\n    }\r\n    resolveNode(node, cachedVersionId) {\r\n        if (getNodeIsInOverviewRuler(node)) {\r\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\r\n        }\r\n        else {\r\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\r\n        }\r\n    }\r\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\r\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\r\n    }\r\n}\r\nfunction cleanClassName(className) {\r\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\r\n}\r\nclass DecorationOptions {\r\n    constructor(options) {\r\n        this.color = options.color || '';\r\n        this.darkColor = options.darkColor || '';\r\n    }\r\n}\r\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\r\n    constructor(options) {\r\n        super(options);\r\n        this._resolvedColor = null;\r\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\r\n    }\r\n    getColor(theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    }\r\n    invalidateCachedColor() {\r\n        this._resolvedColor = null;\r\n    }\r\n    _resolveColor(color, theme) {\r\n        if (typeof color === 'string') {\r\n            return color;\r\n        }\r\n        let c = color ? theme.getColor(color.id) : null;\r\n        if (!c) {\r\n            return '';\r\n        }\r\n        return c.toString();\r\n    }\r\n}\r\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\r\n    constructor(options) {\r\n        super(options);\r\n        this.position = options.position;\r\n    }\r\n    getColor(theme) {\r\n        if (!this._resolvedColor) {\r\n            if (theme.type !== 'light' && this.darkColor) {\r\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\r\n            }\r\n            else {\r\n                this._resolvedColor = this._resolveColor(this.color, theme);\r\n            }\r\n        }\r\n        return this._resolvedColor;\r\n    }\r\n    invalidateCachedColor() {\r\n        this._resolvedColor = undefined;\r\n    }\r\n    _resolveColor(color, theme) {\r\n        if (typeof color === 'string') {\r\n            return Color.fromHex(color);\r\n        }\r\n        return theme.getColor(color.id);\r\n    }\r\n}\r\nexport class ModelDecorationOptions {\r\n    constructor(options) {\r\n        this.stickiness = options.stickiness || 0 /* AlwaysGrowsWhenTypingAtEdges */;\r\n        this.zIndex = options.zIndex || 0;\r\n        this.className = options.className ? cleanClassName(options.className) : null;\r\n        this.hoverMessage = options.hoverMessage || null;\r\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\r\n        this.isWholeLine = options.isWholeLine || false;\r\n        this.showIfCollapsed = options.showIfCollapsed || false;\r\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\r\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\r\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\r\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\r\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\r\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\r\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\r\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\r\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\r\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\r\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\r\n    }\r\n    static register(options) {\r\n        return new ModelDecorationOptions(options);\r\n    }\r\n    static createDynamic(options) {\r\n        return new ModelDecorationOptions(options);\r\n    }\r\n}\r\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({});\r\n/**\r\n * The order carefully matches the values of the enum.\r\n */\r\nconst TRACKED_RANGE_OPTIONS = [\r\n    ModelDecorationOptions.register({ stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }),\r\n    ModelDecorationOptions.register({ stickiness: 2 /* GrowsOnlyWhenTypingBefore */ }),\r\n    ModelDecorationOptions.register({ stickiness: 3 /* GrowsOnlyWhenTypingAfter */ }),\r\n];\r\nfunction _normalizeOptions(options) {\r\n    if (options instanceof ModelDecorationOptions) {\r\n        return options;\r\n    }\r\n    return ModelDecorationOptions.createDynamic(options);\r\n}\r\nexport class DidChangeDecorationsEmitter extends Disposable {\r\n    constructor() {\r\n        super();\r\n        this._actual = this._register(new Emitter());\r\n        this.event = this._actual.event;\r\n        this._deferredCnt = 0;\r\n        this._shouldFire = false;\r\n        this._affectsMinimap = false;\r\n        this._affectsOverviewRuler = false;\r\n    }\r\n    beginDeferredEmit() {\r\n        this._deferredCnt++;\r\n    }\r\n    endDeferredEmit() {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._shouldFire) {\r\n                const event = {\r\n                    affectsMinimap: this._affectsMinimap,\r\n                    affectsOverviewRuler: this._affectsOverviewRuler,\r\n                };\r\n                this._shouldFire = false;\r\n                this._affectsMinimap = false;\r\n                this._affectsOverviewRuler = false;\r\n                this._actual.fire(event);\r\n            }\r\n        }\r\n    }\r\n    checkAffectedAndFire(options) {\r\n        if (!this._affectsMinimap) {\r\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\r\n        }\r\n        if (!this._affectsOverviewRuler) {\r\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\r\n        }\r\n        this._shouldFire = true;\r\n    }\r\n    fire() {\r\n        this._affectsMinimap = true;\r\n        this._affectsOverviewRuler = true;\r\n        this._shouldFire = true;\r\n    }\r\n}\r\n//#endregion\r\nexport class DidChangeContentEmitter extends Disposable {\r\n    constructor() {\r\n        super();\r\n        /**\r\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\r\n         */\r\n        this._fastEmitter = this._register(new Emitter());\r\n        this.fastEvent = this._fastEmitter.event;\r\n        this._slowEmitter = this._register(new Emitter());\r\n        this.slowEvent = this._slowEmitter.event;\r\n        this._deferredCnt = 0;\r\n        this._deferredEvent = null;\r\n    }\r\n    beginDeferredEmit() {\r\n        this._deferredCnt++;\r\n    }\r\n    endDeferredEmit(resultingSelection = null) {\r\n        this._deferredCnt--;\r\n        if (this._deferredCnt === 0) {\r\n            if (this._deferredEvent !== null) {\r\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\r\n                const e = this._deferredEvent;\r\n                this._deferredEvent = null;\r\n                this._fastEmitter.fire(e);\r\n                this._slowEmitter.fire(e);\r\n            }\r\n        }\r\n    }\r\n    fire(e) {\r\n        if (this._deferredCnt > 0) {\r\n            if (this._deferredEvent) {\r\n                this._deferredEvent = this._deferredEvent.merge(e);\r\n            }\r\n            else {\r\n                this._deferredEvent = e;\r\n            }\r\n            return;\r\n        }\r\n        this._fastEmitter.fire(e);\r\n        this._slowEmitter.fire(e);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}