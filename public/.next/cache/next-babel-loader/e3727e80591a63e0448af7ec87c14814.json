{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nimport * as extpath from './extpath.js';\nimport * as paths from './path.js';\nimport { LRUCache } from './map.js';\nimport { isThenable } from './async.js';\nvar GLOBSTAR = '**';\nvar GLOB_SPLIT = '/';\nvar PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\n\nvar NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\n\nvar ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount) {\n  switch (starCount) {\n    case 0:\n      return '';\n\n    case 1:\n      return \"\".concat(NO_PATH_REGEX, \"*?\");\n    // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\n    default:\n      // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\n      // Group is non capturing because we don't need to capture at all (?:...)\n      // Overall we use non-greedy matching because it could be that we match too much\n      return \"(?:\".concat(PATH_REGEX, \"|\").concat(NO_PATH_REGEX, \"+\").concat(PATH_REGEX, \"|\").concat(PATH_REGEX).concat(NO_PATH_REGEX, \"+)*?\");\n  }\n}\n\nexport function splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n\n  var segments = [];\n  var inBraces = false;\n  var inBrackets = false;\n  var curVal = '';\n\n  var _iterator = _createForOfIteratorHelper(pattern),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _char = _step.value;\n\n      switch (_char) {\n        case splitChar:\n          if (!inBraces && !inBrackets) {\n            segments.push(curVal);\n            curVal = '';\n            continue;\n          }\n\n          break;\n\n        case '{':\n          inBraces = true;\n          break;\n\n        case '}':\n          inBraces = false;\n          break;\n\n        case '[':\n          inBrackets = true;\n          break;\n\n        case ']':\n          inBrackets = false;\n          break;\n      }\n\n      curVal += _char;\n    } // Tail\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (curVal) {\n    segments.push(curVal);\n  }\n\n  return segments;\n}\n\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n\n  var regEx = ''; // Split up into segments for each slash found\n\n  var segments = splitGlobAware(pattern, GLOB_SPLIT); // Special case where we only have globstars\n\n  if (segments.every(function (s) {\n    return s === GLOBSTAR;\n  })) {\n    regEx = '.*';\n  } // Build regex over segments\n  else {\n      var previousSegmentWasGlobStar = false;\n      segments.forEach(function (segment, index) {\n        // Globstar is special\n        if (segment === GLOBSTAR) {\n          // if we have more than one globstar after another, just ignore it\n          if (!previousSegmentWasGlobStar) {\n            regEx += starsToRegExp(2);\n            previousSegmentWasGlobStar = true;\n          }\n\n          return;\n        } // States\n\n\n        var inBraces = false;\n        var braceVal = '';\n        var inBrackets = false;\n        var bracketVal = '';\n\n        var _iterator2 = _createForOfIteratorHelper(segment),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _char2 = _step2.value;\n\n            // Support brace expansion\n            if (_char2 !== '}' && inBraces) {\n              braceVal += _char2;\n              continue;\n            } // Support brackets\n\n\n            if (inBrackets && (_char2 !== ']' || !bracketVal)\n            /* ] is literally only allowed as first character in brackets to match it */\n            ) {\n                var res = void 0; // range operator\n\n                if (_char2 === '-') {\n                  res = _char2;\n                } // negation operator (only valid on first index in bracket)\n                else if ((_char2 === '^' || _char2 === '!') && !bracketVal) {\n                    res = '^';\n                  } // glob split matching is not allowed within character ranges\n                  // see http://man7.org/linux/man-pages/man7/glob.7.html\n                  else if (_char2 === GLOB_SPLIT) {\n                      res = '';\n                    } // anything else gets escaped\n                    else {\n                        res = strings.escapeRegExpCharacters(_char2);\n                      }\n\n                bracketVal += res;\n                continue;\n              }\n\n            switch (_char2) {\n              case '{':\n                inBraces = true;\n                continue;\n\n              case '[':\n                inBrackets = true;\n                continue;\n\n              case '}':\n                var choices = splitGlobAware(braceVal, ','); // Converts {foo,bar} => [foo|bar]\n\n                var braceRegExp = \"(?:\".concat(choices.map(function (c) {\n                  return parseRegExp(c);\n                }).join('|'), \")\");\n                regEx += braceRegExp;\n                inBraces = false;\n                braceVal = '';\n                break;\n\n              case ']':\n                regEx += '[' + bracketVal + ']';\n                inBrackets = false;\n                bracketVal = '';\n                break;\n\n              case '?':\n                regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\n                continue;\n\n              case '*':\n                regEx += starsToRegExp(1);\n                continue;\n\n              default:\n                regEx += strings.escapeRegExpCharacters(_char2);\n            }\n          } // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\n          // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\n          // a folder called \"something\" to match as well.\n          // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\n          // is to match 0-N segments.\n\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n          regEx += PATH_REGEX;\n        } // reset state\n\n\n        previousSegmentWasGlobStar = false;\n      });\n    }\n\n  return regEx;\n} // regexes to check for trival glob patterns that just check for String#endsWith\n\n\nvar T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\n\nvar T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\n\nvar T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\n\nvar T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\n\nvar T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\n\nvar T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\n\nvar CACHE = new LRUCache(10000); // bounded to 10000 elements\n\nvar FALSE = function FALSE() {\n  return false;\n};\n\n_c = FALSE;\n\nvar NULL = function NULL() {\n  return null;\n};\n\n_c2 = NULL;\n\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  } // Handle IRelativePattern\n\n\n  var pattern;\n\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  } // Whitespace trimming\n\n\n  pattern = pattern.trim(); // Check cache\n\n  var patternKey = \"\".concat(pattern, \"_\").concat(!!options.trimForExclusions);\n  var parsedPattern = CACHE.get(patternKey);\n\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  } // Check for Trivias\n\n\n  var match;\n\n  if (T1.test(pattern)) {\n    // common pattern: **/*.txt just need endsWith check\n    var base = pattern.substr(4); // '**/*'.length === 4\n\n    parsedPattern = function parsedPattern(path, basename) {\n      return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/some.txt just need basename check\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    // repetition of common patterns (see above) {**/*.txt,**/*.png}\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    // common pattern: **/something/else just need endsWith check\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    // common pattern: something/else just need equals check\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } // Otherwise convert to pattern\n  else {\n      parsedPattern = toRegExp(pattern);\n    } // Cache\n\n\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n\n  return function (path, basename) {\n    if (!extpath.isEqualOrParent(path, arg2.base)) {\n      return null;\n    }\n\n    return parsedPattern(paths.relative(arg2.base, path), basename);\n  };\n}\n\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n} // common pattern: **/some.txt just need basename check\n\n\nfunction trivia2(base, originalPattern) {\n  var slashBase = \"/\".concat(base);\n  var backslashBase = \"\\\\\".concat(base);\n\n  var parsedPattern = function parsedPattern(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (basename) {\n      return basename === base ? originalPattern : null;\n    }\n\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\n  };\n\n  var basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [originalPattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n} // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\n\nfunction trivia3(pattern, options) {\n  var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(function (pattern) {\n    return parsePattern(pattern, options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }), pattern);\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (n === 1) {\n    return parsedPatterns[0];\n  }\n\n  var parsedPattern = function parsedPattern(path, basename) {\n    for (var i = 0, _n = parsedPatterns.length; i < _n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = parsedPatterns.find(function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n\n  return parsedPattern;\n} // common patterns: **/something/else just need endsWith check, something/else just needs and equals check\n\n\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  var usingPosixSep = paths.sep === paths.posix.sep;\n  var nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\n  var nativePathEnd = paths.sep + nativePath;\n  var targetPathEnd = paths.posix.sep + targetPath;\n  var parsedPattern = matchPathEnds ? function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || testPath.endsWith(nativePathEnd) || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd))) ? pattern : null;\n  } : function (testPath, basename) {\n    return typeof testPath === 'string' && (testPath === nativePath || !usingPosixSep && testPath === targetPath) ? pattern : null;\n  };\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\n\nfunction toRegExp(pattern) {\n  try {\n    var regExp = new RegExp(\"^\".concat(parseRegExp(pattern), \"$\"));\n    return function (path) {\n      regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\n\nexport function match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n\n  return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!arg1) {\n    return FALSE;\n  } // Glob with String\n\n\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    var parsedPattern = parsePattern(arg1, options);\n\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n\n    var resultPattern = function resultPattern(path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n\n    return resultPattern;\n  } // Glob with Expression\n\n\n  return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n  var rp = obj;\n  return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nfunction parsedExpression(expression, options) {\n  var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(function (pattern) {\n    return parseExpressionPattern(pattern, expression[pattern], options);\n  }).filter(function (pattern) {\n    return pattern !== NULL;\n  }));\n  var n = parsedPatterns.length;\n\n  if (!n) {\n    return NULL;\n  }\n\n  if (!parsedPatterns.some(function (parsedPattern) {\n    return !!parsedPattern.requiresSiblings;\n  })) {\n    if (n === 1) {\n      return parsedPatterns[0];\n    }\n\n    var _resultExpression = function _resultExpression(path, basename) {\n      for (var i = 0, _n2 = parsedPatterns.length; i < _n2; i++) {\n        // Pattern matches path\n        var result = parsedPatterns[i](path, basename);\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    };\n\n    var _withBasenames = parsedPatterns.find(function (pattern) {\n      return !!pattern.allBasenames;\n    });\n\n    if (_withBasenames) {\n      _resultExpression.allBasenames = _withBasenames.allBasenames;\n    }\n\n    var _allPaths = parsedPatterns.reduce(function (all, current) {\n      return current.allPaths ? all.concat(current.allPaths) : all;\n    }, []);\n\n    if (_allPaths.length) {\n      _resultExpression.allPaths = _allPaths;\n    }\n\n    return _resultExpression;\n  }\n\n  var resultExpression = function resultExpression(path, basename, hasSibling) {\n    var name = undefined;\n\n    for (var i = 0, _n3 = parsedPatterns.length; i < _n3; i++) {\n      // Pattern matches path\n      var parsedPattern = parsedPatterns[i];\n\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!basename) {\n          basename = paths.basename(path);\n        }\n\n        if (!name) {\n          name = basename.substr(0, basename.length - paths.extname(path).length);\n        }\n      }\n\n      var result = parsedPattern(path, basename, name, hasSibling);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  };\n\n  var withBasenames = parsedPatterns.find(function (pattern) {\n    return !!pattern.allBasenames;\n  });\n\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n\n  var allPaths = parsedPatterns.reduce(function (all, current) {\n    return current.allPaths ? all.concat(current.allPaths) : all;\n  }, []);\n\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n\n  return resultExpression;\n}\n\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL; // pattern is disabled\n  }\n\n  var parsedPattern = parsePattern(pattern, options);\n\n  if (parsedPattern === NULL) {\n    return NULL;\n  } // Expression Pattern is <boolean>\n\n\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  } // Expression Pattern is <SiblingClause>\n\n\n  if (value) {\n    var when = value.when;\n\n    if (typeof when === 'string') {\n      var result = function result(path, basename, name, hasSibling) {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n\n        var clausePattern = when.replace('$(basename)', name);\n        var matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(function (m) {\n          return m ? pattern : null;\n        }) : matched ? pattern : null;\n      };\n\n      result.requiresSiblings = true;\n      return result;\n    }\n  } // Expression is Anything\n\n\n  return parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  var basenamePatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !!parsedPattern.basenames;\n  });\n\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n\n  var basenames = basenamePatterns.reduce(function (all, current) {\n    var basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  var patterns;\n\n  if (result) {\n    patterns = [];\n\n    for (var i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce(function (all, current) {\n      var patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n\n  var aggregate = function aggregate(path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n\n    if (!basename) {\n      var _i;\n\n      for (_i = path.length; _i > 0; _i--) {\n        var ch = path.charCodeAt(_i - 1);\n\n        if (ch === 47\n        /* Slash */\n        || ch === 92\n        /* Backslash */\n        ) {\n            break;\n          }\n      }\n\n      basename = path.substr(_i);\n    }\n\n    var index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) {\n    return !parsedPattern.basenames;\n  });\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"FALSE\");\n$RefreshReg$(_c2, \"NULL\");","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"names":["strings","extpath","paths","LRUCache","isThenable","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","s","previousSegmentWasGlobStar","forEach","segment","index","braceVal","bracketVal","res","escapeRegExpCharacters","choices","braceRegExp","map","c","join","length","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","base","substr","path","basename","endsWith","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","isEqualOrParent","relative","originalPattern","slashBase","backslashBase","basenames","patterns","allBasenames","parsedPatterns","aggregateBasenameMatches","slice","split","filter","n","i","withBasenames","find","allPaths","reduce","all","current","concat","targetPath","matchPathEnds","usingPosixSep","sep","posix","nativePath","replace","nativePathEnd","targetPathEnd","testPath","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","Object","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","result","name","extname","value","when","clausePattern","matched","then","m","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from './strings.js';\r\nimport * as extpath from './extpath.js';\r\nimport * as paths from './path.js';\r\nimport { LRUCache } from './map.js';\r\nimport { isThenable } from './async.js';\r\nconst GLOBSTAR = '**';\r\nconst GLOB_SPLIT = '/';\r\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\r\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\r\nconst ALL_FORWARD_SLASHES = /\\//g;\r\nfunction starsToRegExp(starCount) {\r\n    switch (starCount) {\r\n        case 0:\r\n            return '';\r\n        case 1:\r\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\r\n        default:\r\n            // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times\r\n            // Group is non capturing because we don't need to capture at all (?:...)\r\n            // Overall we use non-greedy matching because it could be that we match too much\r\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`;\r\n    }\r\n}\r\nexport function splitGlobAware(pattern, splitChar) {\r\n    if (!pattern) {\r\n        return [];\r\n    }\r\n    const segments = [];\r\n    let inBraces = false;\r\n    let inBrackets = false;\r\n    let curVal = '';\r\n    for (const char of pattern) {\r\n        switch (char) {\r\n            case splitChar:\r\n                if (!inBraces && !inBrackets) {\r\n                    segments.push(curVal);\r\n                    curVal = '';\r\n                    continue;\r\n                }\r\n                break;\r\n            case '{':\r\n                inBraces = true;\r\n                break;\r\n            case '}':\r\n                inBraces = false;\r\n                break;\r\n            case '[':\r\n                inBrackets = true;\r\n                break;\r\n            case ']':\r\n                inBrackets = false;\r\n                break;\r\n        }\r\n        curVal += char;\r\n    }\r\n    // Tail\r\n    if (curVal) {\r\n        segments.push(curVal);\r\n    }\r\n    return segments;\r\n}\r\nfunction parseRegExp(pattern) {\r\n    if (!pattern) {\r\n        return '';\r\n    }\r\n    let regEx = '';\r\n    // Split up into segments for each slash found\r\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\r\n    // Special case where we only have globstars\r\n    if (segments.every(s => s === GLOBSTAR)) {\r\n        regEx = '.*';\r\n    }\r\n    // Build regex over segments\r\n    else {\r\n        let previousSegmentWasGlobStar = false;\r\n        segments.forEach((segment, index) => {\r\n            // Globstar is special\r\n            if (segment === GLOBSTAR) {\r\n                // if we have more than one globstar after another, just ignore it\r\n                if (!previousSegmentWasGlobStar) {\r\n                    regEx += starsToRegExp(2);\r\n                    previousSegmentWasGlobStar = true;\r\n                }\r\n                return;\r\n            }\r\n            // States\r\n            let inBraces = false;\r\n            let braceVal = '';\r\n            let inBrackets = false;\r\n            let bracketVal = '';\r\n            for (const char of segment) {\r\n                // Support brace expansion\r\n                if (char !== '}' && inBraces) {\r\n                    braceVal += char;\r\n                    continue;\r\n                }\r\n                // Support brackets\r\n                if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\r\n                    let res;\r\n                    // range operator\r\n                    if (char === '-') {\r\n                        res = char;\r\n                    }\r\n                    // negation operator (only valid on first index in bracket)\r\n                    else if ((char === '^' || char === '!') && !bracketVal) {\r\n                        res = '^';\r\n                    }\r\n                    // glob split matching is not allowed within character ranges\r\n                    // see http://man7.org/linux/man-pages/man7/glob.7.html\r\n                    else if (char === GLOB_SPLIT) {\r\n                        res = '';\r\n                    }\r\n                    // anything else gets escaped\r\n                    else {\r\n                        res = strings.escapeRegExpCharacters(char);\r\n                    }\r\n                    bracketVal += res;\r\n                    continue;\r\n                }\r\n                switch (char) {\r\n                    case '{':\r\n                        inBraces = true;\r\n                        continue;\r\n                    case '[':\r\n                        inBrackets = true;\r\n                        continue;\r\n                    case '}':\r\n                        const choices = splitGlobAware(braceVal, ',');\r\n                        // Converts {foo,bar} => [foo|bar]\r\n                        const braceRegExp = `(?:${choices.map(c => parseRegExp(c)).join('|')})`;\r\n                        regEx += braceRegExp;\r\n                        inBraces = false;\r\n                        braceVal = '';\r\n                        break;\r\n                    case ']':\r\n                        regEx += ('[' + bracketVal + ']');\r\n                        inBrackets = false;\r\n                        bracketVal = '';\r\n                        break;\r\n                    case '?':\r\n                        regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\r\n                        continue;\r\n                    case '*':\r\n                        regEx += starsToRegExp(1);\r\n                        continue;\r\n                    default:\r\n                        regEx += strings.escapeRegExpCharacters(char);\r\n                }\r\n            }\r\n            // Tail: Add the slash we had split on if there is more to come and the remaining pattern is not a globstar\r\n            // For example if pattern: some/**/*.js we want the \"/\" after some to be included in the RegEx to prevent\r\n            // a folder called \"something\" to match as well.\r\n            // However, if pattern: some/**, we tolerate that we also match on \"something\" because our globstar behaviour\r\n            // is to match 0-N segments.\r\n            if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\r\n                regEx += PATH_REGEX;\r\n            }\r\n            // reset state\r\n            previousSegmentWasGlobStar = false;\r\n        });\r\n    }\r\n    return regEx;\r\n}\r\n// regexes to check for trival glob patterns that just check for String#endsWith\r\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\r\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\r\nconst T3 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\r\nconst T3_2 = /^{\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/[\\*\\.]?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\r\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\r\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\r\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\r\nconst FALSE = function () {\r\n    return false;\r\n};\r\nconst NULL = function () {\r\n    return null;\r\n};\r\nfunction parsePattern(arg1, options) {\r\n    if (!arg1) {\r\n        return NULL;\r\n    }\r\n    // Handle IRelativePattern\r\n    let pattern;\r\n    if (typeof arg1 !== 'string') {\r\n        pattern = arg1.pattern;\r\n    }\r\n    else {\r\n        pattern = arg1;\r\n    }\r\n    // Whitespace trimming\r\n    pattern = pattern.trim();\r\n    // Check cache\r\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\r\n    let parsedPattern = CACHE.get(patternKey);\r\n    if (parsedPattern) {\r\n        return wrapRelativePattern(parsedPattern, arg1);\r\n    }\r\n    // Check for Trivias\r\n    let match;\r\n    if (T1.test(pattern)) { // common pattern: **/*.txt just need endsWith check\r\n        const base = pattern.substr(4); // '**/*'.length === 4\r\n        parsedPattern = function (path, basename) {\r\n            return typeof path === 'string' && path.endsWith(base) ? pattern : null;\r\n        };\r\n    }\r\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\r\n        parsedPattern = trivia2(match[1], pattern);\r\n    }\r\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\r\n        parsedPattern = trivia3(pattern, options);\r\n    }\r\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\r\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\r\n    }\r\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\r\n        parsedPattern = trivia4and5(match[1], pattern, false);\r\n    }\r\n    // Otherwise convert to pattern\r\n    else {\r\n        parsedPattern = toRegExp(pattern);\r\n    }\r\n    // Cache\r\n    CACHE.set(patternKey, parsedPattern);\r\n    return wrapRelativePattern(parsedPattern, arg1);\r\n}\r\nfunction wrapRelativePattern(parsedPattern, arg2) {\r\n    if (typeof arg2 === 'string') {\r\n        return parsedPattern;\r\n    }\r\n    return function (path, basename) {\r\n        if (!extpath.isEqualOrParent(path, arg2.base)) {\r\n            return null;\r\n        }\r\n        return parsedPattern(paths.relative(arg2.base, path), basename);\r\n    };\r\n}\r\nfunction trimForExclusions(pattern, options) {\r\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\r\n}\r\n// common pattern: **/some.txt just need basename check\r\nfunction trivia2(base, originalPattern) {\r\n    const slashBase = `/${base}`;\r\n    const backslashBase = `\\\\${base}`;\r\n    const parsedPattern = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (basename) {\r\n            return basename === base ? originalPattern : null;\r\n        }\r\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? originalPattern : null;\r\n    };\r\n    const basenames = [base];\r\n    parsedPattern.basenames = basenames;\r\n    parsedPattern.patterns = [originalPattern];\r\n    parsedPattern.allBasenames = basenames;\r\n    return parsedPattern;\r\n}\r\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\r\nfunction trivia3(pattern, options) {\r\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')\r\n        .map(pattern => parsePattern(pattern, options))\r\n        .filter(pattern => pattern !== NULL), pattern);\r\n    const n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (n === 1) {\r\n        return parsedPatterns[0];\r\n    }\r\n    const parsedPattern = function (path, basename) {\r\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n            if (parsedPatterns[i](path, basename)) {\r\n                return pattern;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n    if (withBasenames) {\r\n        parsedPattern.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n    if (allPaths.length) {\r\n        parsedPattern.allPaths = allPaths;\r\n    }\r\n    return parsedPattern;\r\n}\r\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\r\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\r\n    const usingPosixSep = paths.sep === paths.posix.sep;\r\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, paths.sep);\r\n    const nativePathEnd = paths.sep + nativePath;\r\n    const targetPathEnd = paths.posix.sep + targetPath;\r\n    const parsedPattern = matchPathEnds ? function (testPath, basename) {\r\n        return typeof testPath === 'string' &&\r\n            ((testPath === nativePath || testPath.endsWith(nativePathEnd))\r\n                || !usingPosixSep && (testPath === targetPath || testPath.endsWith(targetPathEnd)))\r\n            ? pattern : null;\r\n    } : function (testPath, basename) {\r\n        return typeof testPath === 'string' &&\r\n            (testPath === nativePath\r\n                || (!usingPosixSep && testPath === targetPath))\r\n            ? pattern : null;\r\n    };\r\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\r\n    return parsedPattern;\r\n}\r\nfunction toRegExp(pattern) {\r\n    try {\r\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\r\n        return function (path) {\r\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\r\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\r\n        };\r\n    }\r\n    catch (error) {\r\n        return NULL;\r\n    }\r\n}\r\nexport function match(arg1, path, hasSibling) {\r\n    if (!arg1 || typeof path !== 'string') {\r\n        return false;\r\n    }\r\n    return parse(arg1)(path, undefined, hasSibling);\r\n}\r\nexport function parse(arg1, options = {}) {\r\n    if (!arg1) {\r\n        return FALSE;\r\n    }\r\n    // Glob with String\r\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\r\n        const parsedPattern = parsePattern(arg1, options);\r\n        if (parsedPattern === NULL) {\r\n            return FALSE;\r\n        }\r\n        const resultPattern = function (path, basename) {\r\n            return !!parsedPattern(path, basename);\r\n        };\r\n        if (parsedPattern.allBasenames) {\r\n            resultPattern.allBasenames = parsedPattern.allBasenames;\r\n        }\r\n        if (parsedPattern.allPaths) {\r\n            resultPattern.allPaths = parsedPattern.allPaths;\r\n        }\r\n        return resultPattern;\r\n    }\r\n    // Glob with Expression\r\n    return parsedExpression(arg1, options);\r\n}\r\nexport function isRelativePattern(obj) {\r\n    const rp = obj;\r\n    return rp && typeof rp.base === 'string' && typeof rp.pattern === 'string';\r\n}\r\nfunction parsedExpression(expression, options) {\r\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\r\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\r\n        .filter(pattern => pattern !== NULL));\r\n    const n = parsedPatterns.length;\r\n    if (!n) {\r\n        return NULL;\r\n    }\r\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\r\n        if (n === 1) {\r\n            return parsedPatterns[0];\r\n        }\r\n        const resultExpression = function (path, basename) {\r\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n                // Pattern matches path\r\n                const result = parsedPatterns[i](path, basename);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n        if (withBasenames) {\r\n            resultExpression.allBasenames = withBasenames.allBasenames;\r\n        }\r\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n        if (allPaths.length) {\r\n            resultExpression.allPaths = allPaths;\r\n        }\r\n        return resultExpression;\r\n    }\r\n    const resultExpression = function (path, basename, hasSibling) {\r\n        let name = undefined;\r\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\r\n            // Pattern matches path\r\n            const parsedPattern = parsedPatterns[i];\r\n            if (parsedPattern.requiresSiblings && hasSibling) {\r\n                if (!basename) {\r\n                    basename = paths.basename(path);\r\n                }\r\n                if (!name) {\r\n                    name = basename.substr(0, basename.length - paths.extname(path).length);\r\n                }\r\n            }\r\n            const result = parsedPattern(path, basename, name, hasSibling);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\r\n    if (withBasenames) {\r\n        resultExpression.allBasenames = withBasenames.allBasenames;\r\n    }\r\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\r\n    if (allPaths.length) {\r\n        resultExpression.allPaths = allPaths;\r\n    }\r\n    return resultExpression;\r\n}\r\nfunction parseExpressionPattern(pattern, value, options) {\r\n    if (value === false) {\r\n        return NULL; // pattern is disabled\r\n    }\r\n    const parsedPattern = parsePattern(pattern, options);\r\n    if (parsedPattern === NULL) {\r\n        return NULL;\r\n    }\r\n    // Expression Pattern is <boolean>\r\n    if (typeof value === 'boolean') {\r\n        return parsedPattern;\r\n    }\r\n    // Expression Pattern is <SiblingClause>\r\n    if (value) {\r\n        const when = value.when;\r\n        if (typeof when === 'string') {\r\n            const result = (path, basename, name, hasSibling) => {\r\n                if (!hasSibling || !parsedPattern(path, basename)) {\r\n                    return null;\r\n                }\r\n                const clausePattern = when.replace('$(basename)', name);\r\n                const matched = hasSibling(clausePattern);\r\n                return isThenable(matched) ?\r\n                    matched.then(m => m ? pattern : null) :\r\n                    matched ? pattern : null;\r\n            };\r\n            result.requiresSiblings = true;\r\n            return result;\r\n        }\r\n    }\r\n    // Expression is Anything\r\n    return parsedPattern;\r\n}\r\nfunction aggregateBasenameMatches(parsedPatterns, result) {\r\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\r\n    if (basenamePatterns.length < 2) {\r\n        return parsedPatterns;\r\n    }\r\n    const basenames = basenamePatterns.reduce((all, current) => {\r\n        const basenames = current.basenames;\r\n        return basenames ? all.concat(basenames) : all;\r\n    }, []);\r\n    let patterns;\r\n    if (result) {\r\n        patterns = [];\r\n        for (let i = 0, n = basenames.length; i < n; i++) {\r\n            patterns.push(result);\r\n        }\r\n    }\r\n    else {\r\n        patterns = basenamePatterns.reduce((all, current) => {\r\n            const patterns = current.patterns;\r\n            return patterns ? all.concat(patterns) : all;\r\n        }, []);\r\n    }\r\n    const aggregate = function (path, basename) {\r\n        if (typeof path !== 'string') {\r\n            return null;\r\n        }\r\n        if (!basename) {\r\n            let i;\r\n            for (i = path.length; i > 0; i--) {\r\n                const ch = path.charCodeAt(i - 1);\r\n                if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {\r\n                    break;\r\n                }\r\n            }\r\n            basename = path.substr(i);\r\n        }\r\n        const index = basenames.indexOf(basename);\r\n        return index !== -1 ? patterns[index] : null;\r\n    };\r\n    aggregate.basenames = basenames;\r\n    aggregate.patterns = patterns;\r\n    aggregate.allBasenames = basenames;\r\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\r\n    aggregatedPatterns.push(aggregate);\r\n    return aggregatedPatterns;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}