{"ast":null,"code":"import _toArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TreeError } from './tree.js';\nimport { tail2 } from '../../../common/arrays.js';\nimport { LcsDiff } from '../../../common/diff/diff.js';\nimport { Emitter, EventBufferer } from '../../../common/event.js';\nimport { Iterable } from '../../../common/iterator.js';\nexport function isFilterResult(obj) {\n  return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\n}\nexport function getVisibleState(visibility) {\n  switch (visibility) {\n    case true:\n      return 1\n      /* Visible */\n      ;\n\n    case false:\n      return 0\n      /* Hidden */\n      ;\n\n    default:\n      return visibility;\n  }\n}\n\nfunction isCollapsibleStateUpdate(update) {\n  return typeof update.collapsible === 'boolean';\n}\n\nexport var IndexTreeModel = /*#__PURE__*/function () {\n  function IndexTreeModel(user, list, rootElement) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, IndexTreeModel);\n\n    this.user = user;\n    this.list = list;\n    this.rootRef = [];\n    this.eventBufferer = new EventBufferer();\n    this._onDidChangeCollapseState = new Emitter();\n    this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\n    this._onDidChangeRenderNodeCount = new Emitter();\n    this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\n    this._onDidSplice = new Emitter();\n    this.onDidSplice = this._onDidSplice.event;\n    this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\n    this.filter = options.filter;\n    this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\n    this.root = {\n      parent: undefined,\n      element: rootElement,\n      children: [],\n      depth: 0,\n      visibleChildrenCount: 0,\n      visibleChildIndex: -1,\n      collapsible: false,\n      collapsed: false,\n      renderNodeCount: 0,\n      visibility: 1\n      /* Visible */\n      ,\n      visible: true,\n      filterData: undefined\n    };\n  }\n\n  _createClass(IndexTreeModel, [{\n    key: \"splice\",\n    value: function splice(location, deleteCount) {\n      var toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (location.length === 0) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n\n      if (options.diffIdentityProvider) {\n        this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\n      } else {\n        this.spliceSimple(location, deleteCount, toInsert, options);\n      }\n    }\n  }, {\n    key: \"spliceSmart\",\n    value: function spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\n      var _this = this;\n\n      var _a;\n\n      if (toInsertIterable === void 0) {\n        toInsertIterable = Iterable.empty();\n      }\n\n      if (recurseLevels === void 0) {\n        recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0;\n      }\n\n      var _this$getParentNodeWi = this.getParentNodeWithListIndex(location),\n          parentNode = _this$getParentNodeWi.parentNode;\n\n      var toInsert = _toConsumableArray(toInsertIterable);\n\n      var index = location[location.length - 1];\n      var diff = new LcsDiff({\n        getElements: function getElements() {\n          return parentNode.children.map(function (e) {\n            return identity.getId(e.element).toString();\n          });\n        }\n      }, {\n        getElements: function getElements() {\n          return [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(toInsert), _toConsumableArray(parentNode.children.slice(index + deleteCount))).map(function (e) {\n            return identity.getId(e.element).toString();\n          });\n        }\n      }).ComputeDiff(false); // if we were given a 'best effort' diff, use default behavior\n\n      if (diff.quitEarly) {\n        return this.spliceSimple(location, deleteCount, toInsert, options);\n      }\n\n      var locationPrefix = location.slice(0, -1);\n\n      var recurseSplice = function recurseSplice(fromOriginal, fromModified, count) {\n        if (recurseLevels > 0) {\n          for (var i = 0; i < count; i++) {\n            fromOriginal--;\n            fromModified--;\n\n            _this.spliceSmart(identity, [].concat(_toConsumableArray(locationPrefix), [fromOriginal, 0]), Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\n          }\n        }\n      };\n\n      var lastStartO = Math.min(parentNode.children.length, index + deleteCount);\n      var lastStartM = toInsert.length;\n\n      var _iterator = _createForOfIteratorHelper(diff.changes.sort(function (a, b) {\n        return b.originalStart - a.originalStart;\n      })),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var change = _step.value;\n          recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\n          lastStartO = change.originalStart;\n          lastStartM = change.modifiedStart - index;\n          this.spliceSimple([].concat(_toConsumableArray(locationPrefix), [lastStartO]), change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\n        } // at this point, startO === startM === count since any remaining prefix should match\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      recurseSplice(lastStartO, lastStartM, lastStartO);\n    }\n  }, {\n    key: \"spliceSimple\",\n    value: function spliceSimple(location, deleteCount) {\n      var _this2 = this,\n          _parentNode$children;\n\n      var toInsert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Iterable.empty();\n\n      var _ref = arguments.length > 3 ? arguments[3] : undefined,\n          onDidCreateNode = _ref.onDidCreateNode,\n          onDidDeleteNode = _ref.onDidDeleteNode;\n\n      var _this$getParentNodeWi2 = this.getParentNodeWithListIndex(location),\n          parentNode = _this$getParentNodeWi2.parentNode,\n          listIndex = _this$getParentNodeWi2.listIndex,\n          revealed = _this$getParentNodeWi2.revealed,\n          visible = _this$getParentNodeWi2.visible;\n\n      var treeListElementsToInsert = [];\n      var nodesToInsertIterator = Iterable.map(toInsert, function (el) {\n        return _this2.createTreeNode(el, parentNode, parentNode.visible ? 1\n        /* Visible */\n        : 0\n        /* Hidden */\n        , revealed, treeListElementsToInsert, onDidCreateNode);\n      });\n      var lastIndex = location[location.length - 1];\n      var lastHadChildren = parentNode.children.length > 0; // figure out what's the visible child start index right before the\n      // splice point\n\n      var visibleChildStartIndex = 0;\n\n      for (var i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\n        var child = parentNode.children[i];\n\n        if (child.visible) {\n          visibleChildStartIndex = child.visibleChildIndex;\n          break;\n        }\n      }\n\n      var nodesToInsert = [];\n      var insertedVisibleChildrenCount = 0;\n      var renderNodeCount = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(nodesToInsertIterator),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _child2 = _step2.value;\n          nodesToInsert.push(_child2);\n          renderNodeCount += _child2.renderNodeCount;\n\n          if (_child2.visible) {\n            _child2.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var deletedNodes = (_parentNode$children = parentNode.children).splice.apply(_parentNode$children, [lastIndex, deleteCount].concat(nodesToInsert)); // figure out what is the count of deleted visible children\n\n\n      var deletedVisibleChildrenCount = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(deletedNodes),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _child3 = _step3.value;\n\n          if (_child3.visible) {\n            deletedVisibleChildrenCount++;\n          }\n        } // and adjust for all visible children after the splice point\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (deletedVisibleChildrenCount !== 0) {\n        for (var _i = lastIndex + nodesToInsert.length; _i < parentNode.children.length; _i++) {\n          var _child = parentNode.children[_i];\n\n          if (_child.visible) {\n            _child.visibleChildIndex -= deletedVisibleChildrenCount;\n          }\n        }\n      } // update parent's visible children count\n\n\n      parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\n\n      if (revealed && visible) {\n        var visibleDeleteCount = deletedNodes.reduce(function (r, node) {\n          return r + (node.visible ? node.renderNodeCount : 0);\n        }, 0);\n\n        this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\n\n        this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\n      }\n\n      if (deletedNodes.length > 0 && onDidDeleteNode) {\n        var visit = function visit(node) {\n          onDidDeleteNode(node);\n          node.children.forEach(visit);\n        };\n\n        deletedNodes.forEach(visit);\n      }\n\n      var currentlyHasChildren = parentNode.children.length > 0;\n\n      if (lastHadChildren !== currentlyHasChildren) {\n        this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\n      }\n\n      this._onDidSplice.fire({\n        insertedNodes: nodesToInsert,\n        deletedNodes: deletedNodes\n      });\n\n      var node = parentNode;\n\n      while (node) {\n        if (node.visibility === 2\n        /* Recurse */\n        ) {\n            this.refilter();\n            break;\n          }\n\n        node = node.parent;\n      }\n    }\n  }, {\n    key: \"rerender\",\n    value: function rerender(location) {\n      if (location.length === 0) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n\n      var _this$getTreeNodeWith = this.getTreeNodeWithListIndex(location),\n          node = _this$getTreeNodeWith.node,\n          listIndex = _this$getTreeNodeWith.listIndex,\n          revealed = _this$getTreeNodeWith.revealed;\n\n      if (node.visible && revealed) {\n        this.list.splice(listIndex, 1, [node]);\n      }\n    }\n  }, {\n    key: \"has\",\n    value: function has(location) {\n      return this.hasTreeNode(location);\n    }\n  }, {\n    key: \"getListIndex\",\n    value: function getListIndex(location) {\n      var _this$getTreeNodeWith2 = this.getTreeNodeWithListIndex(location),\n          listIndex = _this$getTreeNodeWith2.listIndex,\n          visible = _this$getTreeNodeWith2.visible,\n          revealed = _this$getTreeNodeWith2.revealed;\n\n      return visible && revealed ? listIndex : -1;\n    }\n  }, {\n    key: \"getListRenderCount\",\n    value: function getListRenderCount(location) {\n      return this.getTreeNode(location).renderNodeCount;\n    }\n  }, {\n    key: \"isCollapsible\",\n    value: function isCollapsible(location) {\n      return this.getTreeNode(location).collapsible;\n    }\n  }, {\n    key: \"setCollapsible\",\n    value: function setCollapsible(location, collapsible) {\n      var _this3 = this;\n\n      var node = this.getTreeNode(location);\n\n      if (typeof collapsible === 'undefined') {\n        collapsible = !node.collapsible;\n      }\n\n      var update = {\n        collapsible: collapsible\n      };\n      return this.eventBufferer.bufferEvents(function () {\n        return _this3._setCollapseState(location, update);\n      });\n    }\n  }, {\n    key: \"isCollapsed\",\n    value: function isCollapsed(location) {\n      return this.getTreeNode(location).collapsed;\n    }\n  }, {\n    key: \"setCollapsed\",\n    value: function setCollapsed(location, collapsed, recursive) {\n      var _this4 = this;\n\n      var node = this.getTreeNode(location);\n\n      if (typeof collapsed === 'undefined') {\n        collapsed = !node.collapsed;\n      }\n\n      var update = {\n        collapsed: collapsed,\n        recursive: recursive || false\n      };\n      return this.eventBufferer.bufferEvents(function () {\n        return _this4._setCollapseState(location, update);\n      });\n    }\n  }, {\n    key: \"_setCollapseState\",\n    value: function _setCollapseState(location, update) {\n      var _this$getTreeNodeWith3 = this.getTreeNodeWithListIndex(location),\n          node = _this$getTreeNodeWith3.node,\n          listIndex = _this$getTreeNodeWith3.listIndex,\n          revealed = _this$getTreeNodeWith3.revealed;\n\n      var result = this._setListNodeCollapseState(node, listIndex, revealed, update);\n\n      if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\n        var onlyVisibleChildIndex = -1;\n\n        for (var i = 0; i < node.children.length; i++) {\n          var child = node.children[i];\n\n          if (child.visible) {\n            if (onlyVisibleChildIndex > -1) {\n              onlyVisibleChildIndex = -1;\n              break;\n            } else {\n              onlyVisibleChildIndex = i;\n            }\n          }\n        }\n\n        if (onlyVisibleChildIndex > -1) {\n          this._setCollapseState([].concat(_toConsumableArray(location), [onlyVisibleChildIndex]), update);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_setListNodeCollapseState\",\n    value: function _setListNodeCollapseState(node, listIndex, revealed, update) {\n      var result = this._setNodeCollapseState(node, update, false);\n\n      if (!revealed || !node.visible || !result) {\n        return result;\n      }\n\n      var previousRenderNodeCount = node.renderNodeCount;\n      var toInsert = this.updateNodeAfterCollapseChange(node);\n      var deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\n      this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\n      return result;\n    }\n  }, {\n    key: \"_setNodeCollapseState\",\n    value: function _setNodeCollapseState(node, update, deep) {\n      var result;\n\n      if (node === this.root) {\n        result = false;\n      } else {\n        if (isCollapsibleStateUpdate(update)) {\n          result = node.collapsible !== update.collapsible;\n          node.collapsible = update.collapsible;\n        } else if (!node.collapsible) {\n          result = false;\n        } else {\n          result = node.collapsed !== update.collapsed;\n          node.collapsed = update.collapsed;\n        }\n\n        if (result) {\n          this._onDidChangeCollapseState.fire({\n            node: node,\n            deep: deep\n          });\n        }\n      }\n\n      if (!isCollapsibleStateUpdate(update) && update.recursive) {\n        var _iterator4 = _createForOfIteratorHelper(node.children),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var child = _step4.value;\n            result = this._setNodeCollapseState(child, update, true) || result;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"expandTo\",\n    value: function expandTo(location) {\n      var _this5 = this;\n\n      this.eventBufferer.bufferEvents(function () {\n        var node = _this5.getTreeNode(location);\n\n        while (node.parent) {\n          node = node.parent;\n          location = location.slice(0, location.length - 1);\n\n          if (node.collapsed) {\n            _this5._setCollapseState(location, {\n              collapsed: false,\n              recursive: false\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: \"refilter\",\n    value: function refilter() {\n      var previousRenderNodeCount = this.root.renderNodeCount;\n      var toInsert = this.updateNodeAfterFilterChange(this.root);\n      this.list.splice(0, previousRenderNodeCount, toInsert);\n    }\n  }, {\n    key: \"createTreeNode\",\n    value: function createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\n      var _this6 = this;\n\n      var node = {\n        parent: parent,\n        element: treeElement.element,\n        children: [],\n        depth: parent.depth + 1,\n        visibleChildrenCount: 0,\n        visibleChildIndex: -1,\n        collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : typeof treeElement.collapsed !== 'undefined',\n        collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\n        renderNodeCount: 1,\n        visibility: 1\n        /* Visible */\n        ,\n        visible: true,\n        filterData: undefined\n      };\n\n      var visibility = this._filterNode(node, parentVisibility);\n\n      node.visibility = visibility;\n\n      if (revealed) {\n        treeListElements.push(node);\n      }\n\n      var childElements = treeElement.children || Iterable.empty();\n      var childRevealed = revealed && visibility !== 0\n      /* Hidden */\n      && !node.collapsed;\n      var childNodes = Iterable.map(childElements, function (el) {\n        return _this6.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode);\n      });\n      var visibleChildrenCount = 0;\n      var renderNodeCount = 1;\n\n      var _iterator5 = _createForOfIteratorHelper(childNodes),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n          node.children.push(child);\n          renderNodeCount += child.renderNodeCount;\n\n          if (child.visible) {\n            child.visibleChildIndex = visibleChildrenCount++;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      node.collapsible = node.collapsible || node.children.length > 0;\n      node.visibleChildrenCount = visibleChildrenCount;\n      node.visible = visibility === 2\n      /* Recurse */\n      ? visibleChildrenCount > 0 : visibility === 1\n      /* Visible */\n      ;\n\n      if (!node.visible) {\n        node.renderNodeCount = 0;\n\n        if (revealed) {\n          treeListElements.pop();\n        }\n      } else if (!node.collapsed) {\n        node.renderNodeCount = renderNodeCount;\n      }\n\n      if (onDidCreateNode) {\n        onDidCreateNode(node);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"updateNodeAfterCollapseChange\",\n    value: function updateNodeAfterCollapseChange(node) {\n      var previousRenderNodeCount = node.renderNodeCount;\n      var result = [];\n\n      this._updateNodeAfterCollapseChange(node, result);\n\n      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n      return result;\n    }\n  }, {\n    key: \"_updateNodeAfterCollapseChange\",\n    value: function _updateNodeAfterCollapseChange(node, result) {\n      if (node.visible === false) {\n        return 0;\n      }\n\n      result.push(node);\n      node.renderNodeCount = 1;\n\n      if (!node.collapsed) {\n        var _iterator6 = _createForOfIteratorHelper(node.children),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var child = _step6.value;\n            node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n\n      this._onDidChangeRenderNodeCount.fire(node);\n\n      return node.renderNodeCount;\n    }\n  }, {\n    key: \"updateNodeAfterFilterChange\",\n    value: function updateNodeAfterFilterChange(node) {\n      var previousRenderNodeCount = node.renderNodeCount;\n      var result = [];\n\n      this._updateNodeAfterFilterChange(node, node.visible ? 1\n      /* Visible */\n      : 0\n      /* Hidden */\n      , result);\n\n      this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\n\n      return result;\n    }\n  }, {\n    key: \"_updateNodeAfterFilterChange\",\n    value: function _updateNodeAfterFilterChange(node, parentVisibility, result) {\n      var revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var visibility;\n\n      if (node !== this.root) {\n        visibility = this._filterNode(node, parentVisibility);\n\n        if (visibility === 0\n        /* Hidden */\n        ) {\n            node.visible = false;\n            node.renderNodeCount = 0;\n            return false;\n          }\n\n        if (revealed) {\n          result.push(node);\n        }\n      }\n\n      var resultStartLength = result.length;\n      node.renderNodeCount = node === this.root ? 0 : 1;\n      var hasVisibleDescendants = false;\n\n      if (!node.collapsed || visibility !== 0\n      /* Hidden */\n      ) {\n          var visibleChildIndex = 0;\n\n          var _iterator7 = _createForOfIteratorHelper(node.children),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var child = _step7.value;\n              hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\n\n              if (child.visible) {\n                child.visibleChildIndex = visibleChildIndex++;\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          node.visibleChildrenCount = visibleChildIndex;\n        } else {\n        node.visibleChildrenCount = 0;\n      }\n\n      if (node !== this.root) {\n        node.visible = visibility === 2\n        /* Recurse */\n        ? hasVisibleDescendants : visibility === 1\n        /* Visible */\n        ;\n      }\n\n      if (!node.visible) {\n        node.renderNodeCount = 0;\n\n        if (revealed) {\n          result.pop();\n        }\n      } else if (!node.collapsed) {\n        node.renderNodeCount += result.length - resultStartLength;\n      }\n\n      this._onDidChangeRenderNodeCount.fire(node);\n\n      return node.visible;\n    }\n  }, {\n    key: \"_updateAncestorsRenderNodeCount\",\n    value: function _updateAncestorsRenderNodeCount(node, diff) {\n      if (diff === 0) {\n        return;\n      }\n\n      while (node) {\n        node.renderNodeCount += diff;\n\n        this._onDidChangeRenderNodeCount.fire(node);\n\n        node = node.parent;\n      }\n    }\n  }, {\n    key: \"_filterNode\",\n    value: function _filterNode(node, parentVisibility) {\n      var result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1\n      /* Visible */\n      ;\n\n      if (typeof result === 'boolean') {\n        node.filterData = undefined;\n        return result ? 1\n        /* Visible */\n        : 0\n        /* Hidden */\n        ;\n      } else if (isFilterResult(result)) {\n        node.filterData = result.data;\n        return getVisibleState(result.visibility);\n      } else {\n        node.filterData = undefined;\n        return getVisibleState(result);\n      }\n    } // cheap\n\n  }, {\n    key: \"hasTreeNode\",\n    value: function hasTreeNode(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n\n      if (!location || location.length === 0) {\n        return true;\n      }\n\n      var _location = _toArray(location),\n          index = _location[0],\n          rest = _location.slice(1);\n\n      if (index < 0 || index > node.children.length) {\n        return false;\n      }\n\n      return this.hasTreeNode(rest, node.children[index]);\n    } // cheap\n\n  }, {\n    key: \"getTreeNode\",\n    value: function getTreeNode(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n\n      if (!location || location.length === 0) {\n        return node;\n      }\n\n      var _location2 = _toArray(location),\n          index = _location2[0],\n          rest = _location2.slice(1);\n\n      if (index < 0 || index > node.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n\n      return this.getTreeNode(rest, node.children[index]);\n    } // expensive\n\n  }, {\n    key: \"getTreeNodeWithListIndex\",\n    value: function getTreeNodeWithListIndex(location) {\n      if (location.length === 0) {\n        return {\n          node: this.root,\n          listIndex: -1,\n          revealed: true,\n          visible: false\n        };\n      }\n\n      var _this$getParentNodeWi3 = this.getParentNodeWithListIndex(location),\n          parentNode = _this$getParentNodeWi3.parentNode,\n          listIndex = _this$getParentNodeWi3.listIndex,\n          revealed = _this$getParentNodeWi3.revealed,\n          visible = _this$getParentNodeWi3.visible;\n\n      var index = location[location.length - 1];\n\n      if (index < 0 || index > parentNode.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      }\n\n      var node = parentNode.children[index];\n      return {\n        node: node,\n        listIndex: listIndex,\n        revealed: revealed,\n        visible: visible && node.visible\n      };\n    }\n  }, {\n    key: \"getParentNodeWithListIndex\",\n    value: function getParentNodeWithListIndex(location) {\n      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.root;\n      var listIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var revealed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n      var _location3 = _toArray(location),\n          index = _location3[0],\n          rest = _location3.slice(1);\n\n      if (index < 0 || index > node.children.length) {\n        throw new TreeError(this.user, 'Invalid tree location');\n      } // TODO@joao perf!\n\n\n      for (var i = 0; i < index; i++) {\n        listIndex += node.children[i].renderNodeCount;\n      }\n\n      revealed = revealed && !node.collapsed;\n      visible = visible && node.visible;\n\n      if (rest.length === 0) {\n        return {\n          parentNode: node,\n          listIndex: listIndex,\n          revealed: revealed,\n          visible: visible\n        };\n      }\n\n      return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode() {\n      var location = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      return this.getTreeNode(location);\n    } // TODO@joao perf!\n\n  }, {\n    key: \"getNodeLocation\",\n    value: function getNodeLocation(node) {\n      var location = [];\n      var indexTreeNode = node; // typing woes\n\n      while (indexTreeNode.parent) {\n        location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\n        indexTreeNode = indexTreeNode.parent;\n      }\n\n      return location.reverse();\n    }\n  }, {\n    key: \"getParentNodeLocation\",\n    value: function getParentNodeLocation(location) {\n      if (location.length === 0) {\n        return undefined;\n      } else if (location.length === 1) {\n        return [];\n      } else {\n        return tail2(location)[0];\n      }\n    }\n  }]);\n\n  return IndexTreeModel;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/browser/ui/tree/indexTreeModel.js"],"names":["TreeError","tail2","LcsDiff","Emitter","EventBufferer","Iterable","isFilterResult","obj","getVisibleState","visibility","isCollapsibleStateUpdate","update","collapsible","IndexTreeModel","user","list","rootElement","options","rootRef","eventBufferer","_onDidChangeCollapseState","onDidChangeCollapseState","wrapEvent","event","_onDidChangeRenderNodeCount","onDidChangeRenderNodeCount","_onDidSplice","onDidSplice","collapseByDefault","filter","autoExpandSingleChildren","root","parent","undefined","element","children","depth","visibleChildrenCount","visibleChildIndex","collapsed","renderNodeCount","visible","filterData","location","deleteCount","toInsert","empty","length","diffIdentityProvider","spliceSmart","spliceSimple","identity","toInsertIterable","recurseLevels","_a","diffDepth","getParentNodeWithListIndex","parentNode","index","diff","getElements","map","e","getId","toString","slice","ComputeDiff","quitEarly","locationPrefix","recurseSplice","fromOriginal","fromModified","count","i","Number","MAX_SAFE_INTEGER","lastStartO","Math","min","lastStartM","changes","sort","a","b","originalStart","change","originalLength","modifiedStart","modifiedLength","onDidCreateNode","onDidDeleteNode","listIndex","revealed","treeListElementsToInsert","nodesToInsertIterator","el","createTreeNode","lastIndex","lastHadChildren","visibleChildStartIndex","child","nodesToInsert","insertedVisibleChildrenCount","push","deletedNodes","splice","deletedVisibleChildrenCount","visibleDeleteCount","reduce","r","node","_updateAncestorsRenderNodeCount","visit","forEach","currentlyHasChildren","setCollapsible","fire","insertedNodes","refilter","getTreeNodeWithListIndex","hasTreeNode","getTreeNode","bufferEvents","_setCollapseState","recursive","result","_setListNodeCollapseState","onlyVisibleChildIndex","_setNodeCollapseState","previousRenderNodeCount","updateNodeAfterCollapseChange","deep","updateNodeAfterFilterChange","treeElement","parentVisibility","treeListElements","_filterNode","childElements","childRevealed","childNodes","pop","_updateNodeAfterCollapseChange","_updateNodeAfterFilterChange","resultStartLength","hasVisibleDescendants","data","rest","indexTreeNode","indexOf","reverse"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TreeError } from './tree.js';\r\nimport { tail2 } from '../../../common/arrays.js';\r\nimport { LcsDiff } from '../../../common/diff/diff.js';\r\nimport { Emitter, EventBufferer } from '../../../common/event.js';\r\nimport { Iterable } from '../../../common/iterator.js';\r\nexport function isFilterResult(obj) {\r\n    return typeof obj === 'object' && 'visibility' in obj && 'data' in obj;\r\n}\r\nexport function getVisibleState(visibility) {\r\n    switch (visibility) {\r\n        case true: return 1 /* Visible */;\r\n        case false: return 0 /* Hidden */;\r\n        default: return visibility;\r\n    }\r\n}\r\nfunction isCollapsibleStateUpdate(update) {\r\n    return typeof update.collapsible === 'boolean';\r\n}\r\nexport class IndexTreeModel {\r\n    constructor(user, list, rootElement, options = {}) {\r\n        this.user = user;\r\n        this.list = list;\r\n        this.rootRef = [];\r\n        this.eventBufferer = new EventBufferer();\r\n        this._onDidChangeCollapseState = new Emitter();\r\n        this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event);\r\n        this._onDidChangeRenderNodeCount = new Emitter();\r\n        this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event);\r\n        this._onDidSplice = new Emitter();\r\n        this.onDidSplice = this._onDidSplice.event;\r\n        this.collapseByDefault = typeof options.collapseByDefault === 'undefined' ? false : options.collapseByDefault;\r\n        this.filter = options.filter;\r\n        this.autoExpandSingleChildren = typeof options.autoExpandSingleChildren === 'undefined' ? false : options.autoExpandSingleChildren;\r\n        this.root = {\r\n            parent: undefined,\r\n            element: rootElement,\r\n            children: [],\r\n            depth: 0,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: false,\r\n            collapsed: false,\r\n            renderNodeCount: 0,\r\n            visibility: 1 /* Visible */,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n    }\r\n    splice(location, deleteCount, toInsert = Iterable.empty(), options = {}) {\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        if (options.diffIdentityProvider) {\r\n            this.spliceSmart(options.diffIdentityProvider, location, deleteCount, toInsert, options);\r\n        }\r\n        else {\r\n            this.spliceSimple(location, deleteCount, toInsert, options);\r\n        }\r\n    }\r\n    spliceSmart(identity, location, deleteCount, toInsertIterable, options, recurseLevels) {\r\n        var _a;\r\n        if (toInsertIterable === void 0) { toInsertIterable = Iterable.empty(); }\r\n        if (recurseLevels === void 0) { recurseLevels = (_a = options.diffDepth) !== null && _a !== void 0 ? _a : 0; }\r\n        const { parentNode } = this.getParentNodeWithListIndex(location);\r\n        const toInsert = [...toInsertIterable];\r\n        const index = location[location.length - 1];\r\n        const diff = new LcsDiff({ getElements: () => parentNode.children.map(e => identity.getId(e.element).toString()) }, {\r\n            getElements: () => [\r\n                ...parentNode.children.slice(0, index),\r\n                ...toInsert,\r\n                ...parentNode.children.slice(index + deleteCount),\r\n            ].map(e => identity.getId(e.element).toString())\r\n        }).ComputeDiff(false);\r\n        // if we were given a 'best effort' diff, use default behavior\r\n        if (diff.quitEarly) {\r\n            return this.spliceSimple(location, deleteCount, toInsert, options);\r\n        }\r\n        const locationPrefix = location.slice(0, -1);\r\n        const recurseSplice = (fromOriginal, fromModified, count) => {\r\n            if (recurseLevels > 0) {\r\n                for (let i = 0; i < count; i++) {\r\n                    fromOriginal--;\r\n                    fromModified--;\r\n                    this.spliceSmart(identity, [...locationPrefix, fromOriginal, 0], Number.MAX_SAFE_INTEGER, toInsert[fromModified].children, options, recurseLevels - 1);\r\n                }\r\n            }\r\n        };\r\n        let lastStartO = Math.min(parentNode.children.length, index + deleteCount);\r\n        let lastStartM = toInsert.length;\r\n        for (const change of diff.changes.sort((a, b) => b.originalStart - a.originalStart)) {\r\n            recurseSplice(lastStartO, lastStartM, lastStartO - (change.originalStart + change.originalLength));\r\n            lastStartO = change.originalStart;\r\n            lastStartM = change.modifiedStart - index;\r\n            this.spliceSimple([...locationPrefix, lastStartO], change.originalLength, Iterable.slice(toInsert, lastStartM, lastStartM + change.modifiedLength), options);\r\n        }\r\n        // at this point, startO === startM === count since any remaining prefix should match\r\n        recurseSplice(lastStartO, lastStartM, lastStartO);\r\n    }\r\n    spliceSimple(location, deleteCount, toInsert = Iterable.empty(), { onDidCreateNode, onDidDeleteNode }) {\r\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\r\n        const treeListElementsToInsert = [];\r\n        const nodesToInsertIterator = Iterable.map(toInsert, el => this.createTreeNode(el, parentNode, parentNode.visible ? 1 /* Visible */ : 0 /* Hidden */, revealed, treeListElementsToInsert, onDidCreateNode));\r\n        const lastIndex = location[location.length - 1];\r\n        const lastHadChildren = parentNode.children.length > 0;\r\n        // figure out what's the visible child start index right before the\r\n        // splice point\r\n        let visibleChildStartIndex = 0;\r\n        for (let i = lastIndex; i >= 0 && i < parentNode.children.length; i--) {\r\n            const child = parentNode.children[i];\r\n            if (child.visible) {\r\n                visibleChildStartIndex = child.visibleChildIndex;\r\n                break;\r\n            }\r\n        }\r\n        const nodesToInsert = [];\r\n        let insertedVisibleChildrenCount = 0;\r\n        let renderNodeCount = 0;\r\n        for (const child of nodesToInsertIterator) {\r\n            nodesToInsert.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildStartIndex + insertedVisibleChildrenCount++;\r\n            }\r\n        }\r\n        const deletedNodes = parentNode.children.splice(lastIndex, deleteCount, ...nodesToInsert);\r\n        // figure out what is the count of deleted visible children\r\n        let deletedVisibleChildrenCount = 0;\r\n        for (const child of deletedNodes) {\r\n            if (child.visible) {\r\n                deletedVisibleChildrenCount++;\r\n            }\r\n        }\r\n        // and adjust for all visible children after the splice point\r\n        if (deletedVisibleChildrenCount !== 0) {\r\n            for (let i = lastIndex + nodesToInsert.length; i < parentNode.children.length; i++) {\r\n                const child = parentNode.children[i];\r\n                if (child.visible) {\r\n                    child.visibleChildIndex -= deletedVisibleChildrenCount;\r\n                }\r\n            }\r\n        }\r\n        // update parent's visible children count\r\n        parentNode.visibleChildrenCount += insertedVisibleChildrenCount - deletedVisibleChildrenCount;\r\n        if (revealed && visible) {\r\n            const visibleDeleteCount = deletedNodes.reduce((r, node) => r + (node.visible ? node.renderNodeCount : 0), 0);\r\n            this._updateAncestorsRenderNodeCount(parentNode, renderNodeCount - visibleDeleteCount);\r\n            this.list.splice(listIndex, visibleDeleteCount, treeListElementsToInsert);\r\n        }\r\n        if (deletedNodes.length > 0 && onDidDeleteNode) {\r\n            const visit = (node) => {\r\n                onDidDeleteNode(node);\r\n                node.children.forEach(visit);\r\n            };\r\n            deletedNodes.forEach(visit);\r\n        }\r\n        const currentlyHasChildren = parentNode.children.length > 0;\r\n        if (lastHadChildren !== currentlyHasChildren) {\r\n            this.setCollapsible(location.slice(0, -1), currentlyHasChildren);\r\n        }\r\n        this._onDidSplice.fire({ insertedNodes: nodesToInsert, deletedNodes });\r\n        let node = parentNode;\r\n        while (node) {\r\n            if (node.visibility === 2 /* Recurse */) {\r\n                this.refilter();\r\n                break;\r\n            }\r\n            node = node.parent;\r\n        }\r\n    }\r\n    rerender(location) {\r\n        if (location.length === 0) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\r\n        if (node.visible && revealed) {\r\n            this.list.splice(listIndex, 1, [node]);\r\n        }\r\n    }\r\n    has(location) {\r\n        return this.hasTreeNode(location);\r\n    }\r\n    getListIndex(location) {\r\n        const { listIndex, visible, revealed } = this.getTreeNodeWithListIndex(location);\r\n        return visible && revealed ? listIndex : -1;\r\n    }\r\n    getListRenderCount(location) {\r\n        return this.getTreeNode(location).renderNodeCount;\r\n    }\r\n    isCollapsible(location) {\r\n        return this.getTreeNode(location).collapsible;\r\n    }\r\n    setCollapsible(location, collapsible) {\r\n        const node = this.getTreeNode(location);\r\n        if (typeof collapsible === 'undefined') {\r\n            collapsible = !node.collapsible;\r\n        }\r\n        const update = { collapsible };\r\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\r\n    }\r\n    isCollapsed(location) {\r\n        return this.getTreeNode(location).collapsed;\r\n    }\r\n    setCollapsed(location, collapsed, recursive) {\r\n        const node = this.getTreeNode(location);\r\n        if (typeof collapsed === 'undefined') {\r\n            collapsed = !node.collapsed;\r\n        }\r\n        const update = { collapsed, recursive: recursive || false };\r\n        return this.eventBufferer.bufferEvents(() => this._setCollapseState(location, update));\r\n    }\r\n    _setCollapseState(location, update) {\r\n        const { node, listIndex, revealed } = this.getTreeNodeWithListIndex(location);\r\n        const result = this._setListNodeCollapseState(node, listIndex, revealed, update);\r\n        if (node !== this.root && this.autoExpandSingleChildren && result && !isCollapsibleStateUpdate(update) && node.collapsible && !node.collapsed && !update.recursive) {\r\n            let onlyVisibleChildIndex = -1;\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (child.visible) {\r\n                    if (onlyVisibleChildIndex > -1) {\r\n                        onlyVisibleChildIndex = -1;\r\n                        break;\r\n                    }\r\n                    else {\r\n                        onlyVisibleChildIndex = i;\r\n                    }\r\n                }\r\n            }\r\n            if (onlyVisibleChildIndex > -1) {\r\n                this._setCollapseState([...location, onlyVisibleChildIndex], update);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _setListNodeCollapseState(node, listIndex, revealed, update) {\r\n        const result = this._setNodeCollapseState(node, update, false);\r\n        if (!revealed || !node.visible || !result) {\r\n            return result;\r\n        }\r\n        const previousRenderNodeCount = node.renderNodeCount;\r\n        const toInsert = this.updateNodeAfterCollapseChange(node);\r\n        const deleteCount = previousRenderNodeCount - (listIndex === -1 ? 0 : 1);\r\n        this.list.splice(listIndex + 1, deleteCount, toInsert.slice(1));\r\n        return result;\r\n    }\r\n    _setNodeCollapseState(node, update, deep) {\r\n        let result;\r\n        if (node === this.root) {\r\n            result = false;\r\n        }\r\n        else {\r\n            if (isCollapsibleStateUpdate(update)) {\r\n                result = node.collapsible !== update.collapsible;\r\n                node.collapsible = update.collapsible;\r\n            }\r\n            else if (!node.collapsible) {\r\n                result = false;\r\n            }\r\n            else {\r\n                result = node.collapsed !== update.collapsed;\r\n                node.collapsed = update.collapsed;\r\n            }\r\n            if (result) {\r\n                this._onDidChangeCollapseState.fire({ node, deep });\r\n            }\r\n        }\r\n        if (!isCollapsibleStateUpdate(update) && update.recursive) {\r\n            for (const child of node.children) {\r\n                result = this._setNodeCollapseState(child, update, true) || result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    expandTo(location) {\r\n        this.eventBufferer.bufferEvents(() => {\r\n            let node = this.getTreeNode(location);\r\n            while (node.parent) {\r\n                node = node.parent;\r\n                location = location.slice(0, location.length - 1);\r\n                if (node.collapsed) {\r\n                    this._setCollapseState(location, { collapsed: false, recursive: false });\r\n                }\r\n            }\r\n        });\r\n    }\r\n    refilter() {\r\n        const previousRenderNodeCount = this.root.renderNodeCount;\r\n        const toInsert = this.updateNodeAfterFilterChange(this.root);\r\n        this.list.splice(0, previousRenderNodeCount, toInsert);\r\n    }\r\n    createTreeNode(treeElement, parent, parentVisibility, revealed, treeListElements, onDidCreateNode) {\r\n        const node = {\r\n            parent,\r\n            element: treeElement.element,\r\n            children: [],\r\n            depth: parent.depth + 1,\r\n            visibleChildrenCount: 0,\r\n            visibleChildIndex: -1,\r\n            collapsible: typeof treeElement.collapsible === 'boolean' ? treeElement.collapsible : (typeof treeElement.collapsed !== 'undefined'),\r\n            collapsed: typeof treeElement.collapsed === 'undefined' ? this.collapseByDefault : treeElement.collapsed,\r\n            renderNodeCount: 1,\r\n            visibility: 1 /* Visible */,\r\n            visible: true,\r\n            filterData: undefined\r\n        };\r\n        const visibility = this._filterNode(node, parentVisibility);\r\n        node.visibility = visibility;\r\n        if (revealed) {\r\n            treeListElements.push(node);\r\n        }\r\n        const childElements = treeElement.children || Iterable.empty();\r\n        const childRevealed = revealed && visibility !== 0 /* Hidden */ && !node.collapsed;\r\n        const childNodes = Iterable.map(childElements, el => this.createTreeNode(el, node, visibility, childRevealed, treeListElements, onDidCreateNode));\r\n        let visibleChildrenCount = 0;\r\n        let renderNodeCount = 1;\r\n        for (const child of childNodes) {\r\n            node.children.push(child);\r\n            renderNodeCount += child.renderNodeCount;\r\n            if (child.visible) {\r\n                child.visibleChildIndex = visibleChildrenCount++;\r\n            }\r\n        }\r\n        node.collapsible = node.collapsible || node.children.length > 0;\r\n        node.visibleChildrenCount = visibleChildrenCount;\r\n        node.visible = visibility === 2 /* Recurse */ ? visibleChildrenCount > 0 : (visibility === 1 /* Visible */);\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                treeListElements.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount = renderNodeCount;\r\n        }\r\n        if (onDidCreateNode) {\r\n            onDidCreateNode(node);\r\n        }\r\n        return node;\r\n    }\r\n    updateNodeAfterCollapseChange(node) {\r\n        const previousRenderNodeCount = node.renderNodeCount;\r\n        const result = [];\r\n        this._updateNodeAfterCollapseChange(node, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    }\r\n    _updateNodeAfterCollapseChange(node, result) {\r\n        if (node.visible === false) {\r\n            return 0;\r\n        }\r\n        result.push(node);\r\n        node.renderNodeCount = 1;\r\n        if (!node.collapsed) {\r\n            for (const child of node.children) {\r\n                node.renderNodeCount += this._updateNodeAfterCollapseChange(child, result);\r\n            }\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.renderNodeCount;\r\n    }\r\n    updateNodeAfterFilterChange(node) {\r\n        const previousRenderNodeCount = node.renderNodeCount;\r\n        const result = [];\r\n        this._updateNodeAfterFilterChange(node, node.visible ? 1 /* Visible */ : 0 /* Hidden */, result);\r\n        this._updateAncestorsRenderNodeCount(node.parent, result.length - previousRenderNodeCount);\r\n        return result;\r\n    }\r\n    _updateNodeAfterFilterChange(node, parentVisibility, result, revealed = true) {\r\n        let visibility;\r\n        if (node !== this.root) {\r\n            visibility = this._filterNode(node, parentVisibility);\r\n            if (visibility === 0 /* Hidden */) {\r\n                node.visible = false;\r\n                node.renderNodeCount = 0;\r\n                return false;\r\n            }\r\n            if (revealed) {\r\n                result.push(node);\r\n            }\r\n        }\r\n        const resultStartLength = result.length;\r\n        node.renderNodeCount = node === this.root ? 0 : 1;\r\n        let hasVisibleDescendants = false;\r\n        if (!node.collapsed || visibility !== 0 /* Hidden */) {\r\n            let visibleChildIndex = 0;\r\n            for (const child of node.children) {\r\n                hasVisibleDescendants = this._updateNodeAfterFilterChange(child, visibility, result, revealed && !node.collapsed) || hasVisibleDescendants;\r\n                if (child.visible) {\r\n                    child.visibleChildIndex = visibleChildIndex++;\r\n                }\r\n            }\r\n            node.visibleChildrenCount = visibleChildIndex;\r\n        }\r\n        else {\r\n            node.visibleChildrenCount = 0;\r\n        }\r\n        if (node !== this.root) {\r\n            node.visible = visibility === 2 /* Recurse */ ? hasVisibleDescendants : (visibility === 1 /* Visible */);\r\n        }\r\n        if (!node.visible) {\r\n            node.renderNodeCount = 0;\r\n            if (revealed) {\r\n                result.pop();\r\n            }\r\n        }\r\n        else if (!node.collapsed) {\r\n            node.renderNodeCount += result.length - resultStartLength;\r\n        }\r\n        this._onDidChangeRenderNodeCount.fire(node);\r\n        return node.visible;\r\n    }\r\n    _updateAncestorsRenderNodeCount(node, diff) {\r\n        if (diff === 0) {\r\n            return;\r\n        }\r\n        while (node) {\r\n            node.renderNodeCount += diff;\r\n            this._onDidChangeRenderNodeCount.fire(node);\r\n            node = node.parent;\r\n        }\r\n    }\r\n    _filterNode(node, parentVisibility) {\r\n        const result = this.filter ? this.filter.filter(node.element, parentVisibility) : 1 /* Visible */;\r\n        if (typeof result === 'boolean') {\r\n            node.filterData = undefined;\r\n            return result ? 1 /* Visible */ : 0 /* Hidden */;\r\n        }\r\n        else if (isFilterResult(result)) {\r\n            node.filterData = result.data;\r\n            return getVisibleState(result.visibility);\r\n        }\r\n        else {\r\n            node.filterData = undefined;\r\n            return getVisibleState(result);\r\n        }\r\n    }\r\n    // cheap\r\n    hasTreeNode(location, node = this.root) {\r\n        if (!location || location.length === 0) {\r\n            return true;\r\n        }\r\n        const [index, ...rest] = location;\r\n        if (index < 0 || index > node.children.length) {\r\n            return false;\r\n        }\r\n        return this.hasTreeNode(rest, node.children[index]);\r\n    }\r\n    // cheap\r\n    getTreeNode(location, node = this.root) {\r\n        if (!location || location.length === 0) {\r\n            return node;\r\n        }\r\n        const [index, ...rest] = location;\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        return this.getTreeNode(rest, node.children[index]);\r\n    }\r\n    // expensive\r\n    getTreeNodeWithListIndex(location) {\r\n        if (location.length === 0) {\r\n            return { node: this.root, listIndex: -1, revealed: true, visible: false };\r\n        }\r\n        const { parentNode, listIndex, revealed, visible } = this.getParentNodeWithListIndex(location);\r\n        const index = location[location.length - 1];\r\n        if (index < 0 || index > parentNode.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        const node = parentNode.children[index];\r\n        return { node, listIndex, revealed, visible: visible && node.visible };\r\n    }\r\n    getParentNodeWithListIndex(location, node = this.root, listIndex = 0, revealed = true, visible = true) {\r\n        const [index, ...rest] = location;\r\n        if (index < 0 || index > node.children.length) {\r\n            throw new TreeError(this.user, 'Invalid tree location');\r\n        }\r\n        // TODO@joao perf!\r\n        for (let i = 0; i < index; i++) {\r\n            listIndex += node.children[i].renderNodeCount;\r\n        }\r\n        revealed = revealed && !node.collapsed;\r\n        visible = visible && node.visible;\r\n        if (rest.length === 0) {\r\n            return { parentNode: node, listIndex, revealed, visible };\r\n        }\r\n        return this.getParentNodeWithListIndex(rest, node.children[index], listIndex + 1, revealed, visible);\r\n    }\r\n    getNode(location = []) {\r\n        return this.getTreeNode(location);\r\n    }\r\n    // TODO@joao perf!\r\n    getNodeLocation(node) {\r\n        const location = [];\r\n        let indexTreeNode = node; // typing woes\r\n        while (indexTreeNode.parent) {\r\n            location.push(indexTreeNode.parent.children.indexOf(indexTreeNode));\r\n            indexTreeNode = indexTreeNode.parent;\r\n        }\r\n        return location.reverse();\r\n    }\r\n    getParentNodeLocation(location) {\r\n        if (location.length === 0) {\r\n            return undefined;\r\n        }\r\n        else if (location.length === 1) {\r\n            return [];\r\n        }\r\n        else {\r\n            return tail2(location)[0];\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}