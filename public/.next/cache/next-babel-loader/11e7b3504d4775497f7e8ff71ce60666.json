{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { DiffChange } from './diffChange.js';\nimport { stringHash } from '../hash.js';\nexport var StringDiffSequence = /*#__PURE__*/function () {\n  function StringDiffSequence(source) {\n    _classCallCheck(this, StringDiffSequence);\n\n    this.source = source;\n  }\n\n  _createClass(StringDiffSequence, [{\n    key: \"getElements\",\n    value: function getElements() {\n      var source = this.source;\n      var characters = new Int32Array(source.length);\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        characters[i] = source.charCodeAt(i);\n      }\n\n      return characters;\n    }\n  }]);\n\n  return StringDiffSequence;\n}();\nexport function stringDiff(original, modified, pretty) {\n  return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n} //\n// The code below has been ported from a C# implementation in VS\n//\n\nexport var Debug = /*#__PURE__*/function () {\n  function Debug() {\n    _classCallCheck(this, Debug);\n  }\n\n  _createClass(Debug, null, [{\n    key: \"Assert\",\n    value: function Assert(condition, message) {\n      if (!condition) {\n        throw new Error(message);\n      }\n    }\n  }]);\n\n  return Debug;\n}();\nexport var MyArray = /*#__PURE__*/function () {\n  function MyArray() {\n    _classCallCheck(this, MyArray);\n  }\n\n  _createClass(MyArray, null, [{\n    key: \"Copy\",\n\n    /**\r\n     * Copies a range of elements from an Array starting at the specified source index and pastes\r\n     * them to another Array starting at the specified destination index. The length and the indexes\r\n     * are specified as 64-bit integers.\r\n     * sourceArray:\r\n     *\t\tThe Array that contains the data to copy.\r\n     * sourceIndex:\r\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n     * destinationArray:\r\n     *\t\tThe Array that receives the data.\r\n     * destinationIndex:\r\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n     * length:\r\n     *\t\tA 64-bit integer that represents the number of elements to copy.\r\n     */\n    value: function Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n      for (var i = 0; i < length; i++) {\n        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n      }\n    }\n  }, {\n    key: \"Copy2\",\n    value: function Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n      for (var i = 0; i < length; i++) {\n        destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n      }\n    }\n  }]);\n\n  return MyArray;\n}();\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarktNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\n\nvar DiffChangeHelper = /*#__PURE__*/function () {\n  /**\r\n   * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n   */\n  function DiffChangeHelper() {\n    _classCallCheck(this, DiffChangeHelper);\n\n    this.m_changes = [];\n    this.m_originalStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    this.m_modifiedStart = 1073741824\n    /* MAX_SAFE_SMALL_INTEGER */\n    ;\n    this.m_originalCount = 0;\n    this.m_modifiedCount = 0;\n  }\n  /**\r\n   * Marks the beginning of the next change in the set of differences.\r\n   */\n\n\n  _createClass(DiffChangeHelper, [{\n    key: \"MarkNextChange\",\n    value: function MarkNextChange() {\n      // Only add to the list if there is something to add\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Add the new change to our list\n        this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n      } // Reset for the next change\n\n\n      this.m_originalCount = 0;\n      this.m_modifiedCount = 0;\n      this.m_originalStart = 1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      ;\n      this.m_modifiedStart = 1073741824\n      /* MAX_SAFE_SMALL_INTEGER */\n      ;\n    }\n    /**\r\n     * Adds the original element at the given position to the elements\r\n     * affected by the current change. The modified index gives context\r\n     * to the change position with respect to the original sequence.\r\n     * @param originalIndex The index of the original element to add.\r\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n     */\n\n  }, {\n    key: \"AddOriginalElement\",\n    value: function AddOriginalElement(originalIndex, modifiedIndex) {\n      // The 'true' start index is the smallest of the ones we've seen\n      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n      this.m_originalCount++;\n    }\n    /**\r\n     * Adds the modified element at the given position to the elements\r\n     * affected by the current change. The original index gives context\r\n     * to the change position with respect to the modified sequence.\r\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n     * @param modifiedIndex The index of the modified element to add.\r\n     */\n\n  }, {\n    key: \"AddModifiedElement\",\n    value: function AddModifiedElement(originalIndex, modifiedIndex) {\n      // The 'true' start index is the smallest of the ones we've seen\n      this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n      this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n      this.m_modifiedCount++;\n    }\n    /**\r\n     * Retrieves all of the changes marked by the class.\r\n     */\n\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Finish up on whatever is left\n        this.MarkNextChange();\n      }\n\n      return this.m_changes;\n    }\n    /**\r\n     * Retrieves all of the changes marked by the class in the reverse order\r\n     */\n\n  }, {\n    key: \"getReverseChanges\",\n    value: function getReverseChanges() {\n      if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n        // Finish up on whatever is left\n        this.MarkNextChange();\n      }\n\n      this.m_changes.reverse();\n      return this.m_changes;\n    }\n  }]);\n\n  return DiffChangeHelper;\n}();\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\n\n\nexport var LcsDiff = /*#__PURE__*/function () {\n  /**\r\n   * Constructs the DiffFinder\r\n   */\n  function LcsDiff(originalSequence, modifiedSequence) {\n    var continueProcessingPredicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, LcsDiff);\n\n    this.ContinueProcessingPredicate = continueProcessingPredicate;\n\n    var _LcsDiff$_getElements = LcsDiff._getElements(originalSequence),\n        _LcsDiff$_getElements2 = _slicedToArray(_LcsDiff$_getElements, 3),\n        originalStringElements = _LcsDiff$_getElements2[0],\n        originalElementsOrHash = _LcsDiff$_getElements2[1],\n        originalHasStrings = _LcsDiff$_getElements2[2];\n\n    var _LcsDiff$_getElements3 = LcsDiff._getElements(modifiedSequence),\n        _LcsDiff$_getElements4 = _slicedToArray(_LcsDiff$_getElements3, 3),\n        modifiedStringElements = _LcsDiff$_getElements4[0],\n        modifiedElementsOrHash = _LcsDiff$_getElements4[1],\n        modifiedHasStrings = _LcsDiff$_getElements4[2];\n\n    this._hasStrings = originalHasStrings && modifiedHasStrings;\n    this._originalStringElements = originalStringElements;\n    this._originalElementsOrHash = originalElementsOrHash;\n    this._modifiedStringElements = modifiedStringElements;\n    this._modifiedElementsOrHash = modifiedElementsOrHash;\n    this.m_forwardHistory = [];\n    this.m_reverseHistory = [];\n  }\n\n  _createClass(LcsDiff, [{\n    key: \"ElementsAreEqual\",\n    value: function ElementsAreEqual(originalIndex, newIndex) {\n      if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n        return false;\n      }\n\n      return this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true;\n    }\n  }, {\n    key: \"OriginalElementsAreEqual\",\n    value: function OriginalElementsAreEqual(index1, index2) {\n      if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n        return false;\n      }\n\n      return this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true;\n    }\n  }, {\n    key: \"ModifiedElementsAreEqual\",\n    value: function ModifiedElementsAreEqual(index1, index2) {\n      if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n        return false;\n      }\n\n      return this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true;\n    }\n  }, {\n    key: \"ComputeDiff\",\n    value: function ComputeDiff(pretty) {\n      return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\r\n     * Computes the differences between the original and modified input\r\n     * sequences on the bounded range.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\n\n  }, {\n    key: \"_ComputeDiff\",\n    value: function _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n      var quitEarlyArr = [false];\n      var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\n      if (pretty) {\n        // We have to clean up the computed diff to be more intuitive\n        // but it turns out this cannot be done correctly until the entire set\n        // of diffs have been computed\n        changes = this.PrettifyChanges(changes);\n      }\n\n      return {\n        quitEarly: quitEarlyArr[0],\n        changes: changes\n      };\n    }\n    /**\r\n     * Private helper method which computes the differences on the bounded range\r\n     * recursively.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\n\n  }, {\n    key: \"ComputeDiffRecursive\",\n    value: function ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n      quitEarlyArr[0] = false; // Find the start of the differences\n\n      while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n        originalStart++;\n        modifiedStart++;\n      } // Find the end of the differences\n\n\n      while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n        originalEnd--;\n        modifiedEnd--;\n      } // In the special case where we either have all insertions or all deletions or the sequences are identical\n\n\n      if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n        var changes;\n\n        if (modifiedStart <= modifiedEnd) {\n          Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd'); // All insertions\n\n          changes = [new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)];\n        } else if (originalStart <= originalEnd) {\n          Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // All deletions\n\n          changes = [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)];\n        } else {\n          Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n          Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd'); // Identical sequences - No differences\n\n          changes = [];\n        }\n\n        return changes;\n      } // This problem can be solved using the Divide-And-Conquer technique.\n\n\n      var midOriginalArr = [0];\n      var midModifiedArr = [0];\n      var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n      var midOriginal = midOriginalArr[0];\n      var midModified = midModifiedArr[0];\n\n      if (result !== null) {\n        // Result is not-null when there was enough memory to compute the changes while\n        // searching for the recursion point\n        return result;\n      } else if (!quitEarlyArr[0]) {\n        // We can break the problem down recursively by finding the changes in the\n        // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n        // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n        // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n        var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n        var rightChanges = [];\n\n        if (!quitEarlyArr[0]) {\n          rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n        } else {\n          // We did't have time to finish the first half, so we don't have time to compute this half.\n          // Consider the entire rest of the sequence different.\n          rightChanges = [new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)];\n        }\n\n        return this.ConcatenateChanges(leftChanges, rightChanges);\n      } // If we hit here, we quit early, and so can't return anything meaningful\n\n\n      return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n    }\n  }, {\n    key: \"WALKTRACE\",\n    value: function WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n      var forwardChanges = null;\n      var reverseChanges = null; // First, walk backward through the forward diagonals history\n\n      var changeHelper = new DiffChangeHelper();\n      var diagonalMin = diagonalForwardStart;\n      var diagonalMax = diagonalForwardEnd;\n      var diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalForwardOffset;\n      var lastOriginalIndex = -1073741824\n      /* MIN_SAFE_SMALL_INTEGER */\n      ;\n      var historyIndex = this.m_forwardHistory.length - 1;\n\n      do {\n        // Get the diagonal index from the relative diagonal number\n        var diagonal = diagonalRelative + diagonalForwardBase; // Figure out where we came from\n\n        if (diagonal === diagonalMin || diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n          // Vertical line (the element is an insert)\n          originalIndex = forwardPoints[diagonal + 1];\n          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n          if (originalIndex < lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex;\n          changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n          diagonalRelative = diagonal + 1 - diagonalForwardBase; //Setup for the next iteration\n        } else {\n          // Horizontal line (the element is a deletion)\n          originalIndex = forwardPoints[diagonal - 1] + 1;\n          modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\n          if (originalIndex < lastOriginalIndex) {\n            changeHelper.MarkNextChange();\n          }\n\n          lastOriginalIndex = originalIndex - 1;\n          changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n          diagonalRelative = diagonal - 1 - diagonalForwardBase; //Setup for the next iteration\n        }\n\n        if (historyIndex >= 0) {\n          forwardPoints = this.m_forwardHistory[historyIndex];\n          diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\n          diagonalMin = 1;\n          diagonalMax = forwardPoints.length - 1;\n        }\n      } while (--historyIndex >= -1); // Ironically, we get the forward changes as the reverse of the\n      // order we added them since we technically added them backwards\n\n\n      forwardChanges = changeHelper.getReverseChanges();\n\n      if (quitEarlyArr[0]) {\n        // TODO: Calculate a partial from the reverse diagonals.\n        //       For now, just assume everything after the midOriginal/midModified point is a diff\n        var originalStartPoint = midOriginalArr[0] + 1;\n        var modifiedStartPoint = midModifiedArr[0] + 1;\n\n        if (forwardChanges !== null && forwardChanges.length > 0) {\n          var lastForwardChange = forwardChanges[forwardChanges.length - 1];\n          originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n          modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n        }\n\n        reverseChanges = [new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)];\n      } else {\n        // Now walk backward through the reverse diagonals history\n        changeHelper = new DiffChangeHelper();\n        diagonalMin = diagonalReverseStart;\n        diagonalMax = diagonalReverseEnd;\n        diagonalRelative = midOriginalArr[0] - midModifiedArr[0] - diagonalReverseOffset;\n        lastOriginalIndex = 1073741824\n        /* MAX_SAFE_SMALL_INTEGER */\n        ;\n        historyIndex = deltaIsEven ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n        do {\n          // Get the diagonal index from the relative diagonal number\n          var _diagonal = diagonalRelative + diagonalReverseBase; // Figure out where we came from\n\n\n          if (_diagonal === diagonalMin || _diagonal < diagonalMax && reversePoints[_diagonal - 1] >= reversePoints[_diagonal + 1]) {\n            // Horizontal line (the element is a deletion))\n            originalIndex = reversePoints[_diagonal + 1] - 1;\n            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n            if (originalIndex > lastOriginalIndex) {\n              changeHelper.MarkNextChange();\n            }\n\n            lastOriginalIndex = originalIndex + 1;\n            changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n            diagonalRelative = _diagonal + 1 - diagonalReverseBase; //Setup for the next iteration\n          } else {\n            // Vertical line (the element is an insertion)\n            originalIndex = reversePoints[_diagonal - 1];\n            modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\n            if (originalIndex > lastOriginalIndex) {\n              changeHelper.MarkNextChange();\n            }\n\n            lastOriginalIndex = originalIndex;\n            changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n            diagonalRelative = _diagonal - 1 - diagonalReverseBase; //Setup for the next iteration\n          }\n\n          if (historyIndex >= 0) {\n            reversePoints = this.m_reverseHistory[historyIndex];\n            diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\n            diagonalMin = 1;\n            diagonalMax = reversePoints.length - 1;\n          }\n        } while (--historyIndex >= -1); // There are cases where the reverse history will find diffs that\n        // are correct, but not intuitive, so we need shift them.\n\n\n        reverseChanges = changeHelper.getChanges();\n      }\n\n      return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\r\n     * Given the range to compute the diff on, this method finds the point:\r\n     * (midOriginal, midModified)\r\n     * that exists in the middle of the LCS of the two sequences and\r\n     * is the point at which the LCS problem may be broken down recursively.\r\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n     * point is calculated and the full trace is available in memory, then this method\r\n     * will return the change list.\r\n     * @param originalStart The start bound of the original sequence range\r\n     * @param originalEnd The end bound of the original sequence range\r\n     * @param modifiedStart The start bound of the modified sequence range\r\n     * @param modifiedEnd The end bound of the modified sequence range\r\n     * @param midOriginal The middle point of the original sequence range\r\n     * @param midModified The middle point of the modified sequence range\r\n     * @returns The diff changes, if available, otherwise null\r\n     */\n\n  }, {\n    key: \"ComputeRecursionPoint\",\n    value: function ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n      var originalIndex = 0,\n          modifiedIndex = 0;\n      var diagonalForwardStart = 0,\n          diagonalForwardEnd = 0;\n      var diagonalReverseStart = 0,\n          diagonalReverseEnd = 0; // To traverse the edit graph and produce the proper LCS, our actual\n      // start position is just outside the given boundary\n\n      originalStart--;\n      modifiedStart--; // We set these up to make the compiler happy, but they will\n      // be replaced before we return with the actual recursion point\n\n      midOriginalArr[0] = 0;\n      midModifiedArr[0] = 0; // Clear out the history\n\n      this.m_forwardHistory = [];\n      this.m_reverseHistory = []; // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n      // The integer value in the cell represents the originalIndex of the furthest\n      // reaching point found so far that ends in that diagonal.\n      // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\n      var maxDifferences = originalEnd - originalStart + (modifiedEnd - modifiedStart);\n      var numDiagonals = maxDifferences + 1;\n      var forwardPoints = new Int32Array(numDiagonals);\n      var reversePoints = new Int32Array(numDiagonals); // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n      // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\n      var diagonalForwardBase = modifiedEnd - modifiedStart;\n      var diagonalReverseBase = originalEnd - originalStart; // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n      //    diagonal number (relative to diagonalForwardBase)\n      // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n      //    diagonal number (relative to diagonalReverseBase)\n\n      var diagonalForwardOffset = originalStart - modifiedStart;\n      var diagonalReverseOffset = originalEnd - modifiedEnd; // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n      //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n      // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\n      var delta = diagonalReverseBase - diagonalForwardBase;\n      var deltaIsEven = delta % 2 === 0; // Here we set up the start and end points as the furthest points found so far\n      // in both the forward and reverse directions, respectively\n\n      forwardPoints[diagonalForwardBase] = originalStart;\n      reversePoints[diagonalReverseBase] = originalEnd; // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\n      quitEarlyArr[0] = false; // A couple of points:\n      // --With this method, we iterate on the number of differences between the two sequences.\n      //   The more differences there actually are, the longer this will take.\n      // --Also, as the number of differences increases, we have to search on diagonals further\n      //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n      // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n      //   is even and odd diagonals only when numDifferences is odd.\n\n      for (var numDifferences = 1; numDifferences <= maxDifferences / 2 + 1; numDifferences++) {\n        var furthestOriginalIndex = 0;\n        var furthestModifiedIndex = 0; // Run the algorithm in the forward direction\n\n        diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n        diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\n        for (var diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n          // STEP 1: We extend the furthest reaching point in the present diagonal\n          // by looking at the diagonals above and below and picking the one whose point\n          // is further away from the start point (originalStart, modifiedStart)\n          if (diagonal === diagonalForwardStart || diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1]) {\n            originalIndex = forwardPoints[diagonal + 1];\n          } else {\n            originalIndex = forwardPoints[diagonal - 1] + 1;\n          }\n\n          modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset; // Save the current originalIndex so we can test for false overlap in step 3\n\n          var tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n          // so long as the elements are equal.\n\n          while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n            originalIndex++;\n            modifiedIndex++;\n          }\n\n          forwardPoints[diagonal] = originalIndex;\n\n          if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n            furthestOriginalIndex = originalIndex;\n            furthestModifiedIndex = modifiedIndex;\n          } // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n          // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n          // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n          // then check for overlap.\n\n\n          if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= numDifferences - 1) {\n            if (originalIndex >= reversePoints[diagonal]) {\n              midOriginalArr[0] = originalIndex;\n              midModifiedArr[0] = modifiedIndex;\n\n              if (tempOriginalIndex <= reversePoints[diagonal] && 1447\n              /* MaxDifferencesHistory */\n              > 0 && numDifferences <= 1447\n              /* MaxDifferencesHistory */\n              + 1) {\n                // BINGO! We overlapped, and we have the full trace in memory!\n                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n              } else {\n                // Either false overlap, or we didn't have enough memory for the full trace\n                // Just return the recursion point\n                return null;\n              }\n            }\n          }\n        } // Check to see if we should be quitting early, before moving on to the next iteration.\n\n\n        var matchLengthOfLongest = (furthestOriginalIndex - originalStart + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n        if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n          // We can't finish, so skip ahead to generating a result from what we have.\n          quitEarlyArr[0] = true; // Use the furthest distance we got in the forward direction.\n\n          midOriginalArr[0] = furthestOriginalIndex;\n          midModifiedArr[0] = furthestModifiedIndex;\n\n          if (matchLengthOfLongest > 0 && 1447\n          /* MaxDifferencesHistory */\n          > 0 && numDifferences <= 1447\n          /* MaxDifferencesHistory */\n          + 1) {\n            // Enough of the history is in memory to walk it backwards\n            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n          } else {\n            // We didn't actually remember enough of the history.\n            //Since we are quiting the diff early, we need to shift back the originalStart and modified start\n            //back into the boundary limits since we decremented their value above beyond the boundary limit.\n            originalStart++;\n            modifiedStart++;\n            return [new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)];\n          }\n        } // Run the algorithm in the reverse direction\n\n\n        diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n        diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\n        for (var _diagonal2 = diagonalReverseStart; _diagonal2 <= diagonalReverseEnd; _diagonal2 += 2) {\n          // STEP 1: We extend the furthest reaching point in the present diagonal\n          // by looking at the diagonals above and below and picking the one whose point\n          // is further away from the start point (originalEnd, modifiedEnd)\n          if (_diagonal2 === diagonalReverseStart || _diagonal2 < diagonalReverseEnd && reversePoints[_diagonal2 - 1] >= reversePoints[_diagonal2 + 1]) {\n            originalIndex = reversePoints[_diagonal2 + 1] - 1;\n          } else {\n            originalIndex = reversePoints[_diagonal2 - 1];\n          }\n\n          modifiedIndex = originalIndex - (_diagonal2 - diagonalReverseBase) - diagonalReverseOffset; // Save the current originalIndex so we can test for false overlap\n\n          var _tempOriginalIndex = originalIndex; // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n          // as long as the elements are equal.\n\n          while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n            originalIndex--;\n            modifiedIndex--;\n          }\n\n          reversePoints[_diagonal2] = originalIndex; // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n          // and diagonal is in the range of forward diagonals computed for numDifferences\n          // then check for overlap.\n\n          if (deltaIsEven && Math.abs(_diagonal2 - diagonalForwardBase) <= numDifferences) {\n            if (originalIndex <= forwardPoints[_diagonal2]) {\n              midOriginalArr[0] = originalIndex;\n              midModifiedArr[0] = modifiedIndex;\n\n              if (_tempOriginalIndex >= forwardPoints[_diagonal2] && 1447\n              /* MaxDifferencesHistory */\n              > 0 && numDifferences <= 1447\n              /* MaxDifferencesHistory */\n              + 1) {\n                // BINGO! We overlapped, and we have the full trace in memory!\n                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n              } else {\n                // Either false overlap, or we didn't have enough memory for the full trace\n                // Just return the recursion point\n                return null;\n              }\n            }\n          }\n        } // Save current vectors to history before the next iteration\n\n\n        if (numDifferences <= 1447\n        /* MaxDifferencesHistory */\n        ) {\n            // We are allocating space for one extra int, which we fill with\n            // the index of the diagonal base index\n            var temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n            temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n            MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n            this.m_forwardHistory.push(temp);\n            temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n            temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n            MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n            this.m_reverseHistory.push(temp);\n          }\n      } // If we got here, then we have the full trace in history. We just have to convert it to a change list\n      // NOTE: This part is a bit messy\n\n\n      return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\r\n     * Shifts the given changes to provide a more intuitive diff.\r\n     * While the first element in a diff matches the first element after the diff,\r\n     * we shift the diff down.\r\n     *\r\n     * @param changes The list of changes to shift\r\n     * @returns The shifted changes\r\n     */\n\n  }, {\n    key: \"PrettifyChanges\",\n    value: function PrettifyChanges(changes) {\n      // Shift all the changes down first\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        var originalStop = i < changes.length - 1 ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n        var modifiedStop = i < changes.length - 1 ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n        var checkOriginal = change.originalLength > 0;\n        var checkModified = change.modifiedLength > 0;\n\n        while (change.originalStart + change.originalLength < originalStop && change.modifiedStart + change.modifiedLength < modifiedStop && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n          change.originalStart++;\n          change.modifiedStart++;\n        }\n\n        var mergedChangeArr = [null];\n\n        if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n          changes[i] = mergedChangeArr[0];\n          changes.splice(i + 1, 1);\n          i--;\n          continue;\n        }\n      } // Shift changes back up until we hit empty or whitespace-only lines\n\n\n      for (var _i = changes.length - 1; _i >= 0; _i--) {\n        var _change = changes[_i];\n        var _originalStop = 0;\n        var _modifiedStop = 0;\n\n        if (_i > 0) {\n          var prevChange = changes[_i - 1];\n\n          if (prevChange.originalLength > 0) {\n            _originalStop = prevChange.originalStart + prevChange.originalLength;\n          }\n\n          if (prevChange.modifiedLength > 0) {\n            _modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n          }\n        }\n\n        var _checkOriginal = _change.originalLength > 0;\n\n        var _checkModified = _change.modifiedLength > 0;\n\n        var bestDelta = 0;\n\n        var bestScore = this._boundaryScore(_change.originalStart, _change.originalLength, _change.modifiedStart, _change.modifiedLength);\n\n        for (var delta = 1;; delta++) {\n          var originalStart = _change.originalStart - delta;\n          var modifiedStart = _change.modifiedStart - delta;\n\n          if (originalStart < _originalStop || modifiedStart < _modifiedStop) {\n            break;\n          }\n\n          if (_checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + _change.originalLength)) {\n            break;\n          }\n\n          if (_checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + _change.modifiedLength)) {\n            break;\n          }\n\n          var score = this._boundaryScore(originalStart, _change.originalLength, modifiedStart, _change.modifiedLength);\n\n          if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n          }\n        }\n\n        _change.originalStart -= bestDelta;\n        _change.modifiedStart -= bestDelta;\n      } // There could be multiple longest common substrings.\n      // Give preference to the ones containing longer lines\n\n\n      if (this._hasStrings) {\n        for (var _i2 = 1, len = changes.length; _i2 < len; _i2++) {\n          var aChange = changes[_i2 - 1];\n          var bChange = changes[_i2];\n          var matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n          var aOriginalStart = aChange.originalStart;\n          var bOriginalEnd = bChange.originalStart + bChange.originalLength;\n          var abOriginalLength = bOriginalEnd - aOriginalStart;\n          var aModifiedStart = aChange.modifiedStart;\n          var bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n          var abModifiedLength = bModifiedEnd - aModifiedStart; // Avoid wasting a lot of time with these searches\n\n          if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n            var t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n\n            if (t) {\n              var _t = _slicedToArray(t, 2),\n                  originalMatchStart = _t[0],\n                  modifiedMatchStart = _t[1];\n\n              if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                // switch to another sequence that has a better score\n                aChange.originalLength = originalMatchStart - aChange.originalStart;\n                aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                bChange.originalStart = originalMatchStart + matchedLength;\n                bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n              }\n            }\n          }\n        }\n      }\n\n      return changes;\n    }\n  }, {\n    key: \"_findBetterContiguousSequence\",\n    value: function _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n      if (originalLength < desiredLength || modifiedLength < desiredLength) {\n        return null;\n      }\n\n      var originalMax = originalStart + originalLength - desiredLength + 1;\n      var modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n      var bestScore = 0;\n      var bestOriginalStart = 0;\n      var bestModifiedStart = 0;\n\n      for (var i = originalStart; i < originalMax; i++) {\n        for (var j = modifiedStart; j < modifiedMax; j++) {\n          var score = this._contiguousSequenceScore(i, j, desiredLength);\n\n          if (score > 0 && score > bestScore) {\n            bestScore = score;\n            bestOriginalStart = i;\n            bestModifiedStart = j;\n          }\n        }\n      }\n\n      if (bestScore > 0) {\n        return [bestOriginalStart, bestModifiedStart];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_contiguousSequenceScore\",\n    value: function _contiguousSequenceScore(originalStart, modifiedStart, length) {\n      var score = 0;\n\n      for (var l = 0; l < length; l++) {\n        if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n          return 0;\n        }\n\n        score += this._originalStringElements[originalStart + l].length;\n      }\n\n      return score;\n    }\n  }, {\n    key: \"_OriginalIsBoundary\",\n    value: function _OriginalIsBoundary(index) {\n      if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n        return true;\n      }\n\n      return this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]);\n    }\n  }, {\n    key: \"_OriginalRegionIsBoundary\",\n    value: function _OriginalRegionIsBoundary(originalStart, originalLength) {\n      if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n        return true;\n      }\n\n      if (originalLength > 0) {\n        var originalEnd = originalStart + originalLength;\n\n        if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_ModifiedIsBoundary\",\n    value: function _ModifiedIsBoundary(index) {\n      if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n        return true;\n      }\n\n      return this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]);\n    }\n  }, {\n    key: \"_ModifiedRegionIsBoundary\",\n    value: function _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n      if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n        return true;\n      }\n\n      if (modifiedLength > 0) {\n        var modifiedEnd = modifiedStart + modifiedLength;\n\n        if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_boundaryScore\",\n    value: function _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n      var originalScore = this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0;\n      var modifiedScore = this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0;\n      return originalScore + modifiedScore;\n    }\n    /**\r\n     * Concatenates the two input DiffChange lists and returns the resulting\r\n     * list.\r\n     * @param The left changes\r\n     * @param The right changes\r\n     * @returns The concatenated list\r\n     */\n\n  }, {\n    key: \"ConcatenateChanges\",\n    value: function ConcatenateChanges(left, right) {\n      var mergedChangeArr = [];\n\n      if (left.length === 0 || right.length === 0) {\n        return right.length > 0 ? right : left;\n      } else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n        // Since we break the problem down recursively, it is possible that we\n        // might recurse in the middle of a change thereby splitting it into\n        // two changes. Here in the combining stage, we detect and fuse those\n        // changes back together\n        var result = new Array(left.length + right.length - 1);\n        MyArray.Copy(left, 0, result, 0, left.length - 1);\n        result[left.length - 1] = mergedChangeArr[0];\n        MyArray.Copy(right, 1, result, left.length, right.length - 1);\n        return result;\n      } else {\n        var _result = new Array(left.length + right.length);\n\n        MyArray.Copy(left, 0, _result, 0, left.length);\n        MyArray.Copy(right, 0, _result, left.length, right.length);\n        return _result;\n      }\n    }\n    /**\r\n     * Returns true if the two changes overlap and can be merged into a single\r\n     * change\r\n     * @param left The left change\r\n     * @param right The right change\r\n     * @param mergedChange The merged change if the two overlap, null otherwise\r\n     * @returns True if the two changes overlap\r\n     */\n\n  }, {\n    key: \"ChangesOverlap\",\n    value: function ChangesOverlap(left, right, mergedChangeArr) {\n      Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n      Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n      if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n        var originalStart = left.originalStart;\n        var originalLength = left.originalLength;\n        var modifiedStart = left.modifiedStart;\n        var modifiedLength = left.modifiedLength;\n\n        if (left.originalStart + left.originalLength >= right.originalStart) {\n          originalLength = right.originalStart + right.originalLength - left.originalStart;\n        }\n\n        if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n          modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n        }\n\n        mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n        return true;\n      } else {\n        mergedChangeArr[0] = null;\n        return false;\n      }\n    }\n    /**\r\n     * Helper method used to clip a diagonal index to the range of valid\r\n     * diagonals. This also decides whether or not the diagonal index,\r\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n     * one inside the boundary depending on the Even/Odd status of the boundary\r\n     * and numDifferences.\r\n     * @param diagonal The index of the diagonal to clip.\r\n     * @param numDifferences The current number of differences being iterated upon.\r\n     * @param diagonalBaseIndex The base reference diagonal.\r\n     * @param numDiagonals The total number of diagonals.\r\n     * @returns The clipped diagonal index.\r\n     */\n\n  }, {\n    key: \"ClipDiagonalBound\",\n    value: function ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n      if (diagonal >= 0 && diagonal < numDiagonals) {\n        // Nothing to clip, its in range\n        return diagonal;\n      } // diagonalsBelow: The number of diagonals below the reference diagonal\n      // diagonalsAbove: The number of diagonals above the reference diagonal\n\n\n      var diagonalsBelow = diagonalBaseIndex;\n      var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n      var diffEven = numDifferences % 2 === 0;\n\n      if (diagonal < 0) {\n        var lowerBoundEven = diagonalsBelow % 2 === 0;\n        return diffEven === lowerBoundEven ? 0 : 1;\n      } else {\n        var upperBoundEven = diagonalsAbove % 2 === 0;\n        return diffEven === upperBoundEven ? numDiagonals - 1 : numDiagonals - 2;\n      }\n    }\n  }], [{\n    key: \"_isStringArray\",\n    value: function _isStringArray(arr) {\n      return arr.length > 0 && typeof arr[0] === 'string';\n    }\n  }, {\n    key: \"_getElements\",\n    value: function _getElements(sequence) {\n      var elements = sequence.getElements();\n\n      if (LcsDiff._isStringArray(elements)) {\n        var hashes = new Int32Array(elements.length);\n\n        for (var i = 0, len = elements.length; i < len; i++) {\n          hashes[i] = stringHash(elements[i], 0);\n        }\n\n        return [elements, hashes, true];\n      }\n\n      if (elements instanceof Int32Array) {\n        return [[], elements, false];\n      }\n\n      return [[], new Int32Array(elements), false];\n    }\n  }]);\n\n  return LcsDiff;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/diff/diff.js"],"names":["DiffChange","stringHash","StringDiffSequence","source","characters","Int32Array","length","i","len","charCodeAt","stringDiff","original","modified","pretty","LcsDiff","ComputeDiff","changes","Debug","condition","message","Error","MyArray","sourceArray","sourceIndex","destinationArray","destinationIndex","DiffChangeHelper","m_changes","m_originalStart","m_modifiedStart","m_originalCount","m_modifiedCount","push","originalIndex","modifiedIndex","Math","min","MarkNextChange","reverse","originalSequence","modifiedSequence","continueProcessingPredicate","ContinueProcessingPredicate","_getElements","originalStringElements","originalElementsOrHash","originalHasStrings","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","_hasStrings","_originalStringElements","_originalElementsOrHash","_modifiedStringElements","_modifiedElementsOrHash","m_forwardHistory","m_reverseHistory","newIndex","index1","index2","_ComputeDiff","originalStart","originalEnd","modifiedStart","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","PrettifyChanges","quitEarly","ElementsAreEqual","Assert","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","AddModifiedElement","AddOriginalElement","getReverseChanges","originalStartPoint","modifiedStartPoint","lastForwardChange","max","getOriginalEnd","getModifiedEnd","getChanges","maxDifferences","numDiagonals","delta","numDifferences","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","tempOriginalIndex","abs","WALKTRACE","matchLengthOfLongest","temp","Copy2","change","originalStop","modifiedStop","checkOriginal","originalLength","checkModified","modifiedLength","OriginalElementsAreEqual","ModifiedElementsAreEqual","mergedChangeArr","ChangesOverlap","splice","prevChange","bestDelta","bestScore","_boundaryScore","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","_findBetterContiguousSequence","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","_contiguousSequenceScore","l","index","test","_OriginalIsBoundary","_ModifiedIsBoundary","originalScore","_OriginalRegionIsBoundary","modifiedScore","_ModifiedRegionIsBoundary","left","right","Array","Copy","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","arr","sequence","elements","getElements","_isStringArray","hashes"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { DiffChange } from './diffChange.js';\r\nimport { stringHash } from '../hash.js';\r\nexport class StringDiffSequence {\r\n    constructor(source) {\r\n        this.source = source;\r\n    }\r\n    getElements() {\r\n        const source = this.source;\r\n        const characters = new Int32Array(source.length);\r\n        for (let i = 0, len = source.length; i < len; i++) {\r\n            characters[i] = source.charCodeAt(i);\r\n        }\r\n        return characters;\r\n    }\r\n}\r\nexport function stringDiff(original, modified, pretty) {\r\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\r\n}\r\n//\r\n// The code below has been ported from a C# implementation in VS\r\n//\r\nexport class Debug {\r\n    static Assert(condition, message) {\r\n        if (!condition) {\r\n            throw new Error(message);\r\n        }\r\n    }\r\n}\r\nexport class MyArray {\r\n    /**\r\n     * Copies a range of elements from an Array starting at the specified source index and pastes\r\n     * them to another Array starting at the specified destination index. The length and the indexes\r\n     * are specified as 64-bit integers.\r\n     * sourceArray:\r\n     *\t\tThe Array that contains the data to copy.\r\n     * sourceIndex:\r\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n     * destinationArray:\r\n     *\t\tThe Array that receives the data.\r\n     * destinationIndex:\r\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n     * length:\r\n     *\t\tA 64-bit integer that represents the number of elements to copy.\r\n     */\r\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n        }\r\n    }\r\n}\r\n/**\r\n * A utility class which helps to create the set of DiffChanges from\r\n * a difference operation. This class accepts original DiffElements and\r\n * modified DiffElements that are involved in a particular change. The\r\n * MarktNextChange() method can be called to mark the separation between\r\n * distinct changes. At the end, the Changes property can be called to retrieve\r\n * the constructed changes.\r\n */\r\nclass DiffChangeHelper {\r\n    /**\r\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n     */\r\n    constructor() {\r\n        this.m_changes = [];\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n    }\r\n    /**\r\n     * Marks the beginning of the next change in the set of differences.\r\n     */\r\n    MarkNextChange() {\r\n        // Only add to the list if there is something to add\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Add the new change to our list\r\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n        }\r\n        // Reset for the next change\r\n        this.m_originalCount = 0;\r\n        this.m_modifiedCount = 0;\r\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n    }\r\n    /**\r\n     * Adds the original element at the given position to the elements\r\n     * affected by the current change. The modified index gives context\r\n     * to the change position with respect to the original sequence.\r\n     * @param originalIndex The index of the original element to add.\r\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n     */\r\n    AddOriginalElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_originalCount++;\r\n    }\r\n    /**\r\n     * Adds the modified element at the given position to the elements\r\n     * affected by the current change. The original index gives context\r\n     * to the change position with respect to the modified sequence.\r\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n     * @param modifiedIndex The index of the modified element to add.\r\n     */\r\n    AddModifiedElement(originalIndex, modifiedIndex) {\r\n        // The 'true' start index is the smallest of the ones we've seen\r\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n        this.m_modifiedCount++;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class.\r\n     */\r\n    getChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        return this.m_changes;\r\n    }\r\n    /**\r\n     * Retrieves all of the changes marked by the class in the reverse order\r\n     */\r\n    getReverseChanges() {\r\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n            // Finish up on whatever is left\r\n            this.MarkNextChange();\r\n        }\r\n        this.m_changes.reverse();\r\n        return this.m_changes;\r\n    }\r\n}\r\n/**\r\n * An implementation of the difference algorithm described in\r\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\r\n */\r\nexport class LcsDiff {\r\n    /**\r\n     * Constructs the DiffFinder\r\n     */\r\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\r\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\r\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\r\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\r\n        this._originalStringElements = originalStringElements;\r\n        this._originalElementsOrHash = originalElementsOrHash;\r\n        this._modifiedStringElements = modifiedStringElements;\r\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n    }\r\n    static _isStringArray(arr) {\r\n        return (arr.length > 0 && typeof arr[0] === 'string');\r\n    }\r\n    static _getElements(sequence) {\r\n        const elements = sequence.getElements();\r\n        if (LcsDiff._isStringArray(elements)) {\r\n            const hashes = new Int32Array(elements.length);\r\n            for (let i = 0, len = elements.length; i < len; i++) {\r\n                hashes[i] = stringHash(elements[i], 0);\r\n            }\r\n            return [elements, hashes, true];\r\n        }\r\n        if (elements instanceof Int32Array) {\r\n            return [[], elements, false];\r\n        }\r\n        return [[], new Int32Array(elements), false];\r\n    }\r\n    ElementsAreEqual(originalIndex, newIndex) {\r\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\r\n    }\r\n    OriginalElementsAreEqual(index1, index2) {\r\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\r\n    }\r\n    ModifiedElementsAreEqual(index1, index2) {\r\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\r\n            return false;\r\n        }\r\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\r\n    }\r\n    ComputeDiff(pretty) {\r\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\r\n    }\r\n    /**\r\n     * Computes the differences between the original and modified input\r\n     * sequences on the bounded range.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\r\n        const quitEarlyArr = [false];\r\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        if (pretty) {\r\n            // We have to clean up the computed diff to be more intuitive\r\n            // but it turns out this cannot be done correctly until the entire set\r\n            // of diffs have been computed\r\n            changes = this.PrettifyChanges(changes);\r\n        }\r\n        return {\r\n            quitEarly: quitEarlyArr[0],\r\n            changes: changes\r\n        };\r\n    }\r\n    /**\r\n     * Private helper method which computes the differences on the bounded range\r\n     * recursively.\r\n     * @returns An array of the differences between the two input sequences.\r\n     */\r\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n        quitEarlyArr[0] = false;\r\n        // Find the start of the differences\r\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n            originalStart++;\r\n            modifiedStart++;\r\n        }\r\n        // Find the end of the differences\r\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n            originalEnd--;\r\n            modifiedEnd--;\r\n        }\r\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n            let changes;\r\n            if (modifiedStart <= modifiedEnd) {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                // All insertions\r\n                changes = [\r\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                ];\r\n            }\r\n            else if (originalStart <= originalEnd) {\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // All deletions\r\n                changes = [\r\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                ];\r\n            }\r\n            else {\r\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                // Identical sequences - No differences\r\n                changes = [];\r\n            }\r\n            return changes;\r\n        }\r\n        // This problem can be solved using the Divide-And-Conquer technique.\r\n        const midOriginalArr = [0];\r\n        const midModifiedArr = [0];\r\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n        const midOriginal = midOriginalArr[0];\r\n        const midModified = midModifiedArr[0];\r\n        if (result !== null) {\r\n            // Result is not-null when there was enough memory to compute the changes while\r\n            // searching for the recursion point\r\n            return result;\r\n        }\r\n        else if (!quitEarlyArr[0]) {\r\n            // We can break the problem down recursively by finding the changes in the\r\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n            let rightChanges = [];\r\n            if (!quitEarlyArr[0]) {\r\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n            }\r\n            else {\r\n                // We did't have time to finish the first half, so we don't have time to compute this half.\r\n                // Consider the entire rest of the sequence different.\r\n                rightChanges = [\r\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                ];\r\n            }\r\n            return this.ConcatenateChanges(leftChanges, rightChanges);\r\n        }\r\n        // If we hit here, we quit early, and so can't return anything meaningful\r\n        return [\r\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n        ];\r\n    }\r\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n        let forwardChanges = null;\r\n        let reverseChanges = null;\r\n        // First, walk backward through the forward diagonals history\r\n        let changeHelper = new DiffChangeHelper();\r\n        let diagonalMin = diagonalForwardStart;\r\n        let diagonalMax = diagonalForwardEnd;\r\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\r\n        let historyIndex = this.m_forwardHistory.length - 1;\r\n        do {\r\n            // Get the diagonal index from the relative diagonal number\r\n            const diagonal = diagonalRelative + diagonalForwardBase;\r\n            // Figure out where we came from\r\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                // Vertical line (the element is an insert)\r\n                originalIndex = forwardPoints[diagonal + 1];\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex;\r\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            else {\r\n                // Horizontal line (the element is a deletion)\r\n                originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                if (originalIndex < lastOriginalIndex) {\r\n                    changeHelper.MarkNextChange();\r\n                }\r\n                lastOriginalIndex = originalIndex - 1;\r\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n            }\r\n            if (historyIndex >= 0) {\r\n                forwardPoints = this.m_forwardHistory[historyIndex];\r\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                diagonalMin = 1;\r\n                diagonalMax = forwardPoints.length - 1;\r\n            }\r\n        } while (--historyIndex >= -1);\r\n        // Ironically, we get the forward changes as the reverse of the\r\n        // order we added them since we technically added them backwards\r\n        forwardChanges = changeHelper.getReverseChanges();\r\n        if (quitEarlyArr[0]) {\r\n            // TODO: Calculate a partial from the reverse diagonals.\r\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n            let originalStartPoint = midOriginalArr[0] + 1;\r\n            let modifiedStartPoint = midModifiedArr[0] + 1;\r\n            if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n            }\r\n            reverseChanges = [\r\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n            ];\r\n        }\r\n        else {\r\n            // Now walk backward through the reverse diagonals history\r\n            changeHelper = new DiffChangeHelper();\r\n            diagonalMin = diagonalReverseStart;\r\n            diagonalMax = diagonalReverseEnd;\r\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                const diagonal = diagonalRelative + diagonalReverseBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    // Horizontal line (the element is a deletion))\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex + 1;\r\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Vertical line (the element is an insertion)\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                    if (originalIndex > lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    reversePoints = this.m_reverseHistory[historyIndex];\r\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = reversePoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // There are cases where the reverse history will find diffs that\r\n            // are correct, but not intuitive, so we need shift them.\r\n            reverseChanges = changeHelper.getChanges();\r\n        }\r\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n    }\r\n    /**\r\n     * Given the range to compute the diff on, this method finds the point:\r\n     * (midOriginal, midModified)\r\n     * that exists in the middle of the LCS of the two sequences and\r\n     * is the point at which the LCS problem may be broken down recursively.\r\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n     * point is calculated and the full trace is available in memory, then this method\r\n     * will return the change list.\r\n     * @param originalStart The start bound of the original sequence range\r\n     * @param originalEnd The end bound of the original sequence range\r\n     * @param modifiedStart The start bound of the modified sequence range\r\n     * @param modifiedEnd The end bound of the modified sequence range\r\n     * @param midOriginal The middle point of the original sequence range\r\n     * @param midModified The middle point of the modified sequence range\r\n     * @returns The diff changes, if available, otherwise null\r\n     */\r\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n        let originalIndex = 0, modifiedIndex = 0;\r\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n        // To traverse the edit graph and produce the proper LCS, our actual\r\n        // start position is just outside the given boundary\r\n        originalStart--;\r\n        modifiedStart--;\r\n        // We set these up to make the compiler happy, but they will\r\n        // be replaced before we return with the actual recursion point\r\n        midOriginalArr[0] = 0;\r\n        midModifiedArr[0] = 0;\r\n        // Clear out the history\r\n        this.m_forwardHistory = [];\r\n        this.m_reverseHistory = [];\r\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n        // The integer value in the cell represents the originalIndex of the furthest\r\n        // reaching point found so far that ends in that diagonal.\r\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n        const numDiagonals = maxDifferences + 1;\r\n        const forwardPoints = new Int32Array(numDiagonals);\r\n        const reversePoints = new Int32Array(numDiagonals);\r\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n        const diagonalReverseBase = (originalEnd - originalStart);\r\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalForwardBase)\r\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n        //    diagonal number (relative to diagonalReverseBase)\r\n        const diagonalForwardOffset = (originalStart - modifiedStart);\r\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n        const delta = diagonalReverseBase - diagonalForwardBase;\r\n        const deltaIsEven = (delta % 2 === 0);\r\n        // Here we set up the start and end points as the furthest points found so far\r\n        // in both the forward and reverse directions, respectively\r\n        forwardPoints[diagonalForwardBase] = originalStart;\r\n        reversePoints[diagonalReverseBase] = originalEnd;\r\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n        quitEarlyArr[0] = false;\r\n        // A couple of points:\r\n        // --With this method, we iterate on the number of differences between the two sequences.\r\n        //   The more differences there actually are, the longer this will take.\r\n        // --Also, as the number of differences increases, we have to search on diagonals further\r\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n        //   is even and odd diagonals only when numDifferences is odd.\r\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n            let furthestOriginalIndex = 0;\r\n            let furthestModifiedIndex = 0;\r\n            // Run the algorithm in the forward direction\r\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalStart, modifiedStart)\r\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                }\r\n                else {\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                // Save the current originalIndex so we can test for false overlap in step 3\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // so long as the elements are equal.\r\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                    originalIndex++;\r\n                    modifiedIndex++;\r\n                }\r\n                forwardPoints[diagonal] = originalIndex;\r\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                    furthestOriginalIndex = originalIndex;\r\n                    furthestModifiedIndex = modifiedIndex;\r\n                }\r\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                // then check for overlap.\r\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                    if (originalIndex >= reversePoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Check to see if we should be quitting early, before moving on to the next iteration.\r\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\r\n                // We can't finish, so skip ahead to generating a result from what we have.\r\n                quitEarlyArr[0] = true;\r\n                // Use the furthest distance we got in the forward direction.\r\n                midOriginalArr[0] = furthestOriginalIndex;\r\n                midModifiedArr[0] = furthestModifiedIndex;\r\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                    // Enough of the history is in memory to walk it backwards\r\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We didn't actually remember enough of the history.\r\n                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start\r\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                    originalStart++;\r\n                    modifiedStart++;\r\n                    return [\r\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n            }\r\n            // Run the algorithm in the reverse direction\r\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                // by looking at the diagonals above and below and picking the one whose point\r\n                // is further away from the start point (originalEnd, modifiedEnd)\r\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                    originalIndex = reversePoints[diagonal + 1] - 1;\r\n                }\r\n                else {\r\n                    originalIndex = reversePoints[diagonal - 1];\r\n                }\r\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                // Save the current originalIndex so we can test for false overlap\r\n                const tempOriginalIndex = originalIndex;\r\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                // as long as the elements are equal.\r\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                    originalIndex--;\r\n                    modifiedIndex--;\r\n                }\r\n                reversePoints[diagonal] = originalIndex;\r\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                // then check for overlap.\r\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                    if (originalIndex <= forwardPoints[diagonal]) {\r\n                        midOriginalArr[0] = originalIndex;\r\n                        midModifiedArr[0] = modifiedIndex;\r\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\r\n                            // BINGO! We overlapped, and we have the full trace in memory!\r\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                        }\r\n                        else {\r\n                            // Either false overlap, or we didn't have enough memory for the full trace\r\n                            // Just return the recursion point\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Save current vectors to history before the next iteration\r\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\r\n                // We are allocating space for one extra int, which we fill with\r\n                // the index of the diagonal base index\r\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                this.m_forwardHistory.push(temp);\r\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                this.m_reverseHistory.push(temp);\r\n            }\r\n        }\r\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n        // NOTE: This part is a bit messy\r\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n    }\r\n    /**\r\n     * Shifts the given changes to provide a more intuitive diff.\r\n     * While the first element in a diff matches the first element after the diff,\r\n     * we shift the diff down.\r\n     *\r\n     * @param changes The list of changes to shift\r\n     * @returns The shifted changes\r\n     */\r\n    PrettifyChanges(changes) {\r\n        // Shift all the changes down first\r\n        for (let i = 0; i < changes.length; i++) {\r\n            const change = changes[i];\r\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\r\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            while (change.originalStart + change.originalLength < originalStop &&\r\n                change.modifiedStart + change.modifiedLength < modifiedStop &&\r\n                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&\r\n                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\r\n                change.originalStart++;\r\n                change.modifiedStart++;\r\n            }\r\n            let mergedChangeArr = [null];\r\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\r\n                changes[i] = mergedChangeArr[0];\r\n                changes.splice(i + 1, 1);\r\n                i--;\r\n                continue;\r\n            }\r\n        }\r\n        // Shift changes back up until we hit empty or whitespace-only lines\r\n        for (let i = changes.length - 1; i >= 0; i--) {\r\n            const change = changes[i];\r\n            let originalStop = 0;\r\n            let modifiedStop = 0;\r\n            if (i > 0) {\r\n                const prevChange = changes[i - 1];\r\n                if (prevChange.originalLength > 0) {\r\n                    originalStop = prevChange.originalStart + prevChange.originalLength;\r\n                }\r\n                if (prevChange.modifiedLength > 0) {\r\n                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\r\n                }\r\n            }\r\n            const checkOriginal = change.originalLength > 0;\r\n            const checkModified = change.modifiedLength > 0;\r\n            let bestDelta = 0;\r\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\r\n            for (let delta = 1;; delta++) {\r\n                const originalStart = change.originalStart - delta;\r\n                const modifiedStart = change.modifiedStart - delta;\r\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\r\n                    break;\r\n                }\r\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\r\n                    break;\r\n                }\r\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\r\n                    break;\r\n                }\r\n                const score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);\r\n                if (score > bestScore) {\r\n                    bestScore = score;\r\n                    bestDelta = delta;\r\n                }\r\n            }\r\n            change.originalStart -= bestDelta;\r\n            change.modifiedStart -= bestDelta;\r\n        }\r\n        // There could be multiple longest common substrings.\r\n        // Give preference to the ones containing longer lines\r\n        if (this._hasStrings) {\r\n            for (let i = 1, len = changes.length; i < len; i++) {\r\n                const aChange = changes[i - 1];\r\n                const bChange = changes[i];\r\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\r\n                const aOriginalStart = aChange.originalStart;\r\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\r\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\r\n                const aModifiedStart = aChange.modifiedStart;\r\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\r\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\r\n                // Avoid wasting a lot of time with these searches\r\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\r\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\r\n                    if (t) {\r\n                        const [originalMatchStart, modifiedMatchStart] = t;\r\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\r\n                            // switch to another sequence that has a better score\r\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\r\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\r\n                            bChange.originalStart = originalMatchStart + matchedLength;\r\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\r\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\r\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return changes;\r\n    }\r\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\r\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\r\n            return null;\r\n        }\r\n        const originalMax = originalStart + originalLength - desiredLength + 1;\r\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\r\n        let bestScore = 0;\r\n        let bestOriginalStart = 0;\r\n        let bestModifiedStart = 0;\r\n        for (let i = originalStart; i < originalMax; i++) {\r\n            for (let j = modifiedStart; j < modifiedMax; j++) {\r\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\r\n                if (score > 0 && score > bestScore) {\r\n                    bestScore = score;\r\n                    bestOriginalStart = i;\r\n                    bestModifiedStart = j;\r\n                }\r\n            }\r\n        }\r\n        if (bestScore > 0) {\r\n            return [bestOriginalStart, bestModifiedStart];\r\n        }\r\n        return null;\r\n    }\r\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\r\n        let score = 0;\r\n        for (let l = 0; l < length; l++) {\r\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\r\n                return 0;\r\n            }\r\n            score += this._originalStringElements[originalStart + l].length;\r\n        }\r\n        return score;\r\n    }\r\n    _OriginalIsBoundary(index) {\r\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\r\n    }\r\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\r\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\r\n            return true;\r\n        }\r\n        if (originalLength > 0) {\r\n            const originalEnd = originalStart + originalLength;\r\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _ModifiedIsBoundary(index) {\r\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\r\n            return true;\r\n        }\r\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\r\n    }\r\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\r\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\r\n            return true;\r\n        }\r\n        if (modifiedLength > 0) {\r\n            const modifiedEnd = modifiedStart + modifiedLength;\r\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\r\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\r\n        return (originalScore + modifiedScore);\r\n    }\r\n    /**\r\n     * Concatenates the two input DiffChange lists and returns the resulting\r\n     * list.\r\n     * @param The left changes\r\n     * @param The right changes\r\n     * @returns The concatenated list\r\n     */\r\n    ConcatenateChanges(left, right) {\r\n        let mergedChangeArr = [];\r\n        if (left.length === 0 || right.length === 0) {\r\n            return (right.length > 0) ? right : left;\r\n        }\r\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n            // Since we break the problem down recursively, it is possible that we\r\n            // might recurse in the middle of a change thereby splitting it into\r\n            // two changes. Here in the combining stage, we detect and fuse those\r\n            // changes back together\r\n            const result = new Array(left.length + right.length - 1);\r\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n            result[left.length - 1] = mergedChangeArr[0];\r\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new Array(left.length + right.length);\r\n            MyArray.Copy(left, 0, result, 0, left.length);\r\n            MyArray.Copy(right, 0, result, left.length, right.length);\r\n            return result;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the two changes overlap and can be merged into a single\r\n     * change\r\n     * @param left The left change\r\n     * @param right The right change\r\n     * @param mergedChange The merged change if the two overlap, null otherwise\r\n     * @returns True if the two changes overlap\r\n     */\r\n    ChangesOverlap(left, right, mergedChangeArr) {\r\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n            const originalStart = left.originalStart;\r\n            let originalLength = left.originalLength;\r\n            const modifiedStart = left.modifiedStart;\r\n            let modifiedLength = left.modifiedLength;\r\n            if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n            }\r\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n            }\r\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n            return true;\r\n        }\r\n        else {\r\n            mergedChangeArr[0] = null;\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Helper method used to clip a diagonal index to the range of valid\r\n     * diagonals. This also decides whether or not the diagonal index,\r\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n     * one inside the boundary depending on the Even/Odd status of the boundary\r\n     * and numDifferences.\r\n     * @param diagonal The index of the diagonal to clip.\r\n     * @param numDifferences The current number of differences being iterated upon.\r\n     * @param diagonalBaseIndex The base reference diagonal.\r\n     * @param numDiagonals The total number of diagonals.\r\n     * @returns The clipped diagonal index.\r\n     */\r\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n        if (diagonal >= 0 && diagonal < numDiagonals) {\r\n            // Nothing to clip, its in range\r\n            return diagonal;\r\n        }\r\n        // diagonalsBelow: The number of diagonals below the reference diagonal\r\n        // diagonalsAbove: The number of diagonals above the reference diagonal\r\n        const diagonalsBelow = diagonalBaseIndex;\r\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n        const diffEven = (numDifferences % 2 === 0);\r\n        if (diagonal < 0) {\r\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n            return (diffEven === lowerBoundEven) ? 0 : 1;\r\n        }\r\n        else {\r\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\r\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}