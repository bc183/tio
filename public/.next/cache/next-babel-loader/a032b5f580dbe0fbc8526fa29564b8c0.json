{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _wrapNativeSuper from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\n\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\nimport * as process from './process.js';\nvar CHAR_UPPERCASE_A = 65;\n/* A */\n\nvar CHAR_LOWERCASE_A = 97;\n/* a */\n\nvar CHAR_UPPERCASE_Z = 90;\n/* Z */\n\nvar CHAR_LOWERCASE_Z = 122;\n/* z */\n\nvar CHAR_DOT = 46;\n/* . */\n\nvar CHAR_FORWARD_SLASH = 47;\n/* / */\n\nvar CHAR_BACKWARD_SLASH = 92;\n/* \\ */\n\nvar CHAR_COLON = 58;\n/* : */\n\nvar CHAR_QUESTION_MARK = 63;\n/* ? */\n\nvar ErrorInvalidArgType = /*#__PURE__*/function (_Error) {\n  _inherits(ErrorInvalidArgType, _Error);\n\n  var _super = _createSuper(ErrorInvalidArgType);\n\n  function ErrorInvalidArgType(name, expected, actual) {\n    var _this;\n\n    _classCallCheck(this, ErrorInvalidArgType);\n\n    // determiner: 'must be' or 'must not be'\n    var determiner;\n\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    var type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    var msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" of type \").concat(expected);\n    msg += \". Received type \".concat(typeof actual);\n    _this = _super.call(this, msg);\n    _this.code = 'ERR_INVALID_ARG_TYPE';\n    return _this;\n  }\n\n  return ErrorInvalidArgType;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n} // Resolves . and .. elements in a path with directory names\n\n\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code = 0;\n\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {// NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf(separator);\n\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n\n        if (allowAboveRoot) {\n          res += res.length > 0 ? \"\".concat(separator, \"..\") : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += \"\".concat(separator).concat(path.slice(lastSlash + 1, i));\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n\n        lastSegmentLength = i - lastSlash - 1;\n      }\n\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\n  }\n\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || \"\".concat(pathObject.name || '').concat(pathObject.ext || '');\n\n  if (!dir) {\n    return base;\n  }\n\n  return dir === pathObject.root ? \"\".concat(dir).concat(base) : \"\".concat(dir).concat(sep).concat(base);\n}\n\nexport var win32 = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path = void 0;\n\n      if (i >= 0) {\n        path = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        validateString(path, 'path'); // Skip empty entries\n\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env[\"=\".concat(resolvedDevice)] || process.cwd(); // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n\n        if (path === undefined || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          path = \"\".concat(resolvedDevice, \"\\\\\");\n        }\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var device = '';\n      var isAbsolute = false;\n      var code = path.charCodeAt(0); // Try to match a root\n\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n        // If we started with a separator, we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(path.charCodeAt(1))) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j; // Match 1 or more non-path separators\n\n          while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n\n          if (j < len && j !== last) {\n            var firstPart = path.slice(last, j); // Matched!\n\n            last = j; // Match 1 or more path separators\n\n            while (j < len && isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n\n            if (j < len && j !== last) {\n              // Matched!\n              last = j; // Match 1 or more non-path separators\n\n              while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device = \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last, j));\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n        // Possible device root\n        device = path.slice(0, 2);\n        rootEnd = 2;\n\n        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            // This path points to another device so it is not applicable\n            continue;\n          }\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0) {\n          break;\n        }\n      } else {\n        resolvedTail = \"\".concat(path.slice(rootEnd), \"\\\\\").concat(resolvedTail);\n        resolvedAbsolute = isAbsolute;\n\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    } // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n    // Normalize the tail path\n\n\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedAbsolute ? \"\".concat(resolvedDevice, \"\\\\\").concat(resolvedTail) : \"\".concat(resolvedDevice).concat(resolvedTail) || '.';\n  },\n  normalize: function normalize(path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = 0;\n    var device;\n    var isAbsolute = false;\n    var code = path.charCodeAt(0); // Try to match a root\n\n    if (len === 1) {\n      // `path` contains just a single char, exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      // If we started with a separator, we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        var j = 2;\n        var last = j; // Match 1 or more non-path separators\n\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n\n        if (j < len && j !== last) {\n          var firstPart = path.slice(last, j); // Matched!\n\n          last = j; // Match 1 or more path separators\n\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more non-path separators\n\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last), \"\\\\\");\n            }\n\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device = \"\\\\\\\\\".concat(firstPart, \"\\\\\").concat(path.slice(last, j));\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      device = path.slice(0, 2);\n      rootEnd = 2;\n\n      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    var tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) : '';\n\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n\n    if (device === undefined) {\n      return isAbsolute ? \"\\\\\".concat(tail) : tail;\n    }\n\n    return isAbsolute ? \"\".concat(device, \"\\\\\").concat(tail) : \"\".concat(device).concat(tail);\n  },\n  isAbsolute: function isAbsolute(path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return false;\n    }\n\n    var code = path.charCodeAt(0);\n    return isPathSeparator(code) || // Possible device root\n    len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));\n  },\n  join: function join() {\n    if (arguments.length === 0) {\n      return '.';\n    }\n\n    var joined;\n    var firstPart;\n\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += \"\\\\\".concat(arg);\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    } // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n\n\n    var needsReplace = true;\n    var slashCount = 0;\n\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      var firstLen = firstPart.length;\n\n      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) {\n            ++slashCount;\n          } else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      } // Replace the slashes if needed\n\n\n      if (slashCount >= 2) {\n        joined = \"\\\\\".concat(joined.slice(slashCount));\n      }\n    }\n\n    return win32.normalize(joined);\n  },\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    }\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig) {\n      return '';\n    }\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to) {\n      return '';\n    } // Trim any leading backslashes\n\n\n    var fromStart = 0;\n\n    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var fromEnd = from.length;\n\n    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n\n    var fromLen = fromEnd - fromStart; // Trim any leading backslashes\n\n    var toStart = 0;\n\n    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    } // Trim trailing backslashes (applicable to UNC paths only)\n\n\n    var toEnd = to.length;\n\n    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n\n    var toLen = toEnd - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i < length; i++) {\n      var fromCode = from.charCodeAt(fromStart + i);\n\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    } // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n\n\n    if (i !== length) {\n      if (lastCommonSep === -1) {\n        return toOrig;\n      }\n    } else {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return toOrig.slice(toStart + i + 1);\n        }\n\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return toOrig.slice(toStart + i);\n        }\n      }\n\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n\n      if (lastCommonSep === -1) {\n        lastCommonSep = 0;\n      }\n    }\n\n    var out = ''; // Generate the relative path based on the path difference between `to` and\n    // `from`\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep; // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n\n    if (out.length > 0) {\n      return \"\".concat(out).concat(toOrig.slice(toStart, toEnd));\n    }\n\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      ++toStart;\n    }\n\n    return toOrig.slice(toStart, toEnd);\n  },\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string') {\n      return path;\n    }\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    var resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2) {\n      return path;\n    }\n\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        var code = resolvedPath.charCodeAt(2);\n\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root, convert the path to a long UNC path\n          return \"\\\\\\\\?\\\\UNC\\\\\".concat(resolvedPath.slice(2));\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      // Matched device root, convert the path to a long UNC path\n      return \"\\\\\\\\?\\\\\".concat(resolvedPath);\n    }\n\n    return path;\n  },\n  dirname: function dirname(path) {\n    validateString(path, 'path');\n    var len = path.length;\n\n    if (len === 0) {\n      return '.';\n    }\n\n    var rootEnd = -1;\n    var offset = 0;\n    var code = path.charCodeAt(0);\n\n    if (len === 1) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    } // Try to match a root\n\n\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        var j = 2;\n        var last = j; // Match 1 or more non-path separators\n\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n\n        if (j < len && j !== last) {\n          // Matched!\n          last = j; // Match 1 or more path separators\n\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more non-path separators\n\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      } // Possible device root\n\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    var end = -1;\n    var matchedSlash = true;\n\n    for (var i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      }\n\n      end = rootEnd;\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= start; --i) {\n        var code = path.charCodeAt(i);\n\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    }\n\n    for (i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n\n    return path.slice(start, end);\n  },\n  extname: function extname(path) {\n    validateString(path, 'path');\n    var start = 0;\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n\n    for (var i = path.length - 1; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '\\\\'),\n  parse: function parse(path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n\n      ret.base = ret.name = path;\n      return ret;\n    } // Try to match a root\n\n\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n      rootEnd = 1;\n\n      if (isPathSeparator(path.charCodeAt(1))) {\n        // Matched double path separator at beginning\n        var j = 2;\n        var last = j; // Match 1 or more non-path separators\n\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n\n        if (j < len && j !== last) {\n          // Matched!\n          last = j; // Match 1 or more path separators\n\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n\n          if (j < len && j !== last) {\n            // Matched!\n            last = j; // Match 1 or more non-path separators\n\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root, exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n\n      rootEnd = 2;\n\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          // `path` contains just a drive root, exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n\n        rootEnd = 3;\n      }\n    }\n\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n\n    var startDot = -1;\n    var startPart = rootEnd;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    } // If the directory is the root, use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n\n\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nexport var posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = i >= 0 ? i < 0 || arguments.length <= i ? undefined : arguments[i] : process.cwd();\n      validateString(path, 'path'); // Skip empty entries\n\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = \"\".concat(path, \"/\").concat(resolvedPath);\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    } // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n    // Normalize the path\n\n\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return \"/\".concat(resolvedPath);\n    }\n\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n  normalize: function normalize(path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH; // Normalize the path\n\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n\n      return trailingSeparator ? './' : '.';\n    }\n\n    if (trailingSeparator) {\n      path += '/';\n    }\n\n    return isAbsolute ? \"/\".concat(path) : path;\n  },\n  isAbsolute: function isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join: function join() {\n    if (arguments.length === 0) {\n      return '.';\n    }\n\n    var joined;\n\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      validateString(arg, 'path');\n\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += \"/\".concat(arg);\n        }\n      }\n    }\n\n    if (joined === undefined) {\n      return '.';\n    }\n\n    return posix.normalize(joined);\n  },\n  relative: function relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n\n    if (from === to) {\n      return '';\n    } // Trim leading forward slashes.\n\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) {\n      return '';\n    }\n\n    var fromStart = 1;\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n    var toStart = 1;\n    var toLen = to.length - toStart; // Compare paths to find the longest common path from root\n\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n\n    for (; i < length; i++) {\n      var fromCode = from.charCodeAt(fromStart + i);\n\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return to.slice(toStart + i + 1);\n        }\n\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    var out = ''; // Generate the relative path based on the path difference between `to`\n    // and `from`.\n\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    } // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n\n\n    return \"\".concat(out).concat(to.slice(toStart + lastCommonSep));\n  },\n  toNamespacedPath: function toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  },\n  dirname: function dirname(path) {\n    validateString(path, 'path');\n\n    if (path.length === 0) {\n      return '.';\n    }\n\n    var hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var end = -1;\n    var matchedSlash = true;\n\n    for (var i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n\n    return path.slice(0, end);\n  },\n  basename: function basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n\n    validateString(path, 'path');\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n\n      return path.slice(start, end);\n    }\n\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1) {\n      return '';\n    }\n\n    return path.slice(start, end);\n  },\n  extname: function extname(path) {\n    validateString(path, 'path');\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0;\n\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '/'),\n  parse: function parse(path) {\n    validateString(path, 'path');\n    var ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n\n    if (path.length === 0) {\n      return ret;\n    }\n\n    var isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    var start;\n\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1; // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n\n    var preDotState = 0; // Get non-dir info\n\n    for (; i >= start; --i) {\n      var code = path.charCodeAt(i);\n\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n\n      if (code === CHAR_DOT) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      var _start = startPart === 0 && isAbsolute ? 1 : startPart;\n\n      if (startDot === -1 || // We saw a non-dot character immediately before the dot\n      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(_start, end);\n      } else {\n        ret.name = path.slice(_start, startDot);\n        ret.base = path.slice(_start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nexport var normalize = process.platform === 'win32' ? win32.normalize : posix.normalize;\nexport var resolve = process.platform === 'win32' ? win32.resolve : posix.resolve;\nexport var relative = process.platform === 'win32' ? win32.relative : posix.relative;\nexport var dirname = process.platform === 'win32' ? win32.dirname : posix.dirname;\nexport var basename = process.platform === 'win32' ? win32.basename : posix.basename;\nexport var extname = process.platform === 'win32' ? win32.extname : posix.extname;\nexport var sep = process.platform === 'win32' ? win32.sep : posix.sep;","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/path.js"],"names":["process","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","name","expected","actual","determiner","indexOf","replace","type","msg","code","Error","validateString","value","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","pathObject","dir","root","base","ext","win32","resolve","resolvedDevice","resolvedTail","resolvedAbsolute","cwd","env","undefined","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","toNamespacedPath","resolvedPath","dirname","offset","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","bind","parse","ret","delimiter","posix","trailingSeparator","hasRoot","platform"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\r\n// Copied from: https://github.com/nodejs/node/blob/v12.8.1/lib/path.js\r\n/**\r\n * Copyright Joyent, Inc. and other Node contributors.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to permit\r\n * persons to whom the Software is furnished to do so, subject to the\r\n * following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included\r\n * in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\nimport * as process from './process.js';\r\nconst CHAR_UPPERCASE_A = 65; /* A */\r\nconst CHAR_LOWERCASE_A = 97; /* a */\r\nconst CHAR_UPPERCASE_Z = 90; /* Z */\r\nconst CHAR_LOWERCASE_Z = 122; /* z */\r\nconst CHAR_DOT = 46; /* . */\r\nconst CHAR_FORWARD_SLASH = 47; /* / */\r\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\r\nconst CHAR_COLON = 58; /* : */\r\nconst CHAR_QUESTION_MARK = 63; /* ? */\r\nclass ErrorInvalidArgType extends Error {\r\n    constructor(name, expected, actual) {\r\n        // determiner: 'must be' or 'must not be'\r\n        let determiner;\r\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\r\n            determiner = 'must not be';\r\n            expected = expected.replace(/^not /, '');\r\n        }\r\n        else {\r\n            determiner = 'must be';\r\n        }\r\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\r\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\r\n        msg += `. Received type ${typeof actual}`;\r\n        super(msg);\r\n        this.code = 'ERR_INVALID_ARG_TYPE';\r\n    }\r\n}\r\nfunction validateString(value, name) {\r\n    if (typeof value !== 'string') {\r\n        throw new ErrorInvalidArgType(name, 'string', value);\r\n    }\r\n}\r\nfunction isPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n}\r\nfunction isPosixPathSeparator(code) {\r\n    return code === CHAR_FORWARD_SLASH;\r\n}\r\nfunction isWindowsDeviceRoot(code) {\r\n    return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z ||\r\n        code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\r\n}\r\n// Resolves . and .. elements in a path with directory names\r\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\r\n    let res = '';\r\n    let lastSegmentLength = 0;\r\n    let lastSlash = -1;\r\n    let dots = 0;\r\n    let code = 0;\r\n    for (let i = 0; i <= path.length; ++i) {\r\n        if (i < path.length) {\r\n            code = path.charCodeAt(i);\r\n        }\r\n        else if (isPathSeparator(code)) {\r\n            break;\r\n        }\r\n        else {\r\n            code = CHAR_FORWARD_SLASH;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            if (lastSlash === i - 1 || dots === 1) {\r\n                // NOOP\r\n            }\r\n            else if (dots === 2) {\r\n                if (res.length < 2 || lastSegmentLength !== 2 ||\r\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\r\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\r\n                    if (res.length > 2) {\r\n                        const lastSlashIndex = res.lastIndexOf(separator);\r\n                        if (lastSlashIndex === -1) {\r\n                            res = '';\r\n                            lastSegmentLength = 0;\r\n                        }\r\n                        else {\r\n                            res = res.slice(0, lastSlashIndex);\r\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\r\n                        }\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                    else if (res.length !== 0) {\r\n                        res = '';\r\n                        lastSegmentLength = 0;\r\n                        lastSlash = i;\r\n                        dots = 0;\r\n                        continue;\r\n                    }\r\n                }\r\n                if (allowAboveRoot) {\r\n                    res += res.length > 0 ? `${separator}..` : '..';\r\n                    lastSegmentLength = 2;\r\n                }\r\n            }\r\n            else {\r\n                if (res.length > 0) {\r\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\r\n                }\r\n                else {\r\n                    res = path.slice(lastSlash + 1, i);\r\n                }\r\n                lastSegmentLength = i - lastSlash - 1;\r\n            }\r\n            lastSlash = i;\r\n            dots = 0;\r\n        }\r\n        else if (code === CHAR_DOT && dots !== -1) {\r\n            ++dots;\r\n        }\r\n        else {\r\n            dots = -1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction _format(sep, pathObject) {\r\n    if (pathObject === null || typeof pathObject !== 'object') {\r\n        throw new ErrorInvalidArgType('pathObject', 'Object', pathObject);\r\n    }\r\n    const dir = pathObject.dir || pathObject.root;\r\n    const base = pathObject.base ||\r\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\r\n    if (!dir) {\r\n        return base;\r\n    }\r\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\r\n}\r\nexport const win32 = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedDevice = '';\r\n        let resolvedTail = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\r\n            let path;\r\n            if (i >= 0) {\r\n                path = pathSegments[i];\r\n                validateString(path, 'path');\r\n                // Skip empty entries\r\n                if (path.length === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n            else if (resolvedDevice.length === 0) {\r\n                path = process.cwd();\r\n            }\r\n            else {\r\n                // Windows has the concept of drive-specific current working\r\n                // directories. If we've resolved a drive letter but not yet an\r\n                // absolute path, get cwd for that drive, or the process cwd if\r\n                // the drive cwd is not available. We're sure the device is not\r\n                // a UNC path at this points, because UNC paths are always absolute.\r\n                path = process.env[`=${resolvedDevice}`] || process.cwd();\r\n                // Verify that a cwd was found and that it actually points\r\n                // to our drive. If not, default to the drive's root.\r\n                if (path === undefined ||\r\n                    path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\r\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n                    path = `${resolvedDevice}\\\\`;\r\n                }\r\n            }\r\n            const len = path.length;\r\n            let rootEnd = 0;\r\n            let device = '';\r\n            let isAbsolute = false;\r\n            const code = path.charCodeAt(0);\r\n            // Try to match a root\r\n            if (len === 1) {\r\n                if (isPathSeparator(code)) {\r\n                    // `path` contains just a path separator\r\n                    rootEnd = 1;\r\n                    isAbsolute = true;\r\n                }\r\n            }\r\n            else if (isPathSeparator(code)) {\r\n                // Possible UNC root\r\n                // If we started with a separator, we know we at least have an\r\n                // absolute path of some kind (UNC or otherwise)\r\n                isAbsolute = true;\r\n                if (isPathSeparator(path.charCodeAt(1))) {\r\n                    // Matched double path separator at beginning\r\n                    let j = 2;\r\n                    let last = j;\r\n                    // Match 1 or more non-path separators\r\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        const firstPart = path.slice(last, j);\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more path separators\r\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j < len && j !== last) {\r\n                            // Matched!\r\n                            last = j;\r\n                            // Match 1 or more non-path separators\r\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                                j++;\r\n                            }\r\n                            if (j === len || j !== last) {\r\n                                // We matched a UNC root\r\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                                rootEnd = j;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rootEnd = 1;\r\n                }\r\n            }\r\n            else if (isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON) {\r\n                // Possible device root\r\n                device = path.slice(0, 2);\r\n                rootEnd = 2;\r\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                    // Treat separator following drive name as an absolute path\r\n                    // indicator\r\n                    isAbsolute = true;\r\n                    rootEnd = 3;\r\n                }\r\n            }\r\n            if (device.length > 0) {\r\n                if (resolvedDevice.length > 0) {\r\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n                        // This path points to another device so it is not applicable\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    resolvedDevice = device;\r\n                }\r\n            }\r\n            if (resolvedAbsolute) {\r\n                if (resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\r\n                resolvedAbsolute = isAbsolute;\r\n                if (isAbsolute && resolvedDevice.length > 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // At this point the path should be resolved to a full absolute path,\r\n        // but handle relative paths to be safe (might happen when process.cwd()\r\n        // fails)\r\n        // Normalize the tail path\r\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\r\n        return resolvedAbsolute ?\r\n            `${resolvedDevice}\\\\${resolvedTail}` :\r\n            `${resolvedDevice}${resolvedTail}` || '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = 0;\r\n        let device;\r\n        let isAbsolute = false;\r\n        const code = path.charCodeAt(0);\r\n        // Try to match a root\r\n        if (len === 1) {\r\n            // `path` contains just a single char, exit early to avoid\r\n            // unnecessary work\r\n            return isPosixPathSeparator(code) ? '\\\\' : path;\r\n        }\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            // If we started with a separator, we know we at least have an absolute\r\n            // path of some kind (UNC or otherwise)\r\n            isAbsolute = true;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    const firstPart = path.slice(last, j);\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            // Return the normalized version of the UNC root since there\r\n                            // is nothing left to process\r\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\r\n                            rootEnd = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                rootEnd = 1;\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            device = path.slice(0, 2);\r\n            rootEnd = 2;\r\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\r\n                // Treat separator following drive name as an absolute path\r\n                // indicator\r\n                isAbsolute = true;\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        let tail = rootEnd < len ?\r\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\r\n            '';\r\n        if (tail.length === 0 && !isAbsolute) {\r\n            tail = '.';\r\n        }\r\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\r\n            tail += '\\\\';\r\n        }\r\n        if (device === undefined) {\r\n            return isAbsolute ? `\\\\${tail}` : tail;\r\n        }\r\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return false;\r\n        }\r\n        const code = path.charCodeAt(0);\r\n        return isPathSeparator(code) ||\r\n            // Possible device root\r\n            len > 2 &&\r\n                isWindowsDeviceRoot(code) &&\r\n                path.charCodeAt(1) === CHAR_COLON &&\r\n                isPathSeparator(path.charCodeAt(2));\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        let firstPart;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = firstPart = arg;\r\n                }\r\n                else {\r\n                    joined += `\\\\${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        // Make sure that the joined path doesn't start with two slashes, because\r\n        // normalize() will mistake it for an UNC path then.\r\n        //\r\n        // This step is skipped when it is very clear that the user actually\r\n        // intended to point at an UNC path. This is assumed when the first\r\n        // non-empty string arguments starts with exactly two slashes followed by\r\n        // at least one more non-slash character.\r\n        //\r\n        // Note that for normalize() to treat a path as an UNC path it needs to\r\n        // have at least 2 components, so we don't filter for that here.\r\n        // This means that the user can use join to construct UNC paths from\r\n        // a server name and a share name; for example:\r\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\r\n        let needsReplace = true;\r\n        let slashCount = 0;\r\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\r\n            ++slashCount;\r\n            const firstLen = firstPart.length;\r\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\r\n                ++slashCount;\r\n                if (firstLen > 2) {\r\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\r\n                        ++slashCount;\r\n                    }\r\n                    else {\r\n                        // We matched a UNC path in the first part\r\n                        needsReplace = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (needsReplace) {\r\n            // Find any more consecutive slashes we need to replace\r\n            while (slashCount < joined.length &&\r\n                isPathSeparator(joined.charCodeAt(slashCount))) {\r\n                slashCount++;\r\n            }\r\n            // Replace the slashes if needed\r\n            if (slashCount >= 2) {\r\n                joined = `\\\\${joined.slice(slashCount)}`;\r\n            }\r\n        }\r\n        return win32.normalize(joined);\r\n    },\r\n    // It will solve the relative path from `from` to `to`, for instance:\r\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromOrig = win32.resolve(from);\r\n        const toOrig = win32.resolve(to);\r\n        if (fromOrig === toOrig) {\r\n            return '';\r\n        }\r\n        from = fromOrig.toLowerCase();\r\n        to = toOrig.toLowerCase();\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim any leading backslashes\r\n        let fromStart = 0;\r\n        while (fromStart < from.length &&\r\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\r\n            fromStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let fromEnd = from.length;\r\n        while (fromEnd - 1 > fromStart &&\r\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            fromEnd--;\r\n        }\r\n        const fromLen = fromEnd - fromStart;\r\n        // Trim any leading backslashes\r\n        let toStart = 0;\r\n        while (toStart < to.length &&\r\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            toStart++;\r\n        }\r\n        // Trim trailing backslashes (applicable to UNC paths only)\r\n        let toEnd = to.length;\r\n        while (toEnd - 1 > toStart &&\r\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\r\n            toEnd--;\r\n        }\r\n        const toLen = toEnd - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = fromLen < toLen ? fromLen : toLen;\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        // We found a mismatch before the first common path separator was seen, so\r\n        // return the original `to`.\r\n        if (i !== length) {\r\n            if (lastCommonSep === -1) {\r\n                return toOrig;\r\n            }\r\n        }\r\n        else {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\r\n                    return toOrig.slice(toStart + i + 1);\r\n                }\r\n                if (i === 2) {\r\n                    // We get here if `from` is the device root.\r\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\r\n                    return toOrig.slice(toStart + i);\r\n                }\r\n            }\r\n            if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 2) {\r\n                    // We get here if `to` is the device root.\r\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\r\n                    lastCommonSep = 3;\r\n                }\r\n            }\r\n            if (lastCommonSep === -1) {\r\n                lastCommonSep = 0;\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to` and\r\n        // `from`\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '\\\\..';\r\n            }\r\n        }\r\n        toStart += lastCommonSep;\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts\r\n        if (out.length > 0) {\r\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\r\n        }\r\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\r\n            ++toStart;\r\n        }\r\n        return toOrig.slice(toStart, toEnd);\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Note: this will *probably* throw somewhere.\r\n        if (typeof path !== 'string') {\r\n            return path;\r\n        }\r\n        if (path.length === 0) {\r\n            return '';\r\n        }\r\n        const resolvedPath = win32.resolve(path);\r\n        if (resolvedPath.length <= 2) {\r\n            return path;\r\n        }\r\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\r\n            // Possible UNC root\r\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\r\n                const code = resolvedPath.charCodeAt(2);\r\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\r\n                    // Matched non-long UNC root, convert the path to a long UNC path\r\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\r\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\r\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\r\n            // Matched device root, convert the path to a long UNC path\r\n            return `\\\\\\\\?\\\\${resolvedPath}`;\r\n        }\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        const len = path.length;\r\n        if (len === 0) {\r\n            return '.';\r\n        }\r\n        let rootEnd = -1;\r\n        let offset = 0;\r\n        const code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            // `path` contains just a path separator, exit early to avoid\r\n            // unnecessary work or a dot.\r\n            return isPathSeparator(code) ? path : '.';\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = offset = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            return path;\r\n                        }\r\n                        if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            // Offset by 1 to include the separator after the UNC root to\r\n                            // treat it as a \"normal root\" on top of a (UNC) root\r\n                            rootEnd = offset = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // Possible device root\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\r\n            offset = rootEnd;\r\n        }\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = len - 1; i >= offset; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (rootEnd === -1) {\r\n                return '.';\r\n            }\r\n            end = rootEnd;\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\r\n            path.charCodeAt(1) === CHAR_COLON) {\r\n            start = 2;\r\n        }\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= start; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (isPathSeparator(code)) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= start; --i) {\r\n            if (isPathSeparator(path.charCodeAt(i))) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Check for a drive letter prefix so as not to mistake the following\r\n        // path separator as an extra separator at the end of the path that can be\r\n        // disregarded\r\n        if (path.length >= 2 &&\r\n            path.charCodeAt(1) === CHAR_COLON &&\r\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\r\n            start = startPart = 2;\r\n        }\r\n        for (let i = path.length - 1; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '\\\\'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const len = path.length;\r\n        let rootEnd = 0;\r\n        let code = path.charCodeAt(0);\r\n        if (len === 1) {\r\n            if (isPathSeparator(code)) {\r\n                // `path` contains just a path separator, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            ret.base = ret.name = path;\r\n            return ret;\r\n        }\r\n        // Try to match a root\r\n        if (isPathSeparator(code)) {\r\n            // Possible UNC root\r\n            rootEnd = 1;\r\n            if (isPathSeparator(path.charCodeAt(1))) {\r\n                // Matched double path separator at beginning\r\n                let j = 2;\r\n                let last = j;\r\n                // Match 1 or more non-path separators\r\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                    j++;\r\n                }\r\n                if (j < len && j !== last) {\r\n                    // Matched!\r\n                    last = j;\r\n                    // Match 1 or more path separators\r\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\r\n                        j++;\r\n                    }\r\n                    if (j < len && j !== last) {\r\n                        // Matched!\r\n                        last = j;\r\n                        // Match 1 or more non-path separators\r\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\r\n                            j++;\r\n                        }\r\n                        if (j === len) {\r\n                            // We matched a UNC root only\r\n                            rootEnd = j;\r\n                        }\r\n                        else if (j !== last) {\r\n                            // We matched a UNC root with leftovers\r\n                            rootEnd = j + 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\r\n            // Possible device root\r\n            if (len <= 2) {\r\n                // `path` contains just a drive root, exit early to avoid\r\n                // unnecessary work\r\n                ret.root = ret.dir = path;\r\n                return ret;\r\n            }\r\n            rootEnd = 2;\r\n            if (isPathSeparator(path.charCodeAt(2))) {\r\n                if (len === 3) {\r\n                    // `path` contains just a drive root, exit early to avoid\r\n                    // unnecessary work\r\n                    ret.root = ret.dir = path;\r\n                    return ret;\r\n                }\r\n                rootEnd = 3;\r\n            }\r\n        }\r\n        if (rootEnd > 0) {\r\n            ret.root = path.slice(0, rootEnd);\r\n        }\r\n        let startDot = -1;\r\n        let startPart = rootEnd;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= rootEnd; --i) {\r\n            code = path.charCodeAt(i);\r\n            if (isPathSeparator(code)) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(startPart, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(startPart, startDot);\r\n                ret.base = path.slice(startPart, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        // If the directory is the root, use the entire root as the `dir` including\r\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\r\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\r\n        if (startPart > 0 && startPart !== rootEnd) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else {\r\n            ret.dir = ret.root;\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '\\\\',\r\n    delimiter: ';',\r\n    win32: null,\r\n    posix: null\r\n};\r\nexport const posix = {\r\n    // path.resolve([from ...], to)\r\n    resolve(...pathSegments) {\r\n        let resolvedPath = '';\r\n        let resolvedAbsolute = false;\r\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n            const path = i >= 0 ? pathSegments[i] : process.cwd();\r\n            validateString(path, 'path');\r\n            // Skip empty entries\r\n            if (path.length === 0) {\r\n                continue;\r\n            }\r\n            resolvedPath = `${path}/${resolvedPath}`;\r\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        // Normalize the path\r\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\r\n        if (resolvedAbsolute) {\r\n            return `/${resolvedPath}`;\r\n        }\r\n        return resolvedPath.length > 0 ? resolvedPath : '.';\r\n    },\r\n    normalize(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\r\n        // Normalize the path\r\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\r\n        if (path.length === 0) {\r\n            if (isAbsolute) {\r\n                return '/';\r\n            }\r\n            return trailingSeparator ? './' : '.';\r\n        }\r\n        if (trailingSeparator) {\r\n            path += '/';\r\n        }\r\n        return isAbsolute ? `/${path}` : path;\r\n    },\r\n    isAbsolute(path) {\r\n        validateString(path, 'path');\r\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n    },\r\n    join(...paths) {\r\n        if (paths.length === 0) {\r\n            return '.';\r\n        }\r\n        let joined;\r\n        for (let i = 0; i < paths.length; ++i) {\r\n            const arg = paths[i];\r\n            validateString(arg, 'path');\r\n            if (arg.length > 0) {\r\n                if (joined === undefined) {\r\n                    joined = arg;\r\n                }\r\n                else {\r\n                    joined += `/${arg}`;\r\n                }\r\n            }\r\n        }\r\n        if (joined === undefined) {\r\n            return '.';\r\n        }\r\n        return posix.normalize(joined);\r\n    },\r\n    relative(from, to) {\r\n        validateString(from, 'from');\r\n        validateString(to, 'to');\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        // Trim leading forward slashes.\r\n        from = posix.resolve(from);\r\n        to = posix.resolve(to);\r\n        if (from === to) {\r\n            return '';\r\n        }\r\n        const fromStart = 1;\r\n        const fromEnd = from.length;\r\n        const fromLen = fromEnd - fromStart;\r\n        const toStart = 1;\r\n        const toLen = to.length - toStart;\r\n        // Compare paths to find the longest common path from root\r\n        const length = (fromLen < toLen ? fromLen : toLen);\r\n        let lastCommonSep = -1;\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n            const fromCode = from.charCodeAt(fromStart + i);\r\n            if (fromCode !== to.charCodeAt(toStart + i)) {\r\n                break;\r\n            }\r\n            else if (fromCode === CHAR_FORWARD_SLASH) {\r\n                lastCommonSep = i;\r\n            }\r\n        }\r\n        if (i === length) {\r\n            if (toLen > length) {\r\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `from` is the exact base path for `to`.\r\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\r\n                    return to.slice(toStart + i + 1);\r\n                }\r\n                if (i === 0) {\r\n                    // We get here if `from` is the root\r\n                    // For example: from='/'; to='/foo'\r\n                    return to.slice(toStart + i);\r\n                }\r\n            }\r\n            else if (fromLen > length) {\r\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\r\n                    // We get here if `to` is the exact base path for `from`.\r\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\r\n                    lastCommonSep = i;\r\n                }\r\n                else if (i === 0) {\r\n                    // We get here if `to` is the root.\r\n                    // For example: from='/foo/bar'; to='/'\r\n                    lastCommonSep = 0;\r\n                }\r\n            }\r\n        }\r\n        let out = '';\r\n        // Generate the relative path based on the path difference between `to`\r\n        // and `from`.\r\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\r\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                out += out.length === 0 ? '..' : '/..';\r\n            }\r\n        }\r\n        // Lastly, append the rest of the destination (`to`) path that comes after\r\n        // the common path parts.\r\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\r\n    },\r\n    toNamespacedPath(path) {\r\n        // Non-op on posix systems\r\n        return path;\r\n    },\r\n    dirname(path) {\r\n        validateString(path, 'path');\r\n        if (path.length === 0) {\r\n            return '.';\r\n        }\r\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        for (let i = path.length - 1; i >= 1; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                if (!matchedSlash) {\r\n                    end = i;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                // We saw the first non-path separator\r\n                matchedSlash = false;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return hasRoot ? '/' : '.';\r\n        }\r\n        if (hasRoot && end === 1) {\r\n            return '//';\r\n        }\r\n        return path.slice(0, end);\r\n    },\r\n    basename(path, ext) {\r\n        if (ext !== undefined) {\r\n            validateString(ext, 'ext');\r\n        }\r\n        validateString(path, 'path');\r\n        let start = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i;\r\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\r\n            if (ext === path) {\r\n                return '';\r\n            }\r\n            let extIdx = ext.length - 1;\r\n            let firstNonSlashEnd = -1;\r\n            for (i = path.length - 1; i >= 0; --i) {\r\n                const code = path.charCodeAt(i);\r\n                if (code === CHAR_FORWARD_SLASH) {\r\n                    // If we reached a path separator that was not part of a set of path\r\n                    // separators at the end of the string, stop now\r\n                    if (!matchedSlash) {\r\n                        start = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (firstNonSlashEnd === -1) {\r\n                        // We saw the first non-path separator, remember this index in case\r\n                        // we need it if the extension ends up not matching\r\n                        matchedSlash = false;\r\n                        firstNonSlashEnd = i + 1;\r\n                    }\r\n                    if (extIdx >= 0) {\r\n                        // Try to match the explicit extension\r\n                        if (code === ext.charCodeAt(extIdx)) {\r\n                            if (--extIdx === -1) {\r\n                                // We matched the extension, so mark this as the end of our path\r\n                                // component\r\n                                end = i;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Extension does not match, so our result is the entire path\r\n                            // component\r\n                            extIdx = -1;\r\n                            end = firstNonSlashEnd;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (start === end) {\r\n                end = firstNonSlashEnd;\r\n            }\r\n            else if (end === -1) {\r\n                end = path.length;\r\n            }\r\n            return path.slice(start, end);\r\n        }\r\n        for (i = path.length - 1; i >= 0; --i) {\r\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    start = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n            else if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // path component\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            return '';\r\n        }\r\n        return path.slice(start, end);\r\n    },\r\n    extname(path) {\r\n        validateString(path, 'path');\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        for (let i = path.length - 1; i >= 0; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (startDot === -1 ||\r\n            end === -1 ||\r\n            // We saw a non-dot character immediately before the dot\r\n            preDotState === 0 ||\r\n            // The (right-most) trimmed path component is exactly '..'\r\n            (preDotState === 1 &&\r\n                startDot === end - 1 &&\r\n                startDot === startPart + 1)) {\r\n            return '';\r\n        }\r\n        return path.slice(startDot, end);\r\n    },\r\n    format: _format.bind(null, '/'),\r\n    parse(path) {\r\n        validateString(path, 'path');\r\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\r\n        if (path.length === 0) {\r\n            return ret;\r\n        }\r\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\r\n        let start;\r\n        if (isAbsolute) {\r\n            ret.root = '/';\r\n            start = 1;\r\n        }\r\n        else {\r\n            start = 0;\r\n        }\r\n        let startDot = -1;\r\n        let startPart = 0;\r\n        let end = -1;\r\n        let matchedSlash = true;\r\n        let i = path.length - 1;\r\n        // Track the state of characters (if any) we see before our first dot and\r\n        // after any path separator we find\r\n        let preDotState = 0;\r\n        // Get non-dir info\r\n        for (; i >= start; --i) {\r\n            const code = path.charCodeAt(i);\r\n            if (code === CHAR_FORWARD_SLASH) {\r\n                // If we reached a path separator that was not part of a set of path\r\n                // separators at the end of the string, stop now\r\n                if (!matchedSlash) {\r\n                    startPart = i + 1;\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (end === -1) {\r\n                // We saw the first non-path separator, mark this as the end of our\r\n                // extension\r\n                matchedSlash = false;\r\n                end = i + 1;\r\n            }\r\n            if (code === CHAR_DOT) {\r\n                // If this is our first dot, mark it as the start of our extension\r\n                if (startDot === -1) {\r\n                    startDot = i;\r\n                }\r\n                else if (preDotState !== 1) {\r\n                    preDotState = 1;\r\n                }\r\n            }\r\n            else if (startDot !== -1) {\r\n                // We saw a non-dot and non-path separator before our dot, so we should\r\n                // have a good chance at having a non-empty extension\r\n                preDotState = -1;\r\n            }\r\n        }\r\n        if (end !== -1) {\r\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\r\n            if (startDot === -1 ||\r\n                // We saw a non-dot character immediately before the dot\r\n                preDotState === 0 ||\r\n                // The (right-most) trimmed path component is exactly '..'\r\n                (preDotState === 1 &&\r\n                    startDot === end - 1 &&\r\n                    startDot === startPart + 1)) {\r\n                ret.base = ret.name = path.slice(start, end);\r\n            }\r\n            else {\r\n                ret.name = path.slice(start, startDot);\r\n                ret.base = path.slice(start, end);\r\n                ret.ext = path.slice(startDot, end);\r\n            }\r\n        }\r\n        if (startPart > 0) {\r\n            ret.dir = path.slice(0, startPart - 1);\r\n        }\r\n        else if (isAbsolute) {\r\n            ret.dir = '/';\r\n        }\r\n        return ret;\r\n    },\r\n    sep: '/',\r\n    delimiter: ':',\r\n    win32: null,\r\n    posix: null\r\n};\r\nposix.win32 = win32.win32 = win32;\r\nposix.posix = win32.posix = posix;\r\nexport const normalize = (process.platform === 'win32' ? win32.normalize : posix.normalize);\r\nexport const resolve = (process.platform === 'win32' ? win32.resolve : posix.resolve);\r\nexport const relative = (process.platform === 'win32' ? win32.relative : posix.relative);\r\nexport const dirname = (process.platform === 'win32' ? win32.dirname : posix.dirname);\r\nexport const basename = (process.platform === 'win32' ? win32.basename : posix.basename);\r\nexport const extname = (process.platform === 'win32' ? win32.extname : posix.extname);\r\nexport const sep = (process.platform === 'win32' ? win32.sep : posix.sep);\r\n"]},"metadata":{},"sourceType":"module"}