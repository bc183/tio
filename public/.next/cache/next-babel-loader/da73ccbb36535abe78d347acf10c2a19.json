{"ast":null,"code":"import _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js'; // const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\n\nexport var AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n  var r;\n\n  if (arr[arr.length - 1] < 65536) {\n    r = new Uint16Array(arr.length);\n  } else {\n    r = new Uint32Array(arr.length);\n  }\n\n  r.set(arr, 0);\n  return r;\n}\nexport var LineStarts = function LineStarts(lineStarts, cr, lf, crlf, isBasicASCII) {\n  _classCallCheck(this, LineStarts);\n\n  this.lineStarts = lineStarts;\n  this.cr = cr;\n  this.lf = lf;\n  this.crlf = crlf;\n  this.isBasicASCII = isBasicASCII;\n};\nexport function createLineStartsFast(str) {\n  var readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var r = [0],\n      rLength = 1;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          // \\r... case\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        r[rLength++] = i + 1;\n      }\n  }\n\n  if (readonly) {\n    return createUintArray(r);\n  } else {\n    return r;\n  }\n}\nexport function createLineStarts(r, str) {\n  r.length = 0;\n  r[0] = 0;\n  var rLength = 1;\n  var cr = 0,\n      lf = 0,\n      crlf = 0;\n  var isBasicASCII = true;\n\n  for (var i = 0, len = str.length; i < len; i++) {\n    var chr = str.charCodeAt(i);\n\n    if (chr === 13\n    /* CarriageReturn */\n    ) {\n        if (i + 1 < len && str.charCodeAt(i + 1) === 10\n        /* LineFeed */\n        ) {\n            // \\r\\n... case\n            crlf++;\n            r[rLength++] = i + 2;\n            i++; // skip \\n\n          } else {\n          cr++; // \\r... case\n\n          r[rLength++] = i + 1;\n        }\n      } else if (chr === 10\n    /* LineFeed */\n    ) {\n        lf++;\n        r[rLength++] = i + 1;\n      } else {\n      if (isBasicASCII) {\n        if (chr !== 9\n        /* Tab */\n        && (chr < 32 || chr > 126)) {\n          isBasicASCII = false;\n        }\n      }\n    }\n  }\n\n  var result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n  r.length = 0;\n  return result;\n}\nexport var Piece = function Piece(bufferIndex, start, end, lineFeedCnt, length) {\n  _classCallCheck(this, Piece);\n\n  this.bufferIndex = bufferIndex;\n  this.start = start;\n  this.end = end;\n  this.lineFeedCnt = lineFeedCnt;\n  this.length = length;\n};\nexport var StringBuffer = function StringBuffer(buffer, lineStarts) {\n  _classCallCheck(this, StringBuffer);\n\n  this.buffer = buffer;\n  this.lineStarts = lineStarts;\n};\n/**\r\n * Readonly snapshot for piece tree.\r\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\r\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\r\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\r\n */\n\nvar PieceTreeSnapshot = /*#__PURE__*/function () {\n  function PieceTreeSnapshot(tree, BOM) {\n    var _this = this;\n\n    _classCallCheck(this, PieceTreeSnapshot);\n\n    this._pieces = [];\n    this._tree = tree;\n    this._BOM = BOM;\n    this._index = 0;\n\n    if (tree.root !== SENTINEL) {\n      tree.iterate(tree.root, function (node) {\n        if (node !== SENTINEL) {\n          _this._pieces.push(node.piece);\n        }\n\n        return true;\n      });\n    }\n  }\n\n  _createClass(PieceTreeSnapshot, [{\n    key: \"read\",\n    value: function read() {\n      if (this._pieces.length === 0) {\n        if (this._index === 0) {\n          this._index++;\n          return this._BOM;\n        } else {\n          return null;\n        }\n      }\n\n      if (this._index > this._pieces.length - 1) {\n        return null;\n      }\n\n      if (this._index === 0) {\n        return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n      }\n\n      return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n  }]);\n\n  return PieceTreeSnapshot;\n}();\n\nvar PieceTreeSearchCache = /*#__PURE__*/function () {\n  function PieceTreeSearchCache(limit) {\n    _classCallCheck(this, PieceTreeSearchCache);\n\n    this._limit = limit;\n    this._cache = [];\n  }\n\n  _createClass(PieceTreeSearchCache, [{\n    key: \"get\",\n    value: function get(offset) {\n      for (var i = this._cache.length - 1; i >= 0; i--) {\n        var nodePos = this._cache[i];\n\n        if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n          return nodePos;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"get2\",\n    value: function get2(lineNumber) {\n      for (var i = this._cache.length - 1; i >= 0; i--) {\n        var nodePos = this._cache[i];\n\n        if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n          return nodePos;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"set\",\n    value: function set(nodePosition) {\n      if (this._cache.length >= this._limit) {\n        this._cache.shift();\n      }\n\n      this._cache.push(nodePosition);\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(offset) {\n      var hasInvalidVal = false;\n      var tmp = this._cache;\n\n      for (var i = 0; i < tmp.length; i++) {\n        var nodePos = tmp[i];\n\n        if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n          tmp[i] = null;\n          hasInvalidVal = true;\n          continue;\n        }\n      }\n\n      if (hasInvalidVal) {\n        var newArr = [];\n\n        var _iterator = _createForOfIteratorHelper(tmp),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n\n            if (entry !== null) {\n              newArr.push(entry);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this._cache = newArr;\n      }\n    }\n  }]);\n\n  return PieceTreeSearchCache;\n}();\n\nexport var PieceTreeBase = /*#__PURE__*/function () {\n  function PieceTreeBase(chunks, eol, eolNormalized) {\n    _classCallCheck(this, PieceTreeBase);\n\n    this.create(chunks, eol, eolNormalized);\n  }\n\n  _createClass(PieceTreeBase, [{\n    key: \"create\",\n    value: function create(chunks, eol, eolNormalized) {\n      this._buffers = [new StringBuffer('', [0])];\n      this._lastChangeBufferPos = {\n        line: 0,\n        column: 0\n      };\n      this.root = SENTINEL;\n      this._lineCnt = 1;\n      this._length = 0;\n      this._EOL = eol;\n      this._EOLLength = eol.length;\n      this._EOLNormalized = eolNormalized;\n      var lastNode = null;\n\n      for (var i = 0, len = chunks.length; i < len; i++) {\n        if (chunks[i].buffer.length > 0) {\n          if (!chunks[i].lineStarts) {\n            chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n          }\n\n          var piece = new Piece(i + 1, {\n            line: 0,\n            column: 0\n          }, {\n            line: chunks[i].lineStarts.length - 1,\n            column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1]\n          }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n\n          this._buffers.push(chunks[i]);\n\n          lastNode = this.rbInsertRight(lastNode, piece);\n        }\n      }\n\n      this._searchCache = new PieceTreeSearchCache(1);\n      this._lastVisitedLine = {\n        lineNumber: 0,\n        value: ''\n      };\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"normalizeEOL\",\n    value: function normalizeEOL(eol) {\n      var _this2 = this;\n\n      var averageBufferSize = AverageBufferSize;\n      var min = averageBufferSize - Math.floor(averageBufferSize / 3);\n      var max = min * 2;\n      var tempChunk = '';\n      var tempChunkLen = 0;\n      var chunks = [];\n      this.iterate(this.root, function (node) {\n        var str = _this2.getNodeContent(node);\n\n        var len = str.length;\n\n        if (tempChunkLen <= min || tempChunkLen + len < max) {\n          tempChunk += str;\n          tempChunkLen += len;\n          return true;\n        } // flush anyways\n\n\n        var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n        chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        tempChunk = str;\n        tempChunkLen = len;\n        return true;\n      });\n\n      if (tempChunkLen > 0) {\n        var text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n        chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n      }\n\n      this.create(chunks, eol, true);\n    } // #region Buffer API\n\n  }, {\n    key: \"getEOL\",\n    value: function getEOL() {\n      return this._EOL;\n    }\n  }, {\n    key: \"setEOL\",\n    value: function setEOL(newEOL) {\n      this._EOL = newEOL;\n      this._EOLLength = this._EOL.length;\n      this.normalizeEOL(newEOL);\n    }\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(BOM) {\n      return new PieceTreeSnapshot(this, BOM);\n    }\n  }, {\n    key: \"getOffsetAt\",\n    value: function getOffsetAt(lineNumber, column) {\n      var leftLen = 0; // inorder\n\n      var x = this.root;\n\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n          leftLen += x.size_left; // lineNumber >= 2\n\n          var accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          return leftLen += accumualtedValInCurrentIndex + column - 1;\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          leftLen += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n\n      return leftLen;\n    }\n  }, {\n    key: \"getPositionAt\",\n    value: function getPositionAt(offset) {\n      offset = Math.floor(offset);\n      offset = Math.max(0, offset);\n      var x = this.root;\n      var lfCnt = 0;\n      var originalOffset = offset;\n\n      while (x !== SENTINEL) {\n        if (x.size_left !== 0 && x.size_left >= offset) {\n          x = x.left;\n        } else if (x.size_left + x.piece.length >= offset) {\n          var out = this.getIndexOf(x, offset - x.size_left);\n          lfCnt += x.lf_left + out.index;\n\n          if (out.index === 0) {\n            var lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n            var column = originalOffset - lineStartOffset;\n            return new Position(lfCnt + 1, column + 1);\n          }\n\n          return new Position(lfCnt + 1, out.remainder + 1);\n        } else {\n          offset -= x.size_left + x.piece.length;\n          lfCnt += x.lf_left + x.piece.lineFeedCnt;\n\n          if (x.right === SENTINEL) {\n            // last node\n            var _lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n\n            var _column = originalOffset - offset - _lineStartOffset;\n\n            return new Position(lfCnt + 1, _column + 1);\n          } else {\n            x = x.right;\n          }\n        }\n      }\n\n      return new Position(1, 1);\n    }\n  }, {\n    key: \"getValueInRange\",\n    value: function getValueInRange(range, eol) {\n      if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n        return '';\n      }\n\n      var startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n      var endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n      var value = this.getValueInRange2(startPosition, endPosition);\n\n      if (eol) {\n        if (eol !== this._EOL || !this._EOLNormalized) {\n          return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n\n        if (eol === this.getEOL() && this._EOLNormalized) {\n          if (eol === '\\r\\n') {}\n\n          return value;\n        }\n\n        return value.replace(/\\r\\n|\\r|\\n/g, eol);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"getValueInRange2\",\n    value: function getValueInRange2(startPosition, endPosition) {\n      if (startPosition.node === endPosition.node) {\n        var node = startPosition.node;\n        var _buffer = this._buffers[node.piece.bufferIndex].buffer;\n\n        var _startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n\n        return _buffer.substring(_startOffset + startPosition.remainder, _startOffset + endPosition.remainder);\n      }\n\n      var x = startPosition.node;\n      var buffer = this._buffers[x.piece.bufferIndex].buffer;\n      var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n      var ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n      x = x.next();\n\n      while (x !== SENTINEL) {\n        var _buffer2 = this._buffers[x.piece.bufferIndex].buffer;\n\n        var _startOffset2 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n        if (x === endPosition.node) {\n          ret += _buffer2.substring(_startOffset2, _startOffset2 + endPosition.remainder);\n          break;\n        } else {\n          ret += _buffer2.substr(_startOffset2, x.piece.length);\n        }\n\n        x = x.next();\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"getLinesContent\",\n    value: function getLinesContent() {\n      var _this3 = this;\n\n      var lines = [];\n      var linesLength = 0;\n      var currentLine = '';\n      var danglingCR = false;\n      this.iterate(this.root, function (node) {\n        if (node === SENTINEL) {\n          return true;\n        }\n\n        var piece = node.piece;\n        var pieceLength = piece.length;\n\n        if (pieceLength === 0) {\n          return true;\n        }\n\n        var buffer = _this3._buffers[piece.bufferIndex].buffer;\n        var lineStarts = _this3._buffers[piece.bufferIndex].lineStarts;\n        var pieceStartLine = piece.start.line;\n        var pieceEndLine = piece.end.line;\n        var pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n\n        if (danglingCR) {\n          if (buffer.charCodeAt(pieceStartOffset) === 10\n          /* LineFeed */\n          ) {\n              // pretend the \\n was in the previous piece..\n              pieceStartOffset++;\n              pieceLength--;\n            }\n\n          lines[linesLength++] = currentLine;\n          currentLine = '';\n          danglingCR = false;\n\n          if (pieceLength === 0) {\n            return true;\n          }\n        }\n\n        if (pieceStartLine === pieceEndLine) {\n          // this piece has no new lines\n          if (!_this3._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13\n          /* CarriageReturn */\n          ) {\n              danglingCR = true;\n              currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n            } else {\n            currentLine += buffer.substr(pieceStartOffset, pieceLength);\n          }\n\n          return true;\n        } // add the text before the first line start in this piece\n\n\n        currentLine += _this3._EOLNormalized ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - _this3._EOLLength)) : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n        lines[linesLength++] = currentLine;\n\n        for (var line = pieceStartLine + 1; line < pieceEndLine; line++) {\n          currentLine = _this3._EOLNormalized ? buffer.substring(lineStarts[line], lineStarts[line + 1] - _this3._EOLLength) : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, '');\n          lines[linesLength++] = currentLine;\n        }\n\n        if (!_this3._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13\n        /* CarriageReturn */\n        ) {\n            danglingCR = true;\n\n            if (piece.end.column === 0) {\n              // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n              linesLength--;\n            } else {\n              currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n            }\n          } else {\n          currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n        }\n\n        return true;\n      });\n\n      if (danglingCR) {\n        lines[linesLength++] = currentLine;\n        currentLine = '';\n      }\n\n      lines[linesLength++] = currentLine;\n      return lines;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._length;\n    }\n  }, {\n    key: \"getLineCount\",\n    value: function getLineCount() {\n      return this._lineCnt;\n    }\n  }, {\n    key: \"getLineContent\",\n    value: function getLineContent(lineNumber) {\n      if (this._lastVisitedLine.lineNumber === lineNumber) {\n        return this._lastVisitedLine.value;\n      }\n\n      this._lastVisitedLine.lineNumber = lineNumber;\n\n      if (lineNumber === this._lineCnt) {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n      } else if (this._EOLNormalized) {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n      } else {\n        this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n      }\n\n      return this._lastVisitedLine.value;\n    }\n  }, {\n    key: \"_getCharCode\",\n    value: function _getCharCode(nodePos) {\n      if (nodePos.remainder === nodePos.node.piece.length) {\n        // the char we want to fetch is at the head of next node.\n        var matchingNode = nodePos.node.next();\n\n        if (!matchingNode) {\n          return 0;\n        }\n\n        var buffer = this._buffers[matchingNode.piece.bufferIndex];\n        var startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n        return buffer.buffer.charCodeAt(startOffset);\n      } else {\n        var _buffer3 = this._buffers[nodePos.node.piece.bufferIndex];\n\n        var _startOffset3 = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n\n        var targetOffset = _startOffset3 + nodePos.remainder;\n        return _buffer3.buffer.charCodeAt(targetOffset);\n      }\n    }\n  }, {\n    key: \"getLineCharCode\",\n    value: function getLineCharCode(lineNumber, index) {\n      var nodePos = this.nodeAt2(lineNumber, index + 1);\n      return this._getCharCode(nodePos);\n    }\n  }, {\n    key: \"getLineLength\",\n    value: function getLineLength(lineNumber) {\n      if (lineNumber === this.getLineCount()) {\n        var startOffset = this.getOffsetAt(lineNumber, 1);\n        return this.getLength() - startOffset;\n      }\n\n      return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n  }, {\n    key: \"findMatchesInNode\",\n    value: function findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n      var start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n      var end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n      var m; // Reset regex to search from the beginning\n\n      var ret = {\n        line: 0,\n        column: 0\n      };\n      var searchText;\n      var offsetInBuffer;\n\n      if (searcher._wordSeparators) {\n        searchText = buffer.buffer.substring(start, end);\n\n        offsetInBuffer = function offsetInBuffer(offset) {\n          return offset + start;\n        };\n\n        searcher.reset(0);\n      } else {\n        searchText = buffer.buffer;\n\n        offsetInBuffer = function offsetInBuffer(offset) {\n          return offset;\n        };\n\n        searcher.reset(start);\n      }\n\n      do {\n        m = searcher.next(searchText);\n\n        if (m) {\n          if (offsetInBuffer(m.index) >= end) {\n            return resultLen;\n          }\n\n          this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n          var lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n          var retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n          var retEndColumn = retStartColumn + m[0].length;\n          result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n\n          if (offsetInBuffer(m.index) + m[0].length >= end) {\n            return resultLen;\n          }\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n\n      return resultLen;\n    }\n  }, {\n    key: \"findMatchesLineByLine\",\n    value: function findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n      var result = [];\n      var resultLen = 0;\n      var searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n      var startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n\n      if (startPosition === null) {\n        return [];\n      }\n\n      var endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n\n      if (endPosition === null) {\n        return [];\n      }\n\n      var start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n      var end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n\n      if (startPosition.node === endPosition.node) {\n        this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n      }\n\n      var startLineNumber = searchRange.startLineNumber;\n      var currentNode = startPosition.node;\n\n      while (currentNode !== endPosition.node) {\n        var lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n\n        if (lineBreakCnt >= 1) {\n          // last line break position\n          var lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n          var startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n          var nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n\n          var _startColumn2 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n\n          resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, _startColumn2, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n\n          if (resultLen >= limitResultCount) {\n            return result;\n          }\n\n          startLineNumber += lineBreakCnt;\n        }\n\n        var _startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0; // search for the remaining content\n\n\n        if (startLineNumber === searchRange.endLineNumber) {\n          var text = this.getLineContent(startLineNumber).substring(_startColumn, searchRange.endColumn - 1);\n          resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, _startColumn, resultLen, result, captureMatches, limitResultCount);\n          return result;\n        }\n\n        resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(_startColumn), startLineNumber, _startColumn, resultLen, result, captureMatches, limitResultCount);\n\n        if (resultLen >= limitResultCount) {\n          return result;\n        }\n\n        startLineNumber++;\n        startPosition = this.nodeAt2(startLineNumber, 1);\n        currentNode = startPosition.node;\n        start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n      }\n\n      if (startLineNumber === searchRange.endLineNumber) {\n        var _startColumn3 = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n\n        var _text = this.getLineContent(startLineNumber).substring(_startColumn3, searchRange.endColumn - 1);\n\n        resultLen = this._findMatchesInLine(searchData, searcher, _text, searchRange.endLineNumber, _startColumn3, resultLen, result, captureMatches, limitResultCount);\n        return result;\n      }\n\n      var startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n      resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n      return result;\n    }\n  }, {\n    key: \"_findMatchesInLine\",\n    value: function _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n      var wordSeparators = searchData.wordSeparators;\n\n      if (!captureMatches && searchData.simpleSearch) {\n        var searchString = searchData.simpleSearch;\n        var searchStringLen = searchString.length;\n        var textLength = text.length;\n        var lastMatchIndex = -searchStringLen;\n\n        while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n          if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n            result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n\n            if (resultLen >= limitResultCount) {\n              return resultLen;\n            }\n          }\n        }\n\n        return resultLen;\n      }\n\n      var m; // Reset regex to search from the beginning\n\n      searcher.reset(0);\n\n      do {\n        m = searcher.next(text);\n\n        if (m) {\n          result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n\n          if (resultLen >= limitResultCount) {\n            return resultLen;\n          }\n        }\n      } while (m);\n\n      return resultLen;\n    } // #endregion\n    // #region Piece Table\n\n  }, {\n    key: \"insert\",\n    value: function insert(offset, value) {\n      var eolNormalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._EOLNormalized = this._EOLNormalized && eolNormalized;\n      this._lastVisitedLine.lineNumber = 0;\n      this._lastVisitedLine.value = '';\n\n      if (this.root !== SENTINEL) {\n        var _this$nodeAt = this.nodeAt(offset),\n            node = _this$nodeAt.node,\n            remainder = _this$nodeAt.remainder,\n            nodeStartOffset = _this$nodeAt.nodeStartOffset;\n\n        var piece = node.piece;\n        var bufferIndex = piece.bufferIndex;\n        var insertPosInBuffer = this.positionInBuffer(node, remainder);\n\n        if (node.piece.bufferIndex === 0 && piece.end.line === this._lastChangeBufferPos.line && piece.end.column === this._lastChangeBufferPos.column && nodeStartOffset + piece.length === offset && value.length < AverageBufferSize) {\n          // changed buffer\n          this.appendToNode(node, value);\n          this.computeBufferMetadata();\n          return;\n        }\n\n        if (nodeStartOffset === offset) {\n          this.insertContentToNodeLeft(value, node);\n\n          this._searchCache.validate(offset);\n        } else if (nodeStartOffset + node.piece.length > offset) {\n          // we are inserting into the middle of a node.\n          var nodesToDel = [];\n          var newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n\n          if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            var headOfRight = this.nodeCharCodeAt(node, remainder);\n\n            if (headOfRight === 10\n            /** \\n */\n            ) {\n                var newStart = {\n                  line: newRightPiece.start.line + 1,\n                  column: 0\n                };\n                newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                value += '\\n';\n              }\n          } // reuse node for content before insertion point.\n\n\n          if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n            var tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n\n            if (tailOfLeft === 13\n            /** \\r */\n            ) {\n                var previousPos = this.positionInBuffer(node, remainder - 1);\n                this.deleteNodeTail(node, previousPos);\n                value = '\\r' + value;\n\n                if (node.piece.length === 0) {\n                  nodesToDel.push(node);\n                }\n              } else {\n              this.deleteNodeTail(node, insertPosInBuffer);\n            }\n          } else {\n            this.deleteNodeTail(node, insertPosInBuffer);\n          }\n\n          var newPieces = this.createNewPieces(value);\n\n          if (newRightPiece.length > 0) {\n            this.rbInsertRight(node, newRightPiece);\n          }\n\n          var tmpNode = node;\n\n          for (var k = 0; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n          }\n\n          this.deleteNodes(nodesToDel);\n        } else {\n          this.insertContentToNodeRight(value, node);\n        }\n      } else {\n        // insert new node\n        var pieces = this.createNewPieces(value);\n\n        var _node = this.rbInsertLeft(null, pieces[0]);\n\n        for (var _k = 1; _k < pieces.length; _k++) {\n          _node = this.rbInsertRight(_node, pieces[_k]);\n        }\n      } // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n\n\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(offset, cnt) {\n      this._lastVisitedLine.lineNumber = 0;\n      this._lastVisitedLine.value = '';\n\n      if (cnt <= 0 || this.root === SENTINEL) {\n        return;\n      }\n\n      var startPosition = this.nodeAt(offset);\n      var endPosition = this.nodeAt(offset + cnt);\n      var startNode = startPosition.node;\n      var endNode = endPosition.node;\n\n      if (startNode === endNode) {\n        var _startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n\n        var _endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n\n        if (startPosition.nodeStartOffset === offset) {\n          if (cnt === startNode.piece.length) {\n            // delete node\n            var next = startNode.next();\n            rbDelete(this, startNode);\n            this.validateCRLFWithPrevNode(next);\n            this.computeBufferMetadata();\n            return;\n          }\n\n          this.deleteNodeHead(startNode, _endSplitPosInBuffer);\n\n          this._searchCache.validate(offset);\n\n          this.validateCRLFWithPrevNode(startNode);\n          this.computeBufferMetadata();\n          return;\n        }\n\n        if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n          this.deleteNodeTail(startNode, _startSplitPosInBuffer);\n          this.validateCRLFWithNextNode(startNode);\n          this.computeBufferMetadata();\n          return;\n        } // delete content in the middle, this node will be splitted to nodes\n\n\n        this.shrinkNode(startNode, _startSplitPosInBuffer, _endSplitPosInBuffer);\n        this.computeBufferMetadata();\n        return;\n      }\n\n      var nodesToDel = [];\n      var startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n      this.deleteNodeTail(startNode, startSplitPosInBuffer);\n\n      this._searchCache.validate(offset);\n\n      if (startNode.piece.length === 0) {\n        nodesToDel.push(startNode);\n      } // update last touched node\n\n\n      var endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n      this.deleteNodeHead(endNode, endSplitPosInBuffer);\n\n      if (endNode.piece.length === 0) {\n        nodesToDel.push(endNode);\n      } // delete nodes in between\n\n\n      var secondNode = startNode.next();\n\n      for (var node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n        nodesToDel.push(node);\n      }\n\n      var prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n      this.deleteNodes(nodesToDel);\n      this.validateCRLFWithNextNode(prev);\n      this.computeBufferMetadata();\n    }\n  }, {\n    key: \"insertContentToNodeLeft\",\n    value: function insertContentToNodeLeft(value, node) {\n      // we are inserting content to the beginning of node\n      var nodesToDel = [];\n\n      if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n        // move `\\n` to new node.\n        var piece = node.piece;\n        var newStart = {\n          line: piece.start.line + 1,\n          column: 0\n        };\n        var nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n        node.piece = nPiece;\n        value += '\\n';\n        updateTreeMetadata(this, node, -1, -1);\n\n        if (node.piece.length === 0) {\n          nodesToDel.push(node);\n        }\n      }\n\n      var newPieces = this.createNewPieces(value);\n      var newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n\n      for (var k = newPieces.length - 2; k >= 0; k--) {\n        newNode = this.rbInsertLeft(newNode, newPieces[k]);\n      }\n\n      this.validateCRLFWithPrevNode(newNode);\n      this.deleteNodes(nodesToDel);\n    }\n  }, {\n    key: \"insertContentToNodeRight\",\n    value: function insertContentToNodeRight(value, node) {\n      // we are inserting to the right of this node.\n      if (this.adjustCarriageReturnFromNext(value, node)) {\n        // move \\n to the new node.\n        value += '\\n';\n      }\n\n      var newPieces = this.createNewPieces(value);\n      var newNode = this.rbInsertRight(node, newPieces[0]);\n      var tmpNode = newNode;\n\n      for (var k = 1; k < newPieces.length; k++) {\n        tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n      }\n\n      this.validateCRLFWithPrevNode(newNode);\n    }\n  }, {\n    key: \"positionInBuffer\",\n    value: function positionInBuffer(node, remainder, ret) {\n      var piece = node.piece;\n      var bufferIndex = node.piece.bufferIndex;\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n      var startOffset = lineStarts[piece.start.line] + piece.start.column;\n      var offset = startOffset + remainder; // binary search offset between startOffset and endOffset\n\n      var low = piece.start.line;\n      var high = piece.end.line;\n      var mid = 0;\n      var midStop = 0;\n      var midStart = 0;\n\n      while (low <= high) {\n        mid = low + (high - low) / 2 | 0;\n        midStart = lineStarts[mid];\n\n        if (mid === high) {\n          break;\n        }\n\n        midStop = lineStarts[mid + 1];\n\n        if (offset < midStart) {\n          high = mid - 1;\n        } else if (offset >= midStop) {\n          low = mid + 1;\n        } else {\n          break;\n        }\n      }\n\n      if (ret) {\n        ret.line = mid;\n        ret.column = offset - midStart;\n        return null;\n      }\n\n      return {\n        line: mid,\n        column: offset - midStart\n      };\n    }\n  }, {\n    key: \"getLineFeedCnt\",\n    value: function getLineFeedCnt(bufferIndex, start, end) {\n      // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n      // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n      if (end.column === 0) {\n        return end.line - start.line;\n      }\n\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n\n      if (end.line === lineStarts.length - 1) {\n        // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n        return end.line - start.line;\n      }\n\n      var nextLineStartOffset = lineStarts[end.line + 1];\n      var endOffset = lineStarts[end.line] + end.column;\n\n      if (nextLineStartOffset > endOffset + 1) {\n        // there are more than 1 character after end, which means it can't be \\n\n        return end.line - start.line;\n      } // endOffset + 1 === nextLineStartOffset\n      // character at endOffset is \\n, so we check the character before first\n      // if character at endOffset is \\r, end.column is 0 and we can't get here.\n\n\n      var previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n\n      var buffer = this._buffers[bufferIndex].buffer;\n\n      if (buffer.charCodeAt(previousCharOffset) === 13) {\n        return end.line - start.line + 1;\n      } else {\n        return end.line - start.line;\n      }\n    }\n  }, {\n    key: \"offsetInBuffer\",\n    value: function offsetInBuffer(bufferIndex, cursor) {\n      var lineStarts = this._buffers[bufferIndex].lineStarts;\n      return lineStarts[cursor.line] + cursor.column;\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        rbDelete(this, nodes[i]);\n      }\n    }\n  }, {\n    key: \"createNewPieces\",\n    value: function createNewPieces(text) {\n      if (text.length > AverageBufferSize) {\n        // the content is large, operations like substring, charCode becomes slow\n        // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n        var newPieces = [];\n\n        while (text.length > AverageBufferSize) {\n          var lastChar = text.charCodeAt(AverageBufferSize - 1);\n          var splitText = void 0;\n\n          if (lastChar === 13\n          /* CarriageReturn */\n          || lastChar >= 0xD800 && lastChar <= 0xDBFF) {\n            // last character is \\r or a high surrogate => keep it back\n            splitText = text.substring(0, AverageBufferSize - 1);\n            text = text.substring(AverageBufferSize - 1);\n          } else {\n            splitText = text.substring(0, AverageBufferSize);\n            text = text.substring(AverageBufferSize);\n          }\n\n          var _lineStarts2 = createLineStartsFast(splitText);\n\n          newPieces.push(new Piece(this._buffers.length,\n          /* buffer index */\n          {\n            line: 0,\n            column: 0\n          }, {\n            line: _lineStarts2.length - 1,\n            column: splitText.length - _lineStarts2[_lineStarts2.length - 1]\n          }, _lineStarts2.length - 1, splitText.length));\n\n          this._buffers.push(new StringBuffer(splitText, _lineStarts2));\n        }\n\n        var _lineStarts = createLineStartsFast(text);\n\n        newPieces.push(new Piece(this._buffers.length,\n        /* buffer index */\n        {\n          line: 0,\n          column: 0\n        }, {\n          line: _lineStarts.length - 1,\n          column: text.length - _lineStarts[_lineStarts.length - 1]\n        }, _lineStarts.length - 1, text.length));\n\n        this._buffers.push(new StringBuffer(text, _lineStarts));\n\n        return newPieces;\n      }\n\n      var startOffset = this._buffers[0].buffer.length;\n      var lineStarts = createLineStartsFast(text, false);\n      var start = this._lastChangeBufferPos;\n\n      if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset && startOffset !== 0 && this.startWithLF(text) && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n      ) {\n          this._lastChangeBufferPos = {\n            line: this._lastChangeBufferPos.line,\n            column: this._lastChangeBufferPos.column + 1\n          };\n          start = this._lastChangeBufferPos;\n\n          for (var i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset + 1;\n          }\n\n          this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n          this._buffers[0].buffer += '_' + text;\n          startOffset += 1;\n        } else {\n        if (startOffset !== 0) {\n          for (var _i = 0; _i < lineStarts.length; _i++) {\n            lineStarts[_i] += startOffset;\n          }\n        }\n\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        this._buffers[0].buffer += text;\n      }\n\n      var endOffset = this._buffers[0].buffer.length;\n      var endIndex = this._buffers[0].lineStarts.length - 1;\n      var endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n      var endPos = {\n        line: endIndex,\n        column: endColumn\n      };\n      var newPiece = new Piece(0,\n      /** todo@peng */\n      start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n      this._lastChangeBufferPos = endPos;\n      return [newPiece];\n    }\n  }, {\n    key: \"getLineRawContent\",\n    value: function getLineRawContent(lineNumber) {\n      var endOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var x = this.root;\n      var ret = '';\n\n      var cache = this._searchCache.get2(lineNumber);\n\n      if (cache) {\n        x = cache.node;\n        var prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n        var buffer = this._buffers[x.piece.bufferIndex].buffer;\n        var startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n        if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n          ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n        } else {\n          var accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n          return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n        }\n      } else {\n        var nodeStartOffset = 0;\n        var originalLineNumber = lineNumber;\n\n        while (x !== SENTINEL) {\n          if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n            x = x.left;\n          } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n            var _prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n            var _accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n\n            var _buffer4 = this._buffers[x.piece.bufferIndex].buffer;\n\n            var _startOffset4 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n            nodeStartOffset += x.size_left;\n\n            this._searchCache.set({\n              node: x,\n              nodeStartOffset: nodeStartOffset,\n              nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n            });\n\n            return _buffer4.substring(_startOffset4 + _prevAccumulatedValue, _startOffset4 + _accumulatedValue - endOffset);\n          } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n            var _prevAccumulatedValue2 = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n            var _buffer5 = this._buffers[x.piece.bufferIndex].buffer;\n\n            var _startOffset5 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n            ret = _buffer5.substring(_startOffset5 + _prevAccumulatedValue2, _startOffset5 + x.piece.length);\n            break;\n          } else {\n            lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n            nodeStartOffset += x.size_left + x.piece.length;\n            x = x.right;\n          }\n        }\n      } // search in order, to find the node contains end column\n\n\n      x = x.next();\n\n      while (x !== SENTINEL) {\n        var _buffer6 = this._buffers[x.piece.bufferIndex].buffer;\n\n        if (x.piece.lineFeedCnt > 0) {\n          var _accumulatedValue2 = this.getAccumulatedValue(x, 0);\n\n          var _startOffset6 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n          ret += _buffer6.substring(_startOffset6, _startOffset6 + _accumulatedValue2 - endOffset);\n          return ret;\n        } else {\n          var _startOffset7 = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n\n          ret += _buffer6.substr(_startOffset7, x.piece.length);\n        }\n\n        x = x.next();\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"computeBufferMetadata\",\n    value: function computeBufferMetadata() {\n      var x = this.root;\n      var lfCnt = 1;\n      var len = 0;\n\n      while (x !== SENTINEL) {\n        lfCnt += x.lf_left + x.piece.lineFeedCnt;\n        len += x.size_left + x.piece.length;\n        x = x.right;\n      }\n\n      this._lineCnt = lfCnt;\n      this._length = len;\n\n      this._searchCache.validate(this._length);\n    } // #region node operations\n\n  }, {\n    key: \"getIndexOf\",\n    value: function getIndexOf(node, accumulatedValue) {\n      var piece = node.piece;\n      var pos = this.positionInBuffer(node, accumulatedValue);\n      var lineCnt = pos.line - piece.start.line;\n\n      if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n        // we are checking the end of this node, so a CRLF check is necessary.\n        var realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n\n        if (realLineCnt !== lineCnt) {\n          // aha yes, CRLF\n          return {\n            index: realLineCnt,\n            remainder: 0\n          };\n        }\n      }\n\n      return {\n        index: lineCnt,\n        remainder: pos.column\n      };\n    }\n  }, {\n    key: \"getAccumulatedValue\",\n    value: function getAccumulatedValue(node, index) {\n      if (index < 0) {\n        return 0;\n      }\n\n      var piece = node.piece;\n      var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n      var expectedLineStartIndex = piece.start.line + index + 1;\n\n      if (expectedLineStartIndex > piece.end.line) {\n        return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n      } else {\n        return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n      }\n    }\n  }, {\n    key: \"deleteNodeTail\",\n    value: function deleteNodeTail(node, pos) {\n      var piece = node.piece;\n      var originalLFCnt = piece.lineFeedCnt;\n      var originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      var newEnd = pos;\n      var newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n      var lf_delta = newLineFeedCnt - originalLFCnt;\n      var size_delta = newEndOffset - originalEndOffset;\n      var newLength = piece.length + size_delta;\n      node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n  }, {\n    key: \"deleteNodeHead\",\n    value: function deleteNodeHead(node, pos) {\n      var piece = node.piece;\n      var originalLFCnt = piece.lineFeedCnt;\n      var originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var newStart = pos;\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n      var newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n      var lf_delta = newLineFeedCnt - originalLFCnt;\n      var size_delta = originalStartOffset - newStartOffset;\n      var newLength = piece.length + size_delta;\n      node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n  }, {\n    key: \"shrinkNode\",\n    value: function shrinkNode(node, start, end) {\n      var piece = node.piece;\n      var originalStartPos = piece.start;\n      var originalEndPos = piece.end; // old piece, originalStartPos, start\n\n      var oldLength = piece.length;\n      var oldLFCnt = piece.lineFeedCnt;\n      var newEnd = start;\n      var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n      var newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n      node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt); // new right piece, end, originalEndPos\n\n      var newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n      var newNode = this.rbInsertRight(node, newPiece);\n      this.validateCRLFWithPrevNode(newNode);\n    }\n  }, {\n    key: \"appendToNode\",\n    value: function appendToNode(node, value) {\n      if (this.adjustCarriageReturnFromNext(value, node)) {\n        value += '\\n';\n      }\n\n      var hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n      var startOffset = this._buffers[0].buffer.length;\n      this._buffers[0].buffer += value;\n      var lineStarts = createLineStartsFast(value, false);\n\n      for (var i = 0; i < lineStarts.length; i++) {\n        lineStarts[i] += startOffset;\n      }\n\n      if (hitCRLF) {\n        var prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n\n        this._buffers[0].lineStarts.pop(); // _lastChangeBufferPos is already wrong\n\n\n        this._lastChangeBufferPos = {\n          line: this._lastChangeBufferPos.line - 1,\n          column: startOffset - prevStartOffset\n        };\n      }\n\n      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n      var endIndex = this._buffers[0].lineStarts.length - 1;\n      var endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n      var newEnd = {\n        line: endIndex,\n        column: endColumn\n      };\n      var newLength = node.piece.length + value.length;\n      var oldLineFeedCnt = node.piece.lineFeedCnt;\n      var newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n      var lf_delta = newLineFeedCnt - oldLineFeedCnt;\n      node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n      this._lastChangeBufferPos = newEnd;\n      updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(offset) {\n      var x = this.root;\n\n      var cache = this._searchCache.get(offset);\n\n      if (cache) {\n        return {\n          node: cache.node,\n          nodeStartOffset: cache.nodeStartOffset,\n          remainder: offset - cache.nodeStartOffset\n        };\n      }\n\n      var nodeStartOffset = 0;\n\n      while (x !== SENTINEL) {\n        if (x.size_left > offset) {\n          x = x.left;\n        } else if (x.size_left + x.piece.length >= offset) {\n          nodeStartOffset += x.size_left;\n          var ret = {\n            node: x,\n            remainder: offset - x.size_left,\n            nodeStartOffset: nodeStartOffset\n          };\n\n          this._searchCache.set(ret);\n\n          return ret;\n        } else {\n          offset -= x.size_left + x.piece.length;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"nodeAt2\",\n    value: function nodeAt2(lineNumber, column) {\n      var x = this.root;\n      var nodeStartOffset = 0;\n\n      while (x !== SENTINEL) {\n        if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n          x = x.left;\n        } else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n          var prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n          var accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n          nodeStartOffset += x.size_left;\n          return {\n            node: x,\n            remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n            nodeStartOffset: nodeStartOffset\n          };\n        } else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n          var _prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n\n          if (_prevAccumualtedValue + column - 1 <= x.piece.length) {\n            return {\n              node: x,\n              remainder: _prevAccumualtedValue + column - 1,\n              nodeStartOffset: nodeStartOffset\n            };\n          } else {\n            column -= x.piece.length - _prevAccumualtedValue;\n            break;\n          }\n        } else {\n          lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n          nodeStartOffset += x.size_left + x.piece.length;\n          x = x.right;\n        }\n      } // search in order, to find the node contains position.column\n\n\n      x = x.next();\n\n      while (x !== SENTINEL) {\n        if (x.piece.lineFeedCnt > 0) {\n          var _accumulatedValue3 = this.getAccumulatedValue(x, 0);\n\n          var _nodeStartOffset = this.offsetOfNode(x);\n\n          return {\n            node: x,\n            remainder: Math.min(column - 1, _accumulatedValue3),\n            nodeStartOffset: _nodeStartOffset\n          };\n        } else {\n          if (x.piece.length >= column - 1) {\n            var _nodeStartOffset2 = this.offsetOfNode(x);\n\n            return {\n              node: x,\n              remainder: column - 1,\n              nodeStartOffset: _nodeStartOffset2\n            };\n          } else {\n            column -= x.piece.length;\n          }\n        }\n\n        x = x.next();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"nodeCharCodeAt\",\n    value: function nodeCharCodeAt(node, offset) {\n      if (node.piece.lineFeedCnt < 1) {\n        return -1;\n      }\n\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n      return buffer.buffer.charCodeAt(newOffset);\n    }\n  }, {\n    key: \"offsetOfNode\",\n    value: function offsetOfNode(node) {\n      if (!node) {\n        return 0;\n      }\n\n      var pos = node.size_left;\n\n      while (node !== this.root) {\n        if (node.parent.right === node) {\n          pos += node.parent.size_left + node.parent.piece.length;\n        }\n\n        node = node.parent;\n      }\n\n      return pos;\n    } // #endregion\n    // #region CRLF\n\n  }, {\n    key: \"shouldCheckCRLF\",\n    value: function shouldCheckCRLF() {\n      return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n  }, {\n    key: \"startWithLF\",\n    value: function startWithLF(val) {\n      if (typeof val === 'string') {\n        return val.charCodeAt(0) === 10;\n      }\n\n      if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n        return false;\n      }\n\n      var piece = val.piece;\n      var lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n      var line = piece.start.line;\n      var startOffset = lineStarts[line] + piece.start.column;\n\n      if (line === lineStarts.length - 1) {\n        // last line, so there is no line feed at the end of this line\n        return false;\n      }\n\n      var nextLineOffset = lineStarts[line + 1];\n\n      if (nextLineOffset > startOffset + 1) {\n        return false;\n      }\n\n      return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n  }, {\n    key: \"endWithCR\",\n    value: function endWithCR(val) {\n      if (typeof val === 'string') {\n        return val.charCodeAt(val.length - 1) === 13;\n      }\n\n      if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n        return false;\n      }\n\n      return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n  }, {\n    key: \"validateCRLFWithPrevNode\",\n    value: function validateCRLFWithPrevNode(nextNode) {\n      if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n        var node = nextNode.prev();\n\n        if (this.endWithCR(node)) {\n          this.fixCRLF(node, nextNode);\n        }\n      }\n    }\n  }, {\n    key: \"validateCRLFWithNextNode\",\n    value: function validateCRLFWithNextNode(node) {\n      if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n        var nextNode = node.next();\n\n        if (this.startWithLF(nextNode)) {\n          this.fixCRLF(node, nextNode);\n        }\n      }\n    }\n  }, {\n    key: \"fixCRLF\",\n    value: function fixCRLF(prev, next) {\n      var nodesToDel = []; // update node\n\n      var lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n      var newEnd;\n\n      if (prev.piece.end.column === 0) {\n        // it means, last line ends with \\r, not \\r\\n\n        newEnd = {\n          line: prev.piece.end.line - 1,\n          column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1\n        };\n      } else {\n        // \\r\\n\n        newEnd = {\n          line: prev.piece.end.line,\n          column: prev.piece.end.column - 1\n        };\n      }\n\n      var prevNewLength = prev.piece.length - 1;\n      var prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n      prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n      updateTreeMetadata(this, prev, -1, -1);\n\n      if (prev.piece.length === 0) {\n        nodesToDel.push(prev);\n      } // update nextNode\n\n\n      var newStart = {\n        line: next.piece.start.line + 1,\n        column: 0\n      };\n      var newLength = next.piece.length - 1;\n      var newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n      next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n      updateTreeMetadata(this, next, -1, -1);\n\n      if (next.piece.length === 0) {\n        nodesToDel.push(next);\n      } // create new piece which contains \\r\\n\n\n\n      var pieces = this.createNewPieces('\\r\\n');\n      this.rbInsertRight(prev, pieces[0]); // delete empty nodes\n\n      for (var i = 0; i < nodesToDel.length; i++) {\n        rbDelete(this, nodesToDel[i]);\n      }\n    }\n  }, {\n    key: \"adjustCarriageReturnFromNext\",\n    value: function adjustCarriageReturnFromNext(value, node) {\n      if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n        var nextNode = node.next();\n\n        if (this.startWithLF(nextNode)) {\n          // move `\\n` forward\n          value += '\\n';\n\n          if (nextNode.piece.length === 1) {\n            rbDelete(this, nextNode);\n          } else {\n            var piece = nextNode.piece;\n            var newStart = {\n              line: piece.start.line + 1,\n              column: 0\n            };\n            var newLength = piece.length - 1;\n            var newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n            nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n            updateTreeMetadata(this, nextNode, -1, -1);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    } // #endregion\n    // #endregion\n    // #region Tree operations\n\n  }, {\n    key: \"iterate\",\n    value: function iterate(node, callback) {\n      if (node === SENTINEL) {\n        return callback(SENTINEL);\n      }\n\n      var leftRet = this.iterate(node.left, callback);\n\n      if (!leftRet) {\n        return leftRet;\n      }\n\n      return callback(node) && this.iterate(node.right, callback);\n    }\n  }, {\n    key: \"getNodeContent\",\n    value: function getNodeContent(node) {\n      if (node === SENTINEL) {\n        return '';\n      }\n\n      var buffer = this._buffers[node.piece.bufferIndex];\n      var currentContent;\n      var piece = node.piece;\n      var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      currentContent = buffer.buffer.substring(startOffset, endOffset);\n      return currentContent;\n    }\n  }, {\n    key: \"getPieceContent\",\n    value: function getPieceContent(piece) {\n      var buffer = this._buffers[piece.bufferIndex];\n      var startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n      var endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n      var currentContent = buffer.buffer.substring(startOffset, endOffset);\n      return currentContent;\n    }\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b    <----   a    b\r\n     *                         /\r\n     *                        z\r\n     */\n\n  }, {\n    key: \"rbInsertRight\",\n    value: function rbInsertRight(node, p) {\n      var z = new TreeNode(p, 1\n      /* Red */\n      );\n      z.left = SENTINEL;\n      z.right = SENTINEL;\n      z.parent = SENTINEL;\n      z.size_left = 0;\n      z.lf_left = 0;\n      var x = this.root;\n\n      if (x === SENTINEL) {\n        this.root = z;\n        z.color = 0\n        /* Black */\n        ;\n      } else if (node.right === SENTINEL) {\n        node.right = z;\n        z.parent = node;\n      } else {\n        var nextNode = leftest(node.right);\n        nextNode.left = z;\n        z.parent = nextNode;\n      }\n\n      fixInsert(this, z);\n      return z;\n    }\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b     ---->   a    b\r\n     *                       \\\r\n     *                        z\r\n     */\n\n  }, {\n    key: \"rbInsertLeft\",\n    value: function rbInsertLeft(node, p) {\n      var z = new TreeNode(p, 1\n      /* Red */\n      );\n      z.left = SENTINEL;\n      z.right = SENTINEL;\n      z.parent = SENTINEL;\n      z.size_left = 0;\n      z.lf_left = 0;\n\n      if (this.root === SENTINEL) {\n        this.root = z;\n        z.color = 0\n        /* Black */\n        ;\n      } else if (node.left === SENTINEL) {\n        node.left = z;\n        z.parent = node;\n      } else {\n        var prevNode = righttest(node.left); // a\n\n        prevNode.right = z;\n        z.parent = prevNode;\n      }\n\n      fixInsert(this, z);\n      return z;\n    }\n  }]);\n\n  return PieceTreeBase;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js"],"names":["Position","Range","FindMatch","SENTINEL","TreeNode","fixInsert","leftest","rbDelete","righttest","updateTreeMetadata","Searcher","createFindMatch","isValidMatch","AverageBufferSize","createUintArray","arr","r","length","Uint16Array","Uint32Array","set","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","i","len","chr","charCodeAt","createLineStarts","result","Piece","bufferIndex","start","end","lineFeedCnt","StringBuffer","buffer","PieceTreeSnapshot","tree","BOM","_pieces","_tree","_BOM","_index","root","iterate","node","push","piece","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","offset","nodePos","nodeStartOffset","lineNumber","nodeStartLineNumber","nodePosition","shift","hasInvalidVal","tmp","parent","newArr","entry","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","column","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","value","computeBufferMetadata","averageBufferSize","min","Math","floor","max","tempChunk","tempChunkLen","getNodeContent","text","replace","newEOL","normalizeEOL","leftLen","x","left","lf_left","size_left","accumualtedValInCurrentIndex","getAccumulatedValue","right","lfCnt","originalOffset","out","getIndexOf","index","lineStartOffset","getOffsetAt","remainder","range","startLineNumber","endLineNumber","startColumn","endColumn","startPosition","nodeAt2","endPosition","getValueInRange2","getEOL","startOffset","offsetInBuffer","substring","ret","next","substr","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLineRawContent","matchingNode","targetOffset","_getCharCode","getLineCount","getLength","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","startOffsetInBuffer","m","searchText","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","searchRange","wordSeparators","regex","findMatchesInNode","currentNode","lineBreakCnt","nextLineStartOffset","getLineContent","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","validate","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","secondNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","get2","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","lf_delta","size_delta","newLength","originalStartOffset","newStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","get","prevAccumualtedValue","offsetOfNode","newOffset","val","nextLineOffset","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","currentContent","p","z","color","prevNode"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Position } from '../../core/position.js';\r\nimport { Range } from '../../core/range.js';\r\nimport { FindMatch } from '../../model.js';\r\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\r\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\r\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\r\nexport const AverageBufferSize = 65535;\r\nexport function createUintArray(arr) {\r\n    let r;\r\n    if (arr[arr.length - 1] < 65536) {\r\n        r = new Uint16Array(arr.length);\r\n    }\r\n    else {\r\n        r = new Uint32Array(arr.length);\r\n    }\r\n    r.set(arr, 0);\r\n    return r;\r\n}\r\nexport class LineStarts {\r\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\r\n        this.lineStarts = lineStarts;\r\n        this.cr = cr;\r\n        this.lf = lf;\r\n        this.crlf = crlf;\r\n        this.isBasicASCII = isBasicASCII;\r\n    }\r\n}\r\nexport function createLineStartsFast(str, readonly = true) {\r\n    let r = [0], rLength = 1;\r\n    for (let i = 0, len = str.length; i < len; i++) {\r\n        const chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            r[rLength++] = i + 1;\r\n        }\r\n    }\r\n    if (readonly) {\r\n        return createUintArray(r);\r\n    }\r\n    else {\r\n        return r;\r\n    }\r\n}\r\nexport function createLineStarts(r, str) {\r\n    r.length = 0;\r\n    r[0] = 0;\r\n    let rLength = 1;\r\n    let cr = 0, lf = 0, crlf = 0;\r\n    let isBasicASCII = true;\r\n    for (let i = 0, len = str.length; i < len; i++) {\r\n        const chr = str.charCodeAt(i);\r\n        if (chr === 13 /* CarriageReturn */) {\r\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* LineFeed */) {\r\n                // \\r\\n... case\r\n                crlf++;\r\n                r[rLength++] = i + 2;\r\n                i++; // skip \\n\r\n            }\r\n            else {\r\n                cr++;\r\n                // \\r... case\r\n                r[rLength++] = i + 1;\r\n            }\r\n        }\r\n        else if (chr === 10 /* LineFeed */) {\r\n            lf++;\r\n            r[rLength++] = i + 1;\r\n        }\r\n        else {\r\n            if (isBasicASCII) {\r\n                if (chr !== 9 /* Tab */ && (chr < 32 || chr > 126)) {\r\n                    isBasicASCII = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\r\n    r.length = 0;\r\n    return result;\r\n}\r\nexport class Piece {\r\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\r\n        this.bufferIndex = bufferIndex;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.lineFeedCnt = lineFeedCnt;\r\n        this.length = length;\r\n    }\r\n}\r\nexport class StringBuffer {\r\n    constructor(buffer, lineStarts) {\r\n        this.buffer = buffer;\r\n        this.lineStarts = lineStarts;\r\n    }\r\n}\r\n/**\r\n * Readonly snapshot for piece tree.\r\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\r\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\r\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\r\n */\r\nclass PieceTreeSnapshot {\r\n    constructor(tree, BOM) {\r\n        this._pieces = [];\r\n        this._tree = tree;\r\n        this._BOM = BOM;\r\n        this._index = 0;\r\n        if (tree.root !== SENTINEL) {\r\n            tree.iterate(tree.root, node => {\r\n                if (node !== SENTINEL) {\r\n                    this._pieces.push(node.piece);\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n    }\r\n    read() {\r\n        if (this._pieces.length === 0) {\r\n            if (this._index === 0) {\r\n                this._index++;\r\n                return this._BOM;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        if (this._index > this._pieces.length - 1) {\r\n            return null;\r\n        }\r\n        if (this._index === 0) {\r\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\r\n        }\r\n        return this._tree.getPieceContent(this._pieces[this._index++]);\r\n    }\r\n}\r\nclass PieceTreeSearchCache {\r\n    constructor(limit) {\r\n        this._limit = limit;\r\n        this._cache = [];\r\n    }\r\n    get(offset) {\r\n        for (let i = this._cache.length - 1; i >= 0; i--) {\r\n            let nodePos = this._cache[i];\r\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    get2(lineNumber) {\r\n        for (let i = this._cache.length - 1; i >= 0; i--) {\r\n            let nodePos = this._cache[i];\r\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\r\n                return nodePos;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    set(nodePosition) {\r\n        if (this._cache.length >= this._limit) {\r\n            this._cache.shift();\r\n        }\r\n        this._cache.push(nodePosition);\r\n    }\r\n    validate(offset) {\r\n        let hasInvalidVal = false;\r\n        let tmp = this._cache;\r\n        for (let i = 0; i < tmp.length; i++) {\r\n            let nodePos = tmp[i];\r\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\r\n                tmp[i] = null;\r\n                hasInvalidVal = true;\r\n                continue;\r\n            }\r\n        }\r\n        if (hasInvalidVal) {\r\n            let newArr = [];\r\n            for (const entry of tmp) {\r\n                if (entry !== null) {\r\n                    newArr.push(entry);\r\n                }\r\n            }\r\n            this._cache = newArr;\r\n        }\r\n    }\r\n}\r\nexport class PieceTreeBase {\r\n    constructor(chunks, eol, eolNormalized) {\r\n        this.create(chunks, eol, eolNormalized);\r\n    }\r\n    create(chunks, eol, eolNormalized) {\r\n        this._buffers = [\r\n            new StringBuffer('', [0])\r\n        ];\r\n        this._lastChangeBufferPos = { line: 0, column: 0 };\r\n        this.root = SENTINEL;\r\n        this._lineCnt = 1;\r\n        this._length = 0;\r\n        this._EOL = eol;\r\n        this._EOLLength = eol.length;\r\n        this._EOLNormalized = eolNormalized;\r\n        let lastNode = null;\r\n        for (let i = 0, len = chunks.length; i < len; i++) {\r\n            if (chunks[i].buffer.length > 0) {\r\n                if (!chunks[i].lineStarts) {\r\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\r\n                }\r\n                let piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\r\n                this._buffers.push(chunks[i]);\r\n                lastNode = this.rbInsertRight(lastNode, piece);\r\n            }\r\n        }\r\n        this._searchCache = new PieceTreeSearchCache(1);\r\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\r\n        this.computeBufferMetadata();\r\n    }\r\n    normalizeEOL(eol) {\r\n        let averageBufferSize = AverageBufferSize;\r\n        let min = averageBufferSize - Math.floor(averageBufferSize / 3);\r\n        let max = min * 2;\r\n        let tempChunk = '';\r\n        let tempChunkLen = 0;\r\n        let chunks = [];\r\n        this.iterate(this.root, node => {\r\n            let str = this.getNodeContent(node);\r\n            let len = str.length;\r\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\r\n                tempChunk += str;\r\n                tempChunkLen += len;\r\n                return true;\r\n            }\r\n            // flush anyways\r\n            let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n            tempChunk = str;\r\n            tempChunkLen = len;\r\n            return true;\r\n        });\r\n        if (tempChunkLen > 0) {\r\n            let text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\r\n        }\r\n        this.create(chunks, eol, true);\r\n    }\r\n    // #region Buffer API\r\n    getEOL() {\r\n        return this._EOL;\r\n    }\r\n    setEOL(newEOL) {\r\n        this._EOL = newEOL;\r\n        this._EOLLength = this._EOL.length;\r\n        this.normalizeEOL(newEOL);\r\n    }\r\n    createSnapshot(BOM) {\r\n        return new PieceTreeSnapshot(this, BOM);\r\n    }\r\n    getOffsetAt(lineNumber, column) {\r\n        let leftLen = 0; // inorder\r\n        let x = this.root;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\r\n                leftLen += x.size_left;\r\n                // lineNumber >= 2\r\n                let accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                leftLen += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return leftLen;\r\n    }\r\n    getPositionAt(offset) {\r\n        offset = Math.floor(offset);\r\n        offset = Math.max(0, offset);\r\n        let x = this.root;\r\n        let lfCnt = 0;\r\n        let originalOffset = offset;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left !== 0 && x.size_left >= offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                let out = this.getIndexOf(x, offset - x.size_left);\r\n                lfCnt += x.lf_left + out.index;\r\n                if (out.index === 0) {\r\n                    let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    let column = originalOffset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                return new Position(lfCnt + 1, out.remainder + 1);\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n                if (x.right === SENTINEL) {\r\n                    // last node\r\n                    let lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\r\n                    let column = originalOffset - offset - lineStartOffset;\r\n                    return new Position(lfCnt + 1, column + 1);\r\n                }\r\n                else {\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        return new Position(1, 1);\r\n    }\r\n    getValueInRange(range, eol) {\r\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\r\n            return '';\r\n        }\r\n        let startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\r\n        let endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\r\n        let value = this.getValueInRange2(startPosition, endPosition);\r\n        if (eol) {\r\n            if (eol !== this._EOL || !this._EOLNormalized) {\r\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n            }\r\n            if (eol === this.getEOL() && this._EOLNormalized) {\r\n                if (eol === '\\r\\n') {\r\n                }\r\n                return value;\r\n            }\r\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\r\n        }\r\n        return value;\r\n    }\r\n    getValueInRange2(startPosition, endPosition) {\r\n        if (startPosition.node === endPosition.node) {\r\n            let node = startPosition.node;\r\n            let buffer = this._buffers[node.piece.bufferIndex].buffer;\r\n            let startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\r\n        }\r\n        let x = startPosition.node;\r\n        let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n        let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (x === endPosition.node) {\r\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\r\n                break;\r\n            }\r\n            else {\r\n                ret += buffer.substr(startOffset, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    }\r\n    getLinesContent() {\r\n        let lines = [];\r\n        let linesLength = 0;\r\n        let currentLine = '';\r\n        let danglingCR = false;\r\n        this.iterate(this.root, node => {\r\n            if (node === SENTINEL) {\r\n                return true;\r\n            }\r\n            const piece = node.piece;\r\n            let pieceLength = piece.length;\r\n            if (pieceLength === 0) {\r\n                return true;\r\n            }\r\n            const buffer = this._buffers[piece.bufferIndex].buffer;\r\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n            const pieceStartLine = piece.start.line;\r\n            const pieceEndLine = piece.end.line;\r\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\r\n            if (danglingCR) {\r\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* LineFeed */) {\r\n                    // pretend the \\n was in the previous piece..\r\n                    pieceStartOffset++;\r\n                    pieceLength--;\r\n                }\r\n                lines[linesLength++] = currentLine;\r\n                currentLine = '';\r\n                danglingCR = false;\r\n                if (pieceLength === 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            if (pieceStartLine === pieceEndLine) {\r\n                // this piece has no new lines\r\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CarriageReturn */) {\r\n                    danglingCR = true;\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\r\n                }\r\n                else {\r\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\r\n                }\r\n                return true;\r\n            }\r\n            // add the text before the first line start in this piece\r\n            currentLine += (this._EOLNormalized\r\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\r\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n            lines[linesLength++] = currentLine;\r\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\r\n                currentLine = (this._EOLNormalized\r\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\r\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\r\n                lines[linesLength++] = currentLine;\r\n            }\r\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CarriageReturn */) {\r\n                danglingCR = true;\r\n                if (piece.end.column === 0) {\r\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\r\n                    linesLength--;\r\n                }\r\n                else {\r\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\r\n                }\r\n            }\r\n            else {\r\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\r\n            }\r\n            return true;\r\n        });\r\n        if (danglingCR) {\r\n            lines[linesLength++] = currentLine;\r\n            currentLine = '';\r\n        }\r\n        lines[linesLength++] = currentLine;\r\n        return lines;\r\n    }\r\n    getLength() {\r\n        return this._length;\r\n    }\r\n    getLineCount() {\r\n        return this._lineCnt;\r\n    }\r\n    getLineContent(lineNumber) {\r\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\r\n            return this._lastVisitedLine.value;\r\n        }\r\n        this._lastVisitedLine.lineNumber = lineNumber;\r\n        if (lineNumber === this._lineCnt) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\r\n        }\r\n        else if (this._EOLNormalized) {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\r\n        }\r\n        else {\r\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\r\n        }\r\n        return this._lastVisitedLine.value;\r\n    }\r\n    _getCharCode(nodePos) {\r\n        if (nodePos.remainder === nodePos.node.piece.length) {\r\n            // the char we want to fetch is at the head of next node.\r\n            let matchingNode = nodePos.node.next();\r\n            if (!matchingNode) {\r\n                return 0;\r\n            }\r\n            let buffer = this._buffers[matchingNode.piece.bufferIndex];\r\n            let startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\r\n            return buffer.buffer.charCodeAt(startOffset);\r\n        }\r\n        else {\r\n            let buffer = this._buffers[nodePos.node.piece.bufferIndex];\r\n            let startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\r\n            let targetOffset = startOffset + nodePos.remainder;\r\n            return buffer.buffer.charCodeAt(targetOffset);\r\n        }\r\n    }\r\n    getLineCharCode(lineNumber, index) {\r\n        let nodePos = this.nodeAt2(lineNumber, index + 1);\r\n        return this._getCharCode(nodePos);\r\n    }\r\n    getLineLength(lineNumber) {\r\n        if (lineNumber === this.getLineCount()) {\r\n            let startOffset = this.getOffsetAt(lineNumber, 1);\r\n            return this.getLength() - startOffset;\r\n        }\r\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\r\n    }\r\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\r\n        let buffer = this._buffers[node.piece.bufferIndex];\r\n        let startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\r\n        let start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\r\n        let end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\r\n        let m;\r\n        // Reset regex to search from the beginning\r\n        let ret = { line: 0, column: 0 };\r\n        let searchText;\r\n        let offsetInBuffer;\r\n        if (searcher._wordSeparators) {\r\n            searchText = buffer.buffer.substring(start, end);\r\n            offsetInBuffer = (offset) => offset + start;\r\n            searcher.reset(0);\r\n        }\r\n        else {\r\n            searchText = buffer.buffer;\r\n            offsetInBuffer = (offset) => offset;\r\n            searcher.reset(start);\r\n        }\r\n        do {\r\n            m = searcher.next(searchText);\r\n            if (m) {\r\n                if (offsetInBuffer(m.index) >= end) {\r\n                    return resultLen;\r\n                }\r\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\r\n                let lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\r\n                let retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\r\n                let retEndColumn = retStartColumn + m[0].length;\r\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\r\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\r\n                    return resultLen;\r\n                }\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    }\r\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\r\n        const result = [];\r\n        let resultLen = 0;\r\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\r\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\r\n        if (startPosition === null) {\r\n            return [];\r\n        }\r\n        let endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\r\n        if (endPosition === null) {\r\n            return [];\r\n        }\r\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        let end = this.positionInBuffer(endPosition.node, endPosition.remainder);\r\n        if (startPosition.node === endPosition.node) {\r\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n            return result;\r\n        }\r\n        let startLineNumber = searchRange.startLineNumber;\r\n        let currentNode = startPosition.node;\r\n        while (currentNode !== endPosition.node) {\r\n            let lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\r\n            if (lineBreakCnt >= 1) {\r\n                // last line break position\r\n                let lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\r\n                let startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\r\n                let nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\r\n                let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\r\n                if (resultLen >= limitResultCount) {\r\n                    return result;\r\n                }\r\n                startLineNumber += lineBreakCnt;\r\n            }\r\n            let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            // search for the remaining content\r\n            if (startLineNumber === searchRange.endLineNumber) {\r\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\r\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\r\n                return result;\r\n            }\r\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\r\n            if (resultLen >= limitResultCount) {\r\n                return result;\r\n            }\r\n            startLineNumber++;\r\n            startPosition = this.nodeAt2(startLineNumber, 1);\r\n            currentNode = startPosition.node;\r\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\r\n        }\r\n        if (startLineNumber === searchRange.endLineNumber) {\r\n            let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\r\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\r\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\r\n            return result;\r\n        }\r\n        let startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\r\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\r\n        return result;\r\n    }\r\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\r\n        const wordSeparators = searchData.wordSeparators;\r\n        if (!captureMatches && searchData.simpleSearch) {\r\n            const searchString = searchData.simpleSearch;\r\n            const searchStringLen = searchString.length;\r\n            const textLength = text.length;\r\n            let lastMatchIndex = -searchStringLen;\r\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\r\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\r\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\r\n                    if (resultLen >= limitResultCount) {\r\n                        return resultLen;\r\n                    }\r\n                }\r\n            }\r\n            return resultLen;\r\n        }\r\n        let m;\r\n        // Reset regex to search from the beginning\r\n        searcher.reset(0);\r\n        do {\r\n            m = searcher.next(text);\r\n            if (m) {\r\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\r\n                if (resultLen >= limitResultCount) {\r\n                    return resultLen;\r\n                }\r\n            }\r\n        } while (m);\r\n        return resultLen;\r\n    }\r\n    // #endregion\r\n    // #region Piece Table\r\n    insert(offset, value, eolNormalized = false) {\r\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (this.root !== SENTINEL) {\r\n            let { node, remainder, nodeStartOffset } = this.nodeAt(offset);\r\n            let piece = node.piece;\r\n            let bufferIndex = piece.bufferIndex;\r\n            let insertPosInBuffer = this.positionInBuffer(node, remainder);\r\n            if (node.piece.bufferIndex === 0 &&\r\n                piece.end.line === this._lastChangeBufferPos.line &&\r\n                piece.end.column === this._lastChangeBufferPos.column &&\r\n                (nodeStartOffset + piece.length === offset) &&\r\n                value.length < AverageBufferSize) {\r\n                // changed buffer\r\n                this.appendToNode(node, value);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (nodeStartOffset === offset) {\r\n                this.insertContentToNodeLeft(value, node);\r\n                this._searchCache.validate(offset);\r\n            }\r\n            else if (nodeStartOffset + node.piece.length > offset) {\r\n                // we are inserting into the middle of a node.\r\n                let nodesToDel = [];\r\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\r\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n                    let headOfRight = this.nodeCharCodeAt(node, remainder);\r\n                    if (headOfRight === 10 /** \\n */) {\r\n                        let newStart = { line: newRightPiece.start.line + 1, column: 0 };\r\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\r\n                        value += '\\n';\r\n                    }\r\n                }\r\n                // reuse node for content before insertion point.\r\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\r\n                    let tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\r\n                    if (tailOfLeft === 13 /** \\r */) {\r\n                        let previousPos = this.positionInBuffer(node, remainder - 1);\r\n                        this.deleteNodeTail(node, previousPos);\r\n                        value = '\\r' + value;\r\n                        if (node.piece.length === 0) {\r\n                            nodesToDel.push(node);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.deleteNodeTail(node, insertPosInBuffer);\r\n                    }\r\n                }\r\n                else {\r\n                    this.deleteNodeTail(node, insertPosInBuffer);\r\n                }\r\n                let newPieces = this.createNewPieces(value);\r\n                if (newRightPiece.length > 0) {\r\n                    this.rbInsertRight(node, newRightPiece);\r\n                }\r\n                let tmpNode = node;\r\n                for (let k = 0; k < newPieces.length; k++) {\r\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n                }\r\n                this.deleteNodes(nodesToDel);\r\n            }\r\n            else {\r\n                this.insertContentToNodeRight(value, node);\r\n            }\r\n        }\r\n        else {\r\n            // insert new node\r\n            let pieces = this.createNewPieces(value);\r\n            let node = this.rbInsertLeft(null, pieces[0]);\r\n            for (let k = 1; k < pieces.length; k++) {\r\n                node = this.rbInsertRight(node, pieces[k]);\r\n            }\r\n        }\r\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\r\n        this.computeBufferMetadata();\r\n    }\r\n    delete(offset, cnt) {\r\n        this._lastVisitedLine.lineNumber = 0;\r\n        this._lastVisitedLine.value = '';\r\n        if (cnt <= 0 || this.root === SENTINEL) {\r\n            return;\r\n        }\r\n        let startPosition = this.nodeAt(offset);\r\n        let endPosition = this.nodeAt(offset + cnt);\r\n        let startNode = startPosition.node;\r\n        let endNode = endPosition.node;\r\n        if (startNode === endNode) {\r\n            let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\r\n            let endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\r\n            if (startPosition.nodeStartOffset === offset) {\r\n                if (cnt === startNode.piece.length) { // delete node\r\n                    let next = startNode.next();\r\n                    rbDelete(this, startNode);\r\n                    this.validateCRLFWithPrevNode(next);\r\n                    this.computeBufferMetadata();\r\n                    return;\r\n                }\r\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\r\n                this._searchCache.validate(offset);\r\n                this.validateCRLFWithPrevNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\r\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\r\n                this.validateCRLFWithNextNode(startNode);\r\n                this.computeBufferMetadata();\r\n                return;\r\n            }\r\n            // delete content in the middle, this node will be splitted to nodes\r\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\r\n            this.computeBufferMetadata();\r\n            return;\r\n        }\r\n        let nodesToDel = [];\r\n        let startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\r\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\r\n        this._searchCache.validate(offset);\r\n        if (startNode.piece.length === 0) {\r\n            nodesToDel.push(startNode);\r\n        }\r\n        // update last touched node\r\n        let endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\r\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\r\n        if (endNode.piece.length === 0) {\r\n            nodesToDel.push(endNode);\r\n        }\r\n        // delete nodes in between\r\n        let secondNode = startNode.next();\r\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\r\n            nodesToDel.push(node);\r\n        }\r\n        let prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\r\n        this.deleteNodes(nodesToDel);\r\n        this.validateCRLFWithNextNode(prev);\r\n        this.computeBufferMetadata();\r\n    }\r\n    insertContentToNodeLeft(value, node) {\r\n        // we are inserting content to the beginning of node\r\n        let nodesToDel = [];\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\r\n            // move `\\n` to new node.\r\n            let piece = node.piece;\r\n            let newStart = { line: piece.start.line + 1, column: 0 };\r\n            let nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\r\n            node.piece = nPiece;\r\n            value += '\\n';\r\n            updateTreeMetadata(this, node, -1, -1);\r\n            if (node.piece.length === 0) {\r\n                nodesToDel.push(node);\r\n            }\r\n        }\r\n        let newPieces = this.createNewPieces(value);\r\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\r\n        for (let k = newPieces.length - 2; k >= 0; k--) {\r\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n        this.deleteNodes(nodesToDel);\r\n    }\r\n    insertContentToNodeRight(value, node) {\r\n        // we are inserting to the right of this node.\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            // move \\n to the new node.\r\n            value += '\\n';\r\n        }\r\n        let newPieces = this.createNewPieces(value);\r\n        let newNode = this.rbInsertRight(node, newPieces[0]);\r\n        let tmpNode = newNode;\r\n        for (let k = 1; k < newPieces.length; k++) {\r\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\r\n        }\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    }\r\n    positionInBuffer(node, remainder, ret) {\r\n        let piece = node.piece;\r\n        let bufferIndex = node.piece.bufferIndex;\r\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        let startOffset = lineStarts[piece.start.line] + piece.start.column;\r\n        let offset = startOffset + remainder;\r\n        // binary search offset between startOffset and endOffset\r\n        let low = piece.start.line;\r\n        let high = piece.end.line;\r\n        let mid = 0;\r\n        let midStop = 0;\r\n        let midStart = 0;\r\n        while (low <= high) {\r\n            mid = low + ((high - low) / 2) | 0;\r\n            midStart = lineStarts[mid];\r\n            if (mid === high) {\r\n                break;\r\n            }\r\n            midStop = lineStarts[mid + 1];\r\n            if (offset < midStart) {\r\n                high = mid - 1;\r\n            }\r\n            else if (offset >= midStop) {\r\n                low = mid + 1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (ret) {\r\n            ret.line = mid;\r\n            ret.column = offset - midStart;\r\n            return null;\r\n        }\r\n        return {\r\n            line: mid,\r\n            column: offset - midStart\r\n        };\r\n    }\r\n    getLineFeedCnt(bufferIndex, start, end) {\r\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\r\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\r\n        if (end.column === 0) {\r\n            return end.line - start.line;\r\n        }\r\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\r\n            return end.line - start.line;\r\n        }\r\n        let nextLineStartOffset = lineStarts[end.line + 1];\r\n        let endOffset = lineStarts[end.line] + end.column;\r\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\r\n            return end.line - start.line;\r\n        }\r\n        // endOffset + 1 === nextLineStartOffset\r\n        // character at endOffset is \\n, so we check the character before first\r\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\r\n        let previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\r\n        let buffer = this._buffers[bufferIndex].buffer;\r\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\r\n            return end.line - start.line + 1;\r\n        }\r\n        else {\r\n            return end.line - start.line;\r\n        }\r\n    }\r\n    offsetInBuffer(bufferIndex, cursor) {\r\n        let lineStarts = this._buffers[bufferIndex].lineStarts;\r\n        return lineStarts[cursor.line] + cursor.column;\r\n    }\r\n    deleteNodes(nodes) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            rbDelete(this, nodes[i]);\r\n        }\r\n    }\r\n    createNewPieces(text) {\r\n        if (text.length > AverageBufferSize) {\r\n            // the content is large, operations like substring, charCode becomes slow\r\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\r\n            let newPieces = [];\r\n            while (text.length > AverageBufferSize) {\r\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\r\n                let splitText;\r\n                if (lastChar === 13 /* CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\r\n                    // last character is \\r or a high surrogate => keep it back\r\n                    splitText = text.substring(0, AverageBufferSize - 1);\r\n                    text = text.substring(AverageBufferSize - 1);\r\n                }\r\n                else {\r\n                    splitText = text.substring(0, AverageBufferSize);\r\n                    text = text.substring(AverageBufferSize);\r\n                }\r\n                let lineStarts = createLineStartsFast(splitText);\r\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\r\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\r\n            }\r\n            let lineStarts = createLineStartsFast(text);\r\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\r\n            this._buffers.push(new StringBuffer(text, lineStarts));\r\n            return newPieces;\r\n        }\r\n        let startOffset = this._buffers[0].buffer.length;\r\n        const lineStarts = createLineStartsFast(text, false);\r\n        let start = this._lastChangeBufferPos;\r\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\r\n            && startOffset !== 0\r\n            && this.startWithLF(text)\r\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\r\n        ) {\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\r\n            start = this._lastChangeBufferPos;\r\n            for (let i = 0; i < lineStarts.length; i++) {\r\n                lineStarts[i] += startOffset + 1;\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += '_' + text;\r\n            startOffset += 1;\r\n        }\r\n        else {\r\n            if (startOffset !== 0) {\r\n                for (let i = 0; i < lineStarts.length; i++) {\r\n                    lineStarts[i] += startOffset;\r\n                }\r\n            }\r\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n            this._buffers[0].buffer += text;\r\n        }\r\n        const endOffset = this._buffers[0].buffer.length;\r\n        let endIndex = this._buffers[0].lineStarts.length - 1;\r\n        let endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\r\n        let endPos = { line: endIndex, column: endColumn };\r\n        let newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\r\n        this._lastChangeBufferPos = endPos;\r\n        return [newPiece];\r\n    }\r\n    getLineRawContent(lineNumber, endOffset = 0) {\r\n        let x = this.root;\r\n        let ret = '';\r\n        let cache = this._searchCache.get2(lineNumber);\r\n        if (cache) {\r\n            x = cache.node;\r\n            let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\r\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\r\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\r\n            }\r\n            else {\r\n                let accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\r\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\r\n            }\r\n        }\r\n        else {\r\n            let nodeStartOffset = 0;\r\n            const originalLineNumber = lineNumber;\r\n            while (x !== SENTINEL) {\r\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                    x = x.left;\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                    let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                    let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    nodeStartOffset += x.size_left;\r\n                    this._searchCache.set({\r\n                        node: x,\r\n                        nodeStartOffset,\r\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\r\n                    });\r\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\r\n                }\r\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                    let prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                    let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n                    let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\r\n                    break;\r\n                }\r\n                else {\r\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                    nodeStartOffset += x.size_left + x.piece.length;\r\n                    x = x.right;\r\n                }\r\n            }\r\n        }\r\n        // search in order, to find the node contains end column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            let buffer = this._buffers[x.piece.bufferIndex].buffer;\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                let accumulatedValue = this.getAccumulatedValue(x, 0);\r\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\r\n                return ret;\r\n            }\r\n            else {\r\n                let startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\r\n                ret += buffer.substr(startOffset, x.piece.length);\r\n            }\r\n            x = x.next();\r\n        }\r\n        return ret;\r\n    }\r\n    computeBufferMetadata() {\r\n        let x = this.root;\r\n        let lfCnt = 1;\r\n        let len = 0;\r\n        while (x !== SENTINEL) {\r\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\r\n            len += x.size_left + x.piece.length;\r\n            x = x.right;\r\n        }\r\n        this._lineCnt = lfCnt;\r\n        this._length = len;\r\n        this._searchCache.validate(this._length);\r\n    }\r\n    // #region node operations\r\n    getIndexOf(node, accumulatedValue) {\r\n        let piece = node.piece;\r\n        let pos = this.positionInBuffer(node, accumulatedValue);\r\n        let lineCnt = pos.line - piece.start.line;\r\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\r\n            // we are checking the end of this node, so a CRLF check is necessary.\r\n            let realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\r\n            if (realLineCnt !== lineCnt) {\r\n                // aha yes, CRLF\r\n                return { index: realLineCnt, remainder: 0 };\r\n            }\r\n        }\r\n        return { index: lineCnt, remainder: pos.column };\r\n    }\r\n    getAccumulatedValue(node, index) {\r\n        if (index < 0) {\r\n            return 0;\r\n        }\r\n        let piece = node.piece;\r\n        let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        let expectedLineStartIndex = piece.start.line + index + 1;\r\n        if (expectedLineStartIndex > piece.end.line) {\r\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n        else {\r\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\r\n        }\r\n    }\r\n    deleteNodeTail(node, pos) {\r\n        const piece = node.piece;\r\n        const originalLFCnt = piece.lineFeedCnt;\r\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        const newEnd = pos;\r\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\r\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        const lf_delta = newLineFeedCnt - originalLFCnt;\r\n        const size_delta = newEndOffset - originalEndOffset;\r\n        const newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    }\r\n    deleteNodeHead(node, pos) {\r\n        const piece = node.piece;\r\n        const originalLFCnt = piece.lineFeedCnt;\r\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        const newStart = pos;\r\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\r\n        const lf_delta = newLineFeedCnt - originalLFCnt;\r\n        const size_delta = originalStartOffset - newStartOffset;\r\n        const newLength = piece.length + size_delta;\r\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, size_delta, lf_delta);\r\n    }\r\n    shrinkNode(node, start, end) {\r\n        const piece = node.piece;\r\n        const originalStartPos = piece.start;\r\n        const originalEndPos = piece.end;\r\n        // old piece, originalStartPos, start\r\n        const oldLength = piece.length;\r\n        const oldLFCnt = piece.lineFeedCnt;\r\n        const newEnd = start;\r\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\r\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\r\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\r\n        // new right piece, end, originalEndPos\r\n        let newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\r\n        let newNode = this.rbInsertRight(node, newPiece);\r\n        this.validateCRLFWithPrevNode(newNode);\r\n    }\r\n    appendToNode(node, value) {\r\n        if (this.adjustCarriageReturnFromNext(value, node)) {\r\n            value += '\\n';\r\n        }\r\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\r\n        const startOffset = this._buffers[0].buffer.length;\r\n        this._buffers[0].buffer += value;\r\n        const lineStarts = createLineStartsFast(value, false);\r\n        for (let i = 0; i < lineStarts.length; i++) {\r\n            lineStarts[i] += startOffset;\r\n        }\r\n        if (hitCRLF) {\r\n            let prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\r\n            this._buffers[0].lineStarts.pop();\r\n            // _lastChangeBufferPos is already wrong\r\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\r\n        }\r\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\r\n        const endIndex = this._buffers[0].lineStarts.length - 1;\r\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\r\n        const newEnd = { line: endIndex, column: endColumn };\r\n        const newLength = node.piece.length + value.length;\r\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\r\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\r\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\r\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\r\n        this._lastChangeBufferPos = newEnd;\r\n        updateTreeMetadata(this, node, value.length, lf_delta);\r\n    }\r\n    nodeAt(offset) {\r\n        let x = this.root;\r\n        let cache = this._searchCache.get(offset);\r\n        if (cache) {\r\n            return {\r\n                node: cache.node,\r\n                nodeStartOffset: cache.nodeStartOffset,\r\n                remainder: offset - cache.nodeStartOffset\r\n            };\r\n        }\r\n        let nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.size_left > offset) {\r\n                x = x.left;\r\n            }\r\n            else if (x.size_left + x.piece.length >= offset) {\r\n                nodeStartOffset += x.size_left;\r\n                let ret = {\r\n                    node: x,\r\n                    remainder: offset - x.size_left,\r\n                    nodeStartOffset\r\n                };\r\n                this._searchCache.set(ret);\r\n                return ret;\r\n            }\r\n            else {\r\n                offset -= x.size_left + x.piece.length;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    nodeAt2(lineNumber, column) {\r\n        let x = this.root;\r\n        let nodeStartOffset = 0;\r\n        while (x !== SENTINEL) {\r\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\r\n                x = x.left;\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\r\n                let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                let accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\r\n                nodeStartOffset += x.size_left;\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\r\n                    nodeStartOffset\r\n                };\r\n            }\r\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\r\n                let prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\r\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\r\n                    return {\r\n                        node: x,\r\n                        remainder: prevAccumualtedValue + column - 1,\r\n                        nodeStartOffset\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length - prevAccumualtedValue;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\r\n                nodeStartOffset += x.size_left + x.piece.length;\r\n                x = x.right;\r\n            }\r\n        }\r\n        // search in order, to find the node contains position.column\r\n        x = x.next();\r\n        while (x !== SENTINEL) {\r\n            if (x.piece.lineFeedCnt > 0) {\r\n                let accumulatedValue = this.getAccumulatedValue(x, 0);\r\n                let nodeStartOffset = this.offsetOfNode(x);\r\n                return {\r\n                    node: x,\r\n                    remainder: Math.min(column - 1, accumulatedValue),\r\n                    nodeStartOffset\r\n                };\r\n            }\r\n            else {\r\n                if (x.piece.length >= column - 1) {\r\n                    let nodeStartOffset = this.offsetOfNode(x);\r\n                    return {\r\n                        node: x,\r\n                        remainder: column - 1,\r\n                        nodeStartOffset\r\n                    };\r\n                }\r\n                else {\r\n                    column -= x.piece.length;\r\n                }\r\n            }\r\n            x = x.next();\r\n        }\r\n        return null;\r\n    }\r\n    nodeCharCodeAt(node, offset) {\r\n        if (node.piece.lineFeedCnt < 1) {\r\n            return -1;\r\n        }\r\n        let buffer = this._buffers[node.piece.bufferIndex];\r\n        let newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\r\n        return buffer.buffer.charCodeAt(newOffset);\r\n    }\r\n    offsetOfNode(node) {\r\n        if (!node) {\r\n            return 0;\r\n        }\r\n        let pos = node.size_left;\r\n        while (node !== this.root) {\r\n            if (node.parent.right === node) {\r\n                pos += node.parent.size_left + node.parent.piece.length;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return pos;\r\n    }\r\n    // #endregion\r\n    // #region CRLF\r\n    shouldCheckCRLF() {\r\n        return !(this._EOLNormalized && this._EOL === '\\n');\r\n    }\r\n    startWithLF(val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(0) === 10;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        let piece = val.piece;\r\n        let lineStarts = this._buffers[piece.bufferIndex].lineStarts;\r\n        let line = piece.start.line;\r\n        let startOffset = lineStarts[line] + piece.start.column;\r\n        if (line === lineStarts.length - 1) {\r\n            // last line, so there is no line feed at the end of this line\r\n            return false;\r\n        }\r\n        let nextLineOffset = lineStarts[line + 1];\r\n        if (nextLineOffset > startOffset + 1) {\r\n            return false;\r\n        }\r\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\r\n    }\r\n    endWithCR(val) {\r\n        if (typeof val === 'string') {\r\n            return val.charCodeAt(val.length - 1) === 13;\r\n        }\r\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\r\n            return false;\r\n        }\r\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\r\n    }\r\n    validateCRLFWithPrevNode(nextNode) {\r\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\r\n            let node = nextNode.prev();\r\n            if (this.endWithCR(node)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    }\r\n    validateCRLFWithNextNode(node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\r\n            let nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                this.fixCRLF(node, nextNode);\r\n            }\r\n        }\r\n    }\r\n    fixCRLF(prev, next) {\r\n        let nodesToDel = [];\r\n        // update node\r\n        let lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\r\n        let newEnd;\r\n        if (prev.piece.end.column === 0) {\r\n            // it means, last line ends with \\r, not \\r\\n\r\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\r\n        }\r\n        else {\r\n            // \\r\\n\r\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\r\n        }\r\n        const prevNewLength = prev.piece.length - 1;\r\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\r\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\r\n        updateTreeMetadata(this, prev, -1, -1);\r\n        if (prev.piece.length === 0) {\r\n            nodesToDel.push(prev);\r\n        }\r\n        // update nextNode\r\n        let newStart = { line: next.piece.start.line + 1, column: 0 };\r\n        const newLength = next.piece.length - 1;\r\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\r\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\r\n        updateTreeMetadata(this, next, -1, -1);\r\n        if (next.piece.length === 0) {\r\n            nodesToDel.push(next);\r\n        }\r\n        // create new piece which contains \\r\\n\r\n        let pieces = this.createNewPieces('\\r\\n');\r\n        this.rbInsertRight(prev, pieces[0]);\r\n        // delete empty nodes\r\n        for (let i = 0; i < nodesToDel.length; i++) {\r\n            rbDelete(this, nodesToDel[i]);\r\n        }\r\n    }\r\n    adjustCarriageReturnFromNext(value, node) {\r\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\r\n            let nextNode = node.next();\r\n            if (this.startWithLF(nextNode)) {\r\n                // move `\\n` forward\r\n                value += '\\n';\r\n                if (nextNode.piece.length === 1) {\r\n                    rbDelete(this, nextNode);\r\n                }\r\n                else {\r\n                    const piece = nextNode.piece;\r\n                    const newStart = { line: piece.start.line + 1, column: 0 };\r\n                    const newLength = piece.length - 1;\r\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\r\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\r\n                    updateTreeMetadata(this, nextNode, -1, -1);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    // #endregion\r\n    // #endregion\r\n    // #region Tree operations\r\n    iterate(node, callback) {\r\n        if (node === SENTINEL) {\r\n            return callback(SENTINEL);\r\n        }\r\n        let leftRet = this.iterate(node.left, callback);\r\n        if (!leftRet) {\r\n            return leftRet;\r\n        }\r\n        return callback(node) && this.iterate(node.right, callback);\r\n    }\r\n    getNodeContent(node) {\r\n        if (node === SENTINEL) {\r\n            return '';\r\n        }\r\n        let buffer = this._buffers[node.piece.bufferIndex];\r\n        let currentContent;\r\n        let piece = node.piece;\r\n        let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        currentContent = buffer.buffer.substring(startOffset, endOffset);\r\n        return currentContent;\r\n    }\r\n    getPieceContent(piece) {\r\n        let buffer = this._buffers[piece.bufferIndex];\r\n        let startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\r\n        let endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\r\n        let currentContent = buffer.buffer.substring(startOffset, endOffset);\r\n        return currentContent;\r\n    }\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b    <----   a    b\r\n     *                         /\r\n     *                        z\r\n     */\r\n    rbInsertRight(node, p) {\r\n        let z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        let x = this.root;\r\n        if (x === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.right === SENTINEL) {\r\n            node.right = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            let nextNode = leftest(node.right);\r\n            nextNode.left = z;\r\n            z.parent = nextNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    }\r\n    /**\r\n     *      node              node\r\n     *     /  \\              /  \\\r\n     *    a   b     ---->   a    b\r\n     *                       \\\r\n     *                        z\r\n     */\r\n    rbInsertLeft(node, p) {\r\n        let z = new TreeNode(p, 1 /* Red */);\r\n        z.left = SENTINEL;\r\n        z.right = SENTINEL;\r\n        z.parent = SENTINEL;\r\n        z.size_left = 0;\r\n        z.lf_left = 0;\r\n        if (this.root === SENTINEL) {\r\n            this.root = z;\r\n            z.color = 0 /* Black */;\r\n        }\r\n        else if (node.left === SENTINEL) {\r\n            node.left = z;\r\n            z.parent = node;\r\n        }\r\n        else {\r\n            let prevNode = righttest(node.left); // a\r\n            prevNode.right = z;\r\n            z.parent = prevNode;\r\n        }\r\n        fixInsert(this, z);\r\n        return z;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}