{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from './cursorCommon.js';\nexport var AtomicTabMoveOperations = /*#__PURE__*/function () {\n  function AtomicTabMoveOperations() {\n    _classCallCheck(this, AtomicTabMoveOperations);\n  }\n\n  _createClass(AtomicTabMoveOperations, null, [{\n    key: \"whitespaceVisibleColumn\",\n\n    /**\r\n     * Get the visible column at the position. If we get to a non-whitespace character first\r\n     * or past the end of string then return -1.\r\n     *\r\n     * **Note** `position` and the return value are 0-based.\r\n     */\n    value: function whitespaceVisibleColumn(lineContent, position, tabSize) {\n      var lineLength = lineContent.length;\n      var visibleColumn = 0;\n      var prevTabStopPosition = -1;\n      var prevTabStopVisibleColumn = -1;\n\n      for (var i = 0; i < lineLength; i++) {\n        if (i === position) {\n          return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n\n        if (visibleColumn % tabSize === 0) {\n          prevTabStopPosition = i;\n          prevTabStopVisibleColumn = visibleColumn;\n        }\n\n        var chCode = lineContent.charCodeAt(i);\n\n        switch (chCode) {\n          case 32\n          /* Space */\n          :\n            visibleColumn += 1;\n            break;\n\n          case 9\n          /* Tab */\n          :\n            // Skip to the next multiple of tabSize.\n            visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n            break;\n\n          default:\n            return [-1, -1, -1];\n        }\n      }\n\n      if (position === lineLength) {\n        return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n      }\n\n      return [-1, -1, -1];\n    }\n    /**\r\n     * Return the position that should result from a move left, right or to the\r\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\r\n     * arrow key movements, nearest is used for mouse selection. It returns\r\n     * -1 if atomic tabs are not relevant and you should fall back to normal\r\n     * behaviour.\r\n     *\r\n     * **Note**: `position` and the return value are 0-based.\r\n     */\n\n  }, {\n    key: \"atomicPosition\",\n    value: function atomicPosition(lineContent, position, tabSize, direction) {\n      var lineLength = lineContent.length; // Get the 0-based visible column corresponding to the position, or return\n      // -1 if it is not in the initial whitespace.\n\n      var _AtomicTabMoveOperati = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize),\n          _AtomicTabMoveOperati2 = _slicedToArray(_AtomicTabMoveOperati, 3),\n          prevTabStopPosition = _AtomicTabMoveOperati2[0],\n          prevTabStopVisibleColumn = _AtomicTabMoveOperati2[1],\n          visibleColumn = _AtomicTabMoveOperati2[2];\n\n      if (visibleColumn === -1) {\n        return -1;\n      } // Is the output left or right of the current position. The case for nearest\n      // where it is the same as the current position is handled in the switch.\n\n\n      var left;\n\n      switch (direction) {\n        case 0\n        /* Left */\n        :\n          left = true;\n          break;\n\n        case 1\n        /* Right */\n        :\n          left = false;\n          break;\n\n        case 2\n        /* Nearest */\n        :\n          // The code below assumes the output position is either left or right\n          // of the input position. If it is the same, return immediately.\n          if (visibleColumn % tabSize === 0) {\n            return position;\n          } // Go to the nearest indentation.\n\n\n          left = visibleColumn % tabSize <= tabSize / 2;\n          break;\n      } // If going left, we can just use the info about the last tab stop position and\n      // last tab stop visible column that we computed in the first walk over the whitespace.\n\n\n      if (left) {\n        if (prevTabStopPosition === -1) {\n          return -1;\n        } // If the direction is left, we need to keep scanning right to ensure\n        // that targetVisibleColumn + tabSize is before non-whitespace.\n        // This is so that when we press left at the end of a partial\n        // indentation it only goes one character. For example '      foo' with\n        // tabSize 4, should jump from position 6 to position 5, not 4.\n\n\n        var _currentVisibleColumn = prevTabStopVisibleColumn;\n\n        for (var i = prevTabStopPosition; i < lineLength; ++i) {\n          if (_currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n            // It is a full indentation.\n            return prevTabStopPosition;\n          }\n\n          var chCode = lineContent.charCodeAt(i);\n\n          switch (chCode) {\n            case 32\n            /* Space */\n            :\n              _currentVisibleColumn += 1;\n              break;\n\n            case 9\n            /* Tab */\n            :\n              _currentVisibleColumn = CursorColumns.nextRenderTabStop(_currentVisibleColumn, tabSize);\n              break;\n\n            default:\n              return -1;\n          }\n        }\n\n        if (_currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n          return prevTabStopPosition;\n        } // It must have been a partial indentation.\n\n\n        return -1;\n      } // We are going right.\n\n\n      var targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize); // We can just continue from where whitespaceVisibleColumn got to.\n\n      var currentVisibleColumn = visibleColumn;\n\n      for (var _i = position; _i < lineLength; _i++) {\n        if (currentVisibleColumn === targetVisibleColumn) {\n          return _i;\n        }\n\n        var _chCode = lineContent.charCodeAt(_i);\n\n        switch (_chCode) {\n          case 32\n          /* Space */\n          :\n            currentVisibleColumn += 1;\n            break;\n\n          case 9\n          /* Tab */\n          :\n            currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n            break;\n\n          default:\n            return -1;\n        }\n      } // This condition handles when the target column is at the end of the line.\n\n\n      if (currentVisibleColumn === targetVisibleColumn) {\n        return lineLength;\n      }\n\n      return -1;\n    }\n  }]);\n\n  return AtomicTabMoveOperations;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/controller/cursorAtomicMoveOperations.js"],"names":["CursorColumns","AtomicTabMoveOperations","lineContent","position","tabSize","lineLength","length","visibleColumn","prevTabStopPosition","prevTabStopVisibleColumn","i","chCode","charCodeAt","nextRenderTabStop","direction","whitespaceVisibleColumn","left","currentVisibleColumn","targetVisibleColumn"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { CursorColumns } from './cursorCommon.js';\r\nexport class AtomicTabMoveOperations {\r\n    /**\r\n     * Get the visible column at the position. If we get to a non-whitespace character first\r\n     * or past the end of string then return -1.\r\n     *\r\n     * **Note** `position` and the return value are 0-based.\r\n     */\r\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\r\n        const lineLength = lineContent.length;\r\n        let visibleColumn = 0;\r\n        let prevTabStopPosition = -1;\r\n        let prevTabStopVisibleColumn = -1;\r\n        for (let i = 0; i < lineLength; i++) {\r\n            if (i === position) {\r\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\r\n            }\r\n            if (visibleColumn % tabSize === 0) {\r\n                prevTabStopPosition = i;\r\n                prevTabStopVisibleColumn = visibleColumn;\r\n            }\r\n            const chCode = lineContent.charCodeAt(i);\r\n            switch (chCode) {\r\n                case 32 /* Space */:\r\n                    visibleColumn += 1;\r\n                    break;\r\n                case 9 /* Tab */:\r\n                    // Skip to the next multiple of tabSize.\r\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\r\n                    break;\r\n                default:\r\n                    return [-1, -1, -1];\r\n            }\r\n        }\r\n        if (position === lineLength) {\r\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\r\n        }\r\n        return [-1, -1, -1];\r\n    }\r\n    /**\r\n     * Return the position that should result from a move left, right or to the\r\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\r\n     * arrow key movements, nearest is used for mouse selection. It returns\r\n     * -1 if atomic tabs are not relevant and you should fall back to normal\r\n     * behaviour.\r\n     *\r\n     * **Note**: `position` and the return value are 0-based.\r\n     */\r\n    static atomicPosition(lineContent, position, tabSize, direction) {\r\n        const lineLength = lineContent.length;\r\n        // Get the 0-based visible column corresponding to the position, or return\r\n        // -1 if it is not in the initial whitespace.\r\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\r\n        if (visibleColumn === -1) {\r\n            return -1;\r\n        }\r\n        // Is the output left or right of the current position. The case for nearest\r\n        // where it is the same as the current position is handled in the switch.\r\n        let left;\r\n        switch (direction) {\r\n            case 0 /* Left */:\r\n                left = true;\r\n                break;\r\n            case 1 /* Right */:\r\n                left = false;\r\n                break;\r\n            case 2 /* Nearest */:\r\n                // The code below assumes the output position is either left or right\r\n                // of the input position. If it is the same, return immediately.\r\n                if (visibleColumn % tabSize === 0) {\r\n                    return position;\r\n                }\r\n                // Go to the nearest indentation.\r\n                left = visibleColumn % tabSize <= (tabSize / 2);\r\n                break;\r\n        }\r\n        // If going left, we can just use the info about the last tab stop position and\r\n        // last tab stop visible column that we computed in the first walk over the whitespace.\r\n        if (left) {\r\n            if (prevTabStopPosition === -1) {\r\n                return -1;\r\n            }\r\n            // If the direction is left, we need to keep scanning right to ensure\r\n            // that targetVisibleColumn + tabSize is before non-whitespace.\r\n            // This is so that when we press left at the end of a partial\r\n            // indentation it only goes one character. For example '      foo' with\r\n            // tabSize 4, should jump from position 6 to position 5, not 4.\r\n            let currentVisibleColumn = prevTabStopVisibleColumn;\r\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\r\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\r\n                    // It is a full indentation.\r\n                    return prevTabStopPosition;\r\n                }\r\n                const chCode = lineContent.charCodeAt(i);\r\n                switch (chCode) {\r\n                    case 32 /* Space */:\r\n                        currentVisibleColumn += 1;\r\n                        break;\r\n                    case 9 /* Tab */:\r\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\r\n                        break;\r\n                    default:\r\n                        return -1;\r\n                }\r\n            }\r\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\r\n                return prevTabStopPosition;\r\n            }\r\n            // It must have been a partial indentation.\r\n            return -1;\r\n        }\r\n        // We are going right.\r\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\r\n        // We can just continue from where whitespaceVisibleColumn got to.\r\n        let currentVisibleColumn = visibleColumn;\r\n        for (let i = position; i < lineLength; i++) {\r\n            if (currentVisibleColumn === targetVisibleColumn) {\r\n                return i;\r\n            }\r\n            const chCode = lineContent.charCodeAt(i);\r\n            switch (chCode) {\r\n                case 32 /* Space */:\r\n                    currentVisibleColumn += 1;\r\n                    break;\r\n                case 9 /* Tab */:\r\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\r\n                    break;\r\n                default:\r\n                    return -1;\r\n            }\r\n        }\r\n        // This condition handles when the target column is at the end of the line.\r\n        if (currentVisibleColumn === targetVisibleColumn) {\r\n            return lineLength;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}