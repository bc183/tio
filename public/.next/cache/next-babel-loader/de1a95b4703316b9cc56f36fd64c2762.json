{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../core/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { TokenizationRegistry } from '../modes.js';\nimport { nullTokenize2 } from '../modes/nullMode.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\nimport * as platform from '../../../base/common/platform.js';\nexport var TokenizationStateStore = /*#__PURE__*/function () {\n  function TokenizationStateStore() {\n    _classCallCheck(this, TokenizationStateStore);\n\n    this._beginState = [];\n    this._valid = [];\n    this._len = 0;\n    this._invalidLineStartIndex = 0;\n  }\n\n  _createClass(TokenizationStateStore, [{\n    key: \"_reset\",\n    value: function _reset(initialState) {\n      this._beginState = [];\n      this._valid = [];\n      this._len = 0;\n      this._invalidLineStartIndex = 0;\n\n      if (initialState) {\n        this._setBeginState(0, initialState);\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(initialState) {\n      this._reset(initialState);\n    }\n  }, {\n    key: \"_invalidateLine\",\n    value: function _invalidateLine(lineIndex) {\n      if (lineIndex < this._len) {\n        this._valid[lineIndex] = false;\n      }\n\n      if (lineIndex < this._invalidLineStartIndex) {\n        this._invalidLineStartIndex = lineIndex;\n      }\n    }\n  }, {\n    key: \"_isValid\",\n    value: function _isValid(lineIndex) {\n      if (lineIndex < this._len) {\n        return this._valid[lineIndex];\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getBeginState\",\n    value: function getBeginState(lineIndex) {\n      if (lineIndex < this._len) {\n        return this._beginState[lineIndex];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_ensureLine\",\n    value: function _ensureLine(lineIndex) {\n      while (lineIndex >= this._len) {\n        this._beginState[this._len] = null;\n        this._valid[this._len] = false;\n        this._len++;\n      }\n    }\n  }, {\n    key: \"_deleteLines\",\n    value: function _deleteLines(start, deleteCount) {\n      if (deleteCount === 0) {\n        return;\n      }\n\n      if (start + deleteCount > this._len) {\n        deleteCount = this._len - start;\n      }\n\n      this._beginState.splice(start, deleteCount);\n\n      this._valid.splice(start, deleteCount);\n\n      this._len -= deleteCount;\n    }\n  }, {\n    key: \"_insertLines\",\n    value: function _insertLines(insertIndex, insertCount) {\n      if (insertCount === 0) {\n        return;\n      }\n\n      var beginState = [];\n      var valid = [];\n\n      for (var i = 0; i < insertCount; i++) {\n        beginState[i] = null;\n        valid[i] = false;\n      }\n\n      this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\n      this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\n      this._len += insertCount;\n    }\n  }, {\n    key: \"_setValid\",\n    value: function _setValid(lineIndex, valid) {\n      this._ensureLine(lineIndex);\n\n      this._valid[lineIndex] = valid;\n    }\n  }, {\n    key: \"_setBeginState\",\n    value: function _setBeginState(lineIndex, beginState) {\n      this._ensureLine(lineIndex);\n\n      this._beginState[lineIndex] = beginState;\n    }\n  }, {\n    key: \"setEndState\",\n    value: function setEndState(linesLength, lineIndex, endState) {\n      this._setValid(lineIndex, true);\n\n      this._invalidLineStartIndex = lineIndex + 1; // Check if this was the last line\n\n      if (lineIndex === linesLength - 1) {\n        return;\n      } // Check if the end state has changed\n\n\n      var previousEndState = this.getBeginState(lineIndex + 1);\n\n      if (previousEndState === null || !endState.equals(previousEndState)) {\n        this._setBeginState(lineIndex + 1, endState);\n\n        this._invalidateLine(lineIndex + 1);\n\n        return;\n      } // Perhaps we can skip tokenizing some lines...\n\n\n      var i = lineIndex + 1;\n\n      while (i < linesLength) {\n        if (!this._isValid(i)) {\n          break;\n        }\n\n        i++;\n      }\n\n      this._invalidLineStartIndex = i;\n    }\n  }, {\n    key: \"setFakeTokens\",\n    value: function setFakeTokens(lineIndex) {\n      this._setValid(lineIndex, false);\n    } //#region Editing\n\n  }, {\n    key: \"applyEdits\",\n    value: function applyEdits(range, eolCount) {\n      var deletingLinesCnt = range.endLineNumber - range.startLineNumber;\n      var insertingLinesCnt = eolCount;\n      var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n\n      for (var j = editingLinesCnt; j >= 0; j--) {\n        this._invalidateLine(range.startLineNumber + j - 1);\n      }\n\n      this._acceptDeleteRange(range);\n\n      this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\n    }\n  }, {\n    key: \"_acceptDeleteRange\",\n    value: function _acceptDeleteRange(range) {\n      var firstLineIndex = range.startLineNumber - 1;\n\n      if (firstLineIndex >= this._len) {\n        return;\n      }\n\n      this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n  }, {\n    key: \"_acceptInsertText\",\n    value: function _acceptInsertText(position, eolCount) {\n      var lineIndex = position.lineNumber - 1;\n\n      if (lineIndex >= this._len) {\n        return;\n      }\n\n      this._insertLines(position.lineNumber, eolCount);\n    }\n  }, {\n    key: \"invalidLineStartIndex\",\n    get: function get() {\n      return this._invalidLineStartIndex;\n    }\n  }]);\n\n  return TokenizationStateStore;\n}();\nexport var TextModelTokenization = /*#__PURE__*/function (_Disposable) {\n  _inherits(TextModelTokenization, _Disposable);\n\n  var _super = _createSuper(TextModelTokenization);\n\n  function TextModelTokenization(textModel) {\n    var _this;\n\n    _classCallCheck(this, TextModelTokenization);\n\n    _this = _super.call(this);\n    _this._isDisposed = false;\n    _this._textModel = textModel;\n    _this._tokenizationStateStore = new TokenizationStateStore();\n    _this._tokenizationSupport = null;\n\n    _this._register(TokenizationRegistry.onDidChange(function (e) {\n      var languageIdentifier = _this._textModel.getLanguageIdentifier();\n\n      if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\n        return;\n      }\n\n      _this._resetTokenizationState();\n\n      _this._textModel.clearTokens();\n    }));\n\n    _this._register(_this._textModel.onDidChangeRawContentFast(function (e) {\n      if (e.containsEvent(1\n      /* Flush */\n      )) {\n        _this._resetTokenizationState();\n\n        return;\n      }\n    }));\n\n    _this._register(_this._textModel.onDidChangeContentFast(function (e) {\n      for (var i = 0, len = e.changes.length; i < len; i++) {\n        var change = e.changes[i];\n\n        var _countEOL = countEOL(change.text),\n            _countEOL2 = _slicedToArray(_countEOL, 1),\n            eolCount = _countEOL2[0];\n\n        _this._tokenizationStateStore.applyEdits(change.range, eolCount);\n      }\n\n      _this._beginBackgroundTokenization();\n    }));\n\n    _this._register(_this._textModel.onDidChangeAttached(function () {\n      _this._beginBackgroundTokenization();\n    }));\n\n    _this._register(_this._textModel.onDidChangeLanguage(function () {\n      _this._resetTokenizationState();\n\n      _this._textModel.clearTokens();\n    }));\n\n    _this._resetTokenizationState();\n\n    return _this;\n  }\n\n  _createClass(TextModelTokenization, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._isDisposed = true;\n\n      _get(_getPrototypeOf(TextModelTokenization.prototype), \"dispose\", this).call(this);\n    }\n  }, {\n    key: \"_resetTokenizationState\",\n    value: function _resetTokenizationState() {\n      var _initializeTokenizati = initializeTokenization(this._textModel),\n          _initializeTokenizati2 = _slicedToArray(_initializeTokenizati, 2),\n          tokenizationSupport = _initializeTokenizati2[0],\n          initialState = _initializeTokenizati2[1];\n\n      this._tokenizationSupport = tokenizationSupport;\n\n      this._tokenizationStateStore.flush(initialState);\n\n      this._beginBackgroundTokenization();\n    }\n  }, {\n    key: \"_beginBackgroundTokenization\",\n    value: function _beginBackgroundTokenization() {\n      var _this2 = this;\n\n      if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\n        platform.setImmediate(function () {\n          if (_this2._isDisposed) {\n            // disposed in the meantime\n            return;\n          }\n\n          _this2._revalidateTokensNow();\n        });\n      }\n    }\n  }, {\n    key: \"_revalidateTokensNow\",\n    value: function _revalidateTokensNow() {\n      var toLineNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._textModel.getLineCount();\n      var MAX_ALLOWED_TIME = 1;\n      var builder = new MultilineTokensBuilder();\n      var sw = StopWatch.create(false);\n\n      while (this._hasLinesToTokenize()) {\n        if (sw.elapsed() > MAX_ALLOWED_TIME) {\n          // Stop if MAX_ALLOWED_TIME is reached\n          break;\n        }\n\n        var tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n        if (tokenizedLineNumber >= toLineNumber) {\n          break;\n        }\n      }\n\n      this._beginBackgroundTokenization();\n\n      this._textModel.setTokens(builder.tokens);\n    }\n  }, {\n    key: \"tokenizeViewport\",\n    value: function tokenizeViewport(startLineNumber, endLineNumber) {\n      var builder = new MultilineTokensBuilder();\n\n      this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n\n      this._textModel.setTokens(builder.tokens);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._resetTokenizationState();\n\n      this._textModel.clearTokens();\n    }\n  }, {\n    key: \"forceTokenization\",\n    value: function forceTokenization(lineNumber) {\n      var builder = new MultilineTokensBuilder();\n\n      this._updateTokensUntilLine(builder, lineNumber);\n\n      this._textModel.setTokens(builder.tokens);\n    }\n  }, {\n    key: \"isCheapToTokenize\",\n    value: function isCheapToTokenize(lineNumber) {\n      if (!this._tokenizationSupport) {\n        return true;\n      }\n\n      var firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n      if (lineNumber > firstInvalidLineNumber) {\n        return false;\n      }\n\n      if (lineNumber < firstInvalidLineNumber) {\n        return true;\n      }\n\n      if (this._textModel.getLineLength(lineNumber) < 2048\n      /* CHEAP_TOKENIZATION_LENGTH_LIMIT */\n      ) {\n          return true;\n        }\n\n      return false;\n    }\n  }, {\n    key: \"_hasLinesToTokenize\",\n    value: function _hasLinesToTokenize() {\n      if (!this._tokenizationSupport) {\n        return false;\n      }\n\n      return this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount();\n    }\n  }, {\n    key: \"_tokenizeOneInvalidLine\",\n    value: function _tokenizeOneInvalidLine(builder) {\n      if (!this._hasLinesToTokenize()) {\n        return this._textModel.getLineCount() + 1;\n      }\n\n      var lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n\n      this._updateTokensUntilLine(builder, lineNumber);\n\n      return lineNumber;\n    }\n  }, {\n    key: \"_updateTokensUntilLine\",\n    value: function _updateTokensUntilLine(builder, lineNumber) {\n      if (!this._tokenizationSupport) {\n        return;\n      }\n\n      var languageIdentifier = this._textModel.getLanguageIdentifier();\n\n      var linesLength = this._textModel.getLineCount();\n\n      var endLineIndex = lineNumber - 1; // Validate all states up to and including endLineIndex\n\n      for (var lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n        var text = this._textModel.getLineContent(lineIndex + 1);\n\n        var lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n\n        var r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, lineStartState);\n        builder.add(lineIndex + 1, r.tokens);\n\n        this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n\n        lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n      }\n    }\n  }, {\n    key: \"_tokenizeViewport\",\n    value: function _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n      if (!this._tokenizationSupport) {\n        // nothing to do\n        return;\n      }\n\n      if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n        // nothing to do\n        return;\n      }\n\n      if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n        // tokenization has reached the viewport start...\n        this._updateTokensUntilLine(builder, endLineNumber);\n\n        return;\n      }\n\n      var nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n\n      var fakeLines = [];\n      var initialState = null;\n\n      for (var i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\n        var newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\n        if (newNonWhitespaceIndex === 0) {\n          continue;\n        }\n\n        if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n          initialState = this._tokenizationStateStore.getBeginState(i - 1);\n\n          if (initialState) {\n            break;\n          }\n\n          fakeLines.push(this._textModel.getLineContent(i));\n          nonWhitespaceColumn = newNonWhitespaceIndex;\n        }\n      }\n\n      if (!initialState) {\n        initialState = this._tokenizationSupport.getInitialState();\n      }\n\n      var languageIdentifier = this._textModel.getLanguageIdentifier();\n\n      var state = initialState;\n\n      for (var _i = fakeLines.length - 1; _i >= 0; _i--) {\n        var r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[_i], false, state);\n        state = r.endState;\n      }\n\n      for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n        var text = this._textModel.getLineContent(lineNumber);\n\n        var _r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, state);\n\n        builder.add(lineNumber, _r.tokens);\n\n        this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\n\n        state = _r.endState;\n      }\n    }\n  }]);\n\n  return TextModelTokenization;\n}(Disposable);\n\nfunction initializeTokenization(textModel) {\n  var languageIdentifier = textModel.getLanguageIdentifier();\n  var tokenizationSupport = textModel.isTooLargeForTokenization() ? null : TokenizationRegistry.get(languageIdentifier.language);\n  var initialState = null;\n\n  if (tokenizationSupport) {\n    try {\n      initialState = tokenizationSupport.getInitialState();\n    } catch (e) {\n      onUnexpectedError(e);\n      tokenizationSupport = null;\n    }\n  }\n\n  return [tokenizationSupport, initialState];\n}\n\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, hasEOL, state) {\n  var r = null;\n\n  if (tokenizationSupport) {\n    try {\n      r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\n    } catch (e) {\n      onUnexpectedError(e);\n    }\n  }\n\n  if (!r) {\n    r = nullTokenize2(languageIdentifier.id, text, state, 0);\n  }\n\n  LineTokens.convertToEndOffset(r.tokens, text.length);\n  return r;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js"],"names":["arrays","onUnexpectedError","LineTokens","Position","TokenizationRegistry","nullTokenize2","Disposable","StopWatch","MultilineTokensBuilder","countEOL","platform","TokenizationStateStore","_beginState","_valid","_len","_invalidLineStartIndex","initialState","_setBeginState","_reset","lineIndex","start","deleteCount","splice","insertIndex","insertCount","beginState","valid","i","arrayInsert","_ensureLine","linesLength","endState","_setValid","previousEndState","getBeginState","equals","_invalidateLine","_isValid","range","eolCount","deletingLinesCnt","endLineNumber","startLineNumber","insertingLinesCnt","editingLinesCnt","Math","min","j","_acceptDeleteRange","_acceptInsertText","startColumn","firstLineIndex","_deleteLines","position","lineNumber","_insertLines","TextModelTokenization","textModel","_isDisposed","_textModel","_tokenizationStateStore","_tokenizationSupport","_register","onDidChange","e","languageIdentifier","getLanguageIdentifier","changedLanguages","indexOf","language","_resetTokenizationState","clearTokens","onDidChangeRawContentFast","containsEvent","onDidChangeContentFast","len","changes","length","change","text","applyEdits","_beginBackgroundTokenization","onDidChangeAttached","onDidChangeLanguage","initializeTokenization","tokenizationSupport","flush","isAttachedToEditor","_hasLinesToTokenize","setImmediate","_revalidateTokensNow","toLineNumber","getLineCount","MAX_ALLOWED_TIME","builder","sw","create","elapsed","tokenizedLineNumber","_tokenizeOneInvalidLine","setTokens","tokens","_tokenizeViewport","_updateTokensUntilLine","firstInvalidLineNumber","invalidLineStartIndex","getLineLength","endLineIndex","getLineContent","lineStartState","r","safeTokenize","add","setEndState","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","push","getInitialState","state","setFakeTokens","isTooLargeForTokenization","get","hasEOL","tokenize2","clone","id","convertToEndOffset"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as arrays from '../../../base/common/arrays.js';\r\nimport { onUnexpectedError } from '../../../base/common/errors.js';\r\nimport { LineTokens } from '../core/lineTokens.js';\r\nimport { Position } from '../core/position.js';\r\nimport { TokenizationRegistry } from '../modes.js';\r\nimport { nullTokenize2 } from '../modes/nullMode.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport { StopWatch } from '../../../base/common/stopwatch.js';\r\nimport { MultilineTokensBuilder, countEOL } from './tokensStore.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nexport class TokenizationStateStore {\r\n    constructor() {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n    }\r\n    _reset(initialState) {\r\n        this._beginState = [];\r\n        this._valid = [];\r\n        this._len = 0;\r\n        this._invalidLineStartIndex = 0;\r\n        if (initialState) {\r\n            this._setBeginState(0, initialState);\r\n        }\r\n    }\r\n    flush(initialState) {\r\n        this._reset(initialState);\r\n    }\r\n    get invalidLineStartIndex() {\r\n        return this._invalidLineStartIndex;\r\n    }\r\n    _invalidateLine(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            this._valid[lineIndex] = false;\r\n        }\r\n        if (lineIndex < this._invalidLineStartIndex) {\r\n            this._invalidLineStartIndex = lineIndex;\r\n        }\r\n    }\r\n    _isValid(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._valid[lineIndex];\r\n        }\r\n        return false;\r\n    }\r\n    getBeginState(lineIndex) {\r\n        if (lineIndex < this._len) {\r\n            return this._beginState[lineIndex];\r\n        }\r\n        return null;\r\n    }\r\n    _ensureLine(lineIndex) {\r\n        while (lineIndex >= this._len) {\r\n            this._beginState[this._len] = null;\r\n            this._valid[this._len] = false;\r\n            this._len++;\r\n        }\r\n    }\r\n    _deleteLines(start, deleteCount) {\r\n        if (deleteCount === 0) {\r\n            return;\r\n        }\r\n        if (start + deleteCount > this._len) {\r\n            deleteCount = this._len - start;\r\n        }\r\n        this._beginState.splice(start, deleteCount);\r\n        this._valid.splice(start, deleteCount);\r\n        this._len -= deleteCount;\r\n    }\r\n    _insertLines(insertIndex, insertCount) {\r\n        if (insertCount === 0) {\r\n            return;\r\n        }\r\n        let beginState = [];\r\n        let valid = [];\r\n        for (let i = 0; i < insertCount; i++) {\r\n            beginState[i] = null;\r\n            valid[i] = false;\r\n        }\r\n        this._beginState = arrays.arrayInsert(this._beginState, insertIndex, beginState);\r\n        this._valid = arrays.arrayInsert(this._valid, insertIndex, valid);\r\n        this._len += insertCount;\r\n    }\r\n    _setValid(lineIndex, valid) {\r\n        this._ensureLine(lineIndex);\r\n        this._valid[lineIndex] = valid;\r\n    }\r\n    _setBeginState(lineIndex, beginState) {\r\n        this._ensureLine(lineIndex);\r\n        this._beginState[lineIndex] = beginState;\r\n    }\r\n    setEndState(linesLength, lineIndex, endState) {\r\n        this._setValid(lineIndex, true);\r\n        this._invalidLineStartIndex = lineIndex + 1;\r\n        // Check if this was the last line\r\n        if (lineIndex === linesLength - 1) {\r\n            return;\r\n        }\r\n        // Check if the end state has changed\r\n        const previousEndState = this.getBeginState(lineIndex + 1);\r\n        if (previousEndState === null || !endState.equals(previousEndState)) {\r\n            this._setBeginState(lineIndex + 1, endState);\r\n            this._invalidateLine(lineIndex + 1);\r\n            return;\r\n        }\r\n        // Perhaps we can skip tokenizing some lines...\r\n        let i = lineIndex + 1;\r\n        while (i < linesLength) {\r\n            if (!this._isValid(i)) {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        this._invalidLineStartIndex = i;\r\n    }\r\n    setFakeTokens(lineIndex) {\r\n        this._setValid(lineIndex, false);\r\n    }\r\n    //#region Editing\r\n    applyEdits(range, eolCount) {\r\n        const deletingLinesCnt = range.endLineNumber - range.startLineNumber;\r\n        const insertingLinesCnt = eolCount;\r\n        const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\r\n        for (let j = editingLinesCnt; j >= 0; j--) {\r\n            this._invalidateLine(range.startLineNumber + j - 1);\r\n        }\r\n        this._acceptDeleteRange(range);\r\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount);\r\n    }\r\n    _acceptDeleteRange(range) {\r\n        const firstLineIndex = range.startLineNumber - 1;\r\n        if (firstLineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n    }\r\n    _acceptInsertText(position, eolCount) {\r\n        const lineIndex = position.lineNumber - 1;\r\n        if (lineIndex >= this._len) {\r\n            return;\r\n        }\r\n        this._insertLines(position.lineNumber, eolCount);\r\n    }\r\n}\r\nexport class TextModelTokenization extends Disposable {\r\n    constructor(textModel) {\r\n        super();\r\n        this._isDisposed = false;\r\n        this._textModel = textModel;\r\n        this._tokenizationStateStore = new TokenizationStateStore();\r\n        this._tokenizationSupport = null;\r\n        this._register(TokenizationRegistry.onDidChange((e) => {\r\n            const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n            if (e.changedLanguages.indexOf(languageIdentifier.language) === -1) {\r\n                return;\r\n            }\r\n            this._resetTokenizationState();\r\n            this._textModel.clearTokens();\r\n        }));\r\n        this._register(this._textModel.onDidChangeRawContentFast((e) => {\r\n            if (e.containsEvent(1 /* Flush */)) {\r\n                this._resetTokenizationState();\r\n                return;\r\n            }\r\n        }));\r\n        this._register(this._textModel.onDidChangeContentFast((e) => {\r\n            for (let i = 0, len = e.changes.length; i < len; i++) {\r\n                const change = e.changes[i];\r\n                const [eolCount] = countEOL(change.text);\r\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\r\n            }\r\n            this._beginBackgroundTokenization();\r\n        }));\r\n        this._register(this._textModel.onDidChangeAttached(() => {\r\n            this._beginBackgroundTokenization();\r\n        }));\r\n        this._register(this._textModel.onDidChangeLanguage(() => {\r\n            this._resetTokenizationState();\r\n            this._textModel.clearTokens();\r\n        }));\r\n        this._resetTokenizationState();\r\n    }\r\n    dispose() {\r\n        this._isDisposed = true;\r\n        super.dispose();\r\n    }\r\n    _resetTokenizationState() {\r\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel);\r\n        this._tokenizationSupport = tokenizationSupport;\r\n        this._tokenizationStateStore.flush(initialState);\r\n        this._beginBackgroundTokenization();\r\n    }\r\n    _beginBackgroundTokenization() {\r\n        if (this._textModel.isAttachedToEditor() && this._hasLinesToTokenize()) {\r\n            platform.setImmediate(() => {\r\n                if (this._isDisposed) {\r\n                    // disposed in the meantime\r\n                    return;\r\n                }\r\n                this._revalidateTokensNow();\r\n            });\r\n        }\r\n    }\r\n    _revalidateTokensNow(toLineNumber = this._textModel.getLineCount()) {\r\n        const MAX_ALLOWED_TIME = 1;\r\n        const builder = new MultilineTokensBuilder();\r\n        const sw = StopWatch.create(false);\r\n        while (this._hasLinesToTokenize()) {\r\n            if (sw.elapsed() > MAX_ALLOWED_TIME) {\r\n                // Stop if MAX_ALLOWED_TIME is reached\r\n                break;\r\n            }\r\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\r\n            if (tokenizedLineNumber >= toLineNumber) {\r\n                break;\r\n            }\r\n        }\r\n        this._beginBackgroundTokenization();\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    tokenizeViewport(startLineNumber, endLineNumber) {\r\n        const builder = new MultilineTokensBuilder();\r\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    reset() {\r\n        this._resetTokenizationState();\r\n        this._textModel.clearTokens();\r\n    }\r\n    forceTokenization(lineNumber) {\r\n        const builder = new MultilineTokensBuilder();\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        this._textModel.setTokens(builder.tokens);\r\n    }\r\n    isCheapToTokenize(lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return true;\r\n        }\r\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        if (lineNumber > firstInvalidLineNumber) {\r\n            return false;\r\n        }\r\n        if (lineNumber < firstInvalidLineNumber) {\r\n            return true;\r\n        }\r\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _hasLinesToTokenize() {\r\n        if (!this._tokenizationSupport) {\r\n            return false;\r\n        }\r\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\r\n    }\r\n    _tokenizeOneInvalidLine(builder) {\r\n        if (!this._hasLinesToTokenize()) {\r\n            return this._textModel.getLineCount() + 1;\r\n        }\r\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\r\n        this._updateTokensUntilLine(builder, lineNumber);\r\n        return lineNumber;\r\n    }\r\n    _updateTokensUntilLine(builder, lineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            return;\r\n        }\r\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        const linesLength = this._textModel.getLineCount();\r\n        const endLineIndex = lineNumber - 1;\r\n        // Validate all states up to and including endLineIndex\r\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\r\n            const text = this._textModel.getLineContent(lineIndex + 1);\r\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\r\n            const r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, lineStartState);\r\n            builder.add(lineIndex + 1, r.tokens);\r\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\r\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\r\n        }\r\n    }\r\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\r\n        if (!this._tokenizationSupport) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // nothing to do\r\n            return;\r\n        }\r\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\r\n            // tokenization has reached the viewport start...\r\n            this._updateTokensUntilLine(builder, endLineNumber);\r\n            return;\r\n        }\r\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\r\n        let fakeLines = [];\r\n        let initialState = null;\r\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 0 && i >= 1; i--) {\r\n            let newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\r\n            if (newNonWhitespaceIndex === 0) {\r\n                continue;\r\n            }\r\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\r\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\r\n                if (initialState) {\r\n                    break;\r\n                }\r\n                fakeLines.push(this._textModel.getLineContent(i));\r\n                nonWhitespaceColumn = newNonWhitespaceIndex;\r\n            }\r\n        }\r\n        if (!initialState) {\r\n            initialState = this._tokenizationSupport.getInitialState();\r\n        }\r\n        const languageIdentifier = this._textModel.getLanguageIdentifier();\r\n        let state = initialState;\r\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\r\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, fakeLines[i], false, state);\r\n            state = r.endState;\r\n        }\r\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\r\n            let text = this._textModel.getLineContent(lineNumber);\r\n            let r = safeTokenize(languageIdentifier, this._tokenizationSupport, text, true, state);\r\n            builder.add(lineNumber, r.tokens);\r\n            this._tokenizationStateStore.setFakeTokens(lineNumber - 1);\r\n            state = r.endState;\r\n        }\r\n    }\r\n}\r\nfunction initializeTokenization(textModel) {\r\n    const languageIdentifier = textModel.getLanguageIdentifier();\r\n    let tokenizationSupport = (textModel.isTooLargeForTokenization()\r\n        ? null\r\n        : TokenizationRegistry.get(languageIdentifier.language));\r\n    let initialState = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            initialState = tokenizationSupport.getInitialState();\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n            tokenizationSupport = null;\r\n        }\r\n    }\r\n    return [tokenizationSupport, initialState];\r\n}\r\nfunction safeTokenize(languageIdentifier, tokenizationSupport, text, hasEOL, state) {\r\n    let r = null;\r\n    if (tokenizationSupport) {\r\n        try {\r\n            r = tokenizationSupport.tokenize2(text, hasEOL, state.clone(), 0);\r\n        }\r\n        catch (e) {\r\n            onUnexpectedError(e);\r\n        }\r\n    }\r\n    if (!r) {\r\n        r = nullTokenize2(languageIdentifier.id, text, state, 0);\r\n    }\r\n    LineTokens.convertToEndOffset(r.tokens, text.length);\r\n    return r;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}