{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\n\nfunction createWordRegExp() {\n  var allowInWords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\n  var _iterator = _createForOfIteratorHelper(USUAL_WORD_SEPARATORS),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sep = _step.value;\n\n      if (allowInWords.indexOf(sep) >= 0) {\n        continue;\n      }\n\n      source += '\\\\' + sep;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  source += '\\\\s]+)';\n  return new RegExp(source, 'g');\n} // catches numbers (including floating numbers) in the first group, and alphanum in the second\n\n\nexport var DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n  var result = DEFAULT_WORD_REGEXP;\n\n  if (wordDefinition && wordDefinition instanceof RegExp) {\n    if (!wordDefinition.global) {\n      var flags = 'g';\n\n      if (wordDefinition.ignoreCase) {\n        flags += 'i';\n      }\n\n      if (wordDefinition.multiline) {\n        flags += 'm';\n      }\n\n      if (wordDefinition.unicode) {\n        flags += 'u';\n      }\n\n      result = new RegExp(wordDefinition.source, flags);\n    } else {\n      result = wordDefinition;\n    }\n  }\n\n  result.lastIndex = 0;\n  return result;\n}\nvar _defaultConfig = {\n  maxLen: 1000,\n  windowSize: 15,\n  timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset) {\n  var config = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _defaultConfig;\n\n  if (text.length > config.maxLen) {\n    // don't throw strings that long at the regexp\n    // but use a sub-string in which a word must occur\n    var start = column - config.maxLen / 2;\n\n    if (start < 0) {\n      start = 0;\n    } else {\n      textOffset += start;\n    }\n\n    text = text.substring(start, column + config.maxLen / 2);\n    return getWordAtText(column, wordDefinition, text, textOffset, config);\n  }\n\n  var t1 = Date.now();\n  var pos = column - 1 - textOffset;\n  var prevRegexIndex = -1;\n  var match = null;\n\n  for (var i = 1;; i++) {\n    // check time budget\n    if (Date.now() - t1 >= config.timeBudget) {\n      break;\n    } // reset the index at which the regexp should start matching, also know where it\n    // should stop so that subsequent search don't repeat previous searches\n\n\n    var regexIndex = pos - config.windowSize * i;\n    wordDefinition.lastIndex = Math.max(0, regexIndex);\n\n    var thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n\n    if (!thisMatch && match) {\n      // stop: we have something\n      break;\n    }\n\n    match = thisMatch; // stop: searched at start\n\n    if (regexIndex <= 0) {\n      break;\n    }\n\n    prevRegexIndex = regexIndex;\n  }\n\n  if (match) {\n    var result = {\n      word: match[0],\n      startColumn: textOffset + 1 + match.index,\n      endColumn: textOffset + 1 + match.index + match[0].length\n    };\n    wordDefinition.lastIndex = 0;\n    return result;\n  }\n\n  return null;\n}\n\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n  var match;\n\n  while (match = wordDefinition.exec(text)) {\n    var matchIndex = match.index || 0;\n\n    if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n      return match;\n    } else if (stopPos > 0 && matchIndex > stopPos) {\n      return null;\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js"],"names":["USUAL_WORD_SEPARATORS","createWordRegExp","allowInWords","source","sep","indexOf","RegExp","DEFAULT_WORD_REGEXP","ensureValidWordDefinition","wordDefinition","result","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","maxLen","windowSize","timeBudget","getWordAtText","column","text","textOffset","config","length","start","substring","t1","Date","now","pos","prevRegexIndex","match","i","regexIndex","Math","max","thisMatch","_findRegexMatchEnclosingPosition","word","startColumn","index","endColumn","stopPos","exec","matchIndex"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n/**\r\n * Create a word definition regular expression based on default word separators.\r\n * Optionally provide allowed separators that should be included in words.\r\n *\r\n * The default would look like this:\r\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n */\r\nfunction createWordRegExp(allowInWords = '') {\r\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n    for (const sep of USUAL_WORD_SEPARATORS) {\r\n        if (allowInWords.indexOf(sep) >= 0) {\r\n            continue;\r\n        }\r\n        source += '\\\\' + sep;\r\n    }\r\n    source += '\\\\s]+)';\r\n    return new RegExp(source, 'g');\r\n}\r\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\r\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\r\nexport function ensureValidWordDefinition(wordDefinition) {\r\n    let result = DEFAULT_WORD_REGEXP;\r\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n        if (!wordDefinition.global) {\r\n            let flags = 'g';\r\n            if (wordDefinition.ignoreCase) {\r\n                flags += 'i';\r\n            }\r\n            if (wordDefinition.multiline) {\r\n                flags += 'm';\r\n            }\r\n            if (wordDefinition.unicode) {\r\n                flags += 'u';\r\n            }\r\n            result = new RegExp(wordDefinition.source, flags);\r\n        }\r\n        else {\r\n            result = wordDefinition;\r\n        }\r\n    }\r\n    result.lastIndex = 0;\r\n    return result;\r\n}\r\nconst _defaultConfig = {\r\n    maxLen: 1000,\r\n    windowSize: 15,\r\n    timeBudget: 150\r\n};\r\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\r\n    if (text.length > config.maxLen) {\r\n        // don't throw strings that long at the regexp\r\n        // but use a sub-string in which a word must occur\r\n        let start = column - config.maxLen / 2;\r\n        if (start < 0) {\r\n            start = 0;\r\n        }\r\n        else {\r\n            textOffset += start;\r\n        }\r\n        text = text.substring(start, column + config.maxLen / 2);\r\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\r\n    }\r\n    const t1 = Date.now();\r\n    const pos = column - 1 - textOffset;\r\n    let prevRegexIndex = -1;\r\n    let match = null;\r\n    for (let i = 1;; i++) {\r\n        // check time budget\r\n        if (Date.now() - t1 >= config.timeBudget) {\r\n            break;\r\n        }\r\n        // reset the index at which the regexp should start matching, also know where it\r\n        // should stop so that subsequent search don't repeat previous searches\r\n        const regexIndex = pos - config.windowSize * i;\r\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\r\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\r\n        if (!thisMatch && match) {\r\n            // stop: we have something\r\n            break;\r\n        }\r\n        match = thisMatch;\r\n        // stop: searched at start\r\n        if (regexIndex <= 0) {\r\n            break;\r\n        }\r\n        prevRegexIndex = regexIndex;\r\n    }\r\n    if (match) {\r\n        let result = {\r\n            word: match[0],\r\n            startColumn: textOffset + 1 + match.index,\r\n            endColumn: textOffset + 1 + match.index + match[0].length\r\n        };\r\n        wordDefinition.lastIndex = 0;\r\n        return result;\r\n    }\r\n    return null;\r\n}\r\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\r\n    let match;\r\n    while (match = wordDefinition.exec(text)) {\r\n        const matchIndex = match.index || 0;\r\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\r\n            return match;\r\n        }\r\n        else if (stopPos > 0 && matchIndex > stopPos) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}