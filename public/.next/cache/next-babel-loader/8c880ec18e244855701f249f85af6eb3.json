{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nvar hasBuffer = typeof Buffer !== 'undefined';\nvar hasTextDecoder = typeof TextDecoder !== 'undefined';\nvar textDecoder;\nexport var VSBuffer = /*#__PURE__*/function () {\n  function VSBuffer(buffer) {\n    _classCallCheck(this, VSBuffer);\n\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n\n  _createClass(VSBuffer, [{\n    key: \"toString\",\n    value: function toString() {\n      if (hasBuffer) {\n        return this.buffer.toString();\n      } else if (hasTextDecoder) {\n        if (!textDecoder) {\n          textDecoder = new TextDecoder();\n        }\n\n        return textDecoder.decode(this.buffer);\n      } else {\n        return strings.decodeUTF8(this.buffer);\n      }\n    }\n  }], [{\n    key: \"wrap\",\n    value: function wrap(actual) {\n      if (hasBuffer && !Buffer.isBuffer(actual)) {\n        // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n        // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n        actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n      }\n\n      return new VSBuffer(actual);\n    }\n  }]);\n\n  return VSBuffer;\n}();\nexport function readUInt16LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;\n}\nexport function writeUInt16LE(destination, value, offset) {\n  destination[offset + 0] = value & 255;\n  value = value >>> 8;\n  destination[offset + 1] = value & 255;\n}\nexport function readUInt32BE(source, offset) {\n  return source[offset] * Math.pow(2, 24) + source[offset + 1] * Math.pow(2, 16) + source[offset + 2] * Math.pow(2, 8) + source[offset + 3];\n}\nexport function writeUInt32BE(destination, value, offset) {\n  destination[offset + 3] = value;\n  value = value >>> 8;\n  destination[offset + 2] = value;\n  value = value >>> 8;\n  destination[offset + 1] = value;\n  value = value >>> 8;\n  destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n  return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n  destination[offset] = value;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/buffer.js"],"names":["strings","hasBuffer","Buffer","hasTextDecoder","TextDecoder","textDecoder","VSBuffer","buffer","byteLength","toString","decode","decodeUTF8","actual","isBuffer","from","byteOffset","readUInt16LE","source","offset","writeUInt16LE","destination","value","readUInt32BE","Math","pow","writeUInt32BE","readUInt8","writeUInt8"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as strings from './strings.js';\r\nconst hasBuffer = (typeof Buffer !== 'undefined');\r\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\r\nlet textDecoder;\r\nexport class VSBuffer {\r\n    constructor(buffer) {\r\n        this.buffer = buffer;\r\n        this.byteLength = this.buffer.byteLength;\r\n    }\r\n    static wrap(actual) {\r\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\r\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\r\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\r\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\r\n        }\r\n        return new VSBuffer(actual);\r\n    }\r\n    toString() {\r\n        if (hasBuffer) {\r\n            return this.buffer.toString();\r\n        }\r\n        else if (hasTextDecoder) {\r\n            if (!textDecoder) {\r\n                textDecoder = new TextDecoder();\r\n            }\r\n            return textDecoder.decode(this.buffer);\r\n        }\r\n        else {\r\n            return strings.decodeUTF8(this.buffer);\r\n        }\r\n    }\r\n}\r\nexport function readUInt16LE(source, offset) {\r\n    return (((source[offset + 0] << 0) >>> 0) |\r\n        ((source[offset + 1] << 8) >>> 0));\r\n}\r\nexport function writeUInt16LE(destination, value, offset) {\r\n    destination[offset + 0] = (value & 0b11111111);\r\n    value = value >>> 8;\r\n    destination[offset + 1] = (value & 0b11111111);\r\n}\r\nexport function readUInt32BE(source, offset) {\r\n    return (source[offset] * Math.pow(2, 24)\r\n        + source[offset + 1] * Math.pow(2, 16)\r\n        + source[offset + 2] * Math.pow(2, 8)\r\n        + source[offset + 3]);\r\n}\r\nexport function writeUInt32BE(destination, value, offset) {\r\n    destination[offset + 3] = value;\r\n    value = value >>> 8;\r\n    destination[offset + 2] = value;\r\n    value = value >>> 8;\r\n    destination[offset + 1] = value;\r\n    value = value >>> 8;\r\n    destination[offset] = value;\r\n}\r\nexport function readUInt8(source, offset) {\r\n    return source[offset];\r\n}\r\nexport function writeUInt8(destination, value, offset) {\r\n    destination[offset] = value;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}