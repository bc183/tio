{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\n\n/**\r\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\r\n */\nvar MINIMUM_SLIDER_SIZE = 20;\nexport var ScrollbarState = /*#__PURE__*/function () {\n  function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\n    _classCallCheck(this, ScrollbarState);\n\n    this._scrollbarSize = Math.round(scrollbarSize);\n    this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n    this._arrowSize = Math.round(arrowSize);\n    this._visibleSize = visibleSize;\n    this._scrollSize = scrollSize;\n    this._scrollPosition = scrollPosition;\n    this._computedAvailableSize = 0;\n    this._computedIsNeeded = false;\n    this._computedSliderSize = 0;\n    this._computedSliderRatio = 0;\n    this._computedSliderPosition = 0;\n\n    this._refreshComputedValues();\n  }\n\n  _createClass(ScrollbarState, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n    }\n  }, {\n    key: \"setVisibleSize\",\n    value: function setVisibleSize(visibleSize) {\n      var iVisibleSize = Math.round(visibleSize);\n\n      if (this._visibleSize !== iVisibleSize) {\n        this._visibleSize = iVisibleSize;\n\n        this._refreshComputedValues();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setScrollSize\",\n    value: function setScrollSize(scrollSize) {\n      var iScrollSize = Math.round(scrollSize);\n\n      if (this._scrollSize !== iScrollSize) {\n        this._scrollSize = iScrollSize;\n\n        this._refreshComputedValues();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setScrollPosition\",\n    value: function setScrollPosition(scrollPosition) {\n      var iScrollPosition = Math.round(scrollPosition);\n\n      if (this._scrollPosition !== iScrollPosition) {\n        this._scrollPosition = iScrollPosition;\n\n        this._refreshComputedValues();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setScrollbarSize\",\n    value: function setScrollbarSize(scrollbarSize) {\n      this._scrollbarSize = scrollbarSize;\n    }\n  }, {\n    key: \"_refreshComputedValues\",\n    value: function _refreshComputedValues() {\n      var r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\n      this._computedAvailableSize = r.computedAvailableSize;\n      this._computedIsNeeded = r.computedIsNeeded;\n      this._computedSliderSize = r.computedSliderSize;\n      this._computedSliderRatio = r.computedSliderRatio;\n      this._computedSliderPosition = r.computedSliderPosition;\n    }\n  }, {\n    key: \"getArrowSize\",\n    value: function getArrowSize() {\n      return this._arrowSize;\n    }\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      return this._scrollPosition;\n    }\n  }, {\n    key: \"getRectangleLargeSize\",\n    value: function getRectangleLargeSize() {\n      return this._computedAvailableSize;\n    }\n  }, {\n    key: \"getRectangleSmallSize\",\n    value: function getRectangleSmallSize() {\n      return this._scrollbarSize;\n    }\n  }, {\n    key: \"isNeeded\",\n    value: function isNeeded() {\n      return this._computedIsNeeded;\n    }\n  }, {\n    key: \"getSliderSize\",\n    value: function getSliderSize() {\n      return this._computedSliderSize;\n    }\n  }, {\n    key: \"getSliderPosition\",\n    value: function getSliderPosition() {\n      return this._computedSliderPosition;\n    }\n    /**\r\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\r\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\r\n     */\n\n  }, {\n    key: \"getDesiredScrollPositionFromOffset\",\n    value: function getDesiredScrollPositionFromOffset(offset) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n\n      var desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n      return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n    /**\r\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\r\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\r\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\r\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\r\n     */\n\n  }, {\n    key: \"getDesiredScrollPositionFromOffsetPaged\",\n    value: function getDesiredScrollPositionFromOffsetPaged(offset) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n\n      var correctedOffset = offset - this._arrowSize; // compensate if has arrows\n\n      var desiredScrollPosition = this._scrollPosition;\n\n      if (correctedOffset < this._computedSliderPosition) {\n        desiredScrollPosition -= this._visibleSize; // page up/left\n      } else {\n        desiredScrollPosition += this._visibleSize; // page down/right\n      }\n\n      return desiredScrollPosition;\n    }\n    /**\r\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n     */\n\n  }, {\n    key: \"getDesiredScrollPositionFromDelta\",\n    value: function getDesiredScrollPositionFromDelta(delta) {\n      if (!this._computedIsNeeded) {\n        // no need for a slider\n        return 0;\n      }\n\n      var desiredSliderPosition = this._computedSliderPosition + delta;\n      return Math.round(desiredSliderPosition / this._computedSliderRatio);\n    }\n  }], [{\n    key: \"_computeValues\",\n    value: function _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\n      var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n      var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n      var computedIsNeeded = scrollSize > 0 && scrollSize > visibleSize;\n\n      if (!computedIsNeeded) {\n        // There is no need for a slider\n        return {\n          computedAvailableSize: Math.round(computedAvailableSize),\n          computedIsNeeded: computedIsNeeded,\n          computedSliderSize: Math.round(computedRepresentableSize),\n          computedSliderRatio: 0,\n          computedSliderPosition: 0\n        };\n      } // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\n\n      var computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize))); // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n      // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\n      var computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n      var computedSliderPosition = scrollPosition * computedSliderRatio;\n      return {\n        computedAvailableSize: Math.round(computedAvailableSize),\n        computedIsNeeded: computedIsNeeded,\n        computedSliderSize: Math.round(computedSliderSize),\n        computedSliderRatio: computedSliderRatio,\n        computedSliderPosition: Math.round(computedSliderPosition)\n      };\n    }\n  }]);\n\n  return ScrollbarState;\n}();","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollbarState.js"],"names":["MINIMUM_SLIDER_SIZE","ScrollbarState","arrowSize","scrollbarSize","oppositeScrollbarSize","visibleSize","scrollSize","scrollPosition","_scrollbarSize","Math","round","_oppositeScrollbarSize","_arrowSize","_visibleSize","_scrollSize","_scrollPosition","_computedAvailableSize","_computedIsNeeded","_computedSliderSize","_computedSliderRatio","_computedSliderPosition","_refreshComputedValues","iVisibleSize","iScrollSize","iScrollPosition","r","_computeValues","computedAvailableSize","computedIsNeeded","computedSliderSize","computedSliderRatio","computedSliderPosition","offset","desiredSliderPosition","correctedOffset","desiredScrollPosition","delta","max","computedRepresentableSize","floor"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n/**\r\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\r\n */\r\nconst MINIMUM_SLIDER_SIZE = 20;\r\nexport class ScrollbarState {\r\n    constructor(arrowSize, scrollbarSize, oppositeScrollbarSize, visibleSize, scrollSize, scrollPosition) {\r\n        this._scrollbarSize = Math.round(scrollbarSize);\r\n        this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\r\n        this._arrowSize = Math.round(arrowSize);\r\n        this._visibleSize = visibleSize;\r\n        this._scrollSize = scrollSize;\r\n        this._scrollPosition = scrollPosition;\r\n        this._computedAvailableSize = 0;\r\n        this._computedIsNeeded = false;\r\n        this._computedSliderSize = 0;\r\n        this._computedSliderRatio = 0;\r\n        this._computedSliderPosition = 0;\r\n        this._refreshComputedValues();\r\n    }\r\n    clone() {\r\n        return new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\r\n    }\r\n    setVisibleSize(visibleSize) {\r\n        const iVisibleSize = Math.round(visibleSize);\r\n        if (this._visibleSize !== iVisibleSize) {\r\n            this._visibleSize = iVisibleSize;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setScrollSize(scrollSize) {\r\n        const iScrollSize = Math.round(scrollSize);\r\n        if (this._scrollSize !== iScrollSize) {\r\n            this._scrollSize = iScrollSize;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setScrollPosition(scrollPosition) {\r\n        const iScrollPosition = Math.round(scrollPosition);\r\n        if (this._scrollPosition !== iScrollPosition) {\r\n            this._scrollPosition = iScrollPosition;\r\n            this._refreshComputedValues();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setScrollbarSize(scrollbarSize) {\r\n        this._scrollbarSize = scrollbarSize;\r\n    }\r\n    static _computeValues(oppositeScrollbarSize, arrowSize, visibleSize, scrollSize, scrollPosition) {\r\n        const computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\r\n        const computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\r\n        const computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\r\n        if (!computedIsNeeded) {\r\n            // There is no need for a slider\r\n            return {\r\n                computedAvailableSize: Math.round(computedAvailableSize),\r\n                computedIsNeeded: computedIsNeeded,\r\n                computedSliderSize: Math.round(computedRepresentableSize),\r\n                computedSliderRatio: 0,\r\n                computedSliderPosition: 0,\r\n            };\r\n        }\r\n        // We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\r\n        const computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\r\n        // The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\r\n        // in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\r\n        const computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\r\n        const computedSliderPosition = (scrollPosition * computedSliderRatio);\r\n        return {\r\n            computedAvailableSize: Math.round(computedAvailableSize),\r\n            computedIsNeeded: computedIsNeeded,\r\n            computedSliderSize: Math.round(computedSliderSize),\r\n            computedSliderRatio: computedSliderRatio,\r\n            computedSliderPosition: Math.round(computedSliderPosition),\r\n        };\r\n    }\r\n    _refreshComputedValues() {\r\n        const r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\r\n        this._computedAvailableSize = r.computedAvailableSize;\r\n        this._computedIsNeeded = r.computedIsNeeded;\r\n        this._computedSliderSize = r.computedSliderSize;\r\n        this._computedSliderRatio = r.computedSliderRatio;\r\n        this._computedSliderPosition = r.computedSliderPosition;\r\n    }\r\n    getArrowSize() {\r\n        return this._arrowSize;\r\n    }\r\n    getScrollPosition() {\r\n        return this._scrollPosition;\r\n    }\r\n    getRectangleLargeSize() {\r\n        return this._computedAvailableSize;\r\n    }\r\n    getRectangleSmallSize() {\r\n        return this._scrollbarSize;\r\n    }\r\n    isNeeded() {\r\n        return this._computedIsNeeded;\r\n    }\r\n    getSliderSize() {\r\n        return this._computedSliderSize;\r\n    }\r\n    getSliderPosition() {\r\n        return this._computedSliderPosition;\r\n    }\r\n    /**\r\n     * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\r\n     * `offset` is based on the same coordinate system as the `sliderPosition`.\r\n     */\r\n    getDesiredScrollPositionFromOffset(offset) {\r\n        if (!this._computedIsNeeded) {\r\n            // no need for a slider\r\n            return 0;\r\n        }\r\n        const desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\r\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\r\n    }\r\n    /**\r\n     * Compute a desired `scrollPosition` from if offset is before or after the slider position.\r\n     * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\r\n     * `offset` and `_computedSliderPosition` are based on the same coordinate system.\r\n     * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\r\n     */\r\n    getDesiredScrollPositionFromOffsetPaged(offset) {\r\n        if (!this._computedIsNeeded) {\r\n            // no need for a slider\r\n            return 0;\r\n        }\r\n        const correctedOffset = offset - this._arrowSize; // compensate if has arrows\r\n        let desiredScrollPosition = this._scrollPosition;\r\n        if (correctedOffset < this._computedSliderPosition) {\r\n            desiredScrollPosition -= this._visibleSize; // page up/left\r\n        }\r\n        else {\r\n            desiredScrollPosition += this._visibleSize; // page down/right\r\n        }\r\n        return desiredScrollPosition;\r\n    }\r\n    /**\r\n     * Compute a desired `scrollPosition` such that the slider moves by `delta`.\r\n     */\r\n    getDesiredScrollPositionFromDelta(delta) {\r\n        if (!this._computedIsNeeded) {\r\n            // no need for a slider\r\n            return 0;\r\n        }\r\n        const desiredSliderPosition = this._computedSliderPosition + delta;\r\n        return Math.round(desiredSliderPosition / this._computedSliderRatio);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}