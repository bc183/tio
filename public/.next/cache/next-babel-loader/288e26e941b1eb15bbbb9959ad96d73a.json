{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../modes.js';\nimport { LogLevel } from '../../../platform/log/common/log.js';\nimport { MultilineTokens2, SparseEncodedTokens } from '../model/tokensStore.js';\nexport var SemanticTokensProviderStyling = /*#__PURE__*/function () {\n  function SemanticTokensProviderStyling(_legend, _themeService, _logService) {\n    _classCallCheck(this, SemanticTokensProviderStyling);\n\n    this._legend = _legend;\n    this._themeService = _themeService;\n    this._logService = _logService;\n    this._hashTable = new HashTable();\n  }\n\n  _createClass(SemanticTokensProviderStyling, [{\n    key: \"getMetadata\",\n    value: function getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n      var entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\n\n      var metadata;\n\n      if (entry) {\n        metadata = entry.metadata;\n\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling [CACHED] \".concat(tokenTypeIndex, \" / \").concat(tokenModifierSet, \": foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n        }\n      } else {\n        var tokenType = this._legend.tokenTypes[tokenTypeIndex];\n        var tokenModifiers = [];\n\n        if (tokenType) {\n          var modifierSet = tokenModifierSet;\n\n          for (var modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n            if (modifierSet & 1) {\n              tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n            }\n\n            modifierSet = modifierSet >> 1;\n          }\n\n          if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n            this._logService.trace(\"SemanticTokensProviderStyling: unknown token modifier index: \".concat(tokenModifierSet.toString(2), \" for legend: \").concat(JSON.stringify(this._legend.tokenModifiers)));\n\n            tokenModifiers.push('not-in-legend');\n          }\n\n          var tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\n\n          if (typeof tokenStyle === 'undefined') {\n            metadata = 2147483647\n            /* NO_STYLING */\n            ;\n          } else {\n            metadata = 0;\n\n            if (typeof tokenStyle.italic !== 'undefined') {\n              var italicBit = (tokenStyle.italic ? 1\n              /* Italic */\n              : 0) << 11\n              /* FONT_STYLE_OFFSET */\n              ;\n              metadata |= italicBit | 1\n              /* SEMANTIC_USE_ITALIC */\n              ;\n            }\n\n            if (typeof tokenStyle.bold !== 'undefined') {\n              var boldBit = (tokenStyle.bold ? 2\n              /* Bold */\n              : 0) << 11\n              /* FONT_STYLE_OFFSET */\n              ;\n              metadata |= boldBit | 2\n              /* SEMANTIC_USE_BOLD */\n              ;\n            }\n\n            if (typeof tokenStyle.underline !== 'undefined') {\n              var underlineBit = (tokenStyle.underline ? 4\n              /* Underline */\n              : 0) << 11\n              /* FONT_STYLE_OFFSET */\n              ;\n              metadata |= underlineBit | 4\n              /* SEMANTIC_USE_UNDERLINE */\n              ;\n            }\n\n            if (tokenStyle.foreground) {\n              var foregroundBits = tokenStyle.foreground << 14\n              /* FOREGROUND_OFFSET */\n              ;\n              metadata |= foregroundBits | 8\n              /* SEMANTIC_USE_FOREGROUND */\n              ;\n            }\n\n            if (metadata === 0) {\n              // Nothing!\n              metadata = 2147483647\n              /* NO_STYLING */\n              ;\n            }\n          }\n        } else {\n          if (this._logService.getLevel() === LogLevel.Trace) {\n            this._logService.trace(\"SemanticTokensProviderStyling: unknown token type index: \".concat(tokenTypeIndex, \" for legend: \").concat(JSON.stringify(this._legend.tokenTypes)));\n          }\n\n          metadata = 2147483647\n          /* NO_STYLING */\n          ;\n          tokenType = 'not-in-legend';\n        }\n\n        this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\n\n        if (this._logService.getLevel() === LogLevel.Trace) {\n          this._logService.trace(\"SemanticTokensProviderStyling \".concat(tokenTypeIndex, \" (\").concat(tokenType, \") / \").concat(tokenModifierSet, \" (\").concat(tokenModifiers.join(' '), \"): foreground \").concat(TokenMetadata.getForeground(metadata), \", fontStyle \").concat(TokenMetadata.getFontStyle(metadata).toString(2)));\n        }\n      }\n\n      return metadata;\n    }\n  }]);\n\n  return SemanticTokensProviderStyling;\n}();\nexport function toMultilineTokens2(tokens, styling, languageId) {\n  var srcData = tokens.data;\n  var tokenCount = tokens.data.length / 5 | 0;\n  var tokensPerArea = Math.max(Math.ceil(tokenCount / 1024\n  /* DesiredMaxAreas */\n  ), 400\n  /* DesiredTokensPerArea */\n  );\n  var result = [];\n  var tokenIndex = 0;\n  var lastLineNumber = 1;\n  var lastStartCharacter = 0;\n\n  while (tokenIndex < tokenCount) {\n    var tokenStartIndex = tokenIndex;\n    var tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount); // Keep tokens on the same line in the same area...\n\n    if (tokenEndIndex < tokenCount) {\n      var smallTokenEndIndex = tokenEndIndex;\n\n      while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n        smallTokenEndIndex--;\n      }\n\n      if (smallTokenEndIndex - 1 === tokenStartIndex) {\n        // there are so many tokens on this line that our area would be empty, we must now go right\n        var bigTokenEndIndex = tokenEndIndex;\n\n        while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n          bigTokenEndIndex++;\n        }\n\n        tokenEndIndex = bigTokenEndIndex;\n      } else {\n        tokenEndIndex = smallTokenEndIndex;\n      }\n    }\n\n    var destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n    var destOffset = 0;\n    var areaLine = 0;\n\n    while (tokenIndex < tokenEndIndex) {\n      var srcOffset = 5 * tokenIndex;\n      var deltaLine = srcData[srcOffset];\n      var deltaCharacter = srcData[srcOffset + 1];\n      var lineNumber = lastLineNumber + deltaLine;\n      var startCharacter = deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter;\n      var length = srcData[srcOffset + 2];\n      var tokenTypeIndex = srcData[srcOffset + 3];\n      var tokenModifierSet = srcData[srcOffset + 4];\n      var metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n\n      if (metadata !== 2147483647\n      /* NO_STYLING */\n      ) {\n          if (areaLine === 0) {\n            areaLine = lineNumber;\n          }\n\n          destData[destOffset] = lineNumber - areaLine;\n          destData[destOffset + 1] = startCharacter;\n          destData[destOffset + 2] = startCharacter + length;\n          destData[destOffset + 3] = metadata;\n          destOffset += 4;\n        }\n\n      lastLineNumber = lineNumber;\n      lastStartCharacter = startCharacter;\n      tokenIndex++;\n    }\n\n    if (destOffset !== destData.length) {\n      destData = destData.subarray(0, destOffset);\n    }\n\n    var _tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\n\n    result.push(_tokens);\n  }\n\n  return result;\n}\n\nvar HashTableEntry = function HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n  _classCallCheck(this, HashTableEntry);\n\n  this.tokenTypeIndex = tokenTypeIndex;\n  this.tokenModifierSet = tokenModifierSet;\n  this.languageId = languageId;\n  this.metadata = metadata;\n  this.next = null;\n};\n\nvar HashTable = /*#__PURE__*/function () {\n  function HashTable() {\n    _classCallCheck(this, HashTable);\n\n    this._elementsCount = 0;\n    this._currentLengthIndex = 0;\n    this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n    this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n    this._elements = [];\n\n    HashTable._nullOutEntries(this._elements, this._currentLength);\n  }\n\n  _createClass(HashTable, [{\n    key: \"_hash2\",\n    value: function _hash2(n1, n2) {\n      return (n1 << 5) - n1 + n2 | 0; // n1 * 31 + n2, keep as int32\n    }\n  }, {\n    key: \"_hashFunc\",\n    value: function _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n      return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n  }, {\n    key: \"get\",\n    value: function get(tokenTypeIndex, tokenModifierSet, languageId) {\n      var hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n\n      var p = this._elements[hash];\n\n      while (p) {\n        if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n          return p;\n        }\n\n        p = p.next;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"add\",\n    value: function add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n      this._elementsCount++;\n\n      if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n        // expand!\n        var oldElements = this._elements;\n        this._currentLengthIndex++;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n\n        var _iterator = _createForOfIteratorHelper(oldElements),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var first = _step.value;\n            var p = first;\n\n            while (p) {\n              var oldNext = p.next;\n              p.next = null;\n\n              this._add(p);\n\n              p = oldNext;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(element) {\n      var hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n\n      element.next = this._elements[hash];\n      this._elements[hash] = element;\n    }\n  }], [{\n    key: \"_nullOutEntries\",\n    value: function _nullOutEntries(entries, length) {\n      for (var i = 0; i < length; i++) {\n        entries[i] = null;\n      }\n    }\n  }]);\n\n  return HashTable;\n}();\n\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"],"names":["TokenMetadata","LogLevel","MultilineTokens2","SparseEncodedTokens","SemanticTokensProviderStyling","_legend","_themeService","_logService","_hashTable","HashTable","tokenTypeIndex","tokenModifierSet","languageId","entry","get","id","metadata","getLevel","Trace","trace","getForeground","getFontStyle","toString","tokenType","tokenTypes","tokenModifiers","modifierSet","modifierIndex","length","push","JSON","stringify","tokenStyle","getColorTheme","getTokenStyleMetadata","language","italic","italicBit","bold","boldBit","underline","underlineBit","foreground","foregroundBits","add","join","toMultilineTokens2","tokens","styling","srcData","data","tokenCount","tokensPerArea","Math","max","ceil","result","tokenIndex","lastLineNumber","lastStartCharacter","tokenStartIndex","tokenEndIndex","min","smallTokenEndIndex","bigTokenEndIndex","destData","Uint32Array","destOffset","areaLine","srcOffset","deltaLine","deltaCharacter","lineNumber","startCharacter","getMetadata","subarray","HashTableEntry","next","_elementsCount","_currentLengthIndex","_currentLength","_SIZES","_growCount","round","_elements","_nullOutEntries","n1","n2","_hash2","hash","_hashFunc","p","oldElements","first","oldNext","_add","element","entries","i"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { TokenMetadata } from '../modes.js';\r\nimport { LogLevel } from '../../../platform/log/common/log.js';\r\nimport { MultilineTokens2, SparseEncodedTokens } from '../model/tokensStore.js';\r\nexport class SemanticTokensProviderStyling {\r\n    constructor(_legend, _themeService, _logService) {\r\n        this._legend = _legend;\r\n        this._themeService = _themeService;\r\n        this._logService = _logService;\r\n        this._hashTable = new HashTable();\r\n    }\r\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, languageId.id);\r\n        let metadata;\r\n        if (entry) {\r\n            metadata = entry.metadata;\r\n            if (this._logService.getLevel() === LogLevel.Trace) {\r\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\r\n            }\r\n        }\r\n        else {\r\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\r\n            const tokenModifiers = [];\r\n            if (tokenType) {\r\n                let modifierSet = tokenModifierSet;\r\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\r\n                    if (modifierSet & 1) {\r\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\r\n                    }\r\n                    modifierSet = modifierSet >> 1;\r\n                }\r\n                if (modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\r\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\r\n                    tokenModifiers.push('not-in-legend');\r\n                }\r\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId.language);\r\n                if (typeof tokenStyle === 'undefined') {\r\n                    metadata = 2147483647 /* NO_STYLING */;\r\n                }\r\n                else {\r\n                    metadata = 0;\r\n                    if (typeof tokenStyle.italic !== 'undefined') {\r\n                        const italicBit = (tokenStyle.italic ? 1 /* Italic */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= italicBit | 1 /* SEMANTIC_USE_ITALIC */;\r\n                    }\r\n                    if (typeof tokenStyle.bold !== 'undefined') {\r\n                        const boldBit = (tokenStyle.bold ? 2 /* Bold */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= boldBit | 2 /* SEMANTIC_USE_BOLD */;\r\n                    }\r\n                    if (typeof tokenStyle.underline !== 'undefined') {\r\n                        const underlineBit = (tokenStyle.underline ? 4 /* Underline */ : 0) << 11 /* FONT_STYLE_OFFSET */;\r\n                        metadata |= underlineBit | 4 /* SEMANTIC_USE_UNDERLINE */;\r\n                    }\r\n                    if (tokenStyle.foreground) {\r\n                        const foregroundBits = (tokenStyle.foreground) << 14 /* FOREGROUND_OFFSET */;\r\n                        metadata |= foregroundBits | 8 /* SEMANTIC_USE_FOREGROUND */;\r\n                    }\r\n                    if (metadata === 0) {\r\n                        // Nothing!\r\n                        metadata = 2147483647 /* NO_STYLING */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (this._logService.getLevel() === LogLevel.Trace) {\r\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\r\n                }\r\n                metadata = 2147483647 /* NO_STYLING */;\r\n                tokenType = 'not-in-legend';\r\n            }\r\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, languageId.id, metadata);\r\n            if (this._logService.getLevel() === LogLevel.Trace) {\r\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\r\n            }\r\n        }\r\n        return metadata;\r\n    }\r\n}\r\nexport function toMultilineTokens2(tokens, styling, languageId) {\r\n    const srcData = tokens.data;\r\n    const tokenCount = (tokens.data.length / 5) | 0;\r\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* DesiredMaxAreas */), 400 /* DesiredTokensPerArea */);\r\n    const result = [];\r\n    let tokenIndex = 0;\r\n    let lastLineNumber = 1;\r\n    let lastStartCharacter = 0;\r\n    while (tokenIndex < tokenCount) {\r\n        const tokenStartIndex = tokenIndex;\r\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\r\n        // Keep tokens on the same line in the same area...\r\n        if (tokenEndIndex < tokenCount) {\r\n            let smallTokenEndIndex = tokenEndIndex;\r\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\r\n                smallTokenEndIndex--;\r\n            }\r\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\r\n                // there are so many tokens on this line that our area would be empty, we must now go right\r\n                let bigTokenEndIndex = tokenEndIndex;\r\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\r\n                    bigTokenEndIndex++;\r\n                }\r\n                tokenEndIndex = bigTokenEndIndex;\r\n            }\r\n            else {\r\n                tokenEndIndex = smallTokenEndIndex;\r\n            }\r\n        }\r\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\r\n        let destOffset = 0;\r\n        let areaLine = 0;\r\n        while (tokenIndex < tokenEndIndex) {\r\n            const srcOffset = 5 * tokenIndex;\r\n            const deltaLine = srcData[srcOffset];\r\n            const deltaCharacter = srcData[srcOffset + 1];\r\n            const lineNumber = lastLineNumber + deltaLine;\r\n            const startCharacter = (deltaLine === 0 ? lastStartCharacter + deltaCharacter : deltaCharacter);\r\n            const length = srcData[srcOffset + 2];\r\n            const tokenTypeIndex = srcData[srcOffset + 3];\r\n            const tokenModifierSet = srcData[srcOffset + 4];\r\n            const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\r\n            if (metadata !== 2147483647 /* NO_STYLING */) {\r\n                if (areaLine === 0) {\r\n                    areaLine = lineNumber;\r\n                }\r\n                destData[destOffset] = lineNumber - areaLine;\r\n                destData[destOffset + 1] = startCharacter;\r\n                destData[destOffset + 2] = startCharacter + length;\r\n                destData[destOffset + 3] = metadata;\r\n                destOffset += 4;\r\n            }\r\n            lastLineNumber = lineNumber;\r\n            lastStartCharacter = startCharacter;\r\n            tokenIndex++;\r\n        }\r\n        if (destOffset !== destData.length) {\r\n            destData = destData.subarray(0, destOffset);\r\n        }\r\n        const tokens = new MultilineTokens2(areaLine, new SparseEncodedTokens(destData));\r\n        result.push(tokens);\r\n    }\r\n    return result;\r\n}\r\nclass HashTableEntry {\r\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\r\n        this.tokenTypeIndex = tokenTypeIndex;\r\n        this.tokenModifierSet = tokenModifierSet;\r\n        this.languageId = languageId;\r\n        this.metadata = metadata;\r\n        this.next = null;\r\n    }\r\n}\r\nclass HashTable {\r\n    constructor() {\r\n        this._elementsCount = 0;\r\n        this._currentLengthIndex = 0;\r\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\r\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\r\n        this._elements = [];\r\n        HashTable._nullOutEntries(this._elements, this._currentLength);\r\n    }\r\n    static _nullOutEntries(entries, length) {\r\n        for (let i = 0; i < length; i++) {\r\n            entries[i] = null;\r\n        }\r\n    }\r\n    _hash2(n1, n2) {\r\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\r\n    }\r\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\r\n    }\r\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\r\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\r\n        let p = this._elements[hash];\r\n        while (p) {\r\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\r\n                return p;\r\n            }\r\n            p = p.next;\r\n        }\r\n        return null;\r\n    }\r\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\r\n        this._elementsCount++;\r\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\r\n            // expand!\r\n            const oldElements = this._elements;\r\n            this._currentLengthIndex++;\r\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\r\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\r\n            this._elements = [];\r\n            HashTable._nullOutEntries(this._elements, this._currentLength);\r\n            for (const first of oldElements) {\r\n                let p = first;\r\n                while (p) {\r\n                    const oldNext = p.next;\r\n                    p.next = null;\r\n                    this._add(p);\r\n                    p = oldNext;\r\n                }\r\n            }\r\n        }\r\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\r\n    }\r\n    _add(element) {\r\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\r\n        element.next = this._elements[hash];\r\n        this._elements[hash] = element;\r\n    }\r\n}\r\nHashTable._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];\r\n"]},"metadata":{},"sourceType":"module"}