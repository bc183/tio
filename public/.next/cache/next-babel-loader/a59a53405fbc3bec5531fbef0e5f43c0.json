{"ast":null,"code":"import _slicedToArray from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _get from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Position } from '../../common/core/position.js';\nimport { Selection } from '../../common/core/selection.js';\nimport { BrowserFeatures } from '../../../base/browser/canIUse.js';\nexport var CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\r\n * Every time we write to the clipboard, we record a bit of extra metadata here.\r\n * Every time we read from the cipboard, if the text matches our last written text,\r\n * we can fetch the previous metadata.\r\n */\n\nexport var InMemoryClipboardMetadataManager = /*#__PURE__*/function () {\n  function InMemoryClipboardMetadataManager() {\n    _classCallCheck(this, InMemoryClipboardMetadataManager);\n\n    this._lastState = null;\n  }\n\n  _createClass(InMemoryClipboardMetadataManager, [{\n    key: \"set\",\n    value: function set(lastCopiedValue, data) {\n      this._lastState = {\n        lastCopiedValue: lastCopiedValue,\n        data: data\n      };\n    }\n  }, {\n    key: \"get\",\n    value: function get(pastedText) {\n      if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n        // match!\n        return this._lastState.data;\n      }\n\n      this._lastState = null;\n      return null;\n    }\n  }]);\n\n  return InMemoryClipboardMetadataManager;\n}();\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\n/**\r\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\r\n *  - onCut\r\n *  - onPaste\r\n *  - onType\r\n *\r\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\r\n */\n\nexport var TextAreaInput = /*#__PURE__*/function (_Disposable) {\n  _inherits(TextAreaInput, _Disposable);\n\n  var _super = _createSuper(TextAreaInput);\n\n  function TextAreaInput(host, textArea) {\n    var _this;\n\n    _classCallCheck(this, TextAreaInput);\n\n    _this = _super.call(this);\n    _this.textArea = textArea;\n    _this._onFocus = _this._register(new Emitter());\n    _this.onFocus = _this._onFocus.event;\n    _this._onBlur = _this._register(new Emitter());\n    _this.onBlur = _this._onBlur.event;\n    _this._onKeyDown = _this._register(new Emitter());\n    _this.onKeyDown = _this._onKeyDown.event;\n    _this._onKeyUp = _this._register(new Emitter());\n    _this.onKeyUp = _this._onKeyUp.event;\n    _this._onCut = _this._register(new Emitter());\n    _this.onCut = _this._onCut.event;\n    _this._onPaste = _this._register(new Emitter());\n    _this.onPaste = _this._onPaste.event;\n    _this._onType = _this._register(new Emitter());\n    _this.onType = _this._onType.event;\n    _this._onCompositionStart = _this._register(new Emitter());\n    _this.onCompositionStart = _this._onCompositionStart.event;\n    _this._onCompositionUpdate = _this._register(new Emitter());\n    _this.onCompositionUpdate = _this._onCompositionUpdate.event;\n    _this._onCompositionEnd = _this._register(new Emitter());\n    _this.onCompositionEnd = _this._onCompositionEnd.event;\n    _this._onSelectionChangeRequest = _this._register(new Emitter());\n    _this.onSelectionChangeRequest = _this._onSelectionChangeRequest.event;\n    _this._host = host;\n    _this._textArea = _this._register(new TextAreaWrapper(textArea));\n    _this._asyncTriggerCut = _this._register(new RunOnceScheduler(function () {\n      return _this._onCut.fire();\n    }, 0));\n    _this._asyncFocusGainWriteScreenReaderContent = _this._register(new RunOnceScheduler(function () {\n      return _this.writeScreenReaderContent('asyncFocusGain');\n    }, 0));\n    _this._textAreaState = TextAreaState.EMPTY;\n    _this._selectionChangeListener = null;\n\n    _this.writeScreenReaderContent('ctor');\n\n    _this._hasFocus = false;\n    _this._isDoingComposition = false;\n    _this._nextCommand = 0\n    /* Type */\n    ;\n    var lastKeyDown = null;\n\n    _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', function (e) {\n      if (e.keyCode === 109\n      /* KEY_IN_COMPOSITION */\n      || _this._isDoingComposition && e.keyCode === 1\n      /* Backspace */\n      ) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n\n      if (e.equals(9\n      /* Escape */\n      )) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n\n      lastKeyDown = e;\n\n      _this._onKeyDown.fire(e);\n    }));\n\n    _this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', function (e) {\n      _this._onKeyUp.fire(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionstart]\", e);\n      }\n\n      if (_this._isDoingComposition) {\n        return;\n      }\n\n      _this._isDoingComposition = true;\n      var moveOneCharacterLeft = false;\n\n      if (platform.isMacintosh && lastKeyDown && lastKeyDown.equals(109\n      /* KEY_IN_COMPOSITION */\n      ) && _this._textAreaState.selectionStart === _this._textAreaState.selectionEnd && _this._textAreaState.selectionStart > 0 && _this._textAreaState.value.substr(_this._textAreaState.selectionStart - 1, 1) === e.data) {\n        // Handling long press case on macOS + arrow key => pretend the character was selected\n        if (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft') {\n          if (_debugComposition) {\n            console.log(\"[compositionstart] Handling long press case on macOS + arrow key\", e);\n          }\n\n          moveOneCharacterLeft = true;\n        }\n      }\n\n      if (moveOneCharacterLeft) {\n        _this._textAreaState = new TextAreaState(_this._textAreaState.value, _this._textAreaState.selectionStart - 1, _this._textAreaState.selectionEnd, _this._textAreaState.selectionStartPosition ? new Position(_this._textAreaState.selectionStartPosition.lineNumber, _this._textAreaState.selectionStartPosition.column - 1) : null, _this._textAreaState.selectionEndPosition);\n      } else {\n        _this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n      }\n\n      _this._onCompositionStart.fire({\n        moveOneCharacterLeft: moveOneCharacterLeft\n      });\n    }));\n    /**\r\n     * Deduce the typed input from a text area's value and the last observed state.\r\n     */\n\n\n    var deduceInputFromTextAreaValue = function deduceInputFromTextAreaValue(couldBeEmojiInput) {\n      var oldState = _this._textAreaState;\n      var newState = TextAreaState.readFromTextArea(_this._textArea);\n      return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n    };\n    /**\r\n     * Deduce the composition input from a string.\r\n     */\n\n\n    var deduceComposition = function deduceComposition(text) {\n      var oldState = _this._textAreaState;\n      var newState = TextAreaState.selectedText(text);\n      var typeInput = {\n        text: newState.value,\n        replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n      };\n      return [newState, typeInput];\n    };\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionupdate]\", e);\n      }\n\n      var _deduceComposition = deduceComposition(e.data || ''),\n          _deduceComposition2 = _slicedToArray(_deduceComposition, 2),\n          newState = _deduceComposition2[0],\n          typeInput = _deduceComposition2[1];\n\n      _this._textAreaState = newState;\n\n      _this._onType.fire(typeInput);\n\n      _this._onCompositionUpdate.fire(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', function (e) {\n      if (_debugComposition) {\n        console.log(\"[compositionend]\", e);\n      } // https://github.com/microsoft/monaco-editor/issues/1663\n      // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n\n\n      if (!_this._isDoingComposition) {\n        return;\n      }\n\n      var _deduceComposition3 = deduceComposition(e.data || ''),\n          _deduceComposition4 = _slicedToArray(_deduceComposition3, 2),\n          newState = _deduceComposition4[0],\n          typeInput = _deduceComposition4[1];\n\n      _this._textAreaState = newState;\n\n      _this._onType.fire(typeInput); // isChrome: the textarea is not updated correctly when composition ends\n      // isFirefox: the textarea is not updated correctly after inserting emojis\n      // => we cannot assume the text at the end consists only of the composited text\n\n\n      if (browser.isChrome || browser.isFirefox) {\n        _this._textAreaState = TextAreaState.readFromTextArea(_this._textArea);\n      }\n\n      if (!_this._isDoingComposition) {\n        return;\n      }\n\n      _this._isDoingComposition = false;\n\n      _this._onCompositionEnd.fire();\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'input', function () {\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received input event');\n\n      if (_this._isDoingComposition) {\n        return;\n      }\n\n      var _deduceInputFromTextA = deduceInputFromTextAreaValue(\n      /*couldBeEmojiInput*/\n      platform.isMacintosh),\n          _deduceInputFromTextA2 = _slicedToArray(_deduceInputFromTextA, 2),\n          newState = _deduceInputFromTextA2[0],\n          typeInput = _deduceInputFromTextA2[1];\n\n      if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n        // Ignore invalid input but keep it around for next time\n        return;\n      }\n\n      _this._textAreaState = newState;\n\n      if (_this._nextCommand === 0\n      /* Type */\n      ) {\n          if (typeInput.text !== '') {\n            _this._onType.fire(typeInput);\n          }\n        } else {\n        if (typeInput.text !== '' || typeInput.replaceCharCnt !== 0) {\n          _this._firePaste(typeInput.text, null);\n        }\n\n        _this._nextCommand = 0\n        /* Type */\n        ;\n      }\n    })); // --- Clipboard operations\n\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'cut', function (e) {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n      _this._ensureClipboardGetsEditorSelection(e);\n\n      _this._asyncTriggerCut.schedule();\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'copy', function (e) {\n      _this._ensureClipboardGetsEditorSelection(e);\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'paste', function (e) {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      _this._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n      if (ClipboardEventUtils.canUseTextData(e)) {\n        var _ClipboardEventUtils$ = ClipboardEventUtils.getTextData(e),\n            _ClipboardEventUtils$2 = _slicedToArray(_ClipboardEventUtils$, 2),\n            pastePlainText = _ClipboardEventUtils$2[0],\n            metadata = _ClipboardEventUtils$2[1];\n\n        if (pastePlainText !== '') {\n          _this._firePaste(pastePlainText, metadata);\n        }\n      } else {\n        if (_this._textArea.getSelectionStart() !== _this._textArea.getSelectionEnd()) {\n          // Clean up the textarea, to get a clean paste\n          _this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n        }\n\n        _this._nextCommand = 1\n        /* Paste */\n        ;\n      }\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'focus', function () {\n      var hadFocus = _this._hasFocus;\n\n      _this._setHasFocus(true);\n\n      if (browser.isSafari && !hadFocus && _this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        _this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n\n    _this._register(dom.addDisposableListener(textArea.domNode, 'blur', function () {\n      if (_this._isDoingComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        _this._isDoingComposition = false; // Clear the textarea to avoid an unwanted cursor type\n\n        _this.writeScreenReaderContent('blurWithoutCompositionEnd'); // Fire artificial composition end\n\n\n        _this._onCompositionEnd.fire();\n      }\n\n      _this._setHasFocus(false);\n    }));\n\n    return _this;\n  }\n\n  _createClass(TextAreaInput, [{\n    key: \"_installSelectionChangeListener\",\n    value: function _installSelectionChangeListener() {\n      var _this2 = this;\n\n      // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n      // When using a Braille display, it is possible for users to reposition the\n      // system caret. This is reflected in Chrome as a `selectionchange` event.\n      //\n      // The `selectionchange` event appears to be emitted under numerous other circumstances,\n      // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n      // using a Braille display from all the other cases.\n      //\n      // The problems with the `selectionchange` event are:\n      //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n      //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n      //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n      //  * the event is emitted when tabbing into the textarea\n      //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n      //  * the event sometimes comes in bursts for a single logical textarea operation\n      // `selectionchange` events often come multiple times for a single logical change\n      // so throttle multiple `selectionchange` events that burst in a short period of time.\n      var previousSelectionChangeEventTime = 0;\n      return dom.addDisposableListener(document, 'selectionchange', function (e) {\n        if (!_this2._hasFocus) {\n          return;\n        }\n\n        if (_this2._isDoingComposition) {\n          return;\n        }\n\n        if (!browser.isChrome) {\n          // Support only for Chrome until testing happens on other browsers\n          return;\n        }\n\n        var now = Date.now();\n        var delta1 = now - previousSelectionChangeEventTime;\n        previousSelectionChangeEventTime = now;\n\n        if (delta1 < 5) {\n          // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n          // => ignore it\n          return;\n        }\n\n        var delta2 = now - _this2._textArea.getIgnoreSelectionChangeTime();\n\n        _this2._textArea.resetSelectionChangeTime();\n\n        if (delta2 < 100) {\n          // received a `selectionchange` event within 100ms since we touched the textarea\n          // => ignore it, since we caused it\n          return;\n        }\n\n        if (!_this2._textAreaState.selectionStartPosition || !_this2._textAreaState.selectionEndPosition) {\n          // Cannot correlate a position in the textarea with a position in the editor...\n          return;\n        }\n\n        var newValue = _this2._textArea.getValue();\n\n        if (_this2._textAreaState.value !== newValue) {\n          // Cannot correlate a position in the textarea with a position in the editor...\n          return;\n        }\n\n        var newSelectionStart = _this2._textArea.getSelectionStart();\n\n        var newSelectionEnd = _this2._textArea.getSelectionEnd();\n\n        if (_this2._textAreaState.selectionStart === newSelectionStart && _this2._textAreaState.selectionEnd === newSelectionEnd) {\n          // Nothing to do...\n          return;\n        }\n\n        var _newSelectionStartPosition = _this2._textAreaState.deduceEditorPosition(newSelectionStart);\n\n        var newSelectionStartPosition = _this2._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n        var _newSelectionEndPosition = _this2._textAreaState.deduceEditorPosition(newSelectionEnd);\n\n        var newSelectionEndPosition = _this2._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n        var newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n\n        _this2._onSelectionChangeRequest.fire(newSelection);\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TextAreaInput.prototype), \"dispose\", this).call(this);\n\n      if (this._selectionChangeListener) {\n        this._selectionChangeListener.dispose();\n\n        this._selectionChangeListener = null;\n      }\n    }\n  }, {\n    key: \"focusTextArea\",\n    value: function focusTextArea() {\n      // Setting this._hasFocus and writing the screen reader content\n      // will result in a focus() and setSelectionRange() in the textarea\n      this._setHasFocus(true); // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n\n\n      this.refreshFocusState();\n    }\n  }, {\n    key: \"isFocused\",\n    value: function isFocused() {\n      return this._hasFocus;\n    }\n  }, {\n    key: \"refreshFocusState\",\n    value: function refreshFocusState() {\n      var shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n\n      if (shadowRoot) {\n        this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n      } else if (dom.isInDOM(this.textArea.domNode)) {\n        this._setHasFocus(document.activeElement === this.textArea.domNode);\n      } else {\n        this._setHasFocus(false);\n      }\n    }\n  }, {\n    key: \"_setHasFocus\",\n    value: function _setHasFocus(newHasFocus) {\n      if (this._hasFocus === newHasFocus) {\n        // no change\n        return;\n      }\n\n      this._hasFocus = newHasFocus;\n\n      if (this._selectionChangeListener) {\n        this._selectionChangeListener.dispose();\n\n        this._selectionChangeListener = null;\n      }\n\n      if (this._hasFocus) {\n        this._selectionChangeListener = this._installSelectionChangeListener();\n      }\n\n      if (this._hasFocus) {\n        this.writeScreenReaderContent('focusgain');\n      }\n\n      if (this._hasFocus) {\n        this._onFocus.fire();\n      } else {\n        this._onBlur.fire();\n      }\n    }\n  }, {\n    key: \"_setAndWriteTextAreaState\",\n    value: function _setAndWriteTextAreaState(reason, textAreaState) {\n      if (!this._hasFocus) {\n        textAreaState = textAreaState.collapseSelection();\n      }\n\n      textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n      this._textAreaState = textAreaState;\n    }\n  }, {\n    key: \"writeScreenReaderContent\",\n    value: function writeScreenReaderContent(reason) {\n      if (this._isDoingComposition) {\n        // Do not write to the text area when doing composition\n        return;\n      }\n\n      this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n    }\n  }, {\n    key: \"_ensureClipboardGetsEditorSelection\",\n    value: function _ensureClipboardGetsEditorSelection(e) {\n      var dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);\n\n      var storedMetadata = {\n        version: 1,\n        isFromEmptySelection: dataToCopy.isFromEmptySelection,\n        multicursorText: dataToCopy.multicursorText,\n        mode: dataToCopy.mode\n      };\n      InMemoryClipboardMetadataManager.INSTANCE.set( // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n      // Firefox pastes \"LINE\\n\", so let's work around this quirk\n      browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n\n      if (!ClipboardEventUtils.canUseTextData(e)) {\n        // Looks like an old browser. The strategy is to place the text\n        // we'd like to be copied to the clipboard in the textarea and select it.\n        this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n\n        return;\n      }\n\n      ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n  }, {\n    key: \"_firePaste\",\n    value: function _firePaste(text, metadata) {\n      if (!metadata) {\n        // try the in-memory store\n        metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n      }\n\n      this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }\n  }]);\n\n  return TextAreaInput;\n}(Disposable);\n\nvar ClipboardEventUtils = /*#__PURE__*/function () {\n  function ClipboardEventUtils() {\n    _classCallCheck(this, ClipboardEventUtils);\n  }\n\n  _createClass(ClipboardEventUtils, null, [{\n    key: \"canUseTextData\",\n    value: function canUseTextData(e) {\n      if (e.clipboardData) {\n        return true;\n      }\n\n      if (window.clipboardData) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getTextData\",\n    value: function getTextData(e) {\n      if (e.clipboardData) {\n        e.preventDefault();\n        var text = e.clipboardData.getData('text/plain');\n        var metadata = null;\n        var rawmetadata = e.clipboardData.getData('vscode-editor-data');\n\n        if (typeof rawmetadata === 'string') {\n          try {\n            metadata = JSON.parse(rawmetadata);\n\n            if (metadata.version !== 1) {\n              metadata = null;\n            }\n          } catch (err) {// no problem!\n          }\n        }\n\n        return [text, metadata];\n      }\n\n      if (window.clipboardData) {\n        e.preventDefault();\n\n        var _text = window.clipboardData.getData('Text');\n\n        return [_text, null];\n      }\n\n      throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n    }\n  }, {\n    key: \"setTextData\",\n    value: function setTextData(e, text, html, metadata) {\n      if (e.clipboardData) {\n        e.clipboardData.setData('text/plain', text);\n\n        if (typeof html === 'string') {\n          e.clipboardData.setData('text/html', html);\n        }\n\n        e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n        e.preventDefault();\n        return;\n      }\n\n      if (window.clipboardData) {\n        window.clipboardData.setData('Text', text);\n        e.preventDefault();\n        return;\n      }\n\n      throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n    }\n  }]);\n\n  return ClipboardEventUtils;\n}();\n\nvar TextAreaWrapper = /*#__PURE__*/function (_Disposable2) {\n  _inherits(TextAreaWrapper, _Disposable2);\n\n  var _super2 = _createSuper(TextAreaWrapper);\n\n  function TextAreaWrapper(_textArea) {\n    var _this3;\n\n    _classCallCheck(this, TextAreaWrapper);\n\n    _this3 = _super2.call(this);\n    _this3._actual = _textArea;\n    _this3._ignoreSelectionChangeTime = 0;\n    return _this3;\n  }\n\n  _createClass(TextAreaWrapper, [{\n    key: \"setIgnoreSelectionChangeTime\",\n    value: function setIgnoreSelectionChangeTime(reason) {\n      this._ignoreSelectionChangeTime = Date.now();\n    }\n  }, {\n    key: \"getIgnoreSelectionChangeTime\",\n    value: function getIgnoreSelectionChangeTime() {\n      return this._ignoreSelectionChangeTime;\n    }\n  }, {\n    key: \"resetSelectionChangeTime\",\n    value: function resetSelectionChangeTime() {\n      this._ignoreSelectionChangeTime = 0;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      // console.log('current value: ' + this._textArea.value);\n      return this._actual.domNode.value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(reason, value) {\n      var textArea = this._actual.domNode;\n\n      if (textArea.value === value) {\n        // No change\n        return;\n      } // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\n\n      this.setIgnoreSelectionChangeTime('setValue');\n      textArea.value = value;\n    }\n  }, {\n    key: \"getSelectionStart\",\n    value: function getSelectionStart() {\n      return this._actual.domNode.selectionStart;\n    }\n  }, {\n    key: \"getSelectionEnd\",\n    value: function getSelectionEnd() {\n      return this._actual.domNode.selectionEnd;\n    }\n  }, {\n    key: \"setSelectionRange\",\n    value: function setSelectionRange(reason, selectionStart, selectionEnd) {\n      var textArea = this._actual.domNode;\n      var activeElement = null;\n      var shadowRoot = dom.getShadowRoot(textArea);\n\n      if (shadowRoot) {\n        activeElement = shadowRoot.activeElement;\n      } else {\n        activeElement = document.activeElement;\n      }\n\n      var currentIsFocused = activeElement === textArea;\n      var currentSelectionStart = textArea.selectionStart;\n      var currentSelectionEnd = textArea.selectionEnd;\n\n      if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n        // No change\n        // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n        if (browser.isFirefox && window.parent !== window) {\n          textArea.focus();\n        }\n\n        return;\n      } // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\n      if (currentIsFocused) {\n        // No need to focus, only need to change the selection range\n        this.setIgnoreSelectionChangeTime('setSelectionRange');\n        textArea.setSelectionRange(selectionStart, selectionEnd);\n\n        if (browser.isFirefox && window.parent !== window) {\n          textArea.focus();\n        }\n\n        return;\n      } // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n      // Here, we try to undo the browser's desperate reveal.\n\n\n      try {\n        var scrollState = dom.saveParentsScrollTop(textArea);\n        this.setIgnoreSelectionChangeTime('setSelectionRange');\n        textArea.focus();\n        textArea.setSelectionRange(selectionStart, selectionEnd);\n        dom.restoreParentsScrollTop(textArea, scrollState);\n      } catch (e) {// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n      }\n    }\n  }]);\n\n  return TextAreaWrapper;\n}(Disposable);","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"names":["browser","dom","RunOnceScheduler","Emitter","Disposable","platform","strings","TextAreaState","_debugComposition","Position","Selection","BrowserFeatures","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","_lastState","lastCopiedValue","data","pastedText","INSTANCE","TextAreaInput","host","textArea","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_host","_textArea","TextAreaWrapper","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","_textAreaState","EMPTY","_selectionChangeListener","_hasFocus","_isDoingComposition","_nextCommand","lastKeyDown","addStandardDisposableListener","domNode","e","keyCode","stopPropagation","equals","preventDefault","addDisposableListener","console","log","moveOneCharacterLeft","isMacintosh","selectionStart","selectionEnd","value","substr","code","selectionStartPosition","lineNumber","column","selectionEndPosition","_setAndWriteTextAreaState","deduceInputFromTextAreaValue","couldBeEmojiInput","oldState","newState","readFromTextArea","deduceInput","deduceComposition","text","selectedText","typeInput","replaceCharCnt","isChrome","isFirefox","setIgnoreSelectionChangeTime","length","isHighSurrogate","charCodeAt","_firePaste","_ensureClipboardGetsEditorSelection","schedule","ClipboardEventUtils","canUseTextData","getTextData","pastePlainText","metadata","getSelectionStart","getSelectionEnd","hadFocus","_setHasFocus","isSafari","previousSelectionChangeEventTime","document","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","newValue","getValue","newSelectionStart","newSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","dispose","refreshFocusState","shadowRoot","getShadowRoot","activeElement","isInDOM","newHasFocus","_installSelectionChangeListener","reason","textAreaState","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","clipboard","richText","storedMetadata","version","isFromEmptySelection","multicursorText","mode","set","replace","setTextData","html","get","clipboardData","window","getData","rawmetadata","JSON","parse","err","Error","setData","stringify","_actual","_ignoreSelectionChangeTime","currentIsFocused","currentSelectionStart","currentSelectionEnd","parent","focus","setSelectionRange","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport * as browser from '../../../base/browser/browser.js';\r\nimport * as dom from '../../../base/browser/dom.js';\r\nimport { RunOnceScheduler } from '../../../base/common/async.js';\r\nimport { Emitter } from '../../../base/common/event.js';\r\nimport { Disposable } from '../../../base/common/lifecycle.js';\r\nimport * as platform from '../../../base/common/platform.js';\r\nimport * as strings from '../../../base/common/strings.js';\r\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\r\nimport { Position } from '../../common/core/position.js';\r\nimport { Selection } from '../../common/core/selection.js';\r\nimport { BrowserFeatures } from '../../../base/browser/canIUse.js';\r\nexport const CopyOptions = {\r\n    forceCopyWithSyntaxHighlighting: false\r\n};\r\n/**\r\n * Every time we write to the clipboard, we record a bit of extra metadata here.\r\n * Every time we read from the cipboard, if the text matches our last written text,\r\n * we can fetch the previous metadata.\r\n */\r\nexport class InMemoryClipboardMetadataManager {\r\n    constructor() {\r\n        this._lastState = null;\r\n    }\r\n    set(lastCopiedValue, data) {\r\n        this._lastState = { lastCopiedValue, data };\r\n    }\r\n    get(pastedText) {\r\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\r\n            // match!\r\n            return this._lastState.data;\r\n        }\r\n        this._lastState = null;\r\n        return null;\r\n    }\r\n}\r\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\r\n/**\r\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\r\n *  - onCut\r\n *  - onPaste\r\n *  - onType\r\n *\r\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\r\n */\r\nexport class TextAreaInput extends Disposable {\r\n    constructor(host, textArea) {\r\n        super();\r\n        this.textArea = textArea;\r\n        this._onFocus = this._register(new Emitter());\r\n        this.onFocus = this._onFocus.event;\r\n        this._onBlur = this._register(new Emitter());\r\n        this.onBlur = this._onBlur.event;\r\n        this._onKeyDown = this._register(new Emitter());\r\n        this.onKeyDown = this._onKeyDown.event;\r\n        this._onKeyUp = this._register(new Emitter());\r\n        this.onKeyUp = this._onKeyUp.event;\r\n        this._onCut = this._register(new Emitter());\r\n        this.onCut = this._onCut.event;\r\n        this._onPaste = this._register(new Emitter());\r\n        this.onPaste = this._onPaste.event;\r\n        this._onType = this._register(new Emitter());\r\n        this.onType = this._onType.event;\r\n        this._onCompositionStart = this._register(new Emitter());\r\n        this.onCompositionStart = this._onCompositionStart.event;\r\n        this._onCompositionUpdate = this._register(new Emitter());\r\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\r\n        this._onCompositionEnd = this._register(new Emitter());\r\n        this.onCompositionEnd = this._onCompositionEnd.event;\r\n        this._onSelectionChangeRequest = this._register(new Emitter());\r\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\r\n        this._host = host;\r\n        this._textArea = this._register(new TextAreaWrapper(textArea));\r\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\r\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\r\n        this._textAreaState = TextAreaState.EMPTY;\r\n        this._selectionChangeListener = null;\r\n        this.writeScreenReaderContent('ctor');\r\n        this._hasFocus = false;\r\n        this._isDoingComposition = false;\r\n        this._nextCommand = 0 /* Type */;\r\n        let lastKeyDown = null;\r\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e) => {\r\n            if (e.keyCode === 109 /* KEY_IN_COMPOSITION */\r\n                || (this._isDoingComposition && e.keyCode === 1 /* Backspace */)) {\r\n                // Stop propagation for keyDown events if the IME is processing key input\r\n                e.stopPropagation();\r\n            }\r\n            if (e.equals(9 /* Escape */)) {\r\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\r\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\r\n                e.preventDefault();\r\n            }\r\n            lastKeyDown = e;\r\n            this._onKeyDown.fire(e);\r\n        }));\r\n        this._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e) => {\r\n            this._onKeyUp.fire(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionstart]`, e);\r\n            }\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            this._isDoingComposition = true;\r\n            let moveOneCharacterLeft = false;\r\n            if (platform.isMacintosh\r\n                && lastKeyDown\r\n                && lastKeyDown.equals(109 /* KEY_IN_COMPOSITION */)\r\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\r\n                && this._textAreaState.selectionStart > 0\r\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data) {\r\n                // Handling long press case on macOS + arrow key => pretend the character was selected\r\n                if (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft') {\r\n                    if (_debugComposition) {\r\n                        console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\r\n                    }\r\n                    moveOneCharacterLeft = true;\r\n                }\r\n            }\r\n            if (moveOneCharacterLeft) {\r\n                this._textAreaState = new TextAreaState(this._textAreaState.value, this._textAreaState.selectionStart - 1, this._textAreaState.selectionEnd, this._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null, this._textAreaState.selectionEndPosition);\r\n            }\r\n            else {\r\n                this._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\r\n            }\r\n            this._onCompositionStart.fire({ moveOneCharacterLeft });\r\n        }));\r\n        /**\r\n         * Deduce the typed input from a text area's value and the last observed state.\r\n         */\r\n        const deduceInputFromTextAreaValue = (couldBeEmojiInput) => {\r\n            const oldState = this._textAreaState;\r\n            const newState = TextAreaState.readFromTextArea(this._textArea);\r\n            return [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\r\n        };\r\n        /**\r\n         * Deduce the composition input from a string.\r\n         */\r\n        const deduceComposition = (text) => {\r\n            const oldState = this._textAreaState;\r\n            const newState = TextAreaState.selectedText(text);\r\n            const typeInput = {\r\n                text: newState.value,\r\n                replaceCharCnt: oldState.selectionEnd - oldState.selectionStart\r\n            };\r\n            return [newState, typeInput];\r\n        };\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionupdate]`, e);\r\n            }\r\n            const [newState, typeInput] = deduceComposition(e.data || '');\r\n            this._textAreaState = newState;\r\n            this._onType.fire(typeInput);\r\n            this._onCompositionUpdate.fire(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e) => {\r\n            if (_debugComposition) {\r\n                console.log(`[compositionend]`, e);\r\n            }\r\n            // https://github.com/microsoft/monaco-editor/issues/1663\r\n            // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\r\n            if (!this._isDoingComposition) {\r\n                return;\r\n            }\r\n            const [newState, typeInput] = deduceComposition(e.data || '');\r\n            this._textAreaState = newState;\r\n            this._onType.fire(typeInput);\r\n            // isChrome: the textarea is not updated correctly when composition ends\r\n            // isFirefox: the textarea is not updated correctly after inserting emojis\r\n            // => we cannot assume the text at the end consists only of the composited text\r\n            if (browser.isChrome || browser.isFirefox) {\r\n                this._textAreaState = TextAreaState.readFromTextArea(this._textArea);\r\n            }\r\n            if (!this._isDoingComposition) {\r\n                return;\r\n            }\r\n            this._isDoingComposition = false;\r\n            this._onCompositionEnd.fire();\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\r\n            // Pretend here we touched the text area, as the `input` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            const [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/ platform.isMacintosh);\r\n            if (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\r\n                // Ignore invalid input but keep it around for next time\r\n                return;\r\n            }\r\n            this._textAreaState = newState;\r\n            if (this._nextCommand === 0 /* Type */) {\r\n                if (typeInput.text !== '') {\r\n                    this._onType.fire(typeInput);\r\n                }\r\n            }\r\n            else {\r\n                if (typeInput.text !== '' || typeInput.replaceCharCnt !== 0) {\r\n                    this._firePaste(typeInput.text, null);\r\n                }\r\n                this._nextCommand = 0 /* Type */;\r\n            }\r\n        }));\r\n        // --- Clipboard operations\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'cut', (e) => {\r\n            // Pretend here we touched the text area, as the `cut` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\r\n            this._ensureClipboardGetsEditorSelection(e);\r\n            this._asyncTriggerCut.schedule();\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'copy', (e) => {\r\n            this._ensureClipboardGetsEditorSelection(e);\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'paste', (e) => {\r\n            // Pretend here we touched the text area, as the `paste` event will most likely\r\n            // result in a `selectionchange` event which we want to ignore\r\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\r\n            if (ClipboardEventUtils.canUseTextData(e)) {\r\n                const [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\r\n                if (pastePlainText !== '') {\r\n                    this._firePaste(pastePlainText, metadata);\r\n                }\r\n            }\r\n            else {\r\n                if (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\r\n                    // Clean up the textarea, to get a clean paste\r\n                    this._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\r\n                }\r\n                this._nextCommand = 1 /* Paste */;\r\n            }\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\r\n            const hadFocus = this._hasFocus;\r\n            this._setHasFocus(true);\r\n            if (browser.isSafari && !hadFocus && this._hasFocus) {\r\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\r\n                // Safari will always move the selection at offset 0 in the textarea\r\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\r\n            }\r\n        }));\r\n        this._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\r\n            if (this._isDoingComposition) {\r\n                // See https://github.com/microsoft/vscode/issues/112621\r\n                // where compositionend is not triggered when the editor\r\n                // is taken off-dom during a composition\r\n                // Clear the flag to be able to write to the textarea\r\n                this._isDoingComposition = false;\r\n                // Clear the textarea to avoid an unwanted cursor type\r\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\r\n                // Fire artificial composition end\r\n                this._onCompositionEnd.fire();\r\n            }\r\n            this._setHasFocus(false);\r\n        }));\r\n    }\r\n    _installSelectionChangeListener() {\r\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\r\n        // When using a Braille display, it is possible for users to reposition the\r\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\r\n        //\r\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\r\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\r\n        // using a Braille display from all the other cases.\r\n        //\r\n        // The problems with the `selectionchange` event are:\r\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\r\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\r\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\r\n        //  * the event is emitted when tabbing into the textarea\r\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\r\n        //  * the event sometimes comes in bursts for a single logical textarea operation\r\n        // `selectionchange` events often come multiple times for a single logical change\r\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\r\n        let previousSelectionChangeEventTime = 0;\r\n        return dom.addDisposableListener(document, 'selectionchange', (e) => {\r\n            if (!this._hasFocus) {\r\n                return;\r\n            }\r\n            if (this._isDoingComposition) {\r\n                return;\r\n            }\r\n            if (!browser.isChrome) {\r\n                // Support only for Chrome until testing happens on other browsers\r\n                return;\r\n            }\r\n            const now = Date.now();\r\n            const delta1 = now - previousSelectionChangeEventTime;\r\n            previousSelectionChangeEventTime = now;\r\n            if (delta1 < 5) {\r\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\r\n                // => ignore it\r\n                return;\r\n            }\r\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\r\n            this._textArea.resetSelectionChangeTime();\r\n            if (delta2 < 100) {\r\n                // received a `selectionchange` event within 100ms since we touched the textarea\r\n                // => ignore it, since we caused it\r\n                return;\r\n            }\r\n            if (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\r\n                // Cannot correlate a position in the textarea with a position in the editor...\r\n                return;\r\n            }\r\n            const newValue = this._textArea.getValue();\r\n            if (this._textAreaState.value !== newValue) {\r\n                // Cannot correlate a position in the textarea with a position in the editor...\r\n                return;\r\n            }\r\n            const newSelectionStart = this._textArea.getSelectionStart();\r\n            const newSelectionEnd = this._textArea.getSelectionEnd();\r\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\r\n                // Nothing to do...\r\n                return;\r\n            }\r\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\r\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\r\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\r\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\r\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\r\n            this._onSelectionChangeRequest.fire(newSelection);\r\n        });\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        if (this._selectionChangeListener) {\r\n            this._selectionChangeListener.dispose();\r\n            this._selectionChangeListener = null;\r\n        }\r\n    }\r\n    focusTextArea() {\r\n        // Setting this._hasFocus and writing the screen reader content\r\n        // will result in a focus() and setSelectionRange() in the textarea\r\n        this._setHasFocus(true);\r\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\r\n        this.refreshFocusState();\r\n    }\r\n    isFocused() {\r\n        return this._hasFocus;\r\n    }\r\n    refreshFocusState() {\r\n        const shadowRoot = dom.getShadowRoot(this.textArea.domNode);\r\n        if (shadowRoot) {\r\n            this._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\r\n        }\r\n        else if (dom.isInDOM(this.textArea.domNode)) {\r\n            this._setHasFocus(document.activeElement === this.textArea.domNode);\r\n        }\r\n        else {\r\n            this._setHasFocus(false);\r\n        }\r\n    }\r\n    _setHasFocus(newHasFocus) {\r\n        if (this._hasFocus === newHasFocus) {\r\n            // no change\r\n            return;\r\n        }\r\n        this._hasFocus = newHasFocus;\r\n        if (this._selectionChangeListener) {\r\n            this._selectionChangeListener.dispose();\r\n            this._selectionChangeListener = null;\r\n        }\r\n        if (this._hasFocus) {\r\n            this._selectionChangeListener = this._installSelectionChangeListener();\r\n        }\r\n        if (this._hasFocus) {\r\n            this.writeScreenReaderContent('focusgain');\r\n        }\r\n        if (this._hasFocus) {\r\n            this._onFocus.fire();\r\n        }\r\n        else {\r\n            this._onBlur.fire();\r\n        }\r\n    }\r\n    _setAndWriteTextAreaState(reason, textAreaState) {\r\n        if (!this._hasFocus) {\r\n            textAreaState = textAreaState.collapseSelection();\r\n        }\r\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\r\n        this._textAreaState = textAreaState;\r\n    }\r\n    writeScreenReaderContent(reason) {\r\n        if (this._isDoingComposition) {\r\n            // Do not write to the text area when doing composition\r\n            return;\r\n        }\r\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\r\n    }\r\n    _ensureClipboardGetsEditorSelection(e) {\r\n        const dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);\r\n        const storedMetadata = {\r\n            version: 1,\r\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\r\n            multicursorText: dataToCopy.multicursorText,\r\n            mode: dataToCopy.mode\r\n        };\r\n        InMemoryClipboardMetadataManager.INSTANCE.set(\r\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\r\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\r\n        (browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\r\n        if (!ClipboardEventUtils.canUseTextData(e)) {\r\n            // Looks like an old browser. The strategy is to place the text\r\n            // we'd like to be copied to the clipboard in the textarea and select it.\r\n            this._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\r\n            return;\r\n        }\r\n        ClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\r\n    }\r\n    _firePaste(text, metadata) {\r\n        if (!metadata) {\r\n            // try the in-memory store\r\n            metadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\r\n        }\r\n        this._onPaste.fire({\r\n            text: text,\r\n            metadata: metadata\r\n        });\r\n    }\r\n}\r\nclass ClipboardEventUtils {\r\n    static canUseTextData(e) {\r\n        if (e.clipboardData) {\r\n            return true;\r\n        }\r\n        if (window.clipboardData) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    static getTextData(e) {\r\n        if (e.clipboardData) {\r\n            e.preventDefault();\r\n            const text = e.clipboardData.getData('text/plain');\r\n            let metadata = null;\r\n            const rawmetadata = e.clipboardData.getData('vscode-editor-data');\r\n            if (typeof rawmetadata === 'string') {\r\n                try {\r\n                    metadata = JSON.parse(rawmetadata);\r\n                    if (metadata.version !== 1) {\r\n                        metadata = null;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    // no problem!\r\n                }\r\n            }\r\n            return [text, metadata];\r\n        }\r\n        if (window.clipboardData) {\r\n            e.preventDefault();\r\n            const text = window.clipboardData.getData('Text');\r\n            return [text, null];\r\n        }\r\n        throw new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\r\n    }\r\n    static setTextData(e, text, html, metadata) {\r\n        if (e.clipboardData) {\r\n            e.clipboardData.setData('text/plain', text);\r\n            if (typeof html === 'string') {\r\n                e.clipboardData.setData('text/html', html);\r\n            }\r\n            e.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\r\n            e.preventDefault();\r\n            return;\r\n        }\r\n        if (window.clipboardData) {\r\n            window.clipboardData.setData('Text', text);\r\n            e.preventDefault();\r\n            return;\r\n        }\r\n        throw new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\r\n    }\r\n}\r\nclass TextAreaWrapper extends Disposable {\r\n    constructor(_textArea) {\r\n        super();\r\n        this._actual = _textArea;\r\n        this._ignoreSelectionChangeTime = 0;\r\n    }\r\n    setIgnoreSelectionChangeTime(reason) {\r\n        this._ignoreSelectionChangeTime = Date.now();\r\n    }\r\n    getIgnoreSelectionChangeTime() {\r\n        return this._ignoreSelectionChangeTime;\r\n    }\r\n    resetSelectionChangeTime() {\r\n        this._ignoreSelectionChangeTime = 0;\r\n    }\r\n    getValue() {\r\n        // console.log('current value: ' + this._textArea.value);\r\n        return this._actual.domNode.value;\r\n    }\r\n    setValue(reason, value) {\r\n        const textArea = this._actual.domNode;\r\n        if (textArea.value === value) {\r\n            // No change\r\n            return;\r\n        }\r\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\r\n        this.setIgnoreSelectionChangeTime('setValue');\r\n        textArea.value = value;\r\n    }\r\n    getSelectionStart() {\r\n        return this._actual.domNode.selectionStart;\r\n    }\r\n    getSelectionEnd() {\r\n        return this._actual.domNode.selectionEnd;\r\n    }\r\n    setSelectionRange(reason, selectionStart, selectionEnd) {\r\n        const textArea = this._actual.domNode;\r\n        let activeElement = null;\r\n        const shadowRoot = dom.getShadowRoot(textArea);\r\n        if (shadowRoot) {\r\n            activeElement = shadowRoot.activeElement;\r\n        }\r\n        else {\r\n            activeElement = document.activeElement;\r\n        }\r\n        const currentIsFocused = (activeElement === textArea);\r\n        const currentSelectionStart = textArea.selectionStart;\r\n        const currentSelectionEnd = textArea.selectionEnd;\r\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\r\n            // No change\r\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\r\n            if (browser.isFirefox && window.parent !== window) {\r\n                textArea.focus();\r\n            }\r\n            return;\r\n        }\r\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\r\n        if (currentIsFocused) {\r\n            // No need to focus, only need to change the selection range\r\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\r\n            textArea.setSelectionRange(selectionStart, selectionEnd);\r\n            if (browser.isFirefox && window.parent !== window) {\r\n                textArea.focus();\r\n            }\r\n            return;\r\n        }\r\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\r\n        // Here, we try to undo the browser's desperate reveal.\r\n        try {\r\n            const scrollState = dom.saveParentsScrollTop(textArea);\r\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\r\n            textArea.focus();\r\n            textArea.setSelectionRange(selectionStart, selectionEnd);\r\n            dom.restoreParentsScrollTop(textArea, scrollState);\r\n        }\r\n        catch (e) {\r\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}