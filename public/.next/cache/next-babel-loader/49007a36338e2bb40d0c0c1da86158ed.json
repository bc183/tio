{"ast":null,"code":"import _classCallCheck from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/bar007/Desktop/projects/tio/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\nimport * as modes from '../../../common/modes.js';\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\nimport * as monarchCommon from './monarchCommon.js';\nvar CACHE_STACK_DEPTH = 5;\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\n\nvar MonarchStackElementFactory = /*#__PURE__*/function () {\n  function MonarchStackElementFactory(maxCacheDepth) {\n    _classCallCheck(this, MonarchStackElementFactory);\n\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  _createClass(MonarchStackElementFactory, [{\n    key: \"create\",\n    value: function create(parent, state) {\n      if (parent !== null && parent.depth >= this._maxCacheDepth) {\n        // no caching above a certain depth\n        return new MonarchStackElement(parent, state);\n      }\n\n      var stackElementId = MonarchStackElement.getStackElementId(parent);\n\n      if (stackElementId.length > 0) {\n        stackElementId += '|';\n      }\n\n      stackElementId += state;\n      var result = this._entries[stackElementId];\n\n      if (result) {\n        return result;\n      }\n\n      result = new MonarchStackElement(parent, state);\n      this._entries[stackElementId] = result;\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(parent, state) {\n      return this._INSTANCE.create(parent, state);\n    }\n  }]);\n\n  return MonarchStackElementFactory;\n}();\n\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\n\nvar MonarchStackElement = /*#__PURE__*/function () {\n  function MonarchStackElement(parent, state) {\n    _classCallCheck(this, MonarchStackElement);\n\n    this.parent = parent;\n    this.state = state;\n    this.depth = (this.parent ? this.parent.depth : 0) + 1;\n  }\n\n  _createClass(MonarchStackElement, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return MonarchStackElement._equals(this, other);\n    }\n  }, {\n    key: \"push\",\n    value: function push(state) {\n      return MonarchStackElementFactory.create(this, state);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.parent;\n    }\n  }, {\n    key: \"popall\",\n    value: function popall() {\n      var result = this;\n\n      while (result.parent) {\n        result = result.parent;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"switchTo\",\n    value: function switchTo(state) {\n      return MonarchStackElementFactory.create(this.parent, state);\n    }\n  }], [{\n    key: \"getStackElementId\",\n    value: function getStackElementId(element) {\n      var result = '';\n\n      while (element !== null) {\n        if (result.length > 0) {\n          result += '|';\n        }\n\n        result += element.state;\n        element = element.parent;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_equals\",\n    value: function _equals(a, b) {\n      while (a !== null && b !== null) {\n        if (a === b) {\n          return true;\n        }\n\n        if (a.state !== b.state) {\n          return false;\n        }\n\n        a = a.parent;\n        b = b.parent;\n      }\n\n      if (a === null && b === null) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return MonarchStackElement;\n}();\n\nvar EmbeddedModeData = /*#__PURE__*/function () {\n  function EmbeddedModeData(modeId, state) {\n    _classCallCheck(this, EmbeddedModeData);\n\n    this.modeId = modeId;\n    this.state = state;\n  }\n\n  _createClass(EmbeddedModeData, [{\n    key: \"equals\",\n    value: function equals(other) {\n      return this.modeId === other.modeId && this.state.equals(other.state);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var stateClone = this.state.clone(); // save an object\n\n      if (stateClone === this.state) {\n        return this;\n      }\n\n      return new EmbeddedModeData(this.modeId, this.state);\n    }\n  }]);\n\n  return EmbeddedModeData;\n}();\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\n\n\nvar MonarchLineStateFactory = /*#__PURE__*/function () {\n  function MonarchLineStateFactory(maxCacheDepth) {\n    _classCallCheck(this, MonarchLineStateFactory);\n\n    this._maxCacheDepth = maxCacheDepth;\n    this._entries = Object.create(null);\n  }\n\n  _createClass(MonarchLineStateFactory, [{\n    key: \"create\",\n    value: function create(stack, embeddedModeData) {\n      if (embeddedModeData !== null) {\n        // no caching when embedding\n        return new MonarchLineState(stack, embeddedModeData);\n      }\n\n      if (stack !== null && stack.depth >= this._maxCacheDepth) {\n        // no caching above a certain depth\n        return new MonarchLineState(stack, embeddedModeData);\n      }\n\n      var stackElementId = MonarchStackElement.getStackElementId(stack);\n      var result = this._entries[stackElementId];\n\n      if (result) {\n        return result;\n      }\n\n      result = new MonarchLineState(stack, null);\n      this._entries[stackElementId] = result;\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(stack, embeddedModeData) {\n      return this._INSTANCE.create(stack, embeddedModeData);\n    }\n  }]);\n\n  return MonarchLineStateFactory;\n}();\n\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\n\nvar MonarchLineState = /*#__PURE__*/function () {\n  function MonarchLineState(stack, embeddedModeData) {\n    _classCallCheck(this, MonarchLineState);\n\n    this.stack = stack;\n    this.embeddedModeData = embeddedModeData;\n  }\n\n  _createClass(MonarchLineState, [{\n    key: \"clone\",\n    value: function clone() {\n      var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null; // save an object\n\n      if (embeddedModeDataClone === this.embeddedModeData) {\n        return this;\n      }\n\n      return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!(other instanceof MonarchLineState)) {\n        return false;\n      }\n\n      if (!this.stack.equals(other.stack)) {\n        return false;\n      }\n\n      if (this.embeddedModeData === null && other.embeddedModeData === null) {\n        return true;\n      }\n\n      if (this.embeddedModeData === null || other.embeddedModeData === null) {\n        return false;\n      }\n\n      return this.embeddedModeData.equals(other.embeddedModeData);\n    }\n  }]);\n\n  return MonarchLineState;\n}();\n\nvar MonarchClassicTokensCollector = /*#__PURE__*/function () {\n  function MonarchClassicTokensCollector() {\n    _classCallCheck(this, MonarchClassicTokensCollector);\n\n    this._tokens = [];\n    this._language = null;\n    this._lastTokenType = null;\n    this._lastTokenLanguage = null;\n  }\n\n  _createClass(MonarchClassicTokensCollector, [{\n    key: \"enterMode\",\n    value: function enterMode(startOffset, modeId) {\n      this._language = modeId;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(startOffset, type) {\n      if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\n        return;\n      }\n\n      this._lastTokenType = type;\n      this._lastTokenLanguage = this._language;\n\n      this._tokens.push(new Token(startOffset, type, this._language));\n    }\n  }, {\n    key: \"nestedModeTokenize\",\n    value: function nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n      var nestedModeId = embeddedModeData.modeId;\n      var embeddedModeState = embeddedModeData.state;\n      var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (!nestedModeTokenizationSupport) {\n        this.enterMode(offsetDelta, nestedModeId);\n        this.emit(offsetDelta, '');\n        return embeddedModeState;\n      }\n\n      var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n      this._tokens = this._tokens.concat(nestedResult.tokens);\n      this._lastTokenType = null;\n      this._lastTokenLanguage = null;\n      this._language = null;\n      return nestedResult.endState;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize(endState) {\n      return new TokenizationResult(this._tokens, endState);\n    }\n  }]);\n\n  return MonarchClassicTokensCollector;\n}();\n\nvar MonarchModernTokensCollector = /*#__PURE__*/function () {\n  function MonarchModernTokensCollector(modeService, theme) {\n    _classCallCheck(this, MonarchModernTokensCollector);\n\n    this._modeService = modeService;\n    this._theme = theme;\n    this._prependTokens = null;\n    this._tokens = [];\n    this._currentLanguageId = 0\n    /* Null */\n    ;\n    this._lastTokenMetadata = 0;\n  }\n\n  _createClass(MonarchModernTokensCollector, [{\n    key: \"enterMode\",\n    value: function enterMode(startOffset, modeId) {\n      this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(startOffset, type) {\n      var metadata = this._theme.match(this._currentLanguageId, type);\n\n      if (this._lastTokenMetadata === metadata) {\n        return;\n      }\n\n      this._lastTokenMetadata = metadata;\n\n      this._tokens.push(startOffset);\n\n      this._tokens.push(metadata);\n    }\n  }, {\n    key: \"nestedModeTokenize\",\n    value: function nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\n      var nestedModeId = embeddedModeData.modeId;\n      var embeddedModeState = embeddedModeData.state;\n      var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n      if (!nestedModeTokenizationSupport) {\n        this.enterMode(offsetDelta, nestedModeId);\n        this.emit(offsetDelta, '');\n        return embeddedModeState;\n      }\n\n      var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\n      this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\n      this._tokens = [];\n      this._currentLanguageId = 0;\n      this._lastTokenMetadata = 0;\n      return nestedResult.endState;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize(endState) {\n      return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\n    }\n  }], [{\n    key: \"_merge\",\n    value: function _merge(a, b, c) {\n      var aLen = a !== null ? a.length : 0;\n      var bLen = b.length;\n      var cLen = c !== null ? c.length : 0;\n\n      if (aLen === 0 && bLen === 0 && cLen === 0) {\n        return new Uint32Array(0);\n      }\n\n      if (aLen === 0 && bLen === 0) {\n        return c;\n      }\n\n      if (bLen === 0 && cLen === 0) {\n        return a;\n      }\n\n      var result = new Uint32Array(aLen + bLen + cLen);\n\n      if (a !== null) {\n        result.set(a);\n      }\n\n      for (var i = 0; i < bLen; i++) {\n        result[aLen + i] = b[i];\n      }\n\n      if (c !== null) {\n        result.set(c, aLen + bLen);\n      }\n\n      return result;\n    }\n  }]);\n\n  return MonarchModernTokensCollector;\n}();\n\nexport var MonarchTokenizer = /*#__PURE__*/function () {\n  function MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer) {\n    var _this = this;\n\n    _classCallCheck(this, MonarchTokenizer);\n\n    this._modeService = modeService;\n    this._standaloneThemeService = standaloneThemeService;\n    this._modeId = modeId;\n    this._lexer = lexer;\n    this._embeddedModes = Object.create(null);\n    this.embeddedLoaded = Promise.resolve(undefined); // Set up listening for embedded modes\n\n    var emitting = false;\n    this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {\n      if (emitting) {\n        return;\n      }\n\n      var isOneOfMyEmbeddedModes = false;\n\n      for (var i = 0, len = e.changedLanguages.length; i < len; i++) {\n        var language = e.changedLanguages[i];\n\n        if (_this._embeddedModes[language]) {\n          isOneOfMyEmbeddedModes = true;\n          break;\n        }\n      }\n\n      if (isOneOfMyEmbeddedModes) {\n        emitting = true;\n        modes.TokenizationRegistry.fire([_this._modeId]);\n        emitting = false;\n      }\n    });\n  }\n\n  _createClass(MonarchTokenizer, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this._tokenizationRegistryListener.dispose();\n    }\n  }, {\n    key: \"getLoadStatus\",\n    value: function getLoadStatus() {\n      var promises = [];\n\n      for (var nestedModeId in this._embeddedModes) {\n        var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n        if (tokenizationSupport) {\n          // The nested mode is already loaded\n          if (tokenizationSupport instanceof MonarchTokenizer) {\n            var nestedModeStatus = tokenizationSupport.getLoadStatus();\n\n            if (nestedModeStatus.loaded === false) {\n              promises.push(nestedModeStatus.promise);\n            }\n          }\n\n          continue;\n        }\n\n        var tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\n\n        if (tokenizationSupportPromise) {\n          // The nested mode is in the process of being loaded\n          promises.push(tokenizationSupportPromise);\n        }\n      }\n\n      if (promises.length === 0) {\n        return {\n          loaded: true\n        };\n      }\n\n      return {\n        loaded: false,\n        promise: Promise.all(promises).then(function (_) {\n          return undefined;\n        })\n      };\n    }\n  }, {\n    key: \"getInitialState\",\n    value: function getInitialState() {\n      var rootState = MonarchStackElementFactory.create(null, this._lexer.start);\n      return MonarchLineStateFactory.create(rootState, null);\n    }\n  }, {\n    key: \"tokenize\",\n    value: function tokenize(line, hasEOL, lineState, offsetDelta) {\n      var tokensCollector = new MonarchClassicTokensCollector();\n\n      var endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n\n      return tokensCollector.finalize(endLineState);\n    }\n  }, {\n    key: \"tokenize2\",\n    value: function tokenize2(line, hasEOL, lineState, offsetDelta) {\n      var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\n\n      var endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\n\n      return tokensCollector.finalize(endLineState);\n    }\n  }, {\n    key: \"_tokenize\",\n    value: function _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\n      if (lineState.embeddedModeData) {\n        return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\n      } else {\n        return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\n      }\n    }\n  }, {\n    key: \"_findLeavingNestedModeOffset\",\n    value: function _findLeavingNestedModeOffset(line, state) {\n      var rules = this._lexer.tokenizer[state.stack.state];\n\n      if (!rules) {\n        rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\n\n        if (!rules) {\n          throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\n        }\n      }\n\n      var popOffset = -1;\n      var hasEmbeddedPopRule = false;\n\n      var _iterator = _createForOfIteratorHelper(rules),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var rule = _step.value;\n\n          if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\n            continue;\n          }\n\n          hasEmbeddedPopRule = true;\n          var regex = rule.regex;\n          var regexSource = rule.regex.source;\n\n          if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\n            var flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\n            regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\n          }\n\n          var result = line.search(regex);\n\n          if (result === -1 || result !== 0 && rule.matchOnlyAtLineStart) {\n            continue;\n          }\n\n          if (popOffset === -1 || result < popOffset) {\n            popOffset = result;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!hasEmbeddedPopRule) {\n        throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\n      }\n\n      return popOffset;\n    }\n  }, {\n    key: \"_nestedTokenize\",\n    value: function _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\n      var popOffset = this._findLeavingNestedModeOffset(line, lineState);\n\n      if (popOffset === -1) {\n        // tokenization will not leave nested mode\n        var nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\n        return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\n      }\n\n      var nestedModeLine = line.substring(0, popOffset);\n\n      if (nestedModeLine.length > 0) {\n        // tokenize with the nested mode\n        tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\n      }\n\n      var restOfTheLine = line.substring(popOffset);\n      return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\n    }\n  }, {\n    key: \"_safeRuleName\",\n    value: function _safeRuleName(rule) {\n      if (rule) {\n        return rule.name;\n      }\n\n      return '(unknown)';\n    }\n  }, {\n    key: \"_myTokenize\",\n    value: function _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\n      var _this2 = this;\n\n      tokensCollector.enterMode(offsetDelta, this._modeId);\n      var lineWithoutLFLength = lineWithoutLF.length;\n      var line = hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF;\n      var lineLength = line.length;\n      var embeddedModeData = lineState.embeddedModeData;\n      var stack = lineState.stack;\n      var pos = 0;\n      var groupMatching = null; // See https://github.com/microsoft/monaco-editor/issues/1235\n      // Evaluate rules at least once for an empty line\n\n      var forceEvaluation = true;\n\n      while (forceEvaluation || pos < lineLength) {\n        var pos0 = pos;\n        var stackLen0 = stack.depth;\n        var groupLen0 = groupMatching ? groupMatching.groups.length : 0;\n        var state = stack.state;\n        var matches = null;\n        var matched = null;\n        var action = null;\n        var rule = null;\n        var enteringEmbeddedMode = null; // check if we need to process group matches first\n\n        if (groupMatching) {\n          matches = groupMatching.matches;\n          var groupEntry = groupMatching.groups.shift();\n          matched = groupEntry.matched;\n          action = groupEntry.action;\n          rule = groupMatching.rule; // cleanup if necessary\n\n          if (groupMatching.groups.length === 0) {\n            groupMatching = null;\n          }\n        } else {\n          // otherwise we match on the token stream\n          if (!forceEvaluation && pos >= lineLength) {\n            // nothing to do\n            break;\n          }\n\n          forceEvaluation = false; // get the rules for this state\n\n          var rules = this._lexer.tokenizer[state];\n\n          if (!rules) {\n            rules = monarchCommon.findRules(this._lexer, state); // do parent matching\n\n            if (!rules) {\n              throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\n            }\n          } // try each rule until we match\n\n\n          var restOfLine = line.substr(pos);\n\n          var _iterator2 = _createForOfIteratorHelper(rules),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _rule = _step2.value;\n\n              if (pos === 0 || !_rule.matchOnlyAtLineStart) {\n                matches = restOfLine.match(_rule.regex);\n\n                if (matches) {\n                  matched = matches[0];\n                  action = _rule.action;\n                  break;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } // We matched 'rule' with 'matches' and 'action'\n\n\n        if (!matches) {\n          matches = [''];\n          matched = '';\n        }\n\n        if (!action) {\n          // bad: we didn't match anything, and there is no action to take\n          // we need to advance the stream or we get progress trouble\n          if (pos < lineLength) {\n            matches = [line.charAt(pos)];\n            matched = matches[0];\n          }\n\n          action = this._lexer.defaultToken;\n        }\n\n        if (matched === null) {\n          // should never happen, needed for strict null checking\n          break;\n        } // advance stream\n\n\n        pos += matched.length; // maybe call action function (used for 'cases')\n\n        while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\n          action = action.test(matched, matches, state, pos === lineLength);\n        }\n\n        var result = null; // set the result: either a string or an array of actions\n\n        if (typeof action === 'string' || Array.isArray(action)) {\n          result = action;\n        } else if (action.group) {\n          result = action.group;\n        } else if (action.token !== null && action.token !== undefined) {\n          // do $n replacements?\n          if (action.tokenSubst) {\n            result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\n          } else {\n            result = action.token;\n          } // enter embedded mode?\n\n\n          if (action.nextEmbedded) {\n            if (action.nextEmbedded === '@pop') {\n              if (!embeddedModeData) {\n                throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\n              }\n\n              embeddedModeData = null;\n            } else if (embeddedModeData) {\n              throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\n            } else {\n              enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\n            }\n          } // state transformations\n\n\n          if (action.goBack) {\n            // back up the stream..\n            pos = Math.max(0, pos - action.goBack);\n          }\n\n          if (action.switchTo && typeof action.switchTo === 'string') {\n            var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\n\n            if (nextState[0] === '@') {\n              nextState = nextState.substr(1); // peel off starting '@'\n            }\n\n            if (!monarchCommon.findRules(this._lexer, nextState)) {\n              throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n            } else {\n              stack = stack.switchTo(nextState);\n            }\n          } else if (action.transform && typeof action.transform === 'function') {\n            throw monarchCommon.createError(this._lexer, 'action.transform not supported');\n          } else if (action.next) {\n            if (action.next === '@push') {\n              if (stack.depth >= this._lexer.maxStack) {\n                throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' + stack.state + ',' + stack.parent.state + ',...]');\n              } else {\n                stack = stack.push(state);\n              }\n            } else if (action.next === '@pop') {\n              if (stack.depth <= 1) {\n                throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\n              } else {\n                stack = stack.pop();\n              }\n            } else if (action.next === '@popall') {\n              stack = stack.popall();\n            } else {\n              var _nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\n\n              if (_nextState[0] === '@') {\n                _nextState = _nextState.substr(1); // peel off starting '@'\n              }\n\n              if (!monarchCommon.findRules(this._lexer, _nextState)) {\n                throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + _nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\n              } else {\n                stack = stack.push(_nextState);\n              }\n            }\n          }\n\n          if (action.log && typeof action.log === 'string') {\n            monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\n          }\n        } // check result\n\n\n        if (result === null) {\n          throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\n        }\n\n        var computeNewStateForEmbeddedMode = function computeNewStateForEmbeddedMode(enteringEmbeddedMode) {\n          // substitute language alias to known modes to support syntax highlighting\n          var enteringEmbeddedModeId = _this2._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\n\n          if (enteringEmbeddedModeId) {\n            enteringEmbeddedMode = enteringEmbeddedModeId;\n          }\n\n          var embeddedModeData = _this2._getNestedEmbeddedModeData(enteringEmbeddedMode);\n\n          if (pos < lineLength) {\n            // there is content from the embedded mode on this line\n            var _restOfLine = lineWithoutLF.substr(pos);\n\n            return _this2._nestedTokenize(_restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\n          } else {\n            return MonarchLineStateFactory.create(stack, embeddedModeData);\n          }\n        }; // is the result a group match?\n\n\n        if (Array.isArray(result)) {\n          if (groupMatching && groupMatching.groups.length > 0) {\n            throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\n          }\n\n          if (matches.length !== result.length + 1) {\n            throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\n          }\n\n          var totalLen = 0;\n\n          for (var i = 1; i < matches.length; i++) {\n            totalLen += matches[i].length;\n          }\n\n          if (totalLen !== matched.length) {\n            throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\n          }\n\n          groupMatching = {\n            rule: rule,\n            matches: matches,\n            groups: []\n          };\n\n          for (var _i = 0; _i < result.length; _i++) {\n            groupMatching.groups[_i] = {\n              action: result[_i],\n              matched: matches[_i + 1]\n            };\n          }\n\n          pos -= matched.length; // call recursively to initiate first result match\n\n          continue;\n        } else {\n          // regular result\n          // check for '@rematch'\n          if (result === '@rematch') {\n            pos -= matched.length;\n            matched = ''; // better set the next state too..\n\n            matches = null;\n            result = ''; // Even though `@rematch` was specified, if `nextEmbedded` also specified,\n            // a state transition should occur.\n\n            if (enteringEmbeddedMode !== null) {\n              return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n            }\n          } // check progress\n\n\n          if (matched.length === 0) {\n            if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\n              continue;\n            } else {\n              throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\n            }\n          } // return the result (and check for brace matching)\n          // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\n\n\n          var tokenType = null;\n\n          if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\n            var rest = result.substr('@brackets'.length);\n            var bracket = findBracket(this._lexer, matched);\n\n            if (!bracket) {\n              throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\n            }\n\n            tokenType = monarchCommon.sanitize(bracket.token + rest);\n          } else {\n            var token = result === '' ? '' : result + this._lexer.tokenPostfix;\n            tokenType = monarchCommon.sanitize(token);\n          }\n\n          if (pos0 < lineWithoutLFLength) {\n            tokensCollector.emit(pos0 + offsetDelta, tokenType);\n          }\n        }\n\n        if (enteringEmbeddedMode !== null) {\n          return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\n        }\n      }\n\n      return MonarchLineStateFactory.create(stack, embeddedModeData);\n    }\n  }, {\n    key: \"_getNestedEmbeddedModeData\",\n    value: function _getNestedEmbeddedModeData(mimetypeOrModeId) {\n      var nestedModeId = this._locateMode(mimetypeOrModeId);\n\n      if (nestedModeId) {\n        var tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\n\n        if (tokenizationSupport) {\n          return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\n        }\n      }\n\n      return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\n    }\n  }, {\n    key: \"_locateMode\",\n    value: function _locateMode(mimetypeOrModeId) {\n      if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\n        return null;\n      }\n\n      if (mimetypeOrModeId === this._modeId) {\n        // embedding myself...\n        return mimetypeOrModeId;\n      }\n\n      var modeId = this._modeService.getModeId(mimetypeOrModeId);\n\n      if (modeId) {\n        // Fire mode loading event\n        this._modeService.triggerMode(modeId);\n\n        this._embeddedModes[modeId] = true;\n      }\n\n      return modeId;\n    }\n  }]);\n\n  return MonarchTokenizer;\n}();\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\n\nfunction findBracket(lexer, matched) {\n  if (!matched) {\n    return null;\n  }\n\n  matched = monarchCommon.fixCase(lexer, matched);\n  var brackets = lexer.brackets;\n\n  var _iterator3 = _createForOfIteratorHelper(brackets),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var bracket = _step3.value;\n\n      if (bracket.open === matched) {\n        return {\n          token: bracket.token,\n          bracketType: 1\n          /* Open */\n\n        };\n      } else if (bracket.close === matched) {\n        return {\n          token: bracket.token,\n          bracketType: -1\n          /* Close */\n\n        };\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return null;\n}\n\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\n  return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer.js"],"names":["Token","TokenizationResult","TokenizationResult2","modes","NULL_MODE_ID","NULL_STATE","monarchCommon","CACHE_STACK_DEPTH","MonarchStackElementFactory","maxCacheDepth","_maxCacheDepth","_entries","Object","create","parent","state","depth","MonarchStackElement","stackElementId","getStackElementId","length","result","_INSTANCE","other","_equals","element","a","b","EmbeddedModeData","modeId","equals","stateClone","clone","MonarchLineStateFactory","stack","embeddedModeData","MonarchLineState","embeddedModeDataClone","MonarchClassicTokensCollector","_tokens","_language","_lastTokenType","_lastTokenLanguage","startOffset","type","push","embeddedModeLine","hasEOL","offsetDelta","nestedModeId","embeddedModeState","nestedModeTokenizationSupport","TokenizationRegistry","get","enterMode","emit","nestedResult","tokenize","concat","tokens","endState","MonarchModernTokensCollector","modeService","theme","_modeService","_theme","_prependTokens","_currentLanguageId","_lastTokenMetadata","getLanguageIdentifier","id","metadata","match","tokenize2","_merge","c","aLen","bLen","cLen","Uint32Array","set","i","MonarchTokenizer","standaloneThemeService","lexer","_standaloneThemeService","_modeId","_lexer","_embeddedModes","embeddedLoaded","Promise","resolve","undefined","emitting","_tokenizationRegistryListener","onDidChange","e","isOneOfMyEmbeddedModes","len","changedLanguages","language","fire","dispose","promises","tokenizationSupport","nestedModeStatus","getLoadStatus","loaded","promise","tokenizationSupportPromise","getPromise","all","then","_","rootState","start","line","lineState","tokensCollector","endLineState","_tokenize","finalize","getColorTheme","tokenTheme","collector","_nestedTokenize","_myTokenize","rules","tokenizer","findRules","createError","popOffset","hasEmbeddedPopRule","rule","isIAction","action","nextEmbedded","regex","regexSource","source","substr","flags","ignoreCase","unicode","RegExp","search","matchOnlyAtLineStart","_findLeavingNestedModeOffset","nestedEndState","nestedModeTokenize","nestedModeLine","substring","restOfTheLine","name","lineWithoutLF","lineWithoutLFLength","includeLF","lineLength","pos","groupMatching","forceEvaluation","pos0","stackLen0","groupLen0","groups","matches","matched","enteringEmbeddedMode","groupEntry","shift","restOfLine","charAt","defaultToken","isFuzzyAction","test","Array","isArray","group","token","tokenSubst","substituteMatches","goBack","Math","max","switchTo","nextState","_safeRuleName","transform","next","maxStack","pop","popall","log","languageId","computeNewStateForEmbeddedMode","enteringEmbeddedModeId","getModeIdForLanguageName","_getNestedEmbeddedModeData","totalLen","tokenType","isString","indexOf","rest","bracket","findBracket","sanitize","tokenPostfix","mimetypeOrModeId","_locateMode","getInitialState","isRegisteredMode","getModeId","triggerMode","fixCase","brackets","open","bracketType","close","createTokenizationSupport"],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nimport { Token, TokenizationResult, TokenizationResult2 } from '../../../common/core/token.js';\r\nimport * as modes from '../../../common/modes.js';\r\nimport { NULL_MODE_ID, NULL_STATE } from '../../../common/modes/nullMode.js';\r\nimport * as monarchCommon from './monarchCommon.js';\r\nconst CACHE_STACK_DEPTH = 5;\r\n/**\r\n * Reuse the same stack elements up to a certain depth.\r\n */\r\nclass MonarchStackElementFactory {\r\n    constructor(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    static create(parent, state) {\r\n        return this._INSTANCE.create(parent, state);\r\n    }\r\n    create(parent, state) {\r\n        if (parent !== null && parent.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchStackElement(parent, state);\r\n        }\r\n        let stackElementId = MonarchStackElement.getStackElementId(parent);\r\n        if (stackElementId.length > 0) {\r\n            stackElementId += '|';\r\n        }\r\n        stackElementId += state;\r\n        let result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchStackElement(parent, state);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    }\r\n}\r\nMonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);\r\nclass MonarchStackElement {\r\n    constructor(parent, state) {\r\n        this.parent = parent;\r\n        this.state = state;\r\n        this.depth = (this.parent ? this.parent.depth : 0) + 1;\r\n    }\r\n    static getStackElementId(element) {\r\n        let result = '';\r\n        while (element !== null) {\r\n            if (result.length > 0) {\r\n                result += '|';\r\n            }\r\n            result += element.state;\r\n            element = element.parent;\r\n        }\r\n        return result;\r\n    }\r\n    static _equals(a, b) {\r\n        while (a !== null && b !== null) {\r\n            if (a === b) {\r\n                return true;\r\n            }\r\n            if (a.state !== b.state) {\r\n                return false;\r\n            }\r\n            a = a.parent;\r\n            b = b.parent;\r\n        }\r\n        if (a === null && b === null) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    equals(other) {\r\n        return MonarchStackElement._equals(this, other);\r\n    }\r\n    push(state) {\r\n        return MonarchStackElementFactory.create(this, state);\r\n    }\r\n    pop() {\r\n        return this.parent;\r\n    }\r\n    popall() {\r\n        let result = this;\r\n        while (result.parent) {\r\n            result = result.parent;\r\n        }\r\n        return result;\r\n    }\r\n    switchTo(state) {\r\n        return MonarchStackElementFactory.create(this.parent, state);\r\n    }\r\n}\r\nclass EmbeddedModeData {\r\n    constructor(modeId, state) {\r\n        this.modeId = modeId;\r\n        this.state = state;\r\n    }\r\n    equals(other) {\r\n        return (this.modeId === other.modeId\r\n            && this.state.equals(other.state));\r\n    }\r\n    clone() {\r\n        let stateClone = this.state.clone();\r\n        // save an object\r\n        if (stateClone === this.state) {\r\n            return this;\r\n        }\r\n        return new EmbeddedModeData(this.modeId, this.state);\r\n    }\r\n}\r\n/**\r\n * Reuse the same line states up to a certain depth.\r\n */\r\nclass MonarchLineStateFactory {\r\n    constructor(maxCacheDepth) {\r\n        this._maxCacheDepth = maxCacheDepth;\r\n        this._entries = Object.create(null);\r\n    }\r\n    static create(stack, embeddedModeData) {\r\n        return this._INSTANCE.create(stack, embeddedModeData);\r\n    }\r\n    create(stack, embeddedModeData) {\r\n        if (embeddedModeData !== null) {\r\n            // no caching when embedding\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        if (stack !== null && stack.depth >= this._maxCacheDepth) {\r\n            // no caching above a certain depth\r\n            return new MonarchLineState(stack, embeddedModeData);\r\n        }\r\n        let stackElementId = MonarchStackElement.getStackElementId(stack);\r\n        let result = this._entries[stackElementId];\r\n        if (result) {\r\n            return result;\r\n        }\r\n        result = new MonarchLineState(stack, null);\r\n        this._entries[stackElementId] = result;\r\n        return result;\r\n    }\r\n}\r\nMonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);\r\nclass MonarchLineState {\r\n    constructor(stack, embeddedModeData) {\r\n        this.stack = stack;\r\n        this.embeddedModeData = embeddedModeData;\r\n    }\r\n    clone() {\r\n        let embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;\r\n        // save an object\r\n        if (embeddedModeDataClone === this.embeddedModeData) {\r\n            return this;\r\n        }\r\n        return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);\r\n    }\r\n    equals(other) {\r\n        if (!(other instanceof MonarchLineState)) {\r\n            return false;\r\n        }\r\n        if (!this.stack.equals(other.stack)) {\r\n            return false;\r\n        }\r\n        if (this.embeddedModeData === null && other.embeddedModeData === null) {\r\n            return true;\r\n        }\r\n        if (this.embeddedModeData === null || other.embeddedModeData === null) {\r\n            return false;\r\n        }\r\n        return this.embeddedModeData.equals(other.embeddedModeData);\r\n    }\r\n}\r\nclass MonarchClassicTokensCollector {\r\n    constructor() {\r\n        this._tokens = [];\r\n        this._language = null;\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n    }\r\n    enterMode(startOffset, modeId) {\r\n        this._language = modeId;\r\n    }\r\n    emit(startOffset, type) {\r\n        if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {\r\n            return;\r\n        }\r\n        this._lastTokenType = type;\r\n        this._lastTokenLanguage = this._language;\r\n        this._tokens.push(new Token(startOffset, type, this._language));\r\n    }\r\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\r\n        const nestedModeId = embeddedModeData.modeId;\r\n        const embeddedModeState = embeddedModeData.state;\r\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        let nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\r\n        this._tokens = this._tokens.concat(nestedResult.tokens);\r\n        this._lastTokenType = null;\r\n        this._lastTokenLanguage = null;\r\n        this._language = null;\r\n        return nestedResult.endState;\r\n    }\r\n    finalize(endState) {\r\n        return new TokenizationResult(this._tokens, endState);\r\n    }\r\n}\r\nclass MonarchModernTokensCollector {\r\n    constructor(modeService, theme) {\r\n        this._modeService = modeService;\r\n        this._theme = theme;\r\n        this._prependTokens = null;\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0 /* Null */;\r\n        this._lastTokenMetadata = 0;\r\n    }\r\n    enterMode(startOffset, modeId) {\r\n        this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;\r\n    }\r\n    emit(startOffset, type) {\r\n        let metadata = this._theme.match(this._currentLanguageId, type);\r\n        if (this._lastTokenMetadata === metadata) {\r\n            return;\r\n        }\r\n        this._lastTokenMetadata = metadata;\r\n        this._tokens.push(startOffset);\r\n        this._tokens.push(metadata);\r\n    }\r\n    static _merge(a, b, c) {\r\n        let aLen = (a !== null ? a.length : 0);\r\n        let bLen = b.length;\r\n        let cLen = (c !== null ? c.length : 0);\r\n        if (aLen === 0 && bLen === 0 && cLen === 0) {\r\n            return new Uint32Array(0);\r\n        }\r\n        if (aLen === 0 && bLen === 0) {\r\n            return c;\r\n        }\r\n        if (bLen === 0 && cLen === 0) {\r\n            return a;\r\n        }\r\n        let result = new Uint32Array(aLen + bLen + cLen);\r\n        if (a !== null) {\r\n            result.set(a);\r\n        }\r\n        for (let i = 0; i < bLen; i++) {\r\n            result[aLen + i] = b[i];\r\n        }\r\n        if (c !== null) {\r\n            result.set(c, aLen + bLen);\r\n        }\r\n        return result;\r\n    }\r\n    nestedModeTokenize(embeddedModeLine, hasEOL, embeddedModeData, offsetDelta) {\r\n        const nestedModeId = embeddedModeData.modeId;\r\n        const embeddedModeState = embeddedModeData.state;\r\n        const nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n        if (!nestedModeTokenizationSupport) {\r\n            this.enterMode(offsetDelta, nestedModeId);\r\n            this.emit(offsetDelta, '');\r\n            return embeddedModeState;\r\n        }\r\n        let nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, hasEOL, embeddedModeState, offsetDelta);\r\n        this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);\r\n        this._tokens = [];\r\n        this._currentLanguageId = 0;\r\n        this._lastTokenMetadata = 0;\r\n        return nestedResult.endState;\r\n    }\r\n    finalize(endState) {\r\n        return new TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);\r\n    }\r\n}\r\nexport class MonarchTokenizer {\r\n    constructor(modeService, standaloneThemeService, modeId, lexer) {\r\n        this._modeService = modeService;\r\n        this._standaloneThemeService = standaloneThemeService;\r\n        this._modeId = modeId;\r\n        this._lexer = lexer;\r\n        this._embeddedModes = Object.create(null);\r\n        this.embeddedLoaded = Promise.resolve(undefined);\r\n        // Set up listening for embedded modes\r\n        let emitting = false;\r\n        this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange((e) => {\r\n            if (emitting) {\r\n                return;\r\n            }\r\n            let isOneOfMyEmbeddedModes = false;\r\n            for (let i = 0, len = e.changedLanguages.length; i < len; i++) {\r\n                let language = e.changedLanguages[i];\r\n                if (this._embeddedModes[language]) {\r\n                    isOneOfMyEmbeddedModes = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (isOneOfMyEmbeddedModes) {\r\n                emitting = true;\r\n                modes.TokenizationRegistry.fire([this._modeId]);\r\n                emitting = false;\r\n            }\r\n        });\r\n    }\r\n    dispose() {\r\n        this._tokenizationRegistryListener.dispose();\r\n    }\r\n    getLoadStatus() {\r\n        let promises = [];\r\n        for (let nestedModeId in this._embeddedModes) {\r\n            const tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                // The nested mode is already loaded\r\n                if (tokenizationSupport instanceof MonarchTokenizer) {\r\n                    const nestedModeStatus = tokenizationSupport.getLoadStatus();\r\n                    if (nestedModeStatus.loaded === false) {\r\n                        promises.push(nestedModeStatus.promise);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            const tokenizationSupportPromise = modes.TokenizationRegistry.getPromise(nestedModeId);\r\n            if (tokenizationSupportPromise) {\r\n                // The nested mode is in the process of being loaded\r\n                promises.push(tokenizationSupportPromise);\r\n            }\r\n        }\r\n        if (promises.length === 0) {\r\n            return {\r\n                loaded: true\r\n            };\r\n        }\r\n        return {\r\n            loaded: false,\r\n            promise: Promise.all(promises).then(_ => undefined)\r\n        };\r\n    }\r\n    getInitialState() {\r\n        let rootState = MonarchStackElementFactory.create(null, this._lexer.start);\r\n        return MonarchLineStateFactory.create(rootState, null);\r\n    }\r\n    tokenize(line, hasEOL, lineState, offsetDelta) {\r\n        let tokensCollector = new MonarchClassicTokensCollector();\r\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    }\r\n    tokenize2(line, hasEOL, lineState, offsetDelta) {\r\n        let tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneThemeService.getColorTheme().tokenTheme);\r\n        let endLineState = this._tokenize(line, hasEOL, lineState, offsetDelta, tokensCollector);\r\n        return tokensCollector.finalize(endLineState);\r\n    }\r\n    _tokenize(line, hasEOL, lineState, offsetDelta, collector) {\r\n        if (lineState.embeddedModeData) {\r\n            return this._nestedTokenize(line, hasEOL, lineState, offsetDelta, collector);\r\n        }\r\n        else {\r\n            return this._myTokenize(line, hasEOL, lineState, offsetDelta, collector);\r\n        }\r\n    }\r\n    _findLeavingNestedModeOffset(line, state) {\r\n        let rules = this._lexer.tokenizer[state.stack.state];\r\n        if (!rules) {\r\n            rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching\r\n            if (!rules) {\r\n                throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);\r\n            }\r\n        }\r\n        let popOffset = -1;\r\n        let hasEmbeddedPopRule = false;\r\n        for (const rule of rules) {\r\n            if (!monarchCommon.isIAction(rule.action) || rule.action.nextEmbedded !== '@pop') {\r\n                continue;\r\n            }\r\n            hasEmbeddedPopRule = true;\r\n            let regex = rule.regex;\r\n            let regexSource = rule.regex.source;\r\n            if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {\r\n                let flags = (regex.ignoreCase ? 'i' : '') + (regex.unicode ? 'u' : '');\r\n                regex = new RegExp(regexSource.substr(4, regexSource.length - 5), flags);\r\n            }\r\n            let result = line.search(regex);\r\n            if (result === -1 || (result !== 0 && rule.matchOnlyAtLineStart)) {\r\n                continue;\r\n            }\r\n            if (popOffset === -1 || result < popOffset) {\r\n                popOffset = result;\r\n            }\r\n        }\r\n        if (!hasEmbeddedPopRule) {\r\n            throw monarchCommon.createError(this._lexer, 'no rule containing nextEmbedded: \"@pop\" in tokenizer embedded state: ' + state.stack.state);\r\n        }\r\n        return popOffset;\r\n    }\r\n    _nestedTokenize(line, hasEOL, lineState, offsetDelta, tokensCollector) {\r\n        let popOffset = this._findLeavingNestedModeOffset(line, lineState);\r\n        if (popOffset === -1) {\r\n            // tokenization will not leave nested mode\r\n            let nestedEndState = tokensCollector.nestedModeTokenize(line, hasEOL, lineState.embeddedModeData, offsetDelta);\r\n            return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));\r\n        }\r\n        let nestedModeLine = line.substring(0, popOffset);\r\n        if (nestedModeLine.length > 0) {\r\n            // tokenize with the nested mode\r\n            tokensCollector.nestedModeTokenize(nestedModeLine, false, lineState.embeddedModeData, offsetDelta);\r\n        }\r\n        let restOfTheLine = line.substring(popOffset);\r\n        return this._myTokenize(restOfTheLine, hasEOL, lineState, offsetDelta + popOffset, tokensCollector);\r\n    }\r\n    _safeRuleName(rule) {\r\n        if (rule) {\r\n            return rule.name;\r\n        }\r\n        return '(unknown)';\r\n    }\r\n    _myTokenize(lineWithoutLF, hasEOL, lineState, offsetDelta, tokensCollector) {\r\n        tokensCollector.enterMode(offsetDelta, this._modeId);\r\n        const lineWithoutLFLength = lineWithoutLF.length;\r\n        const line = (hasEOL && this._lexer.includeLF ? lineWithoutLF + '\\n' : lineWithoutLF);\r\n        const lineLength = line.length;\r\n        let embeddedModeData = lineState.embeddedModeData;\r\n        let stack = lineState.stack;\r\n        let pos = 0;\r\n        let groupMatching = null;\r\n        // See https://github.com/microsoft/monaco-editor/issues/1235\r\n        // Evaluate rules at least once for an empty line\r\n        let forceEvaluation = true;\r\n        while (forceEvaluation || pos < lineLength) {\r\n            const pos0 = pos;\r\n            const stackLen0 = stack.depth;\r\n            const groupLen0 = groupMatching ? groupMatching.groups.length : 0;\r\n            const state = stack.state;\r\n            let matches = null;\r\n            let matched = null;\r\n            let action = null;\r\n            let rule = null;\r\n            let enteringEmbeddedMode = null;\r\n            // check if we need to process group matches first\r\n            if (groupMatching) {\r\n                matches = groupMatching.matches;\r\n                const groupEntry = groupMatching.groups.shift();\r\n                matched = groupEntry.matched;\r\n                action = groupEntry.action;\r\n                rule = groupMatching.rule;\r\n                // cleanup if necessary\r\n                if (groupMatching.groups.length === 0) {\r\n                    groupMatching = null;\r\n                }\r\n            }\r\n            else {\r\n                // otherwise we match on the token stream\r\n                if (!forceEvaluation && pos >= lineLength) {\r\n                    // nothing to do\r\n                    break;\r\n                }\r\n                forceEvaluation = false;\r\n                // get the rules for this state\r\n                let rules = this._lexer.tokenizer[state];\r\n                if (!rules) {\r\n                    rules = monarchCommon.findRules(this._lexer, state); // do parent matching\r\n                    if (!rules) {\r\n                        throw monarchCommon.createError(this._lexer, 'tokenizer state is not defined: ' + state);\r\n                    }\r\n                }\r\n                // try each rule until we match\r\n                let restOfLine = line.substr(pos);\r\n                for (const rule of rules) {\r\n                    if (pos === 0 || !rule.matchOnlyAtLineStart) {\r\n                        matches = restOfLine.match(rule.regex);\r\n                        if (matches) {\r\n                            matched = matches[0];\r\n                            action = rule.action;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // We matched 'rule' with 'matches' and 'action'\r\n            if (!matches) {\r\n                matches = [''];\r\n                matched = '';\r\n            }\r\n            if (!action) {\r\n                // bad: we didn't match anything, and there is no action to take\r\n                // we need to advance the stream or we get progress trouble\r\n                if (pos < lineLength) {\r\n                    matches = [line.charAt(pos)];\r\n                    matched = matches[0];\r\n                }\r\n                action = this._lexer.defaultToken;\r\n            }\r\n            if (matched === null) {\r\n                // should never happen, needed for strict null checking\r\n                break;\r\n            }\r\n            // advance stream\r\n            pos += matched.length;\r\n            // maybe call action function (used for 'cases')\r\n            while (monarchCommon.isFuzzyAction(action) && monarchCommon.isIAction(action) && action.test) {\r\n                action = action.test(matched, matches, state, pos === lineLength);\r\n            }\r\n            let result = null;\r\n            // set the result: either a string or an array of actions\r\n            if (typeof action === 'string' || Array.isArray(action)) {\r\n                result = action;\r\n            }\r\n            else if (action.group) {\r\n                result = action.group;\r\n            }\r\n            else if (action.token !== null && action.token !== undefined) {\r\n                // do $n replacements?\r\n                if (action.tokenSubst) {\r\n                    result = monarchCommon.substituteMatches(this._lexer, action.token, matched, matches, state);\r\n                }\r\n                else {\r\n                    result = action.token;\r\n                }\r\n                // enter embedded mode?\r\n                if (action.nextEmbedded) {\r\n                    if (action.nextEmbedded === '@pop') {\r\n                        if (!embeddedModeData) {\r\n                            throw monarchCommon.createError(this._lexer, 'cannot pop embedded mode if not inside one');\r\n                        }\r\n                        embeddedModeData = null;\r\n                    }\r\n                    else if (embeddedModeData) {\r\n                        throw monarchCommon.createError(this._lexer, 'cannot enter embedded mode from within an embedded mode');\r\n                    }\r\n                    else {\r\n                        enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);\r\n                    }\r\n                }\r\n                // state transformations\r\n                if (action.goBack) { // back up the stream..\r\n                    pos = Math.max(0, pos - action.goBack);\r\n                }\r\n                if (action.switchTo && typeof action.switchTo === 'string') {\r\n                    let nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...\r\n                    if (nextState[0] === '@') {\r\n                        nextState = nextState.substr(1); // peel off starting '@'\r\n                    }\r\n                    if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                        throw monarchCommon.createError(this._lexer, 'trying to switch to a state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                    else {\r\n                        stack = stack.switchTo(nextState);\r\n                    }\r\n                }\r\n                else if (action.transform && typeof action.transform === 'function') {\r\n                    throw monarchCommon.createError(this._lexer, 'action.transform not supported');\r\n                }\r\n                else if (action.next) {\r\n                    if (action.next === '@push') {\r\n                        if (stack.depth >= this._lexer.maxStack) {\r\n                            throw monarchCommon.createError(this._lexer, 'maximum tokenizer stack size reached: [' +\r\n                                stack.state + ',' + stack.parent.state + ',...]');\r\n                        }\r\n                        else {\r\n                            stack = stack.push(state);\r\n                        }\r\n                    }\r\n                    else if (action.next === '@pop') {\r\n                        if (stack.depth <= 1) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to pop an empty stack in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.pop();\r\n                        }\r\n                    }\r\n                    else if (action.next === '@popall') {\r\n                        stack = stack.popall();\r\n                    }\r\n                    else {\r\n                        let nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);\r\n                        if (nextState[0] === '@') {\r\n                            nextState = nextState.substr(1); // peel off starting '@'\r\n                        }\r\n                        if (!monarchCommon.findRules(this._lexer, nextState)) {\r\n                            throw monarchCommon.createError(this._lexer, 'trying to set a next state \\'' + nextState + '\\' that is undefined in rule: ' + this._safeRuleName(rule));\r\n                        }\r\n                        else {\r\n                            stack = stack.push(nextState);\r\n                        }\r\n                    }\r\n                }\r\n                if (action.log && typeof (action.log) === 'string') {\r\n                    monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));\r\n                }\r\n            }\r\n            // check result\r\n            if (result === null) {\r\n                throw monarchCommon.createError(this._lexer, 'lexer rule has no well-defined action in rule: ' + this._safeRuleName(rule));\r\n            }\r\n            const computeNewStateForEmbeddedMode = (enteringEmbeddedMode) => {\r\n                // substitute language alias to known modes to support syntax highlighting\r\n                let enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);\r\n                if (enteringEmbeddedModeId) {\r\n                    enteringEmbeddedMode = enteringEmbeddedModeId;\r\n                }\r\n                const embeddedModeData = this._getNestedEmbeddedModeData(enteringEmbeddedMode);\r\n                if (pos < lineLength) {\r\n                    // there is content from the embedded mode on this line\r\n                    const restOfLine = lineWithoutLF.substr(pos);\r\n                    return this._nestedTokenize(restOfLine, hasEOL, MonarchLineStateFactory.create(stack, embeddedModeData), offsetDelta + pos, tokensCollector);\r\n                }\r\n                else {\r\n                    return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n                }\r\n            };\r\n            // is the result a group match?\r\n            if (Array.isArray(result)) {\r\n                if (groupMatching && groupMatching.groups.length > 0) {\r\n                    throw monarchCommon.createError(this._lexer, 'groups cannot be nested: ' + this._safeRuleName(rule));\r\n                }\r\n                if (matches.length !== result.length + 1) {\r\n                    throw monarchCommon.createError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                let totalLen = 0;\r\n                for (let i = 1; i < matches.length; i++) {\r\n                    totalLen += matches[i].length;\r\n                }\r\n                if (totalLen !== matched.length) {\r\n                    throw monarchCommon.createError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + this._safeRuleName(rule));\r\n                }\r\n                groupMatching = {\r\n                    rule: rule,\r\n                    matches: matches,\r\n                    groups: []\r\n                };\r\n                for (let i = 0; i < result.length; i++) {\r\n                    groupMatching.groups[i] = {\r\n                        action: result[i],\r\n                        matched: matches[i + 1]\r\n                    };\r\n                }\r\n                pos -= matched.length;\r\n                // call recursively to initiate first result match\r\n                continue;\r\n            }\r\n            else {\r\n                // regular result\r\n                // check for '@rematch'\r\n                if (result === '@rematch') {\r\n                    pos -= matched.length;\r\n                    matched = ''; // better set the next state too..\r\n                    matches = null;\r\n                    result = '';\r\n                    // Even though `@rematch` was specified, if `nextEmbedded` also specified,\r\n                    // a state transition should occur.\r\n                    if (enteringEmbeddedMode !== null) {\r\n                        return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\r\n                    }\r\n                }\r\n                // check progress\r\n                if (matched.length === 0) {\r\n                    if (lineLength === 0 || stackLen0 !== stack.depth || state !== stack.state || (!groupMatching ? 0 : groupMatching.groups.length) !== groupLen0) {\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        throw monarchCommon.createError(this._lexer, 'no progress in tokenizer in rule: ' + this._safeRuleName(rule));\r\n                    }\r\n                }\r\n                // return the result (and check for brace matching)\r\n                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions\r\n                let tokenType = null;\r\n                if (monarchCommon.isString(result) && result.indexOf('@brackets') === 0) {\r\n                    let rest = result.substr('@brackets'.length);\r\n                    let bracket = findBracket(this._lexer, matched);\r\n                    if (!bracket) {\r\n                        throw monarchCommon.createError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);\r\n                    }\r\n                    tokenType = monarchCommon.sanitize(bracket.token + rest);\r\n                }\r\n                else {\r\n                    let token = (result === '' ? '' : result + this._lexer.tokenPostfix);\r\n                    tokenType = monarchCommon.sanitize(token);\r\n                }\r\n                if (pos0 < lineWithoutLFLength) {\r\n                    tokensCollector.emit(pos0 + offsetDelta, tokenType);\r\n                }\r\n            }\r\n            if (enteringEmbeddedMode !== null) {\r\n                return computeNewStateForEmbeddedMode(enteringEmbeddedMode);\r\n            }\r\n        }\r\n        return MonarchLineStateFactory.create(stack, embeddedModeData);\r\n    }\r\n    _getNestedEmbeddedModeData(mimetypeOrModeId) {\r\n        let nestedModeId = this._locateMode(mimetypeOrModeId);\r\n        if (nestedModeId) {\r\n            let tokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);\r\n            if (tokenizationSupport) {\r\n                return new EmbeddedModeData(nestedModeId, tokenizationSupport.getInitialState());\r\n            }\r\n        }\r\n        return new EmbeddedModeData(nestedModeId || NULL_MODE_ID, NULL_STATE);\r\n    }\r\n    _locateMode(mimetypeOrModeId) {\r\n        if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {\r\n            return null;\r\n        }\r\n        if (mimetypeOrModeId === this._modeId) {\r\n            // embedding myself...\r\n            return mimetypeOrModeId;\r\n        }\r\n        let modeId = this._modeService.getModeId(mimetypeOrModeId);\r\n        if (modeId) {\r\n            // Fire mode loading event\r\n            this._modeService.triggerMode(modeId);\r\n            this._embeddedModes[modeId] = true;\r\n        }\r\n        return modeId;\r\n    }\r\n}\r\n/**\r\n * Searches for a bracket in the 'brackets' attribute that matches the input.\r\n */\r\nfunction findBracket(lexer, matched) {\r\n    if (!matched) {\r\n        return null;\r\n    }\r\n    matched = monarchCommon.fixCase(lexer, matched);\r\n    let brackets = lexer.brackets;\r\n    for (const bracket of brackets) {\r\n        if (bracket.open === matched) {\r\n            return { token: bracket.token, bracketType: 1 /* Open */ };\r\n        }\r\n        else if (bracket.close === matched) {\r\n            return { token: bracket.token, bracketType: -1 /* Close */ };\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexport function createTokenizationSupport(modeService, standaloneThemeService, modeId, lexer) {\r\n    return new MonarchTokenizer(modeService, standaloneThemeService, modeId, lexer);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}