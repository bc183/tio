{"ast":null,"code":"import { IdleValue } from './async.js'; // When comparing large numbers of strings, such as in sorting large arrays, is better for\n// performance to create an Intl.Collator object and use the function provided by its compare\n// property than it is to use String.prototype.localeCompare()\n// A collator with numeric sorting enabled, and no sensitivity to case or to accents\n\nvar intlFileNameCollatorBaseNumeric = new IdleValue(function () {\n  var collator = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: 'base'\n  });\n  return {\n    collator: collator,\n    collatorIsNumeric: collator.resolvedOptions().numeric\n  };\n});\n/** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\n\nexport function compareFileNames(one, other) {\n  var caseSensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var a = one || '';\n  var b = other || '';\n  var result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b); // Using the numeric option in the collator will\n  // make compare(`foo1`, `foo01`) === 0. We must disambiguate.\n\n  if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\n    return a < b ? -1 : 1;\n  }\n\n  return result;\n}\nexport function compareAnything(one, other, lookFor) {\n  var elementAName = one.toLowerCase();\n  var elementBName = other.toLowerCase(); // Sort prefix matches over non prefix matches\n\n  var prefixCompare = compareByPrefix(one, other, lookFor);\n\n  if (prefixCompare) {\n    return prefixCompare;\n  } // Sort suffix matches over non suffix matches\n\n\n  var elementASuffixMatch = elementAName.endsWith(lookFor);\n  var elementBSuffixMatch = elementBName.endsWith(lookFor);\n\n  if (elementASuffixMatch !== elementBSuffixMatch) {\n    return elementASuffixMatch ? -1 : 1;\n  } // Understand file names\n\n\n  var r = compareFileNames(elementAName, elementBName);\n\n  if (r !== 0) {\n    return r;\n  } // Compare by name\n\n\n  return elementAName.localeCompare(elementBName);\n}\nexport function compareByPrefix(one, other, lookFor) {\n  var elementAName = one.toLowerCase();\n  var elementBName = other.toLowerCase(); // Sort prefix matches over non prefix matches\n\n  var elementAPrefixMatch = elementAName.startsWith(lookFor);\n  var elementBPrefixMatch = elementBName.startsWith(lookFor);\n\n  if (elementAPrefixMatch !== elementBPrefixMatch) {\n    return elementAPrefixMatch ? -1 : 1;\n  } // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\n  else if (elementAPrefixMatch && elementBPrefixMatch) {\n      if (elementAName.length < elementBName.length) {\n        return -1;\n      }\n\n      if (elementAName.length > elementBName.length) {\n        return 1;\n      }\n    }\n\n  return 0;\n}","map":{"version":3,"sources":["/home/bar007/Desktop/projects/tio/client/node_modules/monaco-editor/esm/vs/base/common/comparers.js"],"names":["IdleValue","intlFileNameCollatorBaseNumeric","collator","Intl","Collator","undefined","numeric","sensitivity","collatorIsNumeric","resolvedOptions","compareFileNames","one","other","caseSensitive","a","b","result","value","compare","compareAnything","lookFor","elementAName","toLowerCase","elementBName","prefixCompare","compareByPrefix","elementASuffixMatch","endsWith","elementBSuffixMatch","r","localeCompare","elementAPrefixMatch","startsWith","elementBPrefixMatch","length"],"mappings":"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","sourcesContent":["import { IdleValue } from './async.js';\r\n// When comparing large numbers of strings, such as in sorting large arrays, is better for\r\n// performance to create an Intl.Collator object and use the function provided by its compare\r\n// property than it is to use String.prototype.localeCompare()\r\n// A collator with numeric sorting enabled, and no sensitivity to case or to accents\r\nconst intlFileNameCollatorBaseNumeric = new IdleValue(() => {\r\n    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });\r\n    return {\r\n        collator: collator,\r\n        collatorIsNumeric: collator.resolvedOptions().numeric\r\n    };\r\n}); /** Compares filenames without distinguishing the name from the extension. Disambiguates by unicode comparison. */\r\nexport function compareFileNames(one, other, caseSensitive = false) {\r\n    const a = one || '';\r\n    const b = other || '';\r\n    const result = intlFileNameCollatorBaseNumeric.value.collator.compare(a, b);\r\n    // Using the numeric option in the collator will\r\n    // make compare(`foo1`, `foo01`) === 0. We must disambiguate.\r\n    if (intlFileNameCollatorBaseNumeric.value.collatorIsNumeric && result === 0 && a !== b) {\r\n        return a < b ? -1 : 1;\r\n    }\r\n    return result;\r\n}\r\nexport function compareAnything(one, other, lookFor) {\r\n    const elementAName = one.toLowerCase();\r\n    const elementBName = other.toLowerCase();\r\n    // Sort prefix matches over non prefix matches\r\n    const prefixCompare = compareByPrefix(one, other, lookFor);\r\n    if (prefixCompare) {\r\n        return prefixCompare;\r\n    }\r\n    // Sort suffix matches over non suffix matches\r\n    const elementASuffixMatch = elementAName.endsWith(lookFor);\r\n    const elementBSuffixMatch = elementBName.endsWith(lookFor);\r\n    if (elementASuffixMatch !== elementBSuffixMatch) {\r\n        return elementASuffixMatch ? -1 : 1;\r\n    }\r\n    // Understand file names\r\n    const r = compareFileNames(elementAName, elementBName);\r\n    if (r !== 0) {\r\n        return r;\r\n    }\r\n    // Compare by name\r\n    return elementAName.localeCompare(elementBName);\r\n}\r\nexport function compareByPrefix(one, other, lookFor) {\r\n    const elementAName = one.toLowerCase();\r\n    const elementBName = other.toLowerCase();\r\n    // Sort prefix matches over non prefix matches\r\n    const elementAPrefixMatch = elementAName.startsWith(lookFor);\r\n    const elementBPrefixMatch = elementBName.startsWith(lookFor);\r\n    if (elementAPrefixMatch !== elementBPrefixMatch) {\r\n        return elementAPrefixMatch ? -1 : 1;\r\n    }\r\n    // Same prefix: Sort shorter matches to the top to have those on top that match more precisely\r\n    else if (elementAPrefixMatch && elementBPrefixMatch) {\r\n        if (elementAName.length < elementBName.length) {\r\n            return -1;\r\n        }\r\n        if (elementAName.length > elementBName.length) {\r\n            return 1;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}